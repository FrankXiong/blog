{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/uploads/checkbox_1.png","path":"uploads/checkbox_1.png","modified":1,"renderable":0},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0},{"_id":"source/uploads/fe-css-0.png","path":"uploads/fe-css-0.png","modified":1,"renderable":0},{"_id":"source/uploads/checkbox_3.png","path":"uploads/checkbox_3.png","modified":1,"renderable":0},{"_id":"source/uploads/checkbox_4.png","path":"uploads/checkbox_4.png","modified":1,"renderable":0},{"_id":"source/uploads/checkbox_2.png","path":"uploads/checkbox_2.png","modified":1,"renderable":0},{"_id":"source/uploads/fe-css-2.png","path":"uploads/fe-css-2.png","modified":1,"renderable":0},{"_id":"source/uploads/fe-css-1.jpg","path":"uploads/fe-css-1.jpg","modified":1,"renderable":0},{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"c3a4e6f775a2d7742b2f57ac9df4b3833ec94fa7","modified":1457343783000},{"_id":"source/404.html","hash":"f7d32c6d1ddac7caa964d346c19e920fa7b3986f","modified":1457265954000},{"_id":"source/CNAME","hash":"87eb67dc0e83d175b646aa565c07a460039107e8","modified":1481790156000},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1481792555000},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1481792555000},{"_id":"themes/Anisina/_config.yml","hash":"c7120c93ab86fe9fea86f0932835d3ffe74f2926","modified":1481802249000},{"_id":"themes/Anisina/README.md","hash":"feab09dfaa2212528428d850bb89db7b670113ba","modified":1481792555000},{"_id":"source/_posts/CDN缓存原理.md","hash":"5c83a9c23ba2a0a109d342238c392fb8687314ad","modified":1458071333000},{"_id":"source/_posts/2016阿里前端实习电话面试实录.md","hash":"5eccb46905345fe3d6ec4c90b76551591044b933","modified":1458138357000},{"_id":"source/about/index.md","hash":"194338bc09cfe6e37dc14af63e0c2ec2621d6db3","modified":1487605442000},{"_id":"source/Tags/index.md","hash":"22383aebe72f65a008d35ad6a21fa5b221567a4e","modified":1487605446000},{"_id":"source/_posts/DNS劫持与DNS污染的原理.md","hash":"f7a26acb30e2e2fd2066c062b177418283ce7301","modified":1461853528000},{"_id":"source/_posts/Cookie和Session的区别总结.md","hash":"57afeb1384db691b36464159f1693865632ba6b8","modified":1472978464000},{"_id":"source/_posts/ES6语法总结.md","hash":"8a1aae5528e59bc63aa4f9447f2c413c968aef42","modified":1490978768000},{"_id":"source/_posts/HTTPS知识点.md","hash":"7018dca6cea59c06c7e92fac26e82e6ac24f5219","modified":1458652775000},{"_id":"source/_posts/Markdown简明语法.md","hash":"b7ee366e4cd89b0264fb420021d42c466b637480","modified":1457342552000},{"_id":"source/_posts/Vue2-0源码学习-0.md","hash":"b68c789d1ac07e872adecafe27969f979512ead6","modified":1486272207000},{"_id":"source/_posts/HTTP状态码大全.md","hash":"3e55e4150513cb3b27f261ae4379ce2b39cf3fb1","modified":1486272339000},{"_id":"source/_posts/TCP性能优化浅析.md","hash":"c7527defb7c4e5607887b4352525d8f445926344","modified":1517587290635},{"_id":"source/_posts/apply方法的妙用.md","hash":"45a1b9eb6ba53e29a7042f4b9475be76f6a16ffd","modified":1458059896000},{"_id":"source/_posts/cookie.md","hash":"ee2006894685dc16d7882ed0893a167803d3a3f7","modified":1457636077000},{"_id":"source/_posts/localStorage详解.md","hash":"664881fad0cdb3ba9160a8cbb919b377c633703d","modified":1457365710000},{"_id":"source/_posts/null和undefined的区别.md","hash":"3614dd5e7af228aaf1d3d009b17ac15e17af835c","modified":1457445796000},{"_id":"source/_posts/traceroute的原理.md","hash":"bd375d377d61039832ac4db2d26c2d2f2f32ae93","modified":1472978678000},{"_id":"source/_posts/【CSS】文本换行的几个属性.md","hash":"d15980b52b95f6cacb90f248cea7baffed0761d5","modified":1457342523000},{"_id":"source/_posts/【JavaScript】splice方法实现原理分析.md","hash":"e99a3ad7bdde82dcfbefc2b1b889b8d2c753855c","modified":1486272083000},{"_id":"source/_posts/【JavaScript】变量作用域.md","hash":"32713ef77b62b585601a8c5569169ffaba0a81de","modified":1457342518000},{"_id":"source/_posts/【JavaScript】常见设计模式总结.md","hash":"e7ec0ee341648b3efe4325bd8e153f764368227c","modified":1517587421613},{"_id":"source/_posts/【JavaScript】闭包的概念.md","hash":"1990790fa8e164f90fd36c10e56a6a4cd0798b74","modified":1457342514000},{"_id":"source/_posts/【JavaScript实现数据结构】栈.md","hash":"70162960f1e9db611e889800e47c97fd513e4ab0","modified":1458553293000},{"_id":"source/_posts/【JavaScript实现数据结构】队列.md","hash":"6cd47a622c5b03c4342674ce2b2ab0e97f4e2079","modified":1458553501000},{"_id":"source/_posts/【JavaScript实现算法】快速排序.md","hash":"482f61257a6420fbc779b1b71ab50902a2a53ba4","modified":1458652506000},{"_id":"source/_posts/【译】2017-年要去学的-3-个-CSS-新属性.md","hash":"45d752d4ffa1d3d9507e0f835fdced326e0298f4","modified":1489256917000},{"_id":"source/_posts/【译】HLS架构简介.md","hash":"da010dce2f8c0299d4a4be9181394b863ead555e","modified":1489257152000},{"_id":"source/_posts/【译】为什么Vue-js不支持templateURL.md","hash":"bf083f7521c83fce2109933df2b880889aca8070","modified":1486271543000},{"_id":"source/_posts/【译】异步：现在与将来（基础篇）.md","hash":"25a06ec489a520bc1e99167c7e4238861386ab28","modified":1491382028000},{"_id":"source/_posts/【译】异步：现在与将来（并发篇）.md","hash":"78f4ca8d0e6963e1921de8fd1d309db6784a4b70","modified":1491382525000},{"_id":"source/_posts/【译】异步：现在与将来（并行篇）.md","hash":"c259898e10228b4af2e4e113c014f644942968a6","modified":1491382010000},{"_id":"source/_posts/【译】真实的Virtual-DOM.md","hash":"5b0a829b14b0c7f5e0eaaf118baa9a5a0ada90b9","modified":1486271530000},{"_id":"source/_posts/一个优化的快速排序.md","hash":"9cdd5ccfb42fe6b9d0028dd631c076c1a14d5adc","modified":1460880097000},{"_id":"source/_posts/一个通用的事件监听器.md","hash":"9b91217c613d59cfb92d8217f89358f8a047b009","modified":1462197253000},{"_id":"source/_posts/什么是TCP连接的三次握手.md","hash":"8569f8b0098c6072909881a33f925fa816b09eb8","modified":1486272316000},{"_id":"source/_posts/你该逃课吗.md","hash":"0b2d7ed59536a9c08f44dad12d64bb81da05ea6c","modified":1472978435000},{"_id":"source/_posts/写给自己的鸡汤.md","hash":"f13830532a23b6496cdd8465feee2edadc54c1a1","modified":1490977423000},{"_id":"source/_posts/实现JavaScript中的indexOf方法.md","hash":"674d89bf0f1506b307565ba66f88140807e987ad","modified":1486272273000},{"_id":"source/_posts/我的HTTPS升级之旅.md","hash":"3237e0a5d9b3f6f3b74e5644cd2c8d2d346477fb","modified":1494533958000},{"_id":"source/_posts/正则表达式的模式匹配.md","hash":"281dedc0dd0c0ef73f8825790454b32dc8eb5437","modified":1457610941000},{"_id":"source/_posts/数组去重.md","hash":"d678161a2d1a22cd07406d47a9f98d1fc4c15102","modified":1458553545000},{"_id":"source/_posts/深入理解BFC.md","hash":"488d739f90bd2c9f9d6d7f08ccd90a28185f11b6","modified":1457610961000},{"_id":"source/_posts/类数组转换为数组.md","hash":"b1b5ec1725dad9f468fdcfa003e30fb2211be27e","modified":1462197101000},{"_id":"source/_posts/网站性能优化的14条规则.md","hash":"0eed4274dbaf9d301302a06e5871493125903655","modified":1458058274000},{"_id":"source/_posts/自定义复选框.md","hash":"d15aba1e4cd1247b54e0535bf5a0bf1e849ebaed","modified":1472978517000},{"_id":"source/_posts/网页渲染中的重绘与重排.md","hash":"a38b7fb8f1f5adc0dd8c82f5bc19f28b0c169ff3","modified":1486272257000},{"_id":"source/_posts/让Ajax支持浏览器的前进后退.md","hash":"a5b9da27ac2c736f07628f6908d5508d93f03e41","modified":1486272522000},{"_id":"source/_posts/部署Node项目到CentOS服务器.md","hash":"05326e5fb92494b193c191934a3f9f7cca8cc976","modified":1486272493000},{"_id":"source/_posts/随笔-1.md","hash":"6bf0d5b63b36e8e78381368ca4d882e919e26835","modified":1457267051000},{"_id":"source/uploads/checkbox_1.png","hash":"26c0c895d54c65e50005fb58943141a4de2bebc5","modified":1463549406000},{"_id":"source/_posts/阿里前端实习电话面试（二）.md","hash":"ab9f83ecb86d2fce2bdef21737584a4c5cf28ea8","modified":1458138335000},{"_id":"source/uploads/avatar.jpg","hash":"7ec3b70597f503e1e91aedfde92144b02503c18f","modified":1441880040000},{"_id":"source/uploads/fe-css-0.png","hash":"499bcc1fa87f3b4ae98c750216972cc79df4f5d9","modified":1457341969000},{"_id":"source/uploads/checkbox_3.png","hash":"7875434faeb6590c33e31ae60687dab88a32eed7","modified":1463549503000},{"_id":"source/uploads/checkbox_4.png","hash":"18d784eda46c00ccffc595c695cb74a1c718b96f","modified":1463549315000},{"_id":"source/uploads/checkbox_2.png","hash":"657b36f7b2040da6d1af72afa867f35f983dc047","modified":1463549480000},{"_id":"source/uploads/fe-css-2.png","hash":"939c40b72b69d4af5d787d771419577bbb558b4f","modified":1457342136000},{"_id":"source/works/index.md","hash":"9a50befd54c7f0ca35994ca2ebcbf161c7dd15b4","modified":1487605403000},{"_id":"themes/Anisina/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1481792555000},{"_id":"source/uploads/fe-css-1.jpg","hash":"889ca1fa98dd91f37a23cfbe5c24c7f03b24e63d","modified":1457342122000},{"_id":"themes/Anisina/.git/config","hash":"050bd84e438fe3cde46d681fefd19a7d07cb0f15","modified":1481792555000},{"_id":"themes/Anisina/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1481792466000},{"_id":"themes/Anisina/.git/packed-refs","hash":"63cbe93752c931e5dc628e06c040b1829697a9c2","modified":1481792555000},{"_id":"themes/Anisina/.git/index","hash":"93a0d6d7151b5f407dc72986744644dbe5e7b5cb","modified":1481792555000},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1481792555000},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1481792555000},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1481792555000},{"_id":"themes/Anisina/layout/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1481792555000},{"_id":"themes/Anisina/layout/layout.ejs","hash":"9d3d82a707b107f42db34ef5a8016693da2be742","modified":1481792555000},{"_id":"themes/Anisina/layout/about.ejs","hash":"b10dac502f2f1f4e4ddad7790be3a3396a383d3e","modified":1493658653000},{"_id":"themes/Anisina/layout/page.ejs","hash":"95bbc74aa6d10cddddd7a5cd5d2a06482f5ea173","modified":1481792555000},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1481792555000},{"_id":"themes/Anisina/layout/post.ejs","hash":"07a81a2b5c3cdb0692935e4a876219e5a5c645bd","modified":1481792555000},{"_id":"themes/Anisina/layout/tags.ejs","hash":"a144c3b5f4a70f881333e4de392a265469cdb649","modified":1481792555000},{"_id":"themes/Anisina/layout/works.ejs","hash":"4c181d7b49363baf7f5480dd9c5101eee4aab3ad","modified":1517592851343},{"_id":"themes/Anisina/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1481792466000},{"_id":"themes/Anisina/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1481792466000},{"_id":"themes/Anisina/.git/logs/HEAD","hash":"158c6bfb519eaafa2e26887e5ecc3afafcb28bb1","modified":1481792555000},{"_id":"themes/Anisina/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1481792466000},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1481792555000},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"49bf5d3f5cacc56be113460fe8fd64a1b7bd3ef4","modified":1517590705000},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"fe90c5edb58d975a99e624fb8630e93f88b63cb0","modified":1487598345000},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1481792555000},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"ac56fd3f56037552650250482b5bd88f9bf9b4da","modified":1487604117000},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"60aab748de9873aaa5c3fee2995d28c139647887","modified":1517593880743},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1481792555000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1481792555000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1481792555000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1481792555000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1481792555000},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1481792555000},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1481792555000},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1481792555000},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1481792555000},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1481792555000},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1481792555000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1481792555000},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1481792555000},{"_id":"themes/Anisina/.git/objects/pack/pack-e692ebd9e3b1a80a9ef3364b1eaaf6934011b873.idx","hash":"48fccb86f970cae33b2ac53c05a8c833c780d4c4","modified":1481792555000},{"_id":"themes/Anisina/.git/refs/heads/master","hash":"6680c8599542d2f05c1104be2e4fafa0adf3a687","modified":1481792555000},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1481792555000},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1481792555000},{"_id":"themes/Anisina/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1481792555000},{"_id":"themes/Anisina/.git/logs/refs/heads/master","hash":"158c6bfb519eaafa2e26887e5ecc3afafcb28bb1","modified":1481792555000},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1481792555000},{"_id":"themes/Anisina/.git/logs/refs/remotes/origin/HEAD","hash":"158c6bfb519eaafa2e26887e5ecc3afafcb28bb1","modified":1481792555000},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1481792555000},{"_id":"themes/Anisina/.git/objects/pack/pack-e692ebd9e3b1a80a9ef3364b1eaaf6934011b873.pack","hash":"8f9cfa0dedc2a80620a74ad2f6010c6fcdeb5162","modified":1481792555000},{"_id":"public/atom.xml","hash":"650ab989c4fc4f4c5a63f3c6c7be3e8344042726","modified":1517594487490},{"_id":"public/sitemap.xml","hash":"df04f4fa468ba0cfac602200025b037518bdce85","modified":1517594487526},{"_id":"public/404.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517594487773},{"_id":"public/about/index.html","hash":"4e6b1ca5eb4aba34a07b7739f322876797c7d88d","modified":1517594487773},{"_id":"public/2018/01/23/【JavaScript】常见设计模式总结/index.html","hash":"8fa6b4922f609852312712a7a2e75e3fa5a9af2c","modified":1517594487773},{"_id":"public/2017/03/19/写给自己的鸡汤/index.html","hash":"d46c33a81b4c2230945a12e98759f68849dc0a7b","modified":1517594487774},{"_id":"public/2016/08/03/【译】为什么Vue-js不支持templateURL/index.html","hash":"a4bb7b41daf86542f71b6bd405dc2c9082b9d755","modified":1517594487774},{"_id":"public/2016/06/26/Cookie和Session的区别总结/index.html","hash":"51440dde27109d65c4514b35c31b8c97d0c1fac1","modified":1517594487774},{"_id":"public/2016/05/29/你该逃课吗/index.html","hash":"98147edec44217f2d2ab83400f980f482229c724","modified":1517594487774},{"_id":"public/2016/05/23/traceroute的原理/index.html","hash":"8f6331b521bbb2a90569fd59eea1edb8b7f7b825","modified":1517594487774},{"_id":"public/2016/05/18/自定义复选框/index.html","hash":"4540243f323b3fa0788750943cb9f4a6defeea89","modified":1517594487774},{"_id":"public/2016/05/02/类数组转换为数组/index.html","hash":"4a11ae1d31356c1a515f72356009021d67bc04b4","modified":1517594487774},{"_id":"public/2016/05/01/让Ajax支持浏览器的前进后退/index.html","hash":"a5ae9b16dfe6ba98373a90297c1d90a7ce88eafc","modified":1517594487774},{"_id":"public/2016/04/28/DNS劫持与DNS污染的原理/index.html","hash":"df05cdae8fbca94cfeb1a5000f3337b199cd1569","modified":1517594487774},{"_id":"public/2016/03/22/【JavaScript实现算法】快速排序/index.html","hash":"760a0b56a60edf18e68cbec37f0c99a006f03d1c","modified":1517594487774},{"_id":"public/2016/03/21/实现JavaScript中的indexOf方法/index.html","hash":"a35343bdd5a6d86dc201765ddb9850c73371d0e0","modified":1517594487774},{"_id":"public/2016/03/21/【JavaScript实现数据结构】队列/index.html","hash":"012d5056a4eed42f2032bfcd27e76fd950b674c2","modified":1517594487774},{"_id":"public/2016/03/16/阿里前端实习电话面试（二）/index.html","hash":"e1e50d4d14a1f07ab6938fd1fd932a87a5c36b82","modified":1517594487774},{"_id":"public/2016/03/16/CDN缓存原理/index.html","hash":"6dad9e9e8281f24bf5c1236008882d4dd7533f20","modified":1517594487774},{"_id":"public/2016/03/16/apply方法的妙用/index.html","hash":"9649c815dd76969b887eaf238434d5f1681b4078","modified":1517594487774},{"_id":"public/2016/03/16/网站性能优化的14条规则/index.html","hash":"2264aa92c392ea6d6efe44dab40a426ec1bc3cd3","modified":1517594487774},{"_id":"public/2016/03/09/2016阿里前端实习电话面试实录/index.html","hash":"ac9ee4ddad844baee09bfc4ee623f84d9bd553b9","modified":1517594487774},{"_id":"public/2016/03/09/什么是TCP连接的三次握手/index.html","hash":"565570b00e6a29f944f8eb3ec642cf870bc449d6","modified":1517594487774},{"_id":"public/2016/03/09/HTTPS知识点/index.html","hash":"4bf208a1a30b3d81caa3aded95027a518573703e","modified":1517594487775},{"_id":"public/2016/03/08/null和undefined的区别/index.html","hash":"703258b12d557e5f731625c98f254d9d38857142","modified":1517594487775},{"_id":"public/2016/03/07/【CSS】文本换行的几个属性/index.html","hash":"7137a584d28adbf9e98452f1d0359fa95f193c2f","modified":1517594487775},{"_id":"public/2016/03/07/【JavaScript】闭包的概念/index.html","hash":"63cf05980fc1ec92fc76d300008569b9371d9aa1","modified":1517594487775},{"_id":"public/2016/03/07/【JavaScript】变量作用域/index.html","hash":"530d2653331953535c629a956fd50896d83faf07","modified":1517594487775},{"_id":"public/2016/03/06/网页渲染中的重绘与重排/index.html","hash":"5b4dc65d6742f65484e2882cea9c73158749ab33","modified":1517594487775},{"_id":"public/2016/03/06/随笔-1/index.html","hash":"d69a119f686c4bda14a4c7d52dc04b413c62d8a1","modified":1517594487775},{"_id":"public/archives/2016/04/index.html","hash":"3870bf1048fa7b9cc65730ed812be2e285489c64","modified":1517594487775},{"_id":"public/archives/2016/06/index.html","hash":"7ca0d3855becb438cd387703c36fbbb725510ab4","modified":1517594487775},{"_id":"public/archives/2016/08/index.html","hash":"bc4704df94ee528a76ab08b8e13c0e3c8c48578d","modified":1517594487775},{"_id":"public/archives/2016/09/index.html","hash":"6452add78158b28534579fbd83169ddde2cef952","modified":1517594487775},{"_id":"public/archives/2017/page/2/index.html","hash":"26817462e7598464de963d8af78dbb923f2e0367","modified":1517594487775},{"_id":"public/archives/2017/01/index.html","hash":"500d3940a7345bc6b47cbf57d6e648e5501218c3","modified":1517594487775},{"_id":"public/archives/2017/02/index.html","hash":"ccbe91790a5f0cec3469bcd6b9bf60311dd1de15","modified":1517594487775},{"_id":"public/archives/2017/03/index.html","hash":"8cd1ce0370c5bcad153df1ecee23d49ddd34e930","modified":1517594487775},{"_id":"public/archives/2017/04/index.html","hash":"6c53f10bc5056086496df359aec8119a1fd3b103","modified":1517594487775},{"_id":"public/archives/2017/05/index.html","hash":"1a879ae745c53b04159b05168a87cae9264d022d","modified":1517594487776},{"_id":"public/archives/2018/index.html","hash":"bfb8d92625ca39a3b21c1306a9470f2ae9abe620","modified":1517594487776},{"_id":"public/archives/2018/01/index.html","hash":"8a6cead154189177e4fe9fd45c9376d21cb38a31","modified":1517594487776},{"_id":"public/archives/2018/02/index.html","hash":"87c39d1eb01b2d5c518b05fdcb70a58b28033687","modified":1517594487776},{"_id":"public/categories/面试/index.html","hash":"c0deeca50a4d7649788662267fa8ee886f86b6c3","modified":1517594487776},{"_id":"public/categories/前端/page/4/index.html","hash":"dab884937e67aad2f92838700da6b935eb0b19c4","modified":1517594487776},{"_id":"public/categories/工具/index.html","hash":"de4940ec069b19fd84796292bbe7e92d768d4095","modified":1517594487776},{"_id":"public/categories/后端/index.html","hash":"c8e7c80fca7f4e4939ea9abab2cfab3129488172","modified":1517594487776},{"_id":"public/categories/随笔/index.html","hash":"0e65f4567a9532334653323ee83ed602b6e0998b","modified":1517594487776},{"_id":"public/categories/Node-js/index.html","hash":"13d98e5a8fcdac2d692a7cbcdb965f1ba930d86d","modified":1517594487776},{"_id":"public/tags/性能优化/index.html","hash":"12070ceb3e4e3667ad7f9daf0c75efcf11df7f45","modified":1517594487776},{"_id":"public/tags/面试/index.html","hash":"7b999cc1e640e0e7d40763352b143bad00ccbd0a","modified":1517594487776},{"_id":"public/tags/DNS/index.html","hash":"989124c76af1e9150e6a2c9face902a7e9265387","modified":1517594487776},{"_id":"public/tags/web安全/index.html","hash":"ce3138453dc78554b5b4d3d94b4c132b7fcaabba","modified":1517594487776},{"_id":"public/tags/JavaScript/page/4/index.html","hash":"b04d0a262902360b4f466ecf13e5a11563bc974c","modified":1517594487777},{"_id":"public/tags/HTTP/index.html","hash":"4b39ca3e69b486045dae7b482631a9385310f212","modified":1517594487777},{"_id":"public/tags/Markdown/index.html","hash":"e731fab2a911c602c3652f71b8e5634cb3bc44c2","modified":1517594487777},{"_id":"public/tags/Vue/index.html","hash":"e07aa34fd13bdcbe15465ad7330c78f8f10c3341","modified":1517594487777},{"_id":"public/tags/TCP/index.html","hash":"f206dcea5906d016f0a56e95602372ccce0aee03","modified":1517594487777},{"_id":"public/tags/IP/index.html","hash":"7aa1cddc38890f30ad21b28d4df39f2b55f2f879","modified":1517594487777},{"_id":"public/tags/CSS/index.html","hash":"d27b525b529539b3aa9781e1109a7c57305489ea","modified":1517594487777},{"_id":"public/tags/前端/index.html","hash":"a1e4eb0d3e7b92a2ff00fe069b813291808deda2","modified":1517594487777},{"_id":"public/tags/数据结构/index.html","hash":"218539a9447857430472cfe34621d2c953e4bbff","modified":1517594487777},{"_id":"public/tags/算法/index.html","hash":"085cb0cde0698c924d0306ef1a4fa434231fa7c1","modified":1517594487777},{"_id":"public/tags/直播/index.html","hash":"0e93e6f9992a568f49deb8c944a10cf2d7471fc3","modified":1517594487778},{"_id":"public/tags/React/index.html","hash":"3e1ac9a346911c898ae1343c29885c2944ec2b5b","modified":1517594487778},{"_id":"public/tags/随笔/index.html","hash":"c2e7d3599157ee40219190144cff61eb77843007","modified":1517594487778},{"_id":"public/tags/浏览器/index.html","hash":"a08512ddd746fcaec2707897ec47fe4d1b1e666c","modified":1517594487778},{"_id":"public/tags/运维/index.html","hash":"a8e1d6c8ac3fde752b4bf1ff643a73971e370a87","modified":1517594487778},{"_id":"public/Tags/index.html","hash":"7170e74ee4cc522480ffc66a018da114a08f54c3","modified":1517594487778},{"_id":"public/works/index.html","hash":"bf66c6a234e1440b532c88af2bba451f5af05b79","modified":1517594487778},{"_id":"public/2018/02/02/TCP性能优化浅析/index.html","hash":"928969afb03a4c8a11bfffafd3014819ff0ffc81","modified":1517594487778},{"_id":"public/2017/05/11/我的HTTPS升级之旅/index.html","hash":"c754ee68b46ebcc3e5a9d34a4d8c23c6e5d248ad","modified":1517594487778},{"_id":"public/2017/04/05/【译】异步：现在与将来（并发篇）/index.html","hash":"02a545bd83601209d1a8da94e269a59ade103b23","modified":1517594487778},{"_id":"public/2017/04/01/ES6语法总结/index.html","hash":"f55a42b392d7458820dd7aa8bd759bd2c1baa412","modified":1517594487778},{"_id":"public/2017/04/01/【译】异步：现在与将来（并行篇）/index.html","hash":"c3ba87e8d47b574f4707b9a9ddadaae325f9647b","modified":1517594487778},{"_id":"public/2017/04/01/【译】异步：现在与将来（基础篇）/index.html","hash":"1abb4599bca4981786be5f5c4af5ce892981e89b","modified":1517594487778},{"_id":"public/2017/03/12/【译】HLS架构简介/index.html","hash":"2371c7cd5401188792ff7a616947ae9c9042000d","modified":1517594487778},{"_id":"public/2017/02/05/【译】2017-年要去学的-3-个-CSS-新属性/index.html","hash":"96118ce750d724e4ec1e7cbc072a1eb0f7f7173e","modified":1517594487779},{"_id":"public/2017/01/09/【JavaScript】splice方法实现原理分析/index.html","hash":"fd68648beb99b6c07067b3bad29d2f331d29980f","modified":1517594487779},{"_id":"public/2016/09/08/【译】真实的Virtual-DOM/index.html","hash":"9a1543e8ddd209e253f624394f6cb8047056f33a","modified":1517594487779},{"_id":"public/2016/09/07/Vue2-0源码学习-0/index.html","hash":"1fd33c5ec41b9855bfb2582f6c3c2a72d3e4b267","modified":1517594487779},{"_id":"public/2016/04/29/一个通用的事件监听器/index.html","hash":"f8c23c2581475da2728d30a259585bdab1496c13","modified":1517594487779},{"_id":"public/2016/04/17/一个优化的快速排序/index.html","hash":"0c77716ec80a84134366199b45dc51078dc4e512","modified":1517594487779},{"_id":"public/2016/04/05/部署Node项目到CentOS服务器/index.html","hash":"d3279b058766777399a2eee924b659bcbb182f49","modified":1517594487779},{"_id":"public/2016/03/21/数组去重/index.html","hash":"ffca3cc37c95b85344ba77caa21bb5ea10091928","modified":1517594487779},{"_id":"public/2016/03/21/【JavaScript实现数据结构】栈/index.html","hash":"3af434c5aea4bf5211c96497893f0a6e1b8e3d3f","modified":1517594487779},{"_id":"public/2016/03/13/HTTP状态码大全/index.html","hash":"e6f69c3ab28b3787377f783dcad7ccae924cf1d9","modified":1517594487779},{"_id":"public/2016/03/11/cookie/index.html","hash":"031975a73d47c3d6c56830e9d91caaa6e5612863","modified":1517594487779},{"_id":"public/2016/03/10/正则表达式的模式匹配/index.html","hash":"da39cd3cf0ed4435c148addbc07d093bb9ca2ad2","modified":1517594487779},{"_id":"public/2016/03/09/深入理解BFC/index.html","hash":"29691a82600395066880561adbce3e846ff9bd29","modified":1517594487780},{"_id":"public/2016/03/07/localStorage详解/index.html","hash":"98a5e5235ee3fb2cea47bee6e23e2d506a4e4755","modified":1517594487780},{"_id":"public/2016/03/07/Markdown简明语法/index.html","hash":"ad29c7d01681ffa02a7caf7db94dcb0bb8e65187","modified":1517594487780},{"_id":"public/archives/index.html","hash":"5abb6802ec87c34fe1a58552488b81af86c877ef","modified":1517594487780},{"_id":"public/archives/page/2/index.html","hash":"dbae5a9d739737d3c284382f6449a018d381fc85","modified":1517594487780},{"_id":"public/archives/page/3/index.html","hash":"6e26808008c657c129c93076c27470b3ca8d82c3","modified":1517594487780},{"_id":"public/archives/page/4/index.html","hash":"3d8bfd8f302e848ce65973c5d698afa0da4b8acb","modified":1517594487780},{"_id":"public/archives/page/5/index.html","hash":"99cb3d66a2e20540f21e4a8bacc71d10349d2dd4","modified":1517594487780},{"_id":"public/archives/page/6/index.html","hash":"9b5d402142fefd1b766d0aeeb2b22ec4067f2f45","modified":1517594487780},{"_id":"public/archives/2016/index.html","hash":"cc977193be7dbc2a1c43b17fa263459022243180","modified":1517594487780},{"_id":"public/archives/2016/page/2/index.html","hash":"b73714687da72356ddd789ac7ba0ba5a8f8d3e5e","modified":1517594487780},{"_id":"public/archives/2016/page/3/index.html","hash":"e620e9436c5e7a6954b7342f2862a551212fc424","modified":1517594487780},{"_id":"public/archives/2016/page/4/index.html","hash":"fefb61a34e9434103ad26e6e9e60bd234bfaf1bf","modified":1517594487781},{"_id":"public/archives/2016/page/5/index.html","hash":"e015b589fbdee39da61e1bcc1b726112fccfb3f3","modified":1517594487781},{"_id":"public/archives/2016/03/index.html","hash":"08dcd405bb0d3ffd140c1a387bfc388d93b5e50a","modified":1517594487781},{"_id":"public/archives/2016/03/page/2/index.html","hash":"1167aa70d0d3077cc868b3811c6cb2a57119f2ef","modified":1517594487781},{"_id":"public/archives/2016/03/page/3/index.html","hash":"bd6b72832c38f55450151f5314f8b58c5f16709d","modified":1517594487781},{"_id":"public/archives/2016/05/index.html","hash":"7ded58627f6ede2bae7fdc6b16eacd177f6f2a4e","modified":1517594487781},{"_id":"public/archives/2017/index.html","hash":"589498cb6100ce6c2a63f4bd40306fc5e89c731f","modified":1517594487781},{"_id":"public/index.html","hash":"e357e1a652b1fbe12dcd2af771f916d746d67393","modified":1517594487781},{"_id":"public/page/2/index.html","hash":"8b3c14532780e5782961a68fa76f85c2776df347","modified":1517594487781},{"_id":"public/page/3/index.html","hash":"89253aa37d6dc4d39919666df77876a0d8110690","modified":1517594487782},{"_id":"public/page/4/index.html","hash":"8b2ee20f33a501594ffde50f88417fa3938ccbf2","modified":1517594487782},{"_id":"public/page/5/index.html","hash":"088d9afb0271a55fcb88fc119c10802a208a349b","modified":1517594487782},{"_id":"public/page/6/index.html","hash":"81ca7291f27141783fe42a17b1e1784bded1247b","modified":1517594487782},{"_id":"public/categories/网络/index.html","hash":"a91d4abba93ff40630ba45031f8427e1af8cec4b","modified":1517594487783},{"_id":"public/categories/前端/index.html","hash":"ace7e69db77fe6923e10ca857e26243df1f7f020","modified":1517594487783},{"_id":"public/categories/前端/page/2/index.html","hash":"28959275a57252b8d243a1cdfd5e6a601410b19a","modified":1517594487783},{"_id":"public/categories/前端/page/3/index.html","hash":"a971b8a34930ca234b3474245713450159e4e464","modified":1517594487784},{"_id":"public/categories/数据结构与算法/index.html","hash":"7221e030744ba444b39f6753920d68351b377f76","modified":1517594487784},{"_id":"public/tags/JavaScript/index.html","hash":"979edce3f0bee991290f8d26f463edefba35651d","modified":1517594487784},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"2fd5427fc9d130bc9a7084fb6903402b321b5bfa","modified":1517594487784},{"_id":"public/tags/JavaScript/page/3/index.html","hash":"d90138ecf2c4d99166c3e4a6829ba8ad4af94bcb","modified":1517594487784},{"_id":"public/tags/翻译/index.html","hash":"02ab84b47aac8213a0e53b317dc7875f68cbb3c2","modified":1517594487784},{"_id":"public/CNAME","hash":"87eb67dc0e83d175b646aa565c07a460039107e8","modified":1517594487801},{"_id":"public/uploads/checkbox_1.png","hash":"26c0c895d54c65e50005fb58943141a4de2bebc5","modified":1517594487801},{"_id":"public/uploads/avatar.jpg","hash":"7ec3b70597f503e1e91aedfde92144b02503c18f","modified":1517594487801},{"_id":"public/uploads/fe-css-0.png","hash":"499bcc1fa87f3b4ae98c750216972cc79df4f5d9","modified":1517594487801},{"_id":"public/uploads/checkbox_3.png","hash":"7875434faeb6590c33e31ae60687dab88a32eed7","modified":1517594487801},{"_id":"public/uploads/checkbox_4.png","hash":"18d784eda46c00ccffc595c695cb74a1c718b96f","modified":1517594487801},{"_id":"public/uploads/checkbox_2.png","hash":"657b36f7b2040da6d1af72afa867f35f983dc047","modified":1517594487802},{"_id":"public/uploads/fe-css-2.png","hash":"939c40b72b69d4af5d787d771419577bbb558b4f","modified":1517594487802},{"_id":"public/uploads/fe-css-1.jpg","hash":"889ca1fa98dd91f37a23cfbe5c24c7f03b24e63d","modified":1517594487802},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1517594487802},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1517594487802},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1517594487802},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1517594487802},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1517594488160},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1517594488233},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1517594488233},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1517594488233},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1517594488233},{"_id":"public/css/blog-style.css","hash":"60aab748de9873aaa5c3fee2995d28c139647887","modified":1517594488233},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1517594488233},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1517594488233},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1517594488233},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1517594488234}],"Category":[{"name":"网络","_id":"cjd68ko2200050pk3pl5dy0jq"},{"name":"面试","_id":"cjd68ko28000b0pk3rhe2wtxy"},{"name":"前端","_id":"cjd68ko2j000n0pk33x06pni8"},{"name":"工具","_id":"cjd68ko2q00100pk3qf8avp1i"},{"name":"数据结构与算法","_id":"cjd68ko33001x0pk38zjpp7hb"},{"name":"后端","_id":"cjd68ko3e002l0pk3uzmcyb55"},{"name":"随笔","_id":"cjd68ko3r00370pk3hb1xzh18"},{"name":"Node.js","_id":"cjd68ko4d004e0pk36ev9nuno"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>","date":"2016-03-06T12:05:54.000Z","updated":"2016-03-06T12:05:54.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjd68ko1300000pk3wumzx6fr","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>"},{"title":"About","date":"2017-01-03T12:35:04.000Z","layout":"about","_content":"aaa\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2017-01-03 20:35:04\nlayout: about\n---\naaa\n","updated":"2017-02-20T15:44:02.000Z","path":"about/index.html","comments":1,"_id":"cjd68ko1y00020pk3avhxl9ag","content":"<p>aaa</p>\n","site":{"data":{}},"excerpt":"","more":"<p>aaa</p>\n"},{"title":"Tags","date":"2016-12-15T10:21:17.000Z","layout":"tags","_content":"","source":"Tags/index.md","raw":"---\ntitle: Tags\ndate: 2016-12-15 18:21:17\nlayout: tags\n---\n","updated":"2017-02-20T15:44:06.000Z","path":"Tags/index.html","comments":1,"_id":"cjd68ko2100040pk3ay6cekx5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Works","date":"2017-01-03T13:07:12.000Z","layout":"works","data":{"project":[{"title":"专家系统","data":"2016.12","img_link":""}]},"_content":"","source":"works/index.md","raw":"---\ntitle: Works\ndate: 2017-01-03 21:07:12\nlayout: works\ndata: {\n  project: [{\n      title: \"专家系统\",\n      data: \"2016.12\",\n      img_link: \"\"\n  }]\n}\n---\n","updated":"2017-02-20T15:43:23.000Z","path":"works/index.html","comments":1,"_id":"cjd68ko2500080pk3dhvx4zdu","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CDN缓存原理","date":"2016-03-15T19:46:38.000Z","_content":"\n启用CDN缓存后浏览器访问的全过程：\n\n1.用户输入URL，浏览器将解析过后的域名发给DNS服务器\n\n2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。\n\n3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。\n\n4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。\n\n5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。\n\n6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。","source":"_posts/CDN缓存原理.md","raw":"---\ntitle: CDN缓存原理\ndate: 2016-03-16 03:46:38\ntags:\n- 性能优化\ncategories: \n- 网络\n---\n\n启用CDN缓存后浏览器访问的全过程：\n\n1.用户输入URL，浏览器将解析过后的域名发给DNS服务器\n\n2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。\n\n3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。\n\n4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。\n\n5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。\n\n6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。","slug":"CDN缓存原理","published":1,"updated":"2016-03-15T19:48:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko1v00010pk3koufyqmq","content":"<p>启用CDN缓存后浏览器访问的全过程：</p>\n<p>1.用户输入URL，浏览器将解析过后的域名发给DNS服务器</p>\n<p>2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。</p>\n<p>3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。</p>\n<p>4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。</p>\n<p>5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。</p>\n<p>6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>启用CDN缓存后浏览器访问的全过程：</p>\n<p>1.用户输入URL，浏览器将解析过后的域名发给DNS服务器</p>\n<p>2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。</p>\n<p>3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。</p>\n<p>4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。</p>\n<p>5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。</p>\n<p>6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。</p>\n"},{"title":"阿里前端实习电话面试（一）","date":"2016-03-09T12:28:43.000Z","_content":"一下子记不全，可能遗漏了一些问题......下面是正文\n\n0.你的项目团队中前端的人数？\n答：（此处略去20字）\n\n1.谈谈你在项目中用到的技术？\n答：全部采用原生CSS，JS，Ajax......\n\n2.CSS如何垂直居中？\n答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等\n\n3.如何清除浮动？\n答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC...\n\n4.好吧，你提到了BFC，那就解释一下BFC的特性吧？\n答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对...\n\n5.如何用原生JS实现jQuery选择器？\n答：querySelector和querySeletorAll\n\n6.如果不使用querySelector呢？如何实现对.a .b的选择？\n答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素...于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。\n\n7.如何给子元素到父元素依次绑定事件？\n答：不考虑兼容性的话，使用addEventListenr。\n\n8.addEventListenr有三个参数，解释一下最后一个参数？\n答：事件冒泡和事件捕获的区别\n\n9.解释一下事件冒泡和事件捕获\n答：（此处略去100字）\n\n10.我的问题问完了，你有什么要问我的吗？\n答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react...\n\n总结：问的问题都相当基础，正好我也只会这些基础的......希望后面能顺利，继续刷犀牛书去了^_^\n\n大致如此","source":"_posts/2016阿里前端实习电话面试实录.md","raw":"---\ntitle: 阿里前端实习电话面试（一）\ndate: 2016-03-09 20:28:43\ntags: \n- 面试\ncategories:\n- 面试\n---\n一下子记不全，可能遗漏了一些问题......下面是正文\n\n0.你的项目团队中前端的人数？\n答：（此处略去20字）\n\n1.谈谈你在项目中用到的技术？\n答：全部采用原生CSS，JS，Ajax......\n\n2.CSS如何垂直居中？\n答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等\n\n3.如何清除浮动？\n答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC...\n\n4.好吧，你提到了BFC，那就解释一下BFC的特性吧？\n答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对...\n\n5.如何用原生JS实现jQuery选择器？\n答：querySelector和querySeletorAll\n\n6.如果不使用querySelector呢？如何实现对.a .b的选择？\n答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素...于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。\n\n7.如何给子元素到父元素依次绑定事件？\n答：不考虑兼容性的话，使用addEventListenr。\n\n8.addEventListenr有三个参数，解释一下最后一个参数？\n答：事件冒泡和事件捕获的区别\n\n9.解释一下事件冒泡和事件捕获\n答：（此处略去100字）\n\n10.我的问题问完了，你有什么要问我的吗？\n答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react...\n\n总结：问的问题都相当基础，正好我也只会这些基础的......希望后面能顺利，继续刷犀牛书去了^_^\n\n大致如此","slug":"2016阿里前端实习电话面试实录","published":1,"updated":"2016-03-16T14:25:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko1z00030pk33d0em4jc","content":"<p>一下子记不全，可能遗漏了一些问题……下面是正文</p>\n<p>0.你的项目团队中前端的人数？<br>答：（此处略去20字）</p>\n<p>1.谈谈你在项目中用到的技术？<br>答：全部采用原生CSS，JS，Ajax……</p>\n<p>2.CSS如何垂直居中？<br>答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等</p>\n<p>3.如何清除浮动？<br>答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC…</p>\n<p>4.好吧，你提到了BFC，那就解释一下BFC的特性吧？<br>答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对…</p>\n<p>5.如何用原生JS实现jQuery选择器？<br>答：querySelector和querySeletorAll</p>\n<p>6.如果不使用querySelector呢？如何实现对.a .b的选择？<br>答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素…于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。</p>\n<p>7.如何给子元素到父元素依次绑定事件？<br>答：不考虑兼容性的话，使用addEventListenr。</p>\n<p>8.addEventListenr有三个参数，解释一下最后一个参数？<br>答：事件冒泡和事件捕获的区别</p>\n<p>9.解释一下事件冒泡和事件捕获<br>答：（此处略去100字）</p>\n<p>10.我的问题问完了，你有什么要问我的吗？<br>答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react…</p>\n<p>总结：问的问题都相当基础，正好我也只会这些基础的……希望后面能顺利，继续刷犀牛书去了^_^</p>\n<p>大致如此</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一下子记不全，可能遗漏了一些问题……下面是正文</p>\n<p>0.你的项目团队中前端的人数？<br>答：（此处略去20字）</p>\n<p>1.谈谈你在项目中用到的技术？<br>答：全部采用原生CSS，JS，Ajax……</p>\n<p>2.CSS如何垂直居中？<br>答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等</p>\n<p>3.如何清除浮动？<br>答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC…</p>\n<p>4.好吧，你提到了BFC，那就解释一下BFC的特性吧？<br>答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对…</p>\n<p>5.如何用原生JS实现jQuery选择器？<br>答：querySelector和querySeletorAll</p>\n<p>6.如果不使用querySelector呢？如何实现对.a .b的选择？<br>答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素…于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。</p>\n<p>7.如何给子元素到父元素依次绑定事件？<br>答：不考虑兼容性的话，使用addEventListenr。</p>\n<p>8.addEventListenr有三个参数，解释一下最后一个参数？<br>答：事件冒泡和事件捕获的区别</p>\n<p>9.解释一下事件冒泡和事件捕获<br>答：（此处略去100字）</p>\n<p>10.我的问题问完了，你有什么要问我的吗？<br>答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react…</p>\n<p>总结：问的问题都相当基础，正好我也只会这些基础的……希望后面能顺利，继续刷犀牛书去了^_^</p>\n<p>大致如此</p>\n"},{"title":"DNS劫持与DNS污染的原理","date":"2016-04-28T14:24:01.000Z","_content":"DNS劫持就是通过**劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP**，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。\nDNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。\n\nDNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常**基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改**，**通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。**用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。\n\nDNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。\n\n区别：\nDNS劫持是劫持了DNS服务器，进而修改其解析结果。\nDNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。\n\n一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。","source":"_posts/DNS劫持与DNS污染的原理.md","raw":"---\ntitle: DNS劫持与DNS污染的原理\ndate: 2016-04-28 22:24:01\ntags:\n- DNS\n- web安全\ncategories:\n- 网络\n---\nDNS劫持就是通过**劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP**，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。\nDNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。\n\nDNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常**基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改**，**通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。**用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。\n\nDNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。\n\n区别：\nDNS劫持是劫持了DNS服务器，进而修改其解析结果。\nDNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。\n\n一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。","slug":"DNS劫持与DNS污染的原理","published":1,"updated":"2016-04-28T14:25:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2400070pk38be4jbng","content":"<p>DNS劫持就是通过<strong>劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP</strong>，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。<br>DNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>\n<p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常<strong>基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改</strong>，<strong>通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</strong>用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。</p>\n<p>DNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。</p>\n<p>区别：<br>DNS劫持是劫持了DNS服务器，进而修改其解析结果。<br>DNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。</p>\n<p>一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>DNS劫持就是通过<strong>劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP</strong>，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。<br>DNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>\n<p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常<strong>基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改</strong>，<strong>通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</strong>用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。</p>\n<p>DNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。</p>\n<p>区别：<br>DNS劫持是劫持了DNS服务器，进而修改其解析结果。<br>DNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。</p>\n<p>一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。</p>\n"},{"title":"Cookie和Session的区别总结","date":"2016-06-26T05:55:10.000Z","_content":"二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。\n<!-- more -->\n创建Session过程：\n- 检查客户端请求中是否包含一个session标识（session id）\n- 若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session\n- 若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）\n\n若Cookie被禁止，必须有其他机制能够把session id回传给服务器\n回传session id至服务器：\n\n- URL重写：把session id直接附加在URL路径后面\n- 隐藏表单字段\n\nCookie和Session的区别：\n- **Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据**，甚至Java Bean乃至任何Java类、对象等\n- **隐私策略不同**。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险\n- **有效期不同**。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。\n- **服务器压力不同**。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。\n- **浏览器支持不同**。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。\n- **跨域支持不同**。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问\n\n------------\n参考：[理解Cookie和Session机制](http://www.lai18.com/content/7450273.html)\n","source":"_posts/Cookie和Session的区别总结.md","raw":"---\ntitle: Cookie和Session的区别总结\ndate: 2016-06-26 13:55:10\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。\n<!-- more -->\n创建Session过程：\n- 检查客户端请求中是否包含一个session标识（session id）\n- 若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session\n- 若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）\n\n若Cookie被禁止，必须有其他机制能够把session id回传给服务器\n回传session id至服务器：\n\n- URL重写：把session id直接附加在URL路径后面\n- 隐藏表单字段\n\nCookie和Session的区别：\n- **Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据**，甚至Java Bean乃至任何Java类、对象等\n- **隐私策略不同**。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险\n- **有效期不同**。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。\n- **服务器压力不同**。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。\n- **浏览器支持不同**。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。\n- **跨域支持不同**。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问\n\n------------\n参考：[理解Cookie和Session机制](http://www.lai18.com/content/7450273.html)\n","slug":"Cookie和Session的区别总结","published":1,"updated":"2016-09-04T08:41:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2600090pk36qwk0l9h","content":"<p>二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。<br><a id=\"more\"></a><br>创建Session过程：</p>\n<ul>\n<li>检查客户端请求中是否包含一个session标识（session id）</li>\n<li>若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session</li>\n<li>若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）</li>\n</ul>\n<p>若Cookie被禁止，必须有其他机制能够把session id回传给服务器<br>回传session id至服务器：</p>\n<ul>\n<li>URL重写：把session id直接附加在URL路径后面</li>\n<li>隐藏表单字段</li>\n</ul>\n<p>Cookie和Session的区别：</p>\n<ul>\n<li><strong>Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据</strong>，甚至Java Bean乃至任何Java类、对象等</li>\n<li><strong>隐私策略不同</strong>。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险</li>\n<li><strong>有效期不同</strong>。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。</li>\n<li><strong>服务器压力不同</strong>。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。</li>\n<li><strong>浏览器支持不同</strong>。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。</li>\n<li><strong>跨域支持不同</strong>。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问</li>\n</ul>\n<hr>\n<p>参考：<a href=\"http://www.lai18.com/content/7450273.html\" target=\"_blank\" rel=\"noopener\">理解Cookie和Session机制</a></p>\n","site":{"data":{}},"excerpt":"<p>二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。<br>","more":"<br>创建Session过程：</p>\n<ul>\n<li>检查客户端请求中是否包含一个session标识（session id）</li>\n<li>若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session</li>\n<li>若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）</li>\n</ul>\n<p>若Cookie被禁止，必须有其他机制能够把session id回传给服务器<br>回传session id至服务器：</p>\n<ul>\n<li>URL重写：把session id直接附加在URL路径后面</li>\n<li>隐藏表单字段</li>\n</ul>\n<p>Cookie和Session的区别：</p>\n<ul>\n<li><strong>Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据</strong>，甚至Java Bean乃至任何Java类、对象等</li>\n<li><strong>隐私策略不同</strong>。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险</li>\n<li><strong>有效期不同</strong>。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。</li>\n<li><strong>服务器压力不同</strong>。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。</li>\n<li><strong>浏览器支持不同</strong>。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。</li>\n<li><strong>跨域支持不同</strong>。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问</li>\n</ul>\n<hr>\n<p>参考：<a href=\"http://www.lai18.com/content/7450273.html\" target=\"_blank\" rel=\"noopener\">理解Cookie和Session机制</a></p>"},{"title":"ES6语法总结","date":"2017-03-31T16:41:08.000Z","_content":"#### Arrow Function\n- 箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）\n\n#### Class\n- 原型链继承的一种语法糖\n- ES6 的类可以看过构造函数的另一种写法\n```\nclass Point {\n//...\n}\ntypeof Point //'function'\nPoint === Point.prototype.constructor\n```\n- 类内部定义的方法都不可枚举(non-enumerable)\n- 不存在变量提升(hoist)\n- 实现私有方法\n  1. 将方法移出 Class，定义在全局作用域\n  2. 将私有方法的名字命名为一个 Symbol 值\n\n```\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\nexport default class myClass{\n　// 公有方法\n　foo(baz) {\n　　this[bar](baz);\n　}\n　// 私有方法\n　[bar](baz) {\n　　return this[snaf] = baz;\n 　}\n　// ...\n};\n```\n- 允许继承原生构造函数\n- 添加静态属性，静态方法\n```\nclass Foo {\n　static classMethod() {\n　　return 'hello';\n　}\n}\nFoo.prop = 1;\nFoo.prop // 1\nFoo.classMethod() // 'hello'\n```\n\n#### Promise\n- 三种状态 Pending、Resolved、Rejected。\n- 缺点：\n  1. 无法中途取消 Promise。\n  2. 如果不设置回调，内部抛出的错误无法反应到外部。\n  3. 大量的 then() 语句导致语义不清楚。\n\n#### Generator\n- yield 语句暂停函数执行。\n- generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。\n- 使用 for...of 遍历 Iterator 对象\n- generator 作用：\n  1.  执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。\n  2. 实现数组数据结构，每一项都是一个函数 。\n- generator 缺点：\n  1. 流程管理困难，需要手动执行。解决办法：\n      - Thunk 函数、传名调用。\n      - 使用 Co　\n      - 将异步操作包装成 Promise 对象，用 then 方法交出执行权。\n\n####Module\n- 编译时确定模块依赖，编译时加载，使得静态分析成为可能。\n- ES6 模块不是对象。\n- export 输出的是对外的接口。\n- 模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。\n- 循环加载：\n  1. CommonJS 特点：加载时执行。当发生循环加载时，就只输出已经执行的部分。\n  2. ES6 模块是动态引用。只要引用存在，代码就可以执行。\n","source":"_posts/ES6语法总结.md","raw":"---\ntitle: ES6语法总结\ndate: 2017-04-01 00:41:08\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n#### Arrow Function\n- 箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）\n\n#### Class\n- 原型链继承的一种语法糖\n- ES6 的类可以看过构造函数的另一种写法\n```\nclass Point {\n//...\n}\ntypeof Point //'function'\nPoint === Point.prototype.constructor\n```\n- 类内部定义的方法都不可枚举(non-enumerable)\n- 不存在变量提升(hoist)\n- 实现私有方法\n  1. 将方法移出 Class，定义在全局作用域\n  2. 将私有方法的名字命名为一个 Symbol 值\n\n```\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\nexport default class myClass{\n　// 公有方法\n　foo(baz) {\n　　this[bar](baz);\n　}\n　// 私有方法\n　[bar](baz) {\n　　return this[snaf] = baz;\n 　}\n　// ...\n};\n```\n- 允许继承原生构造函数\n- 添加静态属性，静态方法\n```\nclass Foo {\n　static classMethod() {\n　　return 'hello';\n　}\n}\nFoo.prop = 1;\nFoo.prop // 1\nFoo.classMethod() // 'hello'\n```\n\n#### Promise\n- 三种状态 Pending、Resolved、Rejected。\n- 缺点：\n  1. 无法中途取消 Promise。\n  2. 如果不设置回调，内部抛出的错误无法反应到外部。\n  3. 大量的 then() 语句导致语义不清楚。\n\n#### Generator\n- yield 语句暂停函数执行。\n- generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。\n- 使用 for...of 遍历 Iterator 对象\n- generator 作用：\n  1.  执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。\n  2. 实现数组数据结构，每一项都是一个函数 。\n- generator 缺点：\n  1. 流程管理困难，需要手动执行。解决办法：\n      - Thunk 函数、传名调用。\n      - 使用 Co　\n      - 将异步操作包装成 Promise 对象，用 then 方法交出执行权。\n\n####Module\n- 编译时确定模块依赖，编译时加载，使得静态分析成为可能。\n- ES6 模块不是对象。\n- export 输出的是对外的接口。\n- 模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。\n- 循环加载：\n  1. CommonJS 特点：加载时执行。当发生循环加载时，就只输出已经执行的部分。\n  2. ES6 模块是动态引用。只要引用存在，代码就可以执行。\n","slug":"ES6语法总结","published":1,"updated":"2017-03-31T16:46:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko27000a0pk35niks76d","content":"<h4 id=\"Arrow-Function\"><a href=\"#Arrow-Function\" class=\"headerlink\" title=\"Arrow Function\"></a>Arrow Function</h4><ul>\n<li>箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）</li>\n</ul>\n<h4 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h4><ul>\n<li>原型链继承的一种语法糖</li>\n<li><p>ES6 的类可以看过构造函数的另一种写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">typeof Point //&apos;function&apos;</span><br><span class=\"line\">Point === Point.prototype.constructor</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类内部定义的方法都不可枚举(non-enumerable)</p>\n</li>\n<li>不存在变量提升(hoist)</li>\n<li>实现私有方法<ol>\n<li>将方法移出 Class，定义在全局作用域</li>\n<li>将私有方法的名字命名为一个 Symbol 值</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const bar = Symbol(&apos;bar&apos;);</span><br><span class=\"line\">const snaf = Symbol(&apos;snaf&apos;);</span><br><span class=\"line\">export default class myClass&#123;</span><br><span class=\"line\">　// 公有方法</span><br><span class=\"line\">　foo(baz) &#123;</span><br><span class=\"line\">　　this[bar](baz);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　// 私有方法</span><br><span class=\"line\">　[bar](baz) &#123;</span><br><span class=\"line\">　　return this[snaf] = baz;</span><br><span class=\"line\"> 　&#125;</span><br><span class=\"line\">　// ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>允许继承原生构造函数</li>\n<li>添加静态属性，静态方法<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">　static classMethod() &#123;</span><br><span class=\"line\">　　return &apos;hello&apos;;</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prop = 1;</span><br><span class=\"line\">Foo.prop // 1</span><br><span class=\"line\">Foo.classMethod() // &apos;hello&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h4><ul>\n<li>三种状态 Pending、Resolved、Rejected。</li>\n<li>缺点：<ol>\n<li>无法中途取消 Promise。</li>\n<li>如果不设置回调，内部抛出的错误无法反应到外部。</li>\n<li>大量的 then() 语句导致语义不清楚。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h4><ul>\n<li>yield 语句暂停函数执行。</li>\n<li>generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。</li>\n<li>使用 for…of 遍历 Iterator 对象</li>\n<li>generator 作用：<ol>\n<li>执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。</li>\n<li>实现数组数据结构，每一项都是一个函数 。</li>\n</ol>\n</li>\n<li>generator 缺点：<ol>\n<li>流程管理困难，需要手动执行。解决办法：<ul>\n<li>Thunk 函数、传名调用。</li>\n<li>使用 Co　</li>\n<li>将异步操作包装成 Promise 对象，用 then 方法交出执行权。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>####Module</p>\n<ul>\n<li>编译时确定模块依赖，编译时加载，使得静态分析成为可能。</li>\n<li>ES6 模块不是对象。</li>\n<li>export 输出的是对外的接口。</li>\n<li>模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。</li>\n<li>循环加载：<ol>\n<li>CommonJS 特点：加载时执行。当发生循环加载时，就只输出已经执行的部分。</li>\n<li>ES6 模块是动态引用。只要引用存在，代码就可以执行。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Arrow-Function\"><a href=\"#Arrow-Function\" class=\"headerlink\" title=\"Arrow Function\"></a>Arrow Function</h4><ul>\n<li>箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）</li>\n</ul>\n<h4 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h4><ul>\n<li>原型链继承的一种语法糖</li>\n<li><p>ES6 的类可以看过构造函数的另一种写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">typeof Point //&apos;function&apos;</span><br><span class=\"line\">Point === Point.prototype.constructor</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类内部定义的方法都不可枚举(non-enumerable)</p>\n</li>\n<li>不存在变量提升(hoist)</li>\n<li>实现私有方法<ol>\n<li>将方法移出 Class，定义在全局作用域</li>\n<li>将私有方法的名字命名为一个 Symbol 值</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const bar = Symbol(&apos;bar&apos;);</span><br><span class=\"line\">const snaf = Symbol(&apos;snaf&apos;);</span><br><span class=\"line\">export default class myClass&#123;</span><br><span class=\"line\">　// 公有方法</span><br><span class=\"line\">　foo(baz) &#123;</span><br><span class=\"line\">　　this[bar](baz);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　// 私有方法</span><br><span class=\"line\">　[bar](baz) &#123;</span><br><span class=\"line\">　　return this[snaf] = baz;</span><br><span class=\"line\"> 　&#125;</span><br><span class=\"line\">　// ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>允许继承原生构造函数</li>\n<li>添加静态属性，静态方法<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">　static classMethod() &#123;</span><br><span class=\"line\">　　return &apos;hello&apos;;</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prop = 1;</span><br><span class=\"line\">Foo.prop // 1</span><br><span class=\"line\">Foo.classMethod() // &apos;hello&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h4><ul>\n<li>三种状态 Pending、Resolved、Rejected。</li>\n<li>缺点：<ol>\n<li>无法中途取消 Promise。</li>\n<li>如果不设置回调，内部抛出的错误无法反应到外部。</li>\n<li>大量的 then() 语句导致语义不清楚。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h4><ul>\n<li>yield 语句暂停函数执行。</li>\n<li>generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。</li>\n<li>使用 for…of 遍历 Iterator 对象</li>\n<li>generator 作用：<ol>\n<li>执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。</li>\n<li>实现数组数据结构，每一项都是一个函数 。</li>\n</ol>\n</li>\n<li>generator 缺点：<ol>\n<li>流程管理困难，需要手动执行。解决办法：<ul>\n<li>Thunk 函数、传名调用。</li>\n<li>使用 Co　</li>\n<li>将异步操作包装成 Promise 对象，用 then 方法交出执行权。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>####Module</p>\n<ul>\n<li>编译时确定模块依赖，编译时加载，使得静态分析成为可能。</li>\n<li>ES6 模块不是对象。</li>\n<li>export 输出的是对外的接口。</li>\n<li>模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。</li>\n<li>循环加载：<ol>\n<li>CommonJS 特点：加载时执行。当发生循环加载时，就只输出已经执行的部分。</li>\n<li>ES6 模块是动态引用。只要引用存在，代码就可以执行。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"HTTPS知识点","date":"2016-03-09T05:02:05.000Z","_content":"1.网景公司首创，所有主要浏览器和服务器都支持此协议\n2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。\n3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。\n4.数字加密\n　1）对称密钥加密（DES、RC2、RC4）\n　　　加密和解密使用相同的密钥。\n　　　优点:加密解密的效率比较高    \n　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销\n　2）非对称密钥加密（RSA）\n　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。\n　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。\n　　　**问题1：数据传输仅单向安全**。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。\n　　　　　整个加密通信的流程如下：\n　　　　　　１．小明访问XX,XX将自己的证书发给浏览器\n　　　　　　２．浏览器从证书中拿到XX的公钥A\n　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX\n　　　　　　４．XX通过私钥解密，拿到对称密钥B\n　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密\n\n　　　　　如此，也解决了非对称密钥加解密效率低的问题。\n　　　问题2：公钥如何获取，如何保证不被篡改。**HTTPS将公钥放在数字证书中**，只要数字证书是可信的，公钥就是可信的。    \n　3）数字签名\n　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。\n　　　数字签名通常是用非对称密钥技术产生\n　4）数字证书\n　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证\n　　　数字证书的主要内容包括：\n　　　　1. 对象的名称\n　　　　2. 过期时间\n　　　　3. 证书发布者\n　　　　4. 来自证书发布者的数字签名\n\n参考链接： \n　[HTTPS科普扫盲帖](https://segmentfault.com/a/1190000004523659)\n　[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n          ","source":"_posts/HTTPS知识点.md","raw":"---\ntitle: HTTPS知识点\ndate: 2016-03-09 13:02:05\ntags:\n- HTTP\ncategories:\n- 网络\n---\n1.网景公司首创，所有主要浏览器和服务器都支持此协议\n2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。\n3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。\n4.数字加密\n　1）对称密钥加密（DES、RC2、RC4）\n　　　加密和解密使用相同的密钥。\n　　　优点:加密解密的效率比较高    \n　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销\n　2）非对称密钥加密（RSA）\n　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。\n　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。\n　　　**问题1：数据传输仅单向安全**。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。\n　　　　　整个加密通信的流程如下：\n　　　　　　１．小明访问XX,XX将自己的证书发给浏览器\n　　　　　　２．浏览器从证书中拿到XX的公钥A\n　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX\n　　　　　　４．XX通过私钥解密，拿到对称密钥B\n　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密\n\n　　　　　如此，也解决了非对称密钥加解密效率低的问题。\n　　　问题2：公钥如何获取，如何保证不被篡改。**HTTPS将公钥放在数字证书中**，只要数字证书是可信的，公钥就是可信的。    \n　3）数字签名\n　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。\n　　　数字签名通常是用非对称密钥技术产生\n　4）数字证书\n　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证\n　　　数字证书的主要内容包括：\n　　　　1. 对象的名称\n　　　　2. 过期时间\n　　　　3. 证书发布者\n　　　　4. 来自证书发布者的数字签名\n\n参考链接： \n　[HTTPS科普扫盲帖](https://segmentfault.com/a/1190000004523659)\n　[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n          ","slug":"HTTPS知识点","published":1,"updated":"2016-03-22T13:19:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2a000e0pk369yn9o1l","content":"<p>1.网景公司首创，所有主要浏览器和服务器都支持此协议<br>2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。<br>3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。<br>4.数字加密<br>　1）对称密钥加密（DES、RC2、RC4）<br>　　　加密和解密使用相同的密钥。<br>　　　优点:加密解密的效率比较高<br>　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销<br>　2）非对称密钥加密（RSA）<br>　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。<br>　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。<br>　　　<strong>问题1：数据传输仅单向安全</strong>。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。<br>　　　　　整个加密通信的流程如下：<br>　　　　　　１．小明访问XX,XX将自己的证书发给浏览器<br>　　　　　　２．浏览器从证书中拿到XX的公钥A<br>　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX<br>　　　　　　４．XX通过私钥解密，拿到对称密钥B<br>　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密</p>\n<p>　　　　　如此，也解决了非对称密钥加解密效率低的问题。<br>　　　问题2：公钥如何获取，如何保证不被篡改。<strong>HTTPS将公钥放在数字证书中</strong>，只要数字证书是可信的，公钥就是可信的。<br>　3）数字签名<br>　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。<br>　　　数字签名通常是用非对称密钥技术产生<br>　4）数字证书<br>　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证<br>　　　数字证书的主要内容包括：<br>　　　　1. 对象的名称<br>　　　　2. 过期时间<br>　　　　3. 证书发布者<br>　　　　4. 来自证书发布者的数字签名</p>\n<p>参考链接：<br>　<a href=\"https://segmentfault.com/a/1190000004523659\" target=\"_blank\" rel=\"noopener\">HTTPS科普扫盲帖</a><br>　<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL/TLS协议运行机制的概述</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.网景公司首创，所有主要浏览器和服务器都支持此协议<br>2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。<br>3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。<br>4.数字加密<br>　1）对称密钥加密（DES、RC2、RC4）<br>　　　加密和解密使用相同的密钥。<br>　　　优点:加密解密的效率比较高<br>　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销<br>　2）非对称密钥加密（RSA）<br>　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。<br>　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。<br>　　　<strong>问题1：数据传输仅单向安全</strong>。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。<br>　　　　　整个加密通信的流程如下：<br>　　　　　　１．小明访问XX,XX将自己的证书发给浏览器<br>　　　　　　２．浏览器从证书中拿到XX的公钥A<br>　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX<br>　　　　　　４．XX通过私钥解密，拿到对称密钥B<br>　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密</p>\n<p>　　　　　如此，也解决了非对称密钥加解密效率低的问题。<br>　　　问题2：公钥如何获取，如何保证不被篡改。<strong>HTTPS将公钥放在数字证书中</strong>，只要数字证书是可信的，公钥就是可信的。<br>　3）数字签名<br>　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。<br>　　　数字签名通常是用非对称密钥技术产生<br>　4）数字证书<br>　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证<br>　　　数字证书的主要内容包括：<br>　　　　1. 对象的名称<br>　　　　2. 过期时间<br>　　　　3. 证书发布者<br>　　　　4. 来自证书发布者的数字签名</p>\n<p>参考链接：<br>　<a href=\"https://segmentfault.com/a/1190000004523659\" target=\"_blank\" rel=\"noopener\">HTTPS科普扫盲帖</a><br>　<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL/TLS协议运行机制的概述</a></p>\n"},{"title":"Markdown简明语法","date":"2016-03-07T08:37:23.000Z","_content":"### 标题\n在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。\n`# 一级标题`\n`## 二级标题`\n`### 三级标题`\n`#### 四级标题`\n`##### 五级标题`\n`###### 六级标题`\n\n### 列表\n\n在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\n`_列表内容`\n`1. 列表内容`\n\n无序列表使用 \\* + 和 - 来做为列表的项目标记，这些符号是都可以使用的\n\n### 修辞和强调\nMarkdown 使用 * 和 _ 来标记需要强调的区段。\n\n`*需要强调的内容*`\n`**需要强调的内容**`\n\n### 引用\n只需要在文本前加入 > 这种尖括号（大于号）即可\n`> 引用的内容`\n\n### 图片与链接\n###### 链接\nMarkdown 支持两种形式的链接语法： **行内** 和 **参考** 两种形式，两种都是使用[ ]来把文字转成连结。\n1. 行内形式是直接在后面用括号直接接上链接：\nThis is an \\[example link\\]\\(http://example.com\\).\n2. 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：\nI get 10 times more traffic from [Google] than from[Yahoo] or [MSN]: \nhttp://google.com/ \"Google\": \nhttp://search.msn.com/ \"MSN\"\n\n###### 图片\n图片的语法和链接很像。\n\n1. 行内形式（title 可选）：\n\\[imgUrl (\"Title\")]\n2. 参考形式：\n\\![alt text][id]\n\\[id]: imgUrl \"Title\"\n\n上面两种方法都会输出 图片 为：\n![avatar.jpg](/uploads/avatar.jpg)\n\n### 代码\n在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 & 、< 和 > 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：\n\n``I strongly recommend against using any `<blink>` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.``\n\n如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &、< 和 > 也一样会自动转成 HTML 实体。\n\n    If you want your page to validate under XHTML 1.0 Strict,you've got to put paragraph tags in your blockquotes:<blockquote><p>For example.</p></blockquote>","source":"_posts/Markdown简明语法.md","raw":"---\ntitle: Markdown简明语法\ndate: 2016-03-07 16:37:23\ntags: \n- Markdown\ncategories:\n- 工具\n---\n### 标题\n在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。\n`# 一级标题`\n`## 二级标题`\n`### 三级标题`\n`#### 四级标题`\n`##### 五级标题`\n`###### 六级标题`\n\n### 列表\n\n在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\n`_列表内容`\n`1. 列表内容`\n\n无序列表使用 \\* + 和 - 来做为列表的项目标记，这些符号是都可以使用的\n\n### 修辞和强调\nMarkdown 使用 * 和 _ 来标记需要强调的区段。\n\n`*需要强调的内容*`\n`**需要强调的内容**`\n\n### 引用\n只需要在文本前加入 > 这种尖括号（大于号）即可\n`> 引用的内容`\n\n### 图片与链接\n###### 链接\nMarkdown 支持两种形式的链接语法： **行内** 和 **参考** 两种形式，两种都是使用[ ]来把文字转成连结。\n1. 行内形式是直接在后面用括号直接接上链接：\nThis is an \\[example link\\]\\(http://example.com\\).\n2. 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：\nI get 10 times more traffic from [Google] than from[Yahoo] or [MSN]: \nhttp://google.com/ \"Google\": \nhttp://search.msn.com/ \"MSN\"\n\n###### 图片\n图片的语法和链接很像。\n\n1. 行内形式（title 可选）：\n\\[imgUrl (\"Title\")]\n2. 参考形式：\n\\![alt text][id]\n\\[id]: imgUrl \"Title\"\n\n上面两种方法都会输出 图片 为：\n![avatar.jpg](/uploads/avatar.jpg)\n\n### 代码\n在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 & 、< 和 > 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：\n\n``I strongly recommend against using any `<blink>` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.``\n\n如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &、< 和 > 也一样会自动转成 HTML 实体。\n\n    If you want your page to validate under XHTML 1.0 Strict,you've got to put paragraph tags in your blockquotes:<blockquote><p>For example.</p></blockquote>","slug":"Markdown简明语法","published":1,"updated":"2016-03-07T09:22:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2e000f0pk3s8tq7j3i","content":"<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。<br><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。<br><code>_列表内容</code><br><code>1. 列表内容</code></p>\n<p>无序列表使用 * + 和 - 来做为列表的项目标记，这些符号是都可以使用的</p>\n<h3 id=\"修辞和强调\"><a href=\"#修辞和强调\" class=\"headerlink\" title=\"修辞和强调\"></a>修辞和强调</h3><p>Markdown 使用 * 和 _ 来标记需要强调的区段。</p>\n<p><code>*需要强调的内容*</code><br><code>**需要强调的内容**</code></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可<br><code>&gt; 引用的内容</code></p>\n<h3 id=\"图片与链接\"><a href=\"#图片与链接\" class=\"headerlink\" title=\"图片与链接\"></a>图片与链接</h3><h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>Markdown 支持两种形式的链接语法： <strong>行内</strong> 和 <strong>参考</strong> 两种形式，两种都是使用[ ]来把文字转成连结。</p>\n<ol>\n<li>行内形式是直接在后面用括号直接接上链接：<br>This is an [example link](<a href=\"http://example.com\\\" target=\"_blank\" rel=\"noopener\">http://example.com\\</a>).</li>\n<li>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：<br>I get 10 times more traffic from [Google] than from[Yahoo] or [MSN]:<br><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">http://google.com/</a> “Google”:<br><a href=\"http://search.msn.com/\" target=\"_blank\" rel=\"noopener\">http://search.msn.com/</a> “MSN”</li>\n</ol>\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>图片的语法和链接很像。</p>\n<ol>\n<li>行内形式（title 可选）：<br>[imgUrl (“Title”)]</li>\n<li>参考形式：<br>![alt text][id]<br>[id]: imgUrl “Title”</li>\n</ol>\n<p>上面两种方法都会输出 图片 为：<br><img src=\"/uploads/avatar.jpg\" alt=\"avatar.jpg\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 &amp; 、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>\n<p><code>I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.</code></p>\n<p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。</p>\n<pre><code>If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;blockquote&gt;&lt;p&gt;For example.&lt;/p&gt;&lt;/blockquote&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。<br><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。<br><code>_列表内容</code><br><code>1. 列表内容</code></p>\n<p>无序列表使用 * + 和 - 来做为列表的项目标记，这些符号是都可以使用的</p>\n<h3 id=\"修辞和强调\"><a href=\"#修辞和强调\" class=\"headerlink\" title=\"修辞和强调\"></a>修辞和强调</h3><p>Markdown 使用 * 和 _ 来标记需要强调的区段。</p>\n<p><code>*需要强调的内容*</code><br><code>**需要强调的内容**</code></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可<br><code>&gt; 引用的内容</code></p>\n<h3 id=\"图片与链接\"><a href=\"#图片与链接\" class=\"headerlink\" title=\"图片与链接\"></a>图片与链接</h3><h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>Markdown 支持两种形式的链接语法： <strong>行内</strong> 和 <strong>参考</strong> 两种形式，两种都是使用[ ]来把文字转成连结。</p>\n<ol>\n<li>行内形式是直接在后面用括号直接接上链接：<br>This is an [example link](<a href=\"http://example.com\\\" target=\"_blank\" rel=\"noopener\">http://example.com\\</a>).</li>\n<li>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：<br>I get 10 times more traffic from [Google] than from[Yahoo] or [MSN]:<br><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">http://google.com/</a> “Google”:<br><a href=\"http://search.msn.com/\" target=\"_blank\" rel=\"noopener\">http://search.msn.com/</a> “MSN”</li>\n</ol>\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>图片的语法和链接很像。</p>\n<ol>\n<li>行内形式（title 可选）：<br>[imgUrl (“Title”)]</li>\n<li>参考形式：<br>![alt text][id]<br>[id]: imgUrl “Title”</li>\n</ol>\n<p>上面两种方法都会输出 图片 为：<br><img src=\"/uploads/avatar.jpg\" alt=\"avatar.jpg\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 &amp; 、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>\n<p><code>I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.</code></p>\n<p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。</p>\n<pre><code>If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;blockquote&gt;&lt;p&gt;For example.&lt;/p&gt;&lt;/blockquote&gt;\n</code></pre>"},{"title":"Vue2.0源码学习#0","date":"2016-09-06T19:37:41.000Z","_content":"> 近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。\n\n<!-- more -->\n作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。\n```\nimport config from './config'\n//加载初始全局API\nimport { initGlobalAPI } from './global-api/index'\n//类的初始化入口\nimport Vue from './instance/index'\n\ninitGlobalAPI(Vue)\n//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染\n//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR\n//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性\n//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因\n//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: () => config._isServer\n})\n//定义Vue版本号\nVue.version = '2.0.0-rc.4'\n\nexport default Vue\n```\n以下就是config的源码\n```\n//Vue使用了Flow做静态类型检查\n//Flow可以在代码运行前检查出参数、返回值、变量等类型异常\n//方便我们在代码运行前进行部分debug\n/* @flow */\nimport { no, noop } from 'shared/util'\nexport type Config = {\n  optionMergeStrategies: { [key: string]: Function };\n  silent: boolean;\n  devtools: boolean;\n  errorHandler: ?Function;\n  ignoredElements: ?Array<string>;\n  keyCodes: { [key: string]: number };\n  // platform\n  isReservedTag: (x?: string) => boolean;\n  isUnknownElement: (x?: string) => boolean;\n  getTagNamespace: (x?: string) => string | void;\n  mustUseProp: (x?: string) => boolean;\n  // internal\n  _assetTypes: Array<string>;\n  _lifecycleHooks: Array<string>;\n  _maxUpdateCount: number;\n  _isServer: boolean;\n}\nconst config: Config = {\n  optionMergeStrategies: Object.create(null),\n  //是否显示warning,默认显示\n  silent: false,\n  //是否启动devtool\n  devtools: process.env.NODE_ENV !== 'production',\n  errorHandler: null,\n  ignoredElements: null,\n  keyCodes: Object.create(null),\n  isReservedTag: no,\n  isUnknownElement: no,\n  getTagNamespace: noop,\n  mustUseProp: no,\n //组件的默认类型\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n //定义组件的各种生命周期\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n //规定组件在一次刷新中的最大循环更新次数\n  _maxUpdateCount: 100,\n  //判断全局环境是否为server\n  _isServer: process.env.VUE_ENV === 'server'\n}\nexport default config\n\n```\n再来看Vue实例由哪些部分构成，这部分代码在`src/instance`，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：\n```\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\n\nfunction Vue (options) {\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：\n```\n//为了说明，这里是其简化版\nexport function eventsMixin (Vue: Class<Component>) {\n  //实现事件绑定的方法，将其添加到原型上\n  Vue.prototype.$on = function (event: string, fn: Function): Component {\n    const vm: Component = this\n   //支持绑定多个事件\n    ;(vm._events[event] || (vm._events[event] = [])).push(fn)\n    return vm\n  }\n```\n\n###### 总结：\n1. Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。\n2. Vue使用了[Flow](https://flowtype.org/)做静态类型检查，有助于提前发现bug\n3. 实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。\n\n------------------------\n参考链接：\n [Object.defineProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters)\n [Flow | A Static Type Checker For JavaScript](https://flowtype.org/)\n","source":"_posts/Vue2-0源码学习-0.md","raw":"---\ntitle: 'Vue2.0源码学习#0'\ndate: 2016-09-07 03:37:41\ntags:\n- Vue\n- JavaScript\ncategories:\n- 前端\n---\n> 近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。\n\n<!-- more -->\n作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。\n```\nimport config from './config'\n//加载初始全局API\nimport { initGlobalAPI } from './global-api/index'\n//类的初始化入口\nimport Vue from './instance/index'\n\ninitGlobalAPI(Vue)\n//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染\n//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR\n//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性\n//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因\n//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: () => config._isServer\n})\n//定义Vue版本号\nVue.version = '2.0.0-rc.4'\n\nexport default Vue\n```\n以下就是config的源码\n```\n//Vue使用了Flow做静态类型检查\n//Flow可以在代码运行前检查出参数、返回值、变量等类型异常\n//方便我们在代码运行前进行部分debug\n/* @flow */\nimport { no, noop } from 'shared/util'\nexport type Config = {\n  optionMergeStrategies: { [key: string]: Function };\n  silent: boolean;\n  devtools: boolean;\n  errorHandler: ?Function;\n  ignoredElements: ?Array<string>;\n  keyCodes: { [key: string]: number };\n  // platform\n  isReservedTag: (x?: string) => boolean;\n  isUnknownElement: (x?: string) => boolean;\n  getTagNamespace: (x?: string) => string | void;\n  mustUseProp: (x?: string) => boolean;\n  // internal\n  _assetTypes: Array<string>;\n  _lifecycleHooks: Array<string>;\n  _maxUpdateCount: number;\n  _isServer: boolean;\n}\nconst config: Config = {\n  optionMergeStrategies: Object.create(null),\n  //是否显示warning,默认显示\n  silent: false,\n  //是否启动devtool\n  devtools: process.env.NODE_ENV !== 'production',\n  errorHandler: null,\n  ignoredElements: null,\n  keyCodes: Object.create(null),\n  isReservedTag: no,\n  isUnknownElement: no,\n  getTagNamespace: noop,\n  mustUseProp: no,\n //组件的默认类型\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n //定义组件的各种生命周期\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n //规定组件在一次刷新中的最大循环更新次数\n  _maxUpdateCount: 100,\n  //判断全局环境是否为server\n  _isServer: process.env.VUE_ENV === 'server'\n}\nexport default config\n\n```\n再来看Vue实例由哪些部分构成，这部分代码在`src/instance`，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：\n```\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\n\nfunction Vue (options) {\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：\n```\n//为了说明，这里是其简化版\nexport function eventsMixin (Vue: Class<Component>) {\n  //实现事件绑定的方法，将其添加到原型上\n  Vue.prototype.$on = function (event: string, fn: Function): Component {\n    const vm: Component = this\n   //支持绑定多个事件\n    ;(vm._events[event] || (vm._events[event] = [])).push(fn)\n    return vm\n  }\n```\n\n###### 总结：\n1. Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。\n2. Vue使用了[Flow](https://flowtype.org/)做静态类型检查，有助于提前发现bug\n3. 实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。\n\n------------------------\n参考链接：\n [Object.defineProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters)\n [Flow | A Static Type Checker For JavaScript](https://flowtype.org/)\n","slug":"Vue2-0源码学习-0","published":1,"updated":"2017-02-05T05:23:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2h000j0pk3jlb0ihpo","content":"<blockquote>\n<p>近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import config from &apos;./config&apos;</span><br><span class=\"line\">//加载初始全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">//类的初始化入口</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染</span><br><span class=\"line\">//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR</span><br><span class=\"line\">//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性</span><br><span class=\"line\">//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因</span><br><span class=\"line\">//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: () =&gt; config._isServer</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//定义Vue版本号</span><br><span class=\"line\">Vue.version = &apos;2.0.0-rc.4&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>以下就是config的源码<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Vue使用了Flow做静态类型检查</span><br><span class=\"line\">//Flow可以在代码运行前检查出参数、返回值、变量等类型异常</span><br><span class=\"line\">//方便我们在代码运行前进行部分debug</span><br><span class=\"line\">/* @flow */</span><br><span class=\"line\">import &#123; no, noop &#125; from &apos;shared/util&apos;</span><br><span class=\"line\">export type Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: &#123; [key: string]: Function &#125;;</span><br><span class=\"line\">  silent: boolean;</span><br><span class=\"line\">  devtools: boolean;</span><br><span class=\"line\">  errorHandler: ?Function;</span><br><span class=\"line\">  ignoredElements: ?Array&lt;string&gt;;</span><br><span class=\"line\">  keyCodes: &#123; [key: string]: number &#125;;</span><br><span class=\"line\">  // platform</span><br><span class=\"line\">  isReservedTag: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  isUnknownElement: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  getTagNamespace: (x?: string) =&gt; string | void;</span><br><span class=\"line\">  mustUseProp: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  // internal</span><br><span class=\"line\">  _assetTypes: Array&lt;string&gt;;</span><br><span class=\"line\">  _lifecycleHooks: Array&lt;string&gt;;</span><br><span class=\"line\">  _maxUpdateCount: number;</span><br><span class=\"line\">  _isServer: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const config: Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: Object.create(null),</span><br><span class=\"line\">  //是否显示warning,默认显示</span><br><span class=\"line\">  silent: false,</span><br><span class=\"line\">  //是否启动devtool</span><br><span class=\"line\">  devtools: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class=\"line\">  errorHandler: null,</span><br><span class=\"line\">  ignoredElements: null,</span><br><span class=\"line\">  keyCodes: Object.create(null),</span><br><span class=\"line\">  isReservedTag: no,</span><br><span class=\"line\">  isUnknownElement: no,</span><br><span class=\"line\">  getTagNamespace: noop,</span><br><span class=\"line\">  mustUseProp: no,</span><br><span class=\"line\"> //组件的默认类型</span><br><span class=\"line\">  _assetTypes: [</span><br><span class=\"line\">    &apos;component&apos;,</span><br><span class=\"line\">    &apos;directive&apos;,</span><br><span class=\"line\">    &apos;filter&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //定义组件的各种生命周期</span><br><span class=\"line\">  _lifecycleHooks: [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //规定组件在一次刷新中的最大循环更新次数</span><br><span class=\"line\">  _maxUpdateCount: 100,</span><br><span class=\"line\">  //判断全局环境是否为server</span><br><span class=\"line\">  _isServer: process.env.VUE_ENV === &apos;server&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default config</span><br></pre></td></tr></table></figure></p>\n<p>再来看Vue实例由哪些部分构成，这部分代码在<code>src/instance</code>，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class=\"line\">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class=\"line\">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class=\"line\">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//为了说明，这里是其简化版</span><br><span class=\"line\">export function eventsMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  //实现事件绑定的方法，将其添加到原型上</span><br><span class=\"line\">  Vue.prototype.$on = function (event: string, fn: Function): Component &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">   //支持绑定多个事件</span><br><span class=\"line\">    ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class=\"line\">    return vm</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h6><ol>\n<li>Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。</li>\n<li>Vue使用了<a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>做静态类型检查，有助于提前发现bug</li>\n<li>实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。</li>\n</ol>\n<hr>\n<p>参考链接：<br> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters\" target=\"_blank\" rel=\"noopener\">Object.defineProperty()</a><br> <a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow | A Static Type Checker For JavaScript</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。</p>\n</blockquote>","more":"<p>作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import config from &apos;./config&apos;</span><br><span class=\"line\">//加载初始全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">//类的初始化入口</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染</span><br><span class=\"line\">//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR</span><br><span class=\"line\">//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性</span><br><span class=\"line\">//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因</span><br><span class=\"line\">//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: () =&gt; config._isServer</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//定义Vue版本号</span><br><span class=\"line\">Vue.version = &apos;2.0.0-rc.4&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>以下就是config的源码<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Vue使用了Flow做静态类型检查</span><br><span class=\"line\">//Flow可以在代码运行前检查出参数、返回值、变量等类型异常</span><br><span class=\"line\">//方便我们在代码运行前进行部分debug</span><br><span class=\"line\">/* @flow */</span><br><span class=\"line\">import &#123; no, noop &#125; from &apos;shared/util&apos;</span><br><span class=\"line\">export type Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: &#123; [key: string]: Function &#125;;</span><br><span class=\"line\">  silent: boolean;</span><br><span class=\"line\">  devtools: boolean;</span><br><span class=\"line\">  errorHandler: ?Function;</span><br><span class=\"line\">  ignoredElements: ?Array&lt;string&gt;;</span><br><span class=\"line\">  keyCodes: &#123; [key: string]: number &#125;;</span><br><span class=\"line\">  // platform</span><br><span class=\"line\">  isReservedTag: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  isUnknownElement: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  getTagNamespace: (x?: string) =&gt; string | void;</span><br><span class=\"line\">  mustUseProp: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  // internal</span><br><span class=\"line\">  _assetTypes: Array&lt;string&gt;;</span><br><span class=\"line\">  _lifecycleHooks: Array&lt;string&gt;;</span><br><span class=\"line\">  _maxUpdateCount: number;</span><br><span class=\"line\">  _isServer: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const config: Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: Object.create(null),</span><br><span class=\"line\">  //是否显示warning,默认显示</span><br><span class=\"line\">  silent: false,</span><br><span class=\"line\">  //是否启动devtool</span><br><span class=\"line\">  devtools: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class=\"line\">  errorHandler: null,</span><br><span class=\"line\">  ignoredElements: null,</span><br><span class=\"line\">  keyCodes: Object.create(null),</span><br><span class=\"line\">  isReservedTag: no,</span><br><span class=\"line\">  isUnknownElement: no,</span><br><span class=\"line\">  getTagNamespace: noop,</span><br><span class=\"line\">  mustUseProp: no,</span><br><span class=\"line\"> //组件的默认类型</span><br><span class=\"line\">  _assetTypes: [</span><br><span class=\"line\">    &apos;component&apos;,</span><br><span class=\"line\">    &apos;directive&apos;,</span><br><span class=\"line\">    &apos;filter&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //定义组件的各种生命周期</span><br><span class=\"line\">  _lifecycleHooks: [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //规定组件在一次刷新中的最大循环更新次数</span><br><span class=\"line\">  _maxUpdateCount: 100,</span><br><span class=\"line\">  //判断全局环境是否为server</span><br><span class=\"line\">  _isServer: process.env.VUE_ENV === &apos;server&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default config</span><br></pre></td></tr></table></figure></p>\n<p>再来看Vue实例由哪些部分构成，这部分代码在<code>src/instance</code>，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class=\"line\">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class=\"line\">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class=\"line\">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//为了说明，这里是其简化版</span><br><span class=\"line\">export function eventsMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  //实现事件绑定的方法，将其添加到原型上</span><br><span class=\"line\">  Vue.prototype.$on = function (event: string, fn: Function): Component &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">   //支持绑定多个事件</span><br><span class=\"line\">    ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class=\"line\">    return vm</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h6><ol>\n<li>Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。</li>\n<li>Vue使用了<a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>做静态类型检查，有助于提前发现bug</li>\n<li>实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。</li>\n</ol>\n<hr>\n<p>参考链接：<br> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters\" target=\"_blank\" rel=\"noopener\">Object.defineProperty()</a><br> <a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow | A Static Type Checker For JavaScript</a></p>"},{"title":"HTTP状态码大全","date":"2016-03-12T17:08:51.000Z","_content":"**HTTP状态码被分成了五类。**\n100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。\n 500-599 用于支持服务器错误。 \n********\n**100-199：信息性状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n| 100    |  continue   | 说明收到了请求的初始部分，请客户端继续发送 |\n|101    |  switch protocols    |    说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议 |\n\n**200-299：成功状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|200|      ok|    请求成功|\n|201|      created|       用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象\n|202  |  accepted|  请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。\n|203   | non-authoritative information|  实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。\n|204    |no content|  响应报文中包含若干首部和一个状态行，但没有实体的主体部分\n|205    |reset content| 负责告知浏览器清除当前页面中所有的HTML表单元素\n\n**300-399：重定向状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|300|  Multiple choices|   客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。\n|301|  move permanently | 被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL\n|302  |found|   请求的资源现在临时从不同的 URI 响应请求。\n|303 | see other |告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去\n|304 | not modified|  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。\n|305|  use proxy|   用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。\n|307|  temporary redirect|  请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n\n**400-499:客户端错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|400  |bad request | 用于告知客户端它发送了一个错误的请求\n|401  |unauthorized | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。\n|403| forbidden| 服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用\n|404|  not found  |无法找到指定位置的资源。\n|405    |Method Not Allowed|    请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。\n|406    |Not Acceptable|    表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。\n|408    |Request Timeout|   请求超时\n**500-599:服务器错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |-------| -------------------------|\n|500  |  Internal Server Error | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\n|501  | Not Implemented | 客户端使用了服务器未实现的请求方法\n|502  | Bad Gateway | 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。\n|503  | Service Unavailable | 用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 \n|504 |Gateway Timeout|该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。\n|505 |HTTP Version Not Supported|服务器不支持在请求中所标明 HTTP 版本。\n\n\n参考：\n    《HTTP权威指南》\n","source":"_posts/HTTP状态码大全.md","raw":"---\ntitle: HTTP状态码大全\ndate: 2016-03-13 01:08:51\ntags:\n- HTTP\ncategories:\n- 网络\n---\n**HTTP状态码被分成了五类。**\n100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。\n 500-599 用于支持服务器错误。 \n********\n**100-199：信息性状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n| 100    |  continue   | 说明收到了请求的初始部分，请客户端继续发送 |\n|101    |  switch protocols    |    说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议 |\n\n**200-299：成功状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|200|      ok|    请求成功|\n|201|      created|       用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象\n|202  |  accepted|  请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。\n|203   | non-authoritative information|  实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。\n|204    |no content|  响应报文中包含若干首部和一个状态行，但没有实体的主体部分\n|205    |reset content| 负责告知浏览器清除当前页面中所有的HTML表单元素\n\n**300-399：重定向状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|300|  Multiple choices|   客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。\n|301|  move permanently | 被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL\n|302  |found|   请求的资源现在临时从不同的 URI 响应请求。\n|303 | see other |告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去\n|304 | not modified|  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。\n|305|  use proxy|   用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。\n|307|  temporary redirect|  请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n\n**400-499:客户端错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|400  |bad request | 用于告知客户端它发送了一个错误的请求\n|401  |unauthorized | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。\n|403| forbidden| 服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用\n|404|  not found  |无法找到指定位置的资源。\n|405    |Method Not Allowed|    请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。\n|406    |Not Acceptable|    表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。\n|408    |Request Timeout|   请求超时\n**500-599:服务器错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |-------| -------------------------|\n|500  |  Internal Server Error | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\n|501  | Not Implemented | 客户端使用了服务器未实现的请求方法\n|502  | Bad Gateway | 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。\n|503  | Service Unavailable | 用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 \n|504 |Gateway Timeout|该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。\n|505 |HTTP Version Not Supported|服务器不支持在请求中所标明 HTTP 版本。\n\n\n参考：\n    《HTTP权威指南》\n","slug":"HTTP状态码大全","published":1,"updated":"2017-02-05T05:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2i000l0pk3s6yofeye","content":"<p><strong>HTTP状态码被分成了五类。</strong><br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br> 500-599 用于支持服务器错误。 </p>\n<hr>\n<p><strong>100-199：信息性状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>continue</td>\n<td>说明收到了请求的初始部分，请客户端继续发送</td>\n</tr>\n<tr>\n<td>101</td>\n<td>switch protocols</td>\n<td>说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议</td>\n</tr>\n</tbody>\n</table>\n<p><strong>200-299：成功状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>ok</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>created</td>\n<td>用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象</td>\n</tr>\n<tr>\n<td>202</td>\n<td>accepted</td>\n<td>请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>non-authoritative information</td>\n<td>实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>no content</td>\n<td>响应报文中包含若干首部和一个状态行，但没有实体的主体部分</td>\n</tr>\n<tr>\n<td>205</td>\n<td>reset content</td>\n<td>负责告知浏览器清除当前页面中所有的HTML表单元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>300-399：重定向状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>300</td>\n<td>Multiple choices</td>\n<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>move permanently</td>\n<td>被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL</td>\n</tr>\n<tr>\n<td>302</td>\n<td>found</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>see other</td>\n<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去</td>\n</tr>\n<tr>\n<td>304</td>\n<td>not modified</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>use proxy</td>\n<td>用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>temporary redirect</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>400-499:客户端错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>bad request</td>\n<td>用于告知客户端它发送了一个错误的请求</td>\n</tr>\n<tr>\n<td>401</td>\n<td>unauthorized</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>forbidden</td>\n<td>服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用</td>\n</tr>\n<tr>\n<td>404</td>\n<td>not found</td>\n<td>无法找到指定位置的资源。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>请求超时</td>\n</tr>\n</tbody>\n</table>\n<p><strong>500-599:服务器错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>客户端使用了服务器未实现的请求方法</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 </td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Timeout</td>\n<td>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version Not Supported</td>\n<td>服务器不支持在请求中所标明 HTTP 版本。</td>\n</tr>\n</tbody>\n</table>\n<p>参考：<br>    《HTTP权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>HTTP状态码被分成了五类。</strong><br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br> 500-599 用于支持服务器错误。 </p>\n<hr>\n<p><strong>100-199：信息性状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>continue</td>\n<td>说明收到了请求的初始部分，请客户端继续发送</td>\n</tr>\n<tr>\n<td>101</td>\n<td>switch protocols</td>\n<td>说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议</td>\n</tr>\n</tbody>\n</table>\n<p><strong>200-299：成功状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>ok</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>created</td>\n<td>用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象</td>\n</tr>\n<tr>\n<td>202</td>\n<td>accepted</td>\n<td>请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>non-authoritative information</td>\n<td>实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>no content</td>\n<td>响应报文中包含若干首部和一个状态行，但没有实体的主体部分</td>\n</tr>\n<tr>\n<td>205</td>\n<td>reset content</td>\n<td>负责告知浏览器清除当前页面中所有的HTML表单元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>300-399：重定向状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>300</td>\n<td>Multiple choices</td>\n<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>move permanently</td>\n<td>被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL</td>\n</tr>\n<tr>\n<td>302</td>\n<td>found</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>see other</td>\n<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去</td>\n</tr>\n<tr>\n<td>304</td>\n<td>not modified</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>use proxy</td>\n<td>用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>temporary redirect</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>400-499:客户端错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>bad request</td>\n<td>用于告知客户端它发送了一个错误的请求</td>\n</tr>\n<tr>\n<td>401</td>\n<td>unauthorized</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>forbidden</td>\n<td>服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用</td>\n</tr>\n<tr>\n<td>404</td>\n<td>not found</td>\n<td>无法找到指定位置的资源。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>请求超时</td>\n</tr>\n</tbody>\n</table>\n<p><strong>500-599:服务器错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>客户端使用了服务器未实现的请求方法</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 </td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Timeout</td>\n<td>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version Not Supported</td>\n<td>服务器不支持在请求中所标明 HTTP 版本。</td>\n</tr>\n</tbody>\n</table>\n<p>参考：<br>    《HTTP权威指南》</p>\n"},{"title":"apply方法的妙用","date":"2016-03-15T16:37:39.000Z","_content":"我们可以使用数组的push()方法来合并数组\n```\nvar a = [1,2,3];\nvar b = [4,5,6];\nArray.prototype.push.apply(a,b);\nconsole.log(a);//输出1,2,3,4,5,6\n```\npush方法本身没有提供push一个数组，但它提供了push(param1,parm2...)，支持传入多个参数。\n而**apply方法可以将一个数组转换为一个参数列表**，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。\n\n此外，找出数组中的最大值、最小值也均可使用此方法。\n如求出数组中的最大值：\n```\nvar a = [3,4,1,5,9];\nvar max = Math.max.apply(null,a);\nconsole.log(max);//输出9\n```","source":"_posts/apply方法的妙用.md","raw":"---\ntitle: apply方法的妙用\ndate: 2016-03-16 00:37:39\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n我们可以使用数组的push()方法来合并数组\n```\nvar a = [1,2,3];\nvar b = [4,5,6];\nArray.prototype.push.apply(a,b);\nconsole.log(a);//输出1,2,3,4,5,6\n```\npush方法本身没有提供push一个数组，但它提供了push(param1,parm2...)，支持传入多个参数。\n而**apply方法可以将一个数组转换为一个参数列表**，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。\n\n此外，找出数组中的最大值、最小值也均可使用此方法。\n如求出数组中的最大值：\n```\nvar a = [3,4,1,5,9];\nvar max = Math.max.apply(null,a);\nconsole.log(max);//输出9\n```","slug":"apply方法的妙用","published":1,"updated":"2016-03-15T16:38:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2k000p0pk3f18wta7r","content":"<p>我们可以使用数组的push()方法来合并数组<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [1,2,3];</span><br><span class=\"line\">var b = [4,5,6];</span><br><span class=\"line\">Array.prototype.push.apply(a,b);</span><br><span class=\"line\">console.log(a);//输出1,2,3,4,5,6</span><br></pre></td></tr></table></figure></p>\n<p>push方法本身没有提供push一个数组，但它提供了push(param1,parm2…)，支持传入多个参数。<br>而<strong>apply方法可以将一个数组转换为一个参数列表</strong>，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。</p>\n<p>此外，找出数组中的最大值、最小值也均可使用此方法。<br>如求出数组中的最大值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [3,4,1,5,9];</span><br><span class=\"line\">var max = Math.max.apply(null,a);</span><br><span class=\"line\">console.log(max);//输出9</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们可以使用数组的push()方法来合并数组<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [1,2,3];</span><br><span class=\"line\">var b = [4,5,6];</span><br><span class=\"line\">Array.prototype.push.apply(a,b);</span><br><span class=\"line\">console.log(a);//输出1,2,3,4,5,6</span><br></pre></td></tr></table></figure></p>\n<p>push方法本身没有提供push一个数组，但它提供了push(param1,parm2…)，支持传入多个参数。<br>而<strong>apply方法可以将一个数组转换为一个参数列表</strong>，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。</p>\n<p>此外，找出数组中的最大值、最小值也均可使用此方法。<br>如求出数组中的最大值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [3,4,1,5,9];</span><br><span class=\"line\">var max = Math.max.apply(null,a);</span><br><span class=\"line\">console.log(max);//输出9</span><br></pre></td></tr></table></figure></p>\n"},{"title":"TCP性能优化浅析","date":"2018-02-02T10:38:42.000Z","_content":"\n### 前言\nTCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。\n\n### 三次握手\n众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。\n\n![图1](https://user-gold-cdn.xitu.io/2018/2/2/161572eb0354f76a?w=1240&h=683&f=png&s=150834)\n\n\n三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。\n\n既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。\n\n除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。\n![图2](https://user-gold-cdn.xitu.io/2018/2/2/161572eb032c6239?w=638&h=479&f=png&s=111523)\n\nLinux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。\n\nPS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。\n![屏幕快照 2018-02-02 下午11.30.33.png](https://user-gold-cdn.xitu.io/2018/2/2/161572eb0342b660?w=1240&h=290&f=png&s=352950)\n\n### 流量控制\n流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。\n\n大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) * round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) * 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。\n\n为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：\n```\nsysctl net.ipv4.tcp_rmem\n// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456\n// 从左到右一次为最小值、默认值、最大值\n```\n \n### 慢启动\n\n流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。\n\n慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。\n\n一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。\n\n此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则\n cwnd=4，也就是 cwnd = cwnd*2。\n\n以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。\n![图3](https://user-gold-cdn.xitu.io/2018/2/2/161572eb0339c685?w=1110&h=472&f=png&s=69457)\n\n随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。\n![图4](https://user-gold-cdn.xitu.io/2018/2/2/161572eb03588303?w=1088&h=482&f=png&s=157267)\n\n为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。\n\n### 总结\n本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。\n \n----------------\n参考文献：\n1. [《Web性能权威指南》](https://book.douban.com/subject/25856314/)\n2. [《TCP/IP详解，卷1:协议》](https://book.douban.com/subject/1088054/)\n3. [浅谈TCP优化](https://huoding.com/2013/11/21/299)\n4. [TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎](\nhttps://www.zhihu.com/question/24886217/answer/149903688)\n\n","source":"_posts/TCP性能优化浅析.md","raw":"---\ntitle: TCP性能优化浅析\ndate: 2018-02-02 18:38:42\ntags:\n- TCP\n- 性能优化\ncategories:\n- 网络\n---\n\n### 前言\nTCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。\n\n### 三次握手\n众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。\n\n![图1](https://user-gold-cdn.xitu.io/2018/2/2/161572eb0354f76a?w=1240&h=683&f=png&s=150834)\n\n\n三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。\n\n既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。\n\n除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。\n![图2](https://user-gold-cdn.xitu.io/2018/2/2/161572eb032c6239?w=638&h=479&f=png&s=111523)\n\nLinux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。\n\nPS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。\n![屏幕快照 2018-02-02 下午11.30.33.png](https://user-gold-cdn.xitu.io/2018/2/2/161572eb0342b660?w=1240&h=290&f=png&s=352950)\n\n### 流量控制\n流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。\n\n大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) * round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) * 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。\n\n为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：\n```\nsysctl net.ipv4.tcp_rmem\n// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456\n// 从左到右一次为最小值、默认值、最大值\n```\n \n### 慢启动\n\n流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。\n\n慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。\n\n一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。\n\n此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则\n cwnd=4，也就是 cwnd = cwnd*2。\n\n以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。\n![图3](https://user-gold-cdn.xitu.io/2018/2/2/161572eb0339c685?w=1110&h=472&f=png&s=69457)\n\n随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。\n![图4](https://user-gold-cdn.xitu.io/2018/2/2/161572eb03588303?w=1088&h=482&f=png&s=157267)\n\n为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。\n\n### 总结\n本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。\n \n----------------\n参考文献：\n1. [《Web性能权威指南》](https://book.douban.com/subject/25856314/)\n2. [《TCP/IP详解，卷1:协议》](https://book.douban.com/subject/1088054/)\n3. [浅谈TCP优化](https://huoding.com/2013/11/21/299)\n4. [TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎](\nhttps://www.zhihu.com/question/24886217/answer/149903688)\n\n","slug":"TCP性能优化浅析","published":1,"updated":"2018-02-02T16:01:30.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2l000r0pk3wcroe6as","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>TCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb0354f76a?w=1240&amp;h=683&amp;f=png&amp;s=150834\" alt=\"图1\"></p>\n<p>三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。</p>\n<p>既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。</p>\n<p>除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb032c6239?w=638&amp;h=479&amp;f=png&amp;s=111523\" alt=\"图2\"></p>\n<p>Linux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。</p>\n<p>PS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb0342b660?w=1240&amp;h=290&amp;f=png&amp;s=352950\" alt=\"屏幕快照 2018-02-02 下午11.30.33.png\"></p>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><p>流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。</p>\n<p>大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) <em> round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) </em> 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。</p>\n<p>为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_rmem</span><br><span class=\"line\">// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456</span><br><span class=\"line\">// 从左到右一次为最小值、默认值、最大值</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"慢启动\"><a href=\"#慢启动\" class=\"headerlink\" title=\"慢启动\"></a>慢启动</h3><p>流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。</p>\n<p>慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。</p>\n<p>一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。</p>\n<p>此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则<br> cwnd=4，也就是 cwnd = cwnd*2。</p>\n<p>以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb0339c685?w=1110&amp;h=472&amp;f=png&amp;s=69457\" alt=\"图3\"></p>\n<p>随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb03588303?w=1088&amp;h=482&amp;f=png&amp;s=157267\" alt=\"图4\"></p>\n<p>为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。</p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/25856314/\" target=\"_blank\" rel=\"noopener\">《Web性能权威指南》</a></li>\n<li><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"noopener\">《TCP/IP详解，卷1:协议》</a></li>\n<li><a href=\"https://huoding.com/2013/11/21/299\" target=\"_blank\" rel=\"noopener\">浅谈TCP优化</a></li>\n<li><a href=\"https://www.zhihu.com/question/24886217/answer/149903688\" target=\"_blank\" rel=\"noopener\">TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>TCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb0354f76a?w=1240&amp;h=683&amp;f=png&amp;s=150834\" alt=\"图1\"></p>\n<p>三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。</p>\n<p>既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。</p>\n<p>除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb032c6239?w=638&amp;h=479&amp;f=png&amp;s=111523\" alt=\"图2\"></p>\n<p>Linux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。</p>\n<p>PS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb0342b660?w=1240&amp;h=290&amp;f=png&amp;s=352950\" alt=\"屏幕快照 2018-02-02 下午11.30.33.png\"></p>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><p>流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。</p>\n<p>大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) <em> round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) </em> 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。</p>\n<p>为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_rmem</span><br><span class=\"line\">// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456</span><br><span class=\"line\">// 从左到右一次为最小值、默认值、最大值</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"慢启动\"><a href=\"#慢启动\" class=\"headerlink\" title=\"慢启动\"></a>慢启动</h3><p>流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。</p>\n<p>慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。</p>\n<p>一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。</p>\n<p>此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则<br> cwnd=4，也就是 cwnd = cwnd*2。</p>\n<p>以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb0339c685?w=1110&amp;h=472&amp;f=png&amp;s=69457\" alt=\"图3\"></p>\n<p>随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/2/161572eb03588303?w=1088&amp;h=482&amp;f=png&amp;s=157267\" alt=\"图4\"></p>\n<p>为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。</p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/25856314/\" target=\"_blank\" rel=\"noopener\">《Web性能权威指南》</a></li>\n<li><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"noopener\">《TCP/IP详解，卷1:协议》</a></li>\n<li><a href=\"https://huoding.com/2013/11/21/299\" target=\"_blank\" rel=\"noopener\">浅谈TCP优化</a></li>\n<li><a href=\"https://www.zhihu.com/question/24886217/answer/149903688\" target=\"_blank\" rel=\"noopener\">TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎</a></li>\n</ol>\n"},{"title":"cookie详解","date":"2016-03-10T16:55:28.000Z","_content":">**前言：**\n- Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。\n- 检测Cookie是否可用：navigator.cookieEnabled\n\n### Cookie的有效期和作用域\n　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。\n　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。**默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见**。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。\n　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。\n　　同时要注意的是，Cookie的**domain只能设置为当前服务器的域**。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。\n### 创建和存储Cookie\n对Cookie的所有操作都要通过**读写document对象的Cookie属性**来完成。Cookie的值都是以键值对的形式存储。\n```\n//创建一个名字Cookie，同时设置它的过期时间\nfunction setCookie(c_name,value,expiredays){\n     var exdate=new Date();\n     exdate.setDate(exdate.getDate()+expiredays);\n     //encodeURIComponent() 对 URI 进行编码\n     document.cookie=c_name+ \"=\" +encodeURIComponent(value)+\n((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());\n}\n```\n同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　\n　　;path=path\n### 读取Cookie\n使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。\n```\nfunction getCookie(){\n    // 初始化要返回的对象\n    var cookie = {};\n    var all = document.cookie;\n    if(all === null){\n        return cookie;\n    }\n    //分离出Cookie的各个属性\n    var list = all.split(';');\n    for(var i = 0;i < list.length;i++){\n        // 查询出等号所在的位置\n        var p = list[i].indexOf('=');\n        // 分离出名字和值\n        var name = list[i].substring(0,p);\n        var value = list[i].substring(p+1);\n        //对值进行解码\n        value = decodeURIComponent(value);\n        // 将名值对存储到对象中\n        cookie[name] = value;\n    }\n    return cookie;\n}\n```\n### Cookie的局限性\n1. Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。\n2. JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。","source":"_posts/cookie.md","raw":"---\ntitle: cookie详解\ndate: 2016-03-11 00:55:28\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n>**前言：**\n- Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。\n- 检测Cookie是否可用：navigator.cookieEnabled\n\n### Cookie的有效期和作用域\n　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。\n　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。**默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见**。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。\n　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。\n　　同时要注意的是，Cookie的**domain只能设置为当前服务器的域**。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。\n### 创建和存储Cookie\n对Cookie的所有操作都要通过**读写document对象的Cookie属性**来完成。Cookie的值都是以键值对的形式存储。\n```\n//创建一个名字Cookie，同时设置它的过期时间\nfunction setCookie(c_name,value,expiredays){\n     var exdate=new Date();\n     exdate.setDate(exdate.getDate()+expiredays);\n     //encodeURIComponent() 对 URI 进行编码\n     document.cookie=c_name+ \"=\" +encodeURIComponent(value)+\n((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());\n}\n```\n同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　\n　　;path=path\n### 读取Cookie\n使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。\n```\nfunction getCookie(){\n    // 初始化要返回的对象\n    var cookie = {};\n    var all = document.cookie;\n    if(all === null){\n        return cookie;\n    }\n    //分离出Cookie的各个属性\n    var list = all.split(';');\n    for(var i = 0;i < list.length;i++){\n        // 查询出等号所在的位置\n        var p = list[i].indexOf('=');\n        // 分离出名字和值\n        var name = list[i].substring(0,p);\n        var value = list[i].substring(p+1);\n        //对值进行解码\n        value = decodeURIComponent(value);\n        // 将名值对存储到对象中\n        cookie[name] = value;\n    }\n    return cookie;\n}\n```\n### Cookie的局限性\n1. Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。\n2. JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。","slug":"cookie","published":1,"updated":"2016-03-10T18:54:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2n000v0pk326n6vij2","content":"<blockquote>\n<p><strong>前言：</strong></p>\n<ul>\n<li>Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。</li>\n<li>检测Cookie是否可用：navigator.cookieEnabled</li>\n</ul>\n</blockquote>\n<h3 id=\"Cookie的有效期和作用域\"><a href=\"#Cookie的有效期和作用域\" class=\"headerlink\" title=\"Cookie的有效期和作用域\"></a>Cookie的有效期和作用域</h3><p>　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。<br>　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。<strong>默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见</strong>。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。<br>　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。<br>　　同时要注意的是，Cookie的<strong>domain只能设置为当前服务器的域</strong>。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。</p>\n<h3 id=\"创建和存储Cookie\"><a href=\"#创建和存储Cookie\" class=\"headerlink\" title=\"创建和存储Cookie\"></a>创建和存储Cookie</h3><p>对Cookie的所有操作都要通过<strong>读写document对象的Cookie属性</strong>来完成。Cookie的值都是以键值对的形式存储。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建一个名字Cookie，同时设置它的过期时间</span><br><span class=\"line\">function setCookie(c_name,value,expiredays)&#123;</span><br><span class=\"line\">     var exdate=new Date();</span><br><span class=\"line\">     exdate.setDate(exdate.getDate()+expiredays);</span><br><span class=\"line\">     //encodeURIComponent() 对 URI 进行编码</span><br><span class=\"line\">     document.cookie=c_name+ &quot;=&quot; +encodeURIComponent(value)+</span><br><span class=\"line\">((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　<br>　　;path=path</p>\n<h3 id=\"读取Cookie\"><a href=\"#读取Cookie\" class=\"headerlink\" title=\"读取Cookie\"></a>读取Cookie</h3><p>使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getCookie()&#123;</span><br><span class=\"line\">    // 初始化要返回的对象</span><br><span class=\"line\">    var cookie = &#123;&#125;;</span><br><span class=\"line\">    var all = document.cookie;</span><br><span class=\"line\">    if(all === null)&#123;</span><br><span class=\"line\">        return cookie;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //分离出Cookie的各个属性</span><br><span class=\"line\">    var list = all.split(&apos;;&apos;);</span><br><span class=\"line\">    for(var i = 0;i &lt; list.length;i++)&#123;</span><br><span class=\"line\">        // 查询出等号所在的位置</span><br><span class=\"line\">        var p = list[i].indexOf(&apos;=&apos;);</span><br><span class=\"line\">        // 分离出名字和值</span><br><span class=\"line\">        var name = list[i].substring(0,p);</span><br><span class=\"line\">        var value = list[i].substring(p+1);</span><br><span class=\"line\">        //对值进行解码</span><br><span class=\"line\">        value = decodeURIComponent(value);</span><br><span class=\"line\">        // 将名值对存储到对象中</span><br><span class=\"line\">        cookie[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cookie;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Cookie的局限性\"><a href=\"#Cookie的局限性\" class=\"headerlink\" title=\"Cookie的局限性\"></a>Cookie的局限性</h3><ol>\n<li>Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。</li>\n<li>JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>前言：</strong></p>\n<ul>\n<li>Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。</li>\n<li>检测Cookie是否可用：navigator.cookieEnabled</li>\n</ul>\n</blockquote>\n<h3 id=\"Cookie的有效期和作用域\"><a href=\"#Cookie的有效期和作用域\" class=\"headerlink\" title=\"Cookie的有效期和作用域\"></a>Cookie的有效期和作用域</h3><p>　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。<br>　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。<strong>默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见</strong>。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。<br>　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。<br>　　同时要注意的是，Cookie的<strong>domain只能设置为当前服务器的域</strong>。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。</p>\n<h3 id=\"创建和存储Cookie\"><a href=\"#创建和存储Cookie\" class=\"headerlink\" title=\"创建和存储Cookie\"></a>创建和存储Cookie</h3><p>对Cookie的所有操作都要通过<strong>读写document对象的Cookie属性</strong>来完成。Cookie的值都是以键值对的形式存储。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建一个名字Cookie，同时设置它的过期时间</span><br><span class=\"line\">function setCookie(c_name,value,expiredays)&#123;</span><br><span class=\"line\">     var exdate=new Date();</span><br><span class=\"line\">     exdate.setDate(exdate.getDate()+expiredays);</span><br><span class=\"line\">     //encodeURIComponent() 对 URI 进行编码</span><br><span class=\"line\">     document.cookie=c_name+ &quot;=&quot; +encodeURIComponent(value)+</span><br><span class=\"line\">((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　<br>　　;path=path</p>\n<h3 id=\"读取Cookie\"><a href=\"#读取Cookie\" class=\"headerlink\" title=\"读取Cookie\"></a>读取Cookie</h3><p>使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getCookie()&#123;</span><br><span class=\"line\">    // 初始化要返回的对象</span><br><span class=\"line\">    var cookie = &#123;&#125;;</span><br><span class=\"line\">    var all = document.cookie;</span><br><span class=\"line\">    if(all === null)&#123;</span><br><span class=\"line\">        return cookie;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //分离出Cookie的各个属性</span><br><span class=\"line\">    var list = all.split(&apos;;&apos;);</span><br><span class=\"line\">    for(var i = 0;i &lt; list.length;i++)&#123;</span><br><span class=\"line\">        // 查询出等号所在的位置</span><br><span class=\"line\">        var p = list[i].indexOf(&apos;=&apos;);</span><br><span class=\"line\">        // 分离出名字和值</span><br><span class=\"line\">        var name = list[i].substring(0,p);</span><br><span class=\"line\">        var value = list[i].substring(p+1);</span><br><span class=\"line\">        //对值进行解码</span><br><span class=\"line\">        value = decodeURIComponent(value);</span><br><span class=\"line\">        // 将名值对存储到对象中</span><br><span class=\"line\">        cookie[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cookie;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Cookie的局限性\"><a href=\"#Cookie的局限性\" class=\"headerlink\" title=\"Cookie的局限性\"></a>Cookie的局限性</h3><ol>\n<li>Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。</li>\n<li>JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。</li>\n</ol>\n"},{"title":"localStorage详解","date":"2016-03-07T13:07:48.000Z","_content":"> 前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。\n\n好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。\n\n以一个留言板为例,直接上代码：\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>localStorage demo</title>\n</head>\n<body>\n  <div>\n    <h3>简单的web存储留言板</h3>\n    <textarea id=\"textarea\"></textarea>\n    <input type=\"button\" onclick=\"addInfo()\" value=\"留言\" />\n    <input type=\"button\" onclick=\"cleanInfo()\" value=\"清除留言\" />\n  </div>\n  <script type=\"text/javascript\">\n        function upInfo() {\n            if(window.localStorage){\n                var lStorage = window.localStorage;\n                var textarea = window.document.getElementById(\"textarea\");\n                var text = lStorage.getItem(\"text\");\n                if (text) {\n                    textarea.value = text;\n                }else {\n                    textarea.value = \"还没有留言\";\n                }\n            }\n        }\n        function addInfo() {\n            if(window.localStorage){\n                var textarea = window.document.getElementById(\"textarea\");\n                var lStorage = window.localStorage;\n                lStorage.setItem(\"text\",textarea.value);\n                upInfo();\n            }\n        }\n        function cleanInfo() {\n            window.localStorage.removeItem(\"text\");\n            upInfo();\n        }\n        upInfo();\n  </script>\n</body>\n</html>\n```\n这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。\n\n这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。\n\n目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。\n\n实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。\n\n**localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同**。**localStorage存储的数据是永久性的**，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。\n\n而**sessionStorage的有效期仅存在于浏览器的标签页**。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。**sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中**，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。","source":"_posts/localStorage详解.md","raw":"---\ntitle: localStorage详解\ndate: 2016-03-07 21:07:48\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> 前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。\n\n好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。\n\n以一个留言板为例,直接上代码：\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>localStorage demo</title>\n</head>\n<body>\n  <div>\n    <h3>简单的web存储留言板</h3>\n    <textarea id=\"textarea\"></textarea>\n    <input type=\"button\" onclick=\"addInfo()\" value=\"留言\" />\n    <input type=\"button\" onclick=\"cleanInfo()\" value=\"清除留言\" />\n  </div>\n  <script type=\"text/javascript\">\n        function upInfo() {\n            if(window.localStorage){\n                var lStorage = window.localStorage;\n                var textarea = window.document.getElementById(\"textarea\");\n                var text = lStorage.getItem(\"text\");\n                if (text) {\n                    textarea.value = text;\n                }else {\n                    textarea.value = \"还没有留言\";\n                }\n            }\n        }\n        function addInfo() {\n            if(window.localStorage){\n                var textarea = window.document.getElementById(\"textarea\");\n                var lStorage = window.localStorage;\n                lStorage.setItem(\"text\",textarea.value);\n                upInfo();\n            }\n        }\n        function cleanInfo() {\n            window.localStorage.removeItem(\"text\");\n            upInfo();\n        }\n        upInfo();\n  </script>\n</body>\n</html>\n```\n这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。\n\n这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。\n\n目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。\n\n实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。\n\n**localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同**。**localStorage存储的数据是永久性的**，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。\n\n而**sessionStorage的有效期仅存在于浏览器的标签页**。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。**sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中**，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。","slug":"localStorage详解","published":1,"updated":"2016-03-07T15:48:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2p000y0pk3idx8i0tg","content":"<blockquote>\n<p>前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。</p>\n</blockquote>\n<p>好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。</p>\n<p>以一个留言板为例,直接上代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;localStorage demo&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h3&gt;简单的web存储留言板&lt;/h3&gt;</span><br><span class=\"line\">    &lt;textarea id=&quot;textarea&quot;&gt;&lt;/textarea&gt;</span><br><span class=\"line\">    &lt;input type=&quot;button&quot; onclick=&quot;addInfo()&quot; value=&quot;留言&quot; /&gt;</span><br><span class=\"line\">    &lt;input type=&quot;button&quot; onclick=&quot;cleanInfo()&quot; value=&quot;清除留言&quot; /&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        function upInfo() &#123;</span><br><span class=\"line\">            if(window.localStorage)&#123;</span><br><span class=\"line\">                var lStorage = window.localStorage;</span><br><span class=\"line\">                var textarea = window.document.getElementById(&quot;textarea&quot;);</span><br><span class=\"line\">                var text = lStorage.getItem(&quot;text&quot;);</span><br><span class=\"line\">                if (text) &#123;</span><br><span class=\"line\">                    textarea.value = text;</span><br><span class=\"line\">                &#125;else &#123;</span><br><span class=\"line\">                    textarea.value = &quot;还没有留言&quot;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function addInfo() &#123;</span><br><span class=\"line\">            if(window.localStorage)&#123;</span><br><span class=\"line\">                var textarea = window.document.getElementById(&quot;textarea&quot;);</span><br><span class=\"line\">                var lStorage = window.localStorage;</span><br><span class=\"line\">                lStorage.setItem(&quot;text&quot;,textarea.value);</span><br><span class=\"line\">                upInfo();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function cleanInfo() &#123;</span><br><span class=\"line\">            window.localStorage.removeItem(&quot;text&quot;);</span><br><span class=\"line\">            upInfo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        upInfo();</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。</p>\n<p>这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。</p>\n<p>目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。</p>\n<p>实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。</p>\n<p><strong>localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同</strong>。<strong>localStorage存储的数据是永久性的</strong>，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。</p>\n<p>而<strong>sessionStorage的有效期仅存在于浏览器的标签页</strong>。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。<strong>sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中</strong>，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。</p>\n</blockquote>\n<p>好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。</p>\n<p>以一个留言板为例,直接上代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;localStorage demo&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h3&gt;简单的web存储留言板&lt;/h3&gt;</span><br><span class=\"line\">    &lt;textarea id=&quot;textarea&quot;&gt;&lt;/textarea&gt;</span><br><span class=\"line\">    &lt;input type=&quot;button&quot; onclick=&quot;addInfo()&quot; value=&quot;留言&quot; /&gt;</span><br><span class=\"line\">    &lt;input type=&quot;button&quot; onclick=&quot;cleanInfo()&quot; value=&quot;清除留言&quot; /&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        function upInfo() &#123;</span><br><span class=\"line\">            if(window.localStorage)&#123;</span><br><span class=\"line\">                var lStorage = window.localStorage;</span><br><span class=\"line\">                var textarea = window.document.getElementById(&quot;textarea&quot;);</span><br><span class=\"line\">                var text = lStorage.getItem(&quot;text&quot;);</span><br><span class=\"line\">                if (text) &#123;</span><br><span class=\"line\">                    textarea.value = text;</span><br><span class=\"line\">                &#125;else &#123;</span><br><span class=\"line\">                    textarea.value = &quot;还没有留言&quot;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function addInfo() &#123;</span><br><span class=\"line\">            if(window.localStorage)&#123;</span><br><span class=\"line\">                var textarea = window.document.getElementById(&quot;textarea&quot;);</span><br><span class=\"line\">                var lStorage = window.localStorage;</span><br><span class=\"line\">                lStorage.setItem(&quot;text&quot;,textarea.value);</span><br><span class=\"line\">                upInfo();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function cleanInfo() &#123;</span><br><span class=\"line\">            window.localStorage.removeItem(&quot;text&quot;);</span><br><span class=\"line\">            upInfo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        upInfo();</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。</p>\n<p>这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。</p>\n<p>目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。</p>\n<p>实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。</p>\n<p><strong>localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同</strong>。<strong>localStorage存储的数据是永久性的</strong>，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。</p>\n<p>而<strong>sessionStorage的有效期仅存在于浏览器的标签页</strong>。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。<strong>sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中</strong>，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。</p>\n"},{"title":"null和undefined的区别","date":"2016-03-08T13:52:17.000Z","_content":" 1.null和undefined都被用来表示空值，**当使用不严格等于号（==）做判断时，他们是等价的**。\n``` \nconsole.log(null == undefined);//输出true\nconsole.log(null === undefined);//输出false\n```\n这也是为什么我们在代码中判断相等时避免使用==\n\n2.当对null执行typeof运算时，结果返回object，也就是说**null是一个对象**，表示“空对象”\nnull的典型用法包括：\n- 作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据\n- 作为对象原型链的终点。在使用for in遍历原型链的会用到。\n```\nconsole.log(Object.getPrototypeOf(Object.prototype));//输出null\n```\n\n3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。\nundefined的用法包括：\n- 变量被声明了，但没有赋值时，等于undefined\nJavaScript函数作用域中会发生变量申明提前\n```\nvar func = function(){\n      console.log(a);//输出undefined\n      var a = \"hello\";\n};\nfunc();\n```\n等价于\n```\nvar func = function(){\n      var a;\n      console.log(a);//输出undefined\n      a = \"hello\";\n};\nfunc();\n```\n- 查询数组元素或对象属性时返回undefined，表示该元素或属性不存在\n在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined\n```\nvar mycars = new Array();\nmycars[0] = \"Saab\"; \nmycars[2] = \"Volvo\"; \nmycars[4] = \"BMW\";\nfor (y=0;y<\\mycars.length;y++){ \n    console.log(mycars[y]); //输出Saab,undefind,Volvo,undefined,BMW\n}\n```\n但是用for in遍历时，并不会输出undefined\n```\nfor (y in mycars){ \n    console.log(mycars[y]); //输出Saab,Volvo，BMW\n}\n```\n所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。\n- 函数没有返回值，返回undefined\n- 调用函数时，应该提供的参数没有提供，该参数等于undefined\n","source":"_posts/null和undefined的区别.md","raw":"---\ntitle: null和undefined的区别\ndate: 2016-03-08 21:52:17\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n 1.null和undefined都被用来表示空值，**当使用不严格等于号（==）做判断时，他们是等价的**。\n``` \nconsole.log(null == undefined);//输出true\nconsole.log(null === undefined);//输出false\n```\n这也是为什么我们在代码中判断相等时避免使用==\n\n2.当对null执行typeof运算时，结果返回object，也就是说**null是一个对象**，表示“空对象”\nnull的典型用法包括：\n- 作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据\n- 作为对象原型链的终点。在使用for in遍历原型链的会用到。\n```\nconsole.log(Object.getPrototypeOf(Object.prototype));//输出null\n```\n\n3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。\nundefined的用法包括：\n- 变量被声明了，但没有赋值时，等于undefined\nJavaScript函数作用域中会发生变量申明提前\n```\nvar func = function(){\n      console.log(a);//输出undefined\n      var a = \"hello\";\n};\nfunc();\n```\n等价于\n```\nvar func = function(){\n      var a;\n      console.log(a);//输出undefined\n      a = \"hello\";\n};\nfunc();\n```\n- 查询数组元素或对象属性时返回undefined，表示该元素或属性不存在\n在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined\n```\nvar mycars = new Array();\nmycars[0] = \"Saab\"; \nmycars[2] = \"Volvo\"; \nmycars[4] = \"BMW\";\nfor (y=0;y<\\mycars.length;y++){ \n    console.log(mycars[y]); //输出Saab,undefind,Volvo,undefined,BMW\n}\n```\n但是用for in遍历时，并不会输出undefined\n```\nfor (y in mycars){ \n    console.log(mycars[y]); //输出Saab,Volvo，BMW\n}\n```\n所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。\n- 函数没有返回值，返回undefined\n- 调用函数时，应该提供的参数没有提供，该参数等于undefined\n","slug":"null和undefined的区别","published":1,"updated":"2016-03-08T14:03:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2r00120pk3mwaexhp6","content":"<p> 1.null和undefined都被用来表示空值，<strong>当使用不严格等于号（==）做判断时，他们是等价的</strong>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(null == undefined);//输出true</span><br><span class=\"line\">console.log(null === undefined);//输出false</span><br></pre></td></tr></table></figure></p>\n<p>这也是为什么我们在代码中判断相等时避免使用==</p>\n<p>2.当对null执行typeof运算时，结果返回object，也就是说<strong>null是一个对象</strong>，表示“空对象”<br>null的典型用法包括：</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据</li>\n<li>作为对象原型链的终点。在使用for in遍历原型链的会用到。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(Object.getPrototypeOf(Object.prototype));//输出null</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。<br>undefined的用法包括：</p>\n<ul>\n<li>变量被声明了，但没有赋值时，等于undefined<br>JavaScript函数作用域中会发生变量申明提前<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var func = function()&#123;</span><br><span class=\"line\">      console.log(a);//输出undefined</span><br><span class=\"line\">      var a = &quot;hello&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等价于<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var func = function()&#123;</span><br><span class=\"line\">      var a;</span><br><span class=\"line\">      console.log(a);//输出undefined</span><br><span class=\"line\">      a = &quot;hello&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>查询数组元素或对象属性时返回undefined，表示该元素或属性不存在<br>在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var mycars = new Array();</span><br><span class=\"line\">mycars[0] = &quot;Saab&quot;; </span><br><span class=\"line\">mycars[2] = &quot;Volvo&quot;; </span><br><span class=\"line\">mycars[4] = &quot;BMW&quot;;</span><br><span class=\"line\">for (y=0;y&lt;\\mycars.length;y++)&#123; </span><br><span class=\"line\">    console.log(mycars[y]); //输出Saab,undefind,Volvo,undefined,BMW</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>但是用for in遍历时，并不会输出undefined<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (y in mycars)&#123; </span><br><span class=\"line\">    console.log(mycars[y]); //输出Saab,Volvo，BMW</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。</p>\n<ul>\n<li>函数没有返回值，返回undefined</li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p> 1.null和undefined都被用来表示空值，<strong>当使用不严格等于号（==）做判断时，他们是等价的</strong>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(null == undefined);//输出true</span><br><span class=\"line\">console.log(null === undefined);//输出false</span><br></pre></td></tr></table></figure></p>\n<p>这也是为什么我们在代码中判断相等时避免使用==</p>\n<p>2.当对null执行typeof运算时，结果返回object，也就是说<strong>null是一个对象</strong>，表示“空对象”<br>null的典型用法包括：</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据</li>\n<li>作为对象原型链的终点。在使用for in遍历原型链的会用到。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(Object.getPrototypeOf(Object.prototype));//输出null</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。<br>undefined的用法包括：</p>\n<ul>\n<li>变量被声明了，但没有赋值时，等于undefined<br>JavaScript函数作用域中会发生变量申明提前<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var func = function()&#123;</span><br><span class=\"line\">      console.log(a);//输出undefined</span><br><span class=\"line\">      var a = &quot;hello&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等价于<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var func = function()&#123;</span><br><span class=\"line\">      var a;</span><br><span class=\"line\">      console.log(a);//输出undefined</span><br><span class=\"line\">      a = &quot;hello&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>查询数组元素或对象属性时返回undefined，表示该元素或属性不存在<br>在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var mycars = new Array();</span><br><span class=\"line\">mycars[0] = &quot;Saab&quot;; </span><br><span class=\"line\">mycars[2] = &quot;Volvo&quot;; </span><br><span class=\"line\">mycars[4] = &quot;BMW&quot;;</span><br><span class=\"line\">for (y=0;y&lt;\\mycars.length;y++)&#123; </span><br><span class=\"line\">    console.log(mycars[y]); //输出Saab,undefind,Volvo,undefined,BMW</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>但是用for in遍历时，并不会输出undefined<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (y in mycars)&#123; </span><br><span class=\"line\">    console.log(mycars[y]); //输出Saab,Volvo，BMW</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。</p>\n<ul>\n<li>函数没有返回值，返回undefined</li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>\n</ul>\n"},{"title":"traceroute的原理","date":"2016-05-23T13:49:09.000Z","_content":"\n###### 1.什么是traceroute?\n traceroute， Linux系统称为tracepath，Windows系统称为tracert，是一种计算机网络工具。它可显示数据包在IP网络经过的路由器的IP地址。通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。\n<!-- more -->\ntraceroute有不同的实现版本：常规的traceroute(基于UDP和ICMP)和tcptraceroute(基于TCP)\n\n###### 2.traceroute原理\n常规的traceroute和tcptraceroute具有相同的工作原理：\n>1.  发送一个TTL(Time-To-Live)相当小的包，TTL经过每一跳时会递减。当它减为0时，数据包就被丢弃。\n2. 当TTL失效后，看哪个路由器返回一个带有表明的ICMP “time exceeded”\n3. 如果返回的路由器就是最终的目的地，停止trace\n4. 否则，TTL加1并返回到步骤1\n\n两者的不同点：\n>- 常规的traceroute使用UDP包或ICMP “Echo”包，这两种包都可能会被防火墙拦截。\n- tcptraceroute使用TCP “SYN”包。发送带SYN标志位的数据段是TCP建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的TCP包。\n- 基于TCP的traceroute拥有更高的访问权限。以amazon.com为例。基于UDP的traceroute停在205.251.248.5，这个地址很可能是某种防火墙。基于TCP的traceroute访问80端口，这是amazon.com的默认端口，然后进入下一步，最终停在72.21.194.212\n","source":"_posts/traceroute的原理.md","raw":"---\ntitle: traceroute的原理\ndate: 2016-05-23 21:49:09\ntags:\n- IP\ncategories:\n- 网络\n---\n\n###### 1.什么是traceroute?\n traceroute， Linux系统称为tracepath，Windows系统称为tracert，是一种计算机网络工具。它可显示数据包在IP网络经过的路由器的IP地址。通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。\n<!-- more -->\ntraceroute有不同的实现版本：常规的traceroute(基于UDP和ICMP)和tcptraceroute(基于TCP)\n\n###### 2.traceroute原理\n常规的traceroute和tcptraceroute具有相同的工作原理：\n>1.  发送一个TTL(Time-To-Live)相当小的包，TTL经过每一跳时会递减。当它减为0时，数据包就被丢弃。\n2. 当TTL失效后，看哪个路由器返回一个带有表明的ICMP “time exceeded”\n3. 如果返回的路由器就是最终的目的地，停止trace\n4. 否则，TTL加1并返回到步骤1\n\n两者的不同点：\n>- 常规的traceroute使用UDP包或ICMP “Echo”包，这两种包都可能会被防火墙拦截。\n- tcptraceroute使用TCP “SYN”包。发送带SYN标志位的数据段是TCP建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的TCP包。\n- 基于TCP的traceroute拥有更高的访问权限。以amazon.com为例。基于UDP的traceroute停在205.251.248.5，这个地址很可能是某种防火墙。基于TCP的traceroute访问80端口，这是amazon.com的默认端口，然后进入下一步，最终停在72.21.194.212\n","slug":"traceroute的原理","published":1,"updated":"2016-09-04T08:44:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2s00160pk3rv0ha1zb","content":"<h6 id=\"1-什么是traceroute\"><a href=\"#1-什么是traceroute\" class=\"headerlink\" title=\"1.什么是traceroute?\"></a>1.什么是traceroute?</h6><p> traceroute， Linux系统称为tracepath，Windows系统称为tracert，是一种计算机网络工具。它可显示数据包在IP网络经过的路由器的IP地址。通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。<br><a id=\"more\"></a><br>traceroute有不同的实现版本：常规的traceroute(基于UDP和ICMP)和tcptraceroute(基于TCP)</p>\n<h6 id=\"2-traceroute原理\"><a href=\"#2-traceroute原理\" class=\"headerlink\" title=\"2.traceroute原理\"></a>2.traceroute原理</h6><p>常规的traceroute和tcptraceroute具有相同的工作原理：</p>\n<blockquote>\n<ol>\n<li>发送一个TTL(Time-To-Live)相当小的包，TTL经过每一跳时会递减。当它减为0时，数据包就被丢弃。</li>\n<li>当TTL失效后，看哪个路由器返回一个带有表明的ICMP “time exceeded”</li>\n<li>如果返回的路由器就是最终的目的地，停止trace</li>\n<li>否则，TTL加1并返回到步骤1</li>\n</ol>\n</blockquote>\n<p>两者的不同点：</p>\n<blockquote>\n<ul>\n<li>常规的traceroute使用UDP包或ICMP “Echo”包，这两种包都可能会被防火墙拦截。</li>\n<li>tcptraceroute使用TCP “SYN”包。发送带SYN标志位的数据段是TCP建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的TCP包。</li>\n<li>基于TCP的traceroute拥有更高的访问权限。以amazon.com为例。基于UDP的traceroute停在205.251.248.5，这个地址很可能是某种防火墙。基于TCP的traceroute访问80端口，这是amazon.com的默认端口，然后进入下一步，最终停在72.21.194.212</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h6 id=\"1-什么是traceroute\"><a href=\"#1-什么是traceroute\" class=\"headerlink\" title=\"1.什么是traceroute?\"></a>1.什么是traceroute?</h6><p> traceroute， Linux系统称为tracepath，Windows系统称为tracert，是一种计算机网络工具。它可显示数据包在IP网络经过的路由器的IP地址。通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。<br>","more":"<br>traceroute有不同的实现版本：常规的traceroute(基于UDP和ICMP)和tcptraceroute(基于TCP)</p>\n<h6 id=\"2-traceroute原理\"><a href=\"#2-traceroute原理\" class=\"headerlink\" title=\"2.traceroute原理\"></a>2.traceroute原理</h6><p>常规的traceroute和tcptraceroute具有相同的工作原理：</p>\n<blockquote>\n<ol>\n<li>发送一个TTL(Time-To-Live)相当小的包，TTL经过每一跳时会递减。当它减为0时，数据包就被丢弃。</li>\n<li>当TTL失效后，看哪个路由器返回一个带有表明的ICMP “time exceeded”</li>\n<li>如果返回的路由器就是最终的目的地，停止trace</li>\n<li>否则，TTL加1并返回到步骤1</li>\n</ol>\n</blockquote>\n<p>两者的不同点：</p>\n<blockquote>\n<ul>\n<li>常规的traceroute使用UDP包或ICMP “Echo”包，这两种包都可能会被防火墙拦截。</li>\n<li>tcptraceroute使用TCP “SYN”包。发送带SYN标志位的数据段是TCP建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的TCP包。</li>\n<li>基于TCP的traceroute拥有更高的访问权限。以amazon.com为例。基于UDP的traceroute停在205.251.248.5，这个地址很可能是某种防火墙。基于TCP的traceroute访问80端口，这是amazon.com的默认端口，然后进入下一步，最终停在72.21.194.212</li>\n</ul>\n</blockquote>"},{"title":"【JavaScript】splice方法实现原理分析","date":"2017-01-08T22:58:12.000Z","_content":"> 近日在[LeetCode](https://leetcode.com/problems/ransom-note/)上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。\n\n**函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )**\n\n　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。\n　那么JavaScript究竟是如何做到这一切的呢？通过翻阅[ECMA5.1文档](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1)，我找到了答案。以下是splice()运行时执行的具体步骤：\n0. Let A = new Array()\n1.  将'length'作为参数传递给[[Get]]内建方法，得到数组的长度len\n2.  Let *relativeStart* be [ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*start*).\n3. 如果relativeStart < 0，那么actualStart = max((*len* + *relativeStart*),0)。也就是说，**当第一个参数start为负时，实际上是从右往左开始计算的**。否则，actualStart = min(*relativeStart*, *len*)。\n4. Let *actualDeleteCount* = min(max([ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*deleteCount*),0), *len* – *actualStart*).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，**防止出现数组越界操作**。\n5. Let *k* = 0\n6. Repeat, while(k < actualDeleteCount)\n　a. 获取数组在当前位置的元素值fromValue\n　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法[DefineOwnProperty()](http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9)，这个方法有三个参数：ToString(k)、 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)、false。在 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: **true**, Enumerable: **true**, Configurable: **true**。用过Object.defineProperty()的同学应该对这些不陌生。\n　c. k++\n**这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回**。\n7. 定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。\n8. 令itemCount 为 items的元素个数\n9. If itemCount < actualDeleteCount, then\n　a. Let k = actualStart.\n　b. Repeat, while k < (len - actualDeleteCount)\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*actualDeleteCount*).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*itemCount*).\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k++\n　c. Let k = len\n　d. Repeat, while k > (len - actualDeleteCount + itemCount)\n　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素\n　　ⅱ k--\n　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：\n1) 只删除元素\n2) 只插入元素\n3) 同时删除和插入元素\n\n![只删除元素](http://upload-images.jianshu.io/upload_images/192464-6871216f40be8f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　如果itemCount = 0且actualDeleteCount > 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。\n![只插入元素](http://upload-images.jianshu.io/upload_images/192464-1bcd00b57fc04537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　如果itemCount > 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。\n![同时删除和插入](http://upload-images.jianshu.io/upload_images/192464-bcf22c20af55c848.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　如果itemCount > 0 且 actualDeleteCount > 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。\n可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。\n\n11 . Else if *itemCount* > *actualDeleteCount*\n　a. Let *k* = (*len* – *actualDeleteCount*).\n　b. Repeat, while *k* > *actualStart*\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *actualDeleteCount* – 1).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *itemCount* – 1)\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k--\n这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。\n\n12 . Let k = actualStart\n13 . Repeat, while items is not empty\n　a. 删除items的第一个元素E\n　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E\n　c. k++\n这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。\n14 . 再次调用数组的内建方法[[Put]]来更新数组的'length'属性，length = *len* – *actualDeleteCount* + *itemCount*\n15 . 返回数组A\n\n　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。**它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。**splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的**新数组**。\n　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过**DefineOwnProperty()**这一内建方法来为自己添加元素，它的 **Property Descriptor中Writable、Enumerable、Configurable等属性都为true**，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。\n　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。\n\n---------------------\n作者：[熊贤仁](http://frankxiong.xyz)\n　\n　\n","source":"_posts/【JavaScript】splice方法实现原理分析.md","raw":"---\ntitle: 【JavaScript】splice方法实现原理分析\ndate: 2017-01-09 06:58:12\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> 近日在[LeetCode](https://leetcode.com/problems/ransom-note/)上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。\n\n**函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )**\n\n　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。\n　那么JavaScript究竟是如何做到这一切的呢？通过翻阅[ECMA5.1文档](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1)，我找到了答案。以下是splice()运行时执行的具体步骤：\n0. Let A = new Array()\n1.  将'length'作为参数传递给[[Get]]内建方法，得到数组的长度len\n2.  Let *relativeStart* be [ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*start*).\n3. 如果relativeStart < 0，那么actualStart = max((*len* + *relativeStart*),0)。也就是说，**当第一个参数start为负时，实际上是从右往左开始计算的**。否则，actualStart = min(*relativeStart*, *len*)。\n4. Let *actualDeleteCount* = min(max([ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*deleteCount*),0), *len* – *actualStart*).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，**防止出现数组越界操作**。\n5. Let *k* = 0\n6. Repeat, while(k < actualDeleteCount)\n　a. 获取数组在当前位置的元素值fromValue\n　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法[DefineOwnProperty()](http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9)，这个方法有三个参数：ToString(k)、 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)、false。在 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: **true**, Enumerable: **true**, Configurable: **true**。用过Object.defineProperty()的同学应该对这些不陌生。\n　c. k++\n**这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回**。\n7. 定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。\n8. 令itemCount 为 items的元素个数\n9. If itemCount < actualDeleteCount, then\n　a. Let k = actualStart.\n　b. Repeat, while k < (len - actualDeleteCount)\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*actualDeleteCount*).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*itemCount*).\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k++\n　c. Let k = len\n　d. Repeat, while k > (len - actualDeleteCount + itemCount)\n　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素\n　　ⅱ k--\n　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：\n1) 只删除元素\n2) 只插入元素\n3) 同时删除和插入元素\n\n![只删除元素](http://upload-images.jianshu.io/upload_images/192464-6871216f40be8f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　如果itemCount = 0且actualDeleteCount > 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。\n![只插入元素](http://upload-images.jianshu.io/upload_images/192464-1bcd00b57fc04537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　如果itemCount > 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。\n![同时删除和插入](http://upload-images.jianshu.io/upload_images/192464-bcf22c20af55c848.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　如果itemCount > 0 且 actualDeleteCount > 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。\n可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。\n\n11 . Else if *itemCount* > *actualDeleteCount*\n　a. Let *k* = (*len* – *actualDeleteCount*).\n　b. Repeat, while *k* > *actualStart*\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *actualDeleteCount* – 1).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *itemCount* – 1)\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k--\n这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。\n\n12 . Let k = actualStart\n13 . Repeat, while items is not empty\n　a. 删除items的第一个元素E\n　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E\n　c. k++\n这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。\n14 . 再次调用数组的内建方法[[Put]]来更新数组的'length'属性，length = *len* – *actualDeleteCount* + *itemCount*\n15 . 返回数组A\n\n　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。**它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。**splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的**新数组**。\n　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过**DefineOwnProperty()**这一内建方法来为自己添加元素，它的 **Property Descriptor中Writable、Enumerable、Configurable等属性都为true**，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。\n　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。\n\n---------------------\n作者：[熊贤仁](http://frankxiong.xyz)\n　\n　\n","slug":"【JavaScript】splice方法实现原理分析","published":1,"updated":"2017-02-05T05:21:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2u001a0pk3m8kbsapl","content":"<blockquote>\n<p>近日在<a href=\"https://leetcode.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。</p>\n</blockquote>\n<p><strong>函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )</strong></p>\n<p>　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。<br>　那么JavaScript究竟是如何做到这一切的呢？通过翻阅<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1\" target=\"_blank\" rel=\"noopener\">ECMA5.1文档</a>，我找到了答案。以下是splice()运行时执行的具体步骤：</p>\n<ol>\n<li>Let A = new Array()</li>\n<li>将’length’作为参数传递给[[Get]]内建方法，得到数组的长度len</li>\n<li>Let <em>relativeStart</em> be <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>start</em>).</li>\n<li>如果relativeStart &lt; 0，那么actualStart = max((<em>len</em> + <em>relativeStart</em>),0)。也就是说，<strong>当第一个参数start为负时，实际上是从右往左开始计算的</strong>。否则，actualStart = min(<em>relativeStart</em>, <em>len</em>)。</li>\n<li>Let <em>actualDeleteCount</em> = min(max(<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>deleteCount</em>),0), <em>len</em> – <em>actualStart</em>).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，<strong>防止出现数组越界操作</strong>。</li>\n<li>Let <em>k</em> = 0</li>\n<li>Repeat, while(k &lt; actualDeleteCount)<br>　a. 获取数组在当前位置的元素值fromValue<br>　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9\" target=\"_blank\" rel=\"noopener\">DefineOwnProperty()</a>，这个方法有三个参数：ToString(k)、 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>、false。在 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: <strong>true</strong>, Enumerable: <strong>true</strong>, Configurable: <strong>true</strong>。用过Object.defineProperty()的同学应该对这些不陌生。<br>　c. k++<br><strong>这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回</strong>。</li>\n<li>定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。</li>\n<li>令itemCount 为 items的元素个数</li>\n<li>If itemCount &lt; actualDeleteCount, then<br>　a. Let k = actualStart.<br>　b. Repeat, while k &lt; (len - actualDeleteCount)<br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>actualDeleteCount</em>).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>itemCount</em>).<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k++<br>　c. Let k = len<br>　d. Repeat, while k &gt; (len - actualDeleteCount + itemCount)<br>　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素<br>　　ⅱ k–<br>　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：<br>1) 只删除元素<br>2) 只插入元素<br>3) 同时删除和插入元素</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-6871216f40be8f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"只删除元素\"><br>　如果itemCount = 0且actualDeleteCount &gt; 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-1bcd00b57fc04537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"只插入元素\"><br>　如果itemCount &gt; 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-bcf22c20af55c848.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"同时删除和插入\"><br>　如果itemCount &gt; 0 且 actualDeleteCount &gt; 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。<br>可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。</p>\n<p>11 . Else if <em>itemCount</em> &gt; <em>actualDeleteCount</em><br>　a. Let <em>k</em> = (<em>len</em> – <em>actualDeleteCount</em>).<br>　b. Repeat, while <em>k</em> &gt; <em>actualStart</em><br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>actualDeleteCount</em> – 1).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>itemCount</em> – 1)<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k–<br>这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。</p>\n<p>12 . Let k = actualStart<br>13 . Repeat, while items is not empty<br>　a. 删除items的第一个元素E<br>　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E<br>　c. k++<br>这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。<br>14 . 再次调用数组的内建方法[[Put]]来更新数组的’length’属性，length = <em>len</em> – <em>actualDeleteCount</em> + <em>itemCount</em><br>15 . 返回数组A</p>\n<p>　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。<strong>它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。</strong>splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的<strong>新数组</strong>。<br>　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过<strong>DefineOwnProperty()</strong>这一内建方法来为自己添加元素，它的 <strong>Property Descriptor中Writable、Enumerable、Configurable等属性都为true</strong>，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。<br>　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。</p>\n<hr>\n<p>作者：<a href=\"http://frankxiong.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a>\n　\n　</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>近日在<a href=\"https://leetcode.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。</p>\n</blockquote>\n<p><strong>函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )</strong></p>\n<p>　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。<br>　那么JavaScript究竟是如何做到这一切的呢？通过翻阅<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1\" target=\"_blank\" rel=\"noopener\">ECMA5.1文档</a>，我找到了答案。以下是splice()运行时执行的具体步骤：</p>\n<ol>\n<li>Let A = new Array()</li>\n<li>将’length’作为参数传递给[[Get]]内建方法，得到数组的长度len</li>\n<li>Let <em>relativeStart</em> be <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>start</em>).</li>\n<li>如果relativeStart &lt; 0，那么actualStart = max((<em>len</em> + <em>relativeStart</em>),0)。也就是说，<strong>当第一个参数start为负时，实际上是从右往左开始计算的</strong>。否则，actualStart = min(<em>relativeStart</em>, <em>len</em>)。</li>\n<li>Let <em>actualDeleteCount</em> = min(max(<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>deleteCount</em>),0), <em>len</em> – <em>actualStart</em>).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，<strong>防止出现数组越界操作</strong>。</li>\n<li>Let <em>k</em> = 0</li>\n<li>Repeat, while(k &lt; actualDeleteCount)<br>　a. 获取数组在当前位置的元素值fromValue<br>　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9\" target=\"_blank\" rel=\"noopener\">DefineOwnProperty()</a>，这个方法有三个参数：ToString(k)、 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>、false。在 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: <strong>true</strong>, Enumerable: <strong>true</strong>, Configurable: <strong>true</strong>。用过Object.defineProperty()的同学应该对这些不陌生。<br>　c. k++<br><strong>这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回</strong>。</li>\n<li>定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。</li>\n<li>令itemCount 为 items的元素个数</li>\n<li>If itemCount &lt; actualDeleteCount, then<br>　a. Let k = actualStart.<br>　b. Repeat, while k &lt; (len - actualDeleteCount)<br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>actualDeleteCount</em>).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>itemCount</em>).<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k++<br>　c. Let k = len<br>　d. Repeat, while k &gt; (len - actualDeleteCount + itemCount)<br>　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素<br>　　ⅱ k–<br>　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：<br>1) 只删除元素<br>2) 只插入元素<br>3) 同时删除和插入元素</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-6871216f40be8f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"只删除元素\"><br>　如果itemCount = 0且actualDeleteCount &gt; 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-1bcd00b57fc04537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"只插入元素\"><br>　如果itemCount &gt; 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-bcf22c20af55c848.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"同时删除和插入\"><br>　如果itemCount &gt; 0 且 actualDeleteCount &gt; 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。<br>可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。</p>\n<p>11 . Else if <em>itemCount</em> &gt; <em>actualDeleteCount</em><br>　a. Let <em>k</em> = (<em>len</em> – <em>actualDeleteCount</em>).<br>　b. Repeat, while <em>k</em> &gt; <em>actualStart</em><br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>actualDeleteCount</em> – 1).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>itemCount</em> – 1)<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k–<br>这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。</p>\n<p>12 . Let k = actualStart<br>13 . Repeat, while items is not empty<br>　a. 删除items的第一个元素E<br>　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E<br>　c. k++<br>这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。<br>14 . 再次调用数组的内建方法[[Put]]来更新数组的’length’属性，length = <em>len</em> – <em>actualDeleteCount</em> + <em>itemCount</em><br>15 . 返回数组A</p>\n<p>　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。<strong>它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。</strong>splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的<strong>新数组</strong>。<br>　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过<strong>DefineOwnProperty()</strong>这一内建方法来为自己添加元素，它的 <strong>Property Descriptor中Writable、Enumerable、Configurable等属性都为true</strong>，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。<br>　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。</p>\n<hr>\n<p>作者：<a href=\"http://frankxiong.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a>\n　\n　</p>\n"},{"title":"【CSS】文本换行的几个属性","date":"2016-03-07T08:58:29.000Z","_content":"**word-wrap:normal | break-word; (内容换行)**         \n* normal:默认的属性值（允许内容顶开指定的容器边界）\n* break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）\n\n**word-break:normal | break-all | keep-all (词内换行)**\n\n* normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。\n* break-all : 强行换行,将截断英文单词。\n* keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。\n\n参数：\nnormal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\nbreak-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。\n\n说明：\n设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。\n\n**text-overflow:clip | ellipsis (文本溢出)**\n\n* clip : 　不显示省略标记（...），而是简单的裁切\n* ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（...）\n\n**white-space: normal | pre | nowrap (内容不换行)**\n* normal 默认。空白会被浏览器忽略。 \n* pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 \n* nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）\n***\n\n例子：\n让文本单行显示，并在溢出时，显示省略标记：\n`white-space:nowrap;\ntext-overflow:ellipsis;\noverflow:hidden;`\n生成效果如下：\n\n![图0.png](/uploads/fe-css-0.png)\n\n\n另一个腾讯NBA官网的例子（看NBA视频无意间发现的...）\n\n![图1.jpg](/uploads/fe-css-1.jpg)\n在这里，腾讯用了上述的三个属性\n`white-space: nowrap;\nword-break: keep-all;\noverflow: hidden;`\n　　这里的文本只能单行显示，多余的文本将被截断。其实`word-break:keep-all`这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上`overflow:hidden`后依然会截断超出盒子宽度的文字。\n　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。\n![图2.png](/uploads/fe-css-2.png)","source":"_posts/【CSS】文本换行的几个属性.md","raw":"---\ntitle: 【CSS】文本换行的几个属性\ndate: 2016-03-07 16:58:29\ntags:\n- CSS\ncategories:\n- 前端\n---\n**word-wrap:normal | break-word; (内容换行)**         \n* normal:默认的属性值（允许内容顶开指定的容器边界）\n* break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）\n\n**word-break:normal | break-all | keep-all (词内换行)**\n\n* normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。\n* break-all : 强行换行,将截断英文单词。\n* keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。\n\n参数：\nnormal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\nbreak-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。\n\n说明：\n设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。\n\n**text-overflow:clip | ellipsis (文本溢出)**\n\n* clip : 　不显示省略标记（...），而是简单的裁切\n* ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（...）\n\n**white-space: normal | pre | nowrap (内容不换行)**\n* normal 默认。空白会被浏览器忽略。 \n* pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 \n* nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）\n***\n\n例子：\n让文本单行显示，并在溢出时，显示省略标记：\n`white-space:nowrap;\ntext-overflow:ellipsis;\noverflow:hidden;`\n生成效果如下：\n\n![图0.png](/uploads/fe-css-0.png)\n\n\n另一个腾讯NBA官网的例子（看NBA视频无意间发现的...）\n\n![图1.jpg](/uploads/fe-css-1.jpg)\n在这里，腾讯用了上述的三个属性\n`white-space: nowrap;\nword-break: keep-all;\noverflow: hidden;`\n　　这里的文本只能单行显示，多余的文本将被截断。其实`word-break:keep-all`这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上`overflow:hidden`后依然会截断超出盒子宽度的文字。\n　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。\n![图2.png](/uploads/fe-css-2.png)","slug":"【CSS】文本换行的几个属性","published":1,"updated":"2016-03-07T09:22:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2v001e0pk3xecofviq","content":"<p><strong>word-wrap:normal | break-word; (内容换行)</strong>         </p>\n<ul>\n<li>normal:默认的属性值（允许内容顶开指定的容器边界）</li>\n<li>break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）</li>\n</ul>\n<p><strong>word-break:normal | break-all | keep-all (词内换行)</strong></p>\n<ul>\n<li>normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。</li>\n<li>break-all : 强行换行,将截断英文单词。</li>\n<li>keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。</li>\n</ul>\n<p>参数：<br>normal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行<br>break-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本</p>\n<p>keep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</p>\n<p>说明：<br>设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。</p>\n<p><strong>text-overflow:clip | ellipsis (文本溢出)</strong></p>\n<ul>\n<li>clip : 　不显示省略标记（…），而是简单的裁切</li>\n<li>ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（…）</li>\n</ul>\n<p><strong>white-space: normal | pre | nowrap (内容不换行)</strong></p>\n<ul>\n<li>normal 默认。空白会被浏览器忽略。 </li>\n<li>pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 </li>\n<li>nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）</li>\n</ul>\n<hr>\n<p>例子：<br>让文本单行显示，并在溢出时，显示省略标记：<br><code>white-space:nowrap;\ntext-overflow:ellipsis;\noverflow:hidden;</code><br>生成效果如下：</p>\n<p><img src=\"/uploads/fe-css-0.png\" alt=\"图0.png\"></p>\n<p>另一个腾讯NBA官网的例子（看NBA视频无意间发现的…）</p>\n<p><img src=\"/uploads/fe-css-1.jpg\" alt=\"图1.jpg\"><br>在这里，腾讯用了上述的三个属性<br><code>white-space: nowrap;\nword-break: keep-all;\noverflow: hidden;</code><br>　　这里的文本只能单行显示，多余的文本将被截断。其实<code>word-break:keep-all</code>这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上<code>overflow:hidden</code>后依然会截断超出盒子宽度的文字。<br>　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。<br><img src=\"/uploads/fe-css-2.png\" alt=\"图2.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>word-wrap:normal | break-word; (内容换行)</strong>         </p>\n<ul>\n<li>normal:默认的属性值（允许内容顶开指定的容器边界）</li>\n<li>break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）</li>\n</ul>\n<p><strong>word-break:normal | break-all | keep-all (词内换行)</strong></p>\n<ul>\n<li>normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。</li>\n<li>break-all : 强行换行,将截断英文单词。</li>\n<li>keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。</li>\n</ul>\n<p>参数：<br>normal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行<br>break-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本</p>\n<p>keep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</p>\n<p>说明：<br>设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。</p>\n<p><strong>text-overflow:clip | ellipsis (文本溢出)</strong></p>\n<ul>\n<li>clip : 　不显示省略标记（…），而是简单的裁切</li>\n<li>ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（…）</li>\n</ul>\n<p><strong>white-space: normal | pre | nowrap (内容不换行)</strong></p>\n<ul>\n<li>normal 默认。空白会被浏览器忽略。 </li>\n<li>pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 </li>\n<li>nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）</li>\n</ul>\n<hr>\n<p>例子：<br>让文本单行显示，并在溢出时，显示省略标记：<br><code>white-space:nowrap;\ntext-overflow:ellipsis;\noverflow:hidden;</code><br>生成效果如下：</p>\n<p><img src=\"/uploads/fe-css-0.png\" alt=\"图0.png\"></p>\n<p>另一个腾讯NBA官网的例子（看NBA视频无意间发现的…）</p>\n<p><img src=\"/uploads/fe-css-1.jpg\" alt=\"图1.jpg\"><br>在这里，腾讯用了上述的三个属性<br><code>white-space: nowrap;\nword-break: keep-all;\noverflow: hidden;</code><br>　　这里的文本只能单行显示，多余的文本将被截断。其实<code>word-break:keep-all</code>这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上<code>overflow:hidden</code>后依然会截断超出盒子宽度的文字。<br>　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。<br><img src=\"/uploads/fe-css-2.png\" alt=\"图2.png\"></p>\n"},{"title":"【JavaScript】变量作用域","date":"2016-03-07T08:51:45.000Z","_content":"背景知识：\n*  编程语言中，作用域控制变量与参数的可见性和生命周期\n* 函数体内，局部变量的优先级高于同名的全局变量\n* 块级作用域：花括号内的每一段代码都具有各自的作用域\n\n1.**JavaScript不支持块级作用域**\nJavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的\n```\nfunction hello( ) { \n        for (var i = 0; i < 10; i++) { \n            doSomething...\n        } \n        //输出10，在支持块级作用域的语言中这里会报错\n        console.log(i); \n    }```\n\n2.声明提前：**JavaScript函数里申明的所有变量都被提前至函数体顶部**\n```\nvar scope = “global”;\nfunction test( ){\n    //输出undefined，这里scope只是申明，还没有被赋初值\n     console.log(scope);     \n    //scope在这里被赋初值，但scoop的申明发生在函数体顶部\n     var scope = “local”;     \n    //输出local\n     console.log(scope);     \n}```\n\n该函数等价于：\n```\nvar scope = “global”;\nfunction test( ){\n     var scope;    \n     console.log(scope);    \n     scope = “local”;   \n     console.log(scope);    \n}```","source":"_posts/【JavaScript】变量作用域.md","raw":"---\ntitle: 【JavaScript】变量作用域\ndate: 2016-03-07 16:51:45\ntags: \n- JavaScript\ncategories:\n- 前端\n---\n背景知识：\n*  编程语言中，作用域控制变量与参数的可见性和生命周期\n* 函数体内，局部变量的优先级高于同名的全局变量\n* 块级作用域：花括号内的每一段代码都具有各自的作用域\n\n1.**JavaScript不支持块级作用域**\nJavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的\n```\nfunction hello( ) { \n        for (var i = 0; i < 10; i++) { \n            doSomething...\n        } \n        //输出10，在支持块级作用域的语言中这里会报错\n        console.log(i); \n    }```\n\n2.声明提前：**JavaScript函数里申明的所有变量都被提前至函数体顶部**\n```\nvar scope = “global”;\nfunction test( ){\n    //输出undefined，这里scope只是申明，还没有被赋初值\n     console.log(scope);     \n    //scope在这里被赋初值，但scoop的申明发生在函数体顶部\n     var scope = “local”;     \n    //输出local\n     console.log(scope);     \n}```\n\n该函数等价于：\n```\nvar scope = “global”;\nfunction test( ){\n     var scope;    \n     console.log(scope);    \n     scope = “local”;   \n     console.log(scope);    \n}```","slug":"【JavaScript】变量作用域","published":1,"updated":"2016-03-07T09:21:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2x001h0pk3a6bgknt1","content":"<p>背景知识：</p>\n<ul>\n<li>编程语言中，作用域控制变量与参数的可见性和生命周期</li>\n<li>函数体内，局部变量的优先级高于同名的全局变量</li>\n<li>块级作用域：花括号内的每一段代码都具有各自的作用域</li>\n</ul>\n<p>1.<strong>JavaScript不支持块级作用域</strong><br>JavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hello( ) &#123; </span><br><span class=\"line\">        for (var i = 0; i &lt; 10; i++) &#123; </span><br><span class=\"line\">            doSomething...</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        //输出10，在支持块级作用域的语言中这里会报错</span><br><span class=\"line\">        console.log(i); </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.声明提前：<strong>JavaScript函数里申明的所有变量都被提前至函数体顶部</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var scope = “global”;</span><br><span class=\"line\">function test( )&#123;</span><br><span class=\"line\">    //输出undefined，这里scope只是申明，还没有被赋初值</span><br><span class=\"line\">     console.log(scope);     </span><br><span class=\"line\">    //scope在这里被赋初值，但scoop的申明发生在函数体顶部</span><br><span class=\"line\">     var scope = “local”;     </span><br><span class=\"line\">    //输出local</span><br><span class=\"line\">     console.log(scope);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该函数等价于：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var scope = “global”;</span><br><span class=\"line\">function test( )&#123;</span><br><span class=\"line\">     var scope;    </span><br><span class=\"line\">     console.log(scope);    </span><br><span class=\"line\">     scope = “local”;   </span><br><span class=\"line\">     console.log(scope);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景知识：</p>\n<ul>\n<li>编程语言中，作用域控制变量与参数的可见性和生命周期</li>\n<li>函数体内，局部变量的优先级高于同名的全局变量</li>\n<li>块级作用域：花括号内的每一段代码都具有各自的作用域</li>\n</ul>\n<p>1.<strong>JavaScript不支持块级作用域</strong><br>JavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hello( ) &#123; </span><br><span class=\"line\">        for (var i = 0; i &lt; 10; i++) &#123; </span><br><span class=\"line\">            doSomething...</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        //输出10，在支持块级作用域的语言中这里会报错</span><br><span class=\"line\">        console.log(i); </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.声明提前：<strong>JavaScript函数里申明的所有变量都被提前至函数体顶部</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var scope = “global”;</span><br><span class=\"line\">function test( )&#123;</span><br><span class=\"line\">    //输出undefined，这里scope只是申明，还没有被赋初值</span><br><span class=\"line\">     console.log(scope);     </span><br><span class=\"line\">    //scope在这里被赋初值，但scoop的申明发生在函数体顶部</span><br><span class=\"line\">     var scope = “local”;     </span><br><span class=\"line\">    //输出local</span><br><span class=\"line\">     console.log(scope);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该函数等价于：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var scope = “global”;</span><br><span class=\"line\">function test( )&#123;</span><br><span class=\"line\">     var scope;    </span><br><span class=\"line\">     console.log(scope);    </span><br><span class=\"line\">     scope = “local”;   </span><br><span class=\"line\">     console.log(scope);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"JavaScript设计模式汇总","date":"2018-01-22T16:04:48.000Z","_content":"\n1. 单例模式\n单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象`var o = {}`，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。\n实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：\n```\nvar getInstance = function() {\n  var _instance;\n  return function() {\n    if (!_instance) {\n      _instance = new Dialog();\n    }\n    return _instance;\n  }\n}\n```\n其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。\n\n2. 发布-订阅模式\n发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。\n```\nvar Event = (function(){\n  var list = {};\n  var listen = function(type, fn) {\n    if (!list[type]) {\n      list[type] = [];\n    } \n    list[type].push(fn);\n  }\n  var trigger = function() {\n    var type = Array.prototype.shift.call(arguments);\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    }\n    for (var i = 0; i < fns.length; i++) {\n      fns[i].apply(this, arguments);\n    }\n  }\n  var remove = function(type, fn) {\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    } \n    fns.forEach(function(_fn, i) {\n      if (_fn == fn) {\n        fns.splice(i, 1);\n      }\n    })\n  }\n  return {\n    listen: listen,\n    trigger: trigger,\n    remove: remove\n  }\n})();\n\nEvent.listen('click', function(data) {\n  console.log('you clicked: ' + data);\n})\nEvent.trigger('click', 'hahaha');\n```\n\n3. 代理模式\n\n待续...\n\n","source":"_posts/【JavaScript】常见设计模式总结.md","raw":"---\ntitle: JavaScript设计模式汇总\ndate: 2018-01-23 00:04:48\ntags: 前端\n---\n\n1. 单例模式\n单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象`var o = {}`，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。\n实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：\n```\nvar getInstance = function() {\n  var _instance;\n  return function() {\n    if (!_instance) {\n      _instance = new Dialog();\n    }\n    return _instance;\n  }\n}\n```\n其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。\n\n2. 发布-订阅模式\n发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。\n```\nvar Event = (function(){\n  var list = {};\n  var listen = function(type, fn) {\n    if (!list[type]) {\n      list[type] = [];\n    } \n    list[type].push(fn);\n  }\n  var trigger = function() {\n    var type = Array.prototype.shift.call(arguments);\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    }\n    for (var i = 0; i < fns.length; i++) {\n      fns[i].apply(this, arguments);\n    }\n  }\n  var remove = function(type, fn) {\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    } \n    fns.forEach(function(_fn, i) {\n      if (_fn == fn) {\n        fns.splice(i, 1);\n      }\n    })\n  }\n  return {\n    listen: listen,\n    trigger: trigger,\n    remove: remove\n  }\n})();\n\nEvent.listen('click', function(data) {\n  console.log('you clicked: ' + data);\n})\nEvent.trigger('click', 'hahaha');\n```\n\n3. 代理模式\n\n待续...\n\n","slug":"【JavaScript】常见设计模式总结","published":1,"updated":"2018-02-02T16:03:41.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko2y001l0pk34ccpoe8r","content":"<ol>\n<li>单例模式<br>单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象<code>var o = {}</code>，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。<br>实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var getInstance = function() &#123;</span><br><span class=\"line\">  var _instance;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    if (!_instance) &#123;</span><br><span class=\"line\">      _instance = new Dialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。</p>\n<ol>\n<li><p>发布-订阅模式<br>发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var Event = (function()&#123;</span><br><span class=\"line\">  var list = &#123;&#125;;</span><br><span class=\"line\">  var listen = function(type, fn) &#123;</span><br><span class=\"line\">    if (!list[type]) &#123;</span><br><span class=\"line\">      list[type] = [];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    list[type].push(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var trigger = function() &#123;</span><br><span class=\"line\">    var type = Array.prototype.shift.call(arguments);</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 0; i &lt; fns.length; i++) &#123;</span><br><span class=\"line\">      fns[i].apply(this, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var remove = function(type, fn) &#123;</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    fns.forEach(function(_fn, i) &#123;</span><br><span class=\"line\">      if (_fn == fn) &#123;</span><br><span class=\"line\">        fns.splice(i, 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    listen: listen,</span><br><span class=\"line\">    trigger: trigger,</span><br><span class=\"line\">    remove: remove</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Event.listen(&apos;click&apos;, function(data) &#123;</span><br><span class=\"line\">  console.log(&apos;you clicked: &apos; + data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Event.trigger(&apos;click&apos;, &apos;hahaha&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代理模式</p>\n</li>\n</ol>\n<p>待续…</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>单例模式<br>单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象<code>var o = {}</code>，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。<br>实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var getInstance = function() &#123;</span><br><span class=\"line\">  var _instance;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    if (!_instance) &#123;</span><br><span class=\"line\">      _instance = new Dialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。</p>\n<ol>\n<li><p>发布-订阅模式<br>发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var Event = (function()&#123;</span><br><span class=\"line\">  var list = &#123;&#125;;</span><br><span class=\"line\">  var listen = function(type, fn) &#123;</span><br><span class=\"line\">    if (!list[type]) &#123;</span><br><span class=\"line\">      list[type] = [];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    list[type].push(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var trigger = function() &#123;</span><br><span class=\"line\">    var type = Array.prototype.shift.call(arguments);</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 0; i &lt; fns.length; i++) &#123;</span><br><span class=\"line\">      fns[i].apply(this, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var remove = function(type, fn) &#123;</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    fns.forEach(function(_fn, i) &#123;</span><br><span class=\"line\">      if (_fn == fn) &#123;</span><br><span class=\"line\">        fns.splice(i, 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    listen: listen,</span><br><span class=\"line\">    trigger: trigger,</span><br><span class=\"line\">    remove: remove</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Event.listen(&apos;click&apos;, function(data) &#123;</span><br><span class=\"line\">  console.log(&apos;you clicked: &apos; + data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Event.trigger(&apos;click&apos;, &apos;hahaha&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代理模式</p>\n</li>\n</ol>\n<p>待续…</p>\n"},{"title":"【JavaScript】闭包的概念","date":"2016-03-07T08:56:03.000Z","_content":"背景：\n* 理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》\n* JavaScript中的函数都是对象\n\n简而言之，JavaScript函数内部的所有变量对外部是不可见的\n比如这样的代码会抛出error\n```\nvar test = function(){\n　var i=0;\n}\nconsole.log(i);//undefined error\n```\n那么怎么让函数访问外部变量呢？\nJavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。\n\n闭包的好处是**内部函数可以访问定义它们的外部函数的参数和变量**\n****\n闭包示例\n```\n    var test = function(status){\n　     return {\n　　     getStatus:function(){\n　　　    return status;\n　　     }\n　     };\n    };\n//测试\n// 调用test时，它返回一个包含getStatus方法的新对象\nvar myQuo = test('404');\nconsole.log(myQuo.getStatus());```\n\n另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号\n```\n// 这是一个错误的例子，点击任意节点输出结果都为9\n// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值\n     var addHandlers = function(nodes){\n        var i;\n        for(i=0;i<nodes.length;i++){\n            nodes[i].onclick = function(e){\n                console.log(i);\n            };\n        }\n    };```\n\n正确的例子·\n```\nvar addHandlers = function(nodes){\n        var helper = function(i){\n            return function(){\n                console.log(i);\n            };\n        };\n        var i;\n        // 避免在循环中创建函数\n        for(i=0;i<nodes.length;i++){\n            nodes[i].onclick = helper(i);\n        }\n    }```\n","source":"_posts/【JavaScript】闭包的概念.md","raw":"---\ntitle: 【JavaScript】闭包的概念\ndate: 2016-03-07 16:56:03\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n背景：\n* 理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》\n* JavaScript中的函数都是对象\n\n简而言之，JavaScript函数内部的所有变量对外部是不可见的\n比如这样的代码会抛出error\n```\nvar test = function(){\n　var i=0;\n}\nconsole.log(i);//undefined error\n```\n那么怎么让函数访问外部变量呢？\nJavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。\n\n闭包的好处是**内部函数可以访问定义它们的外部函数的参数和变量**\n****\n闭包示例\n```\n    var test = function(status){\n　     return {\n　　     getStatus:function(){\n　　　    return status;\n　　     }\n　     };\n    };\n//测试\n// 调用test时，它返回一个包含getStatus方法的新对象\nvar myQuo = test('404');\nconsole.log(myQuo.getStatus());```\n\n另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号\n```\n// 这是一个错误的例子，点击任意节点输出结果都为9\n// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值\n     var addHandlers = function(nodes){\n        var i;\n        for(i=0;i<nodes.length;i++){\n            nodes[i].onclick = function(e){\n                console.log(i);\n            };\n        }\n    };```\n\n正确的例子·\n```\nvar addHandlers = function(nodes){\n        var helper = function(i){\n            return function(){\n                console.log(i);\n            };\n        };\n        var i;\n        // 避免在循环中创建函数\n        for(i=0;i<nodes.length;i++){\n            nodes[i].onclick = helper(i);\n        }\n    }```\n","slug":"【JavaScript】闭包的概念","published":1,"updated":"2016-03-07T09:21:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko30001o0pk3i7wm2t6b","content":"<p>背景：</p>\n<ul>\n<li>理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》</li>\n<li>JavaScript中的函数都是对象</li>\n</ul>\n<p>简而言之，JavaScript函数内部的所有变量对外部是不可见的<br>比如这样的代码会抛出error<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var test = function()&#123;</span><br><span class=\"line\">　var i=0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i);//undefined error</span><br></pre></td></tr></table></figure></p>\n<p>那么怎么让函数访问外部变量呢？<br>JavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。</p>\n<p>闭包的好处是<strong>内部函数可以访问定义它们的外部函数的参数和变量</strong></p>\n<hr>\n<p>闭包示例<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    var test = function(status)&#123;</span><br><span class=\"line\">　     return &#123;</span><br><span class=\"line\">　　     getStatus:function()&#123;</span><br><span class=\"line\">　　　    return status;</span><br><span class=\"line\">　　     &#125;</span><br><span class=\"line\">　     &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">//测试</span><br><span class=\"line\">// 调用test时，它返回一个包含getStatus方法的新对象</span><br><span class=\"line\">var myQuo = test(&apos;404&apos;);</span><br><span class=\"line\">console.log(myQuo.getStatus());</span><br></pre></td></tr></table></figure></p>\n<p>另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 这是一个错误的例子，点击任意节点输出结果都为9</span><br><span class=\"line\">// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值</span><br><span class=\"line\">     var addHandlers = function(nodes)&#123;</span><br><span class=\"line\">        var i;</span><br><span class=\"line\">        for(i=0;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            nodes[i].onclick = function(e)&#123;</span><br><span class=\"line\">                console.log(i);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>正确的例子·<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var addHandlers = function(nodes)&#123;</span><br><span class=\"line\">        var helper = function(i)&#123;</span><br><span class=\"line\">            return function()&#123;</span><br><span class=\"line\">                console.log(i);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var i;</span><br><span class=\"line\">        // 避免在循环中创建函数</span><br><span class=\"line\">        for(i=0;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            nodes[i].onclick = helper(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景：</p>\n<ul>\n<li>理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》</li>\n<li>JavaScript中的函数都是对象</li>\n</ul>\n<p>简而言之，JavaScript函数内部的所有变量对外部是不可见的<br>比如这样的代码会抛出error<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var test = function()&#123;</span><br><span class=\"line\">　var i=0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i);//undefined error</span><br></pre></td></tr></table></figure></p>\n<p>那么怎么让函数访问外部变量呢？<br>JavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。</p>\n<p>闭包的好处是<strong>内部函数可以访问定义它们的外部函数的参数和变量</strong></p>\n<hr>\n<p>闭包示例<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    var test = function(status)&#123;</span><br><span class=\"line\">　     return &#123;</span><br><span class=\"line\">　　     getStatus:function()&#123;</span><br><span class=\"line\">　　　    return status;</span><br><span class=\"line\">　　     &#125;</span><br><span class=\"line\">　     &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">//测试</span><br><span class=\"line\">// 调用test时，它返回一个包含getStatus方法的新对象</span><br><span class=\"line\">var myQuo = test(&apos;404&apos;);</span><br><span class=\"line\">console.log(myQuo.getStatus());</span><br></pre></td></tr></table></figure></p>\n<p>另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 这是一个错误的例子，点击任意节点输出结果都为9</span><br><span class=\"line\">// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值</span><br><span class=\"line\">     var addHandlers = function(nodes)&#123;</span><br><span class=\"line\">        var i;</span><br><span class=\"line\">        for(i=0;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            nodes[i].onclick = function(e)&#123;</span><br><span class=\"line\">                console.log(i);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>正确的例子·<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var addHandlers = function(nodes)&#123;</span><br><span class=\"line\">        var helper = function(i)&#123;</span><br><span class=\"line\">            return function()&#123;</span><br><span class=\"line\">                console.log(i);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var i;</span><br><span class=\"line\">        // 避免在循环中创建函数</span><br><span class=\"line\">        for(i=0;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            nodes[i].onclick = helper(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"【JavaScript实现数据结构】栈","date":"2016-03-21T09:39:09.000Z","_content":"堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。\n代码如下：\n```\n//数组实现\nfunction Stack(){\n   this.items = [];\n   this.size = 0;\n}\nStack.prototype = {\n   constructor:Stack,\n   push:function(data){\n       this.items[this.size++] = data;\n   },\n   pop:function(){\n       return this.items[--this.size];\n   },\n   clear:function(){\n       this.size = 0;\n       this.items = [];\n   },\n   perk:function(){\n       return this.items[this.size-1];\n   }\n}\n```\n\n```\n//链表实现\n    function Stack(){\n        this.top = null;\n        this.size = 0;\n    }\n    Stack.prototype = {\n        constructor:Stack,\n        push:function(data){\n            var node = {\n                data:data,\n                next:null\n            };\n            node.next = this.top;\n            this.top = node;\n            this.size++;\n        },\n        pop:function(){\n            if(this.top === null){\n                return null;\n            }\n            var out = this.top;\n            this.top = this.top.next;\n            if(this.size > 0){\n                this.size--;    \n            }\n            return out.data;\n        },\n        perk:function(){\n            return this.top === null ? null:this.top.data; \n        },\n        clear:function(){\n            this.top = null;\n            this.size = 0;\n        }\n```\n测试：\n```\nvar stack = new Stack();\nstack.push('k');\nstack.push('b');\nconsole.log(stack.perk());//输出b\nstack.pop();\nconsole.log(stack.perk());//输出k\n```\n-----------\n### 栈的应用\n例子：数值进制转换\n算法思想如下：\n(1)  最高位为 n % b,将此位压入栈。\n(2)  使用 n/b 代替 n。\n(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。\n(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。\n\n具体代码实现：\n```    \nfunction mulBase(num,base){\n    var stack = new Stack();\n    do{\n        stack.push(num % base); \n        num = Math.floor(num / base);\n    }while(num>0);\n    var result = '';\n    while(stack.size > 0){\n        result += stack.pop();\n    }\n    return result;\n}\nconsole.log(mulBase(234,2)); //输出11101010\n```\n------------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","source":"_posts/【JavaScript实现数据结构】栈.md","raw":"---\ntitle: 【JavaScript实现数据结构】栈\ndate: 2016-03-21 17:39:09\ntags:\n- JavaScript\n- 数据结构\n- 算法\ncategories:\n- 数据结构与算法\n---\n堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。\n代码如下：\n```\n//数组实现\nfunction Stack(){\n   this.items = [];\n   this.size = 0;\n}\nStack.prototype = {\n   constructor:Stack,\n   push:function(data){\n       this.items[this.size++] = data;\n   },\n   pop:function(){\n       return this.items[--this.size];\n   },\n   clear:function(){\n       this.size = 0;\n       this.items = [];\n   },\n   perk:function(){\n       return this.items[this.size-1];\n   }\n}\n```\n\n```\n//链表实现\n    function Stack(){\n        this.top = null;\n        this.size = 0;\n    }\n    Stack.prototype = {\n        constructor:Stack,\n        push:function(data){\n            var node = {\n                data:data,\n                next:null\n            };\n            node.next = this.top;\n            this.top = node;\n            this.size++;\n        },\n        pop:function(){\n            if(this.top === null){\n                return null;\n            }\n            var out = this.top;\n            this.top = this.top.next;\n            if(this.size > 0){\n                this.size--;    \n            }\n            return out.data;\n        },\n        perk:function(){\n            return this.top === null ? null:this.top.data; \n        },\n        clear:function(){\n            this.top = null;\n            this.size = 0;\n        }\n```\n测试：\n```\nvar stack = new Stack();\nstack.push('k');\nstack.push('b');\nconsole.log(stack.perk());//输出b\nstack.pop();\nconsole.log(stack.perk());//输出k\n```\n-----------\n### 栈的应用\n例子：数值进制转换\n算法思想如下：\n(1)  最高位为 n % b,将此位压入栈。\n(2)  使用 n/b 代替 n。\n(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。\n(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。\n\n具体代码实现：\n```    \nfunction mulBase(num,base){\n    var stack = new Stack();\n    do{\n        stack.push(num % base); \n        num = Math.floor(num / base);\n    }while(num>0);\n    var result = '';\n    while(stack.size > 0){\n        result += stack.pop();\n    }\n    return result;\n}\nconsole.log(mulBase(234,2)); //输出11101010\n```\n------------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","slug":"【JavaScript实现数据结构】栈","published":1,"updated":"2016-03-21T09:41:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko31001s0pk3dfkx27pf","content":"<p>堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//数组实现</span><br><span class=\"line\">function Stack()&#123;</span><br><span class=\"line\">   this.items = [];</span><br><span class=\"line\">   this.size = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Stack.prototype = &#123;</span><br><span class=\"line\">   constructor:Stack,</span><br><span class=\"line\">   push:function(data)&#123;</span><br><span class=\"line\">       this.items[this.size++] = data;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   pop:function()&#123;</span><br><span class=\"line\">       return this.items[--this.size];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   clear:function()&#123;</span><br><span class=\"line\">       this.size = 0;</span><br><span class=\"line\">       this.items = [];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   perk:function()&#123;</span><br><span class=\"line\">       return this.items[this.size-1];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//链表实现</span><br><span class=\"line\">    function Stack()&#123;</span><br><span class=\"line\">        this.top = null;</span><br><span class=\"line\">        this.size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack.prototype = &#123;</span><br><span class=\"line\">        constructor:Stack,</span><br><span class=\"line\">        push:function(data)&#123;</span><br><span class=\"line\">            var node = &#123;</span><br><span class=\"line\">                data:data,</span><br><span class=\"line\">                next:null</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            node.next = this.top;</span><br><span class=\"line\">            this.top = node;</span><br><span class=\"line\">            this.size++;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        pop:function()&#123;</span><br><span class=\"line\">            if(this.top === null)&#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var out = this.top;</span><br><span class=\"line\">            this.top = this.top.next;</span><br><span class=\"line\">            if(this.size &gt; 0)&#123;</span><br><span class=\"line\">                this.size--;    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return out.data;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        perk:function()&#123;</span><br><span class=\"line\">            return this.top === null ? null:this.top.data; </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        clear:function()&#123;</span><br><span class=\"line\">            this.top = null;</span><br><span class=\"line\">            this.size = 0;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var stack = new Stack();</span><br><span class=\"line\">stack.push(&apos;k&apos;);</span><br><span class=\"line\">stack.push(&apos;b&apos;);</span><br><span class=\"line\">console.log(stack.perk());//输出b</span><br><span class=\"line\">stack.pop();</span><br><span class=\"line\">console.log(stack.perk());//输出k</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><p>例子：数值进制转换<br>算法思想如下：<br>(1)  最高位为 n % b,将此位压入栈。<br>(2)  使用 n/b 代替 n。<br>(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。<br>(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。</p>\n<p>具体代码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mulBase(num,base)&#123;</span><br><span class=\"line\">    var stack = new Stack();</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        stack.push(num % base); </span><br><span class=\"line\">        num = Math.floor(num / base);</span><br><span class=\"line\">    &#125;while(num&gt;0);</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    while(stack.size &gt; 0)&#123;</span><br><span class=\"line\">        result += stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(mulBase(234,2)); //输出11101010</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//数组实现</span><br><span class=\"line\">function Stack()&#123;</span><br><span class=\"line\">   this.items = [];</span><br><span class=\"line\">   this.size = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Stack.prototype = &#123;</span><br><span class=\"line\">   constructor:Stack,</span><br><span class=\"line\">   push:function(data)&#123;</span><br><span class=\"line\">       this.items[this.size++] = data;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   pop:function()&#123;</span><br><span class=\"line\">       return this.items[--this.size];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   clear:function()&#123;</span><br><span class=\"line\">       this.size = 0;</span><br><span class=\"line\">       this.items = [];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   perk:function()&#123;</span><br><span class=\"line\">       return this.items[this.size-1];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//链表实现</span><br><span class=\"line\">    function Stack()&#123;</span><br><span class=\"line\">        this.top = null;</span><br><span class=\"line\">        this.size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack.prototype = &#123;</span><br><span class=\"line\">        constructor:Stack,</span><br><span class=\"line\">        push:function(data)&#123;</span><br><span class=\"line\">            var node = &#123;</span><br><span class=\"line\">                data:data,</span><br><span class=\"line\">                next:null</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            node.next = this.top;</span><br><span class=\"line\">            this.top = node;</span><br><span class=\"line\">            this.size++;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        pop:function()&#123;</span><br><span class=\"line\">            if(this.top === null)&#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var out = this.top;</span><br><span class=\"line\">            this.top = this.top.next;</span><br><span class=\"line\">            if(this.size &gt; 0)&#123;</span><br><span class=\"line\">                this.size--;    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return out.data;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        perk:function()&#123;</span><br><span class=\"line\">            return this.top === null ? null:this.top.data; </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        clear:function()&#123;</span><br><span class=\"line\">            this.top = null;</span><br><span class=\"line\">            this.size = 0;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var stack = new Stack();</span><br><span class=\"line\">stack.push(&apos;k&apos;);</span><br><span class=\"line\">stack.push(&apos;b&apos;);</span><br><span class=\"line\">console.log(stack.perk());//输出b</span><br><span class=\"line\">stack.pop();</span><br><span class=\"line\">console.log(stack.perk());//输出k</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><p>例子：数值进制转换<br>算法思想如下：<br>(1)  最高位为 n % b,将此位压入栈。<br>(2)  使用 n/b 代替 n。<br>(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。<br>(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。</p>\n<p>具体代码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mulBase(num,base)&#123;</span><br><span class=\"line\">    var stack = new Stack();</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        stack.push(num % base); </span><br><span class=\"line\">        num = Math.floor(num / base);</span><br><span class=\"line\">    &#125;while(num&gt;0);</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    while(stack.size &gt; 0)&#123;</span><br><span class=\"line\">        result += stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(mulBase(234,2)); //输出11101010</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n"},{"title":"【JavaScript实现数据结构】队列","date":"2016-03-21T09:42:51.000Z","_content":"队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。\n\nJavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：\n```\nfunction Queue(){\n    this.items = [];\n}\nQueue.prototype = {\n    enqueue:function(data){\n        this.items.push(data);\n    },\n    dequeue:function(){\n        return this.items.shift();\n    },\n    front:function(){\n        return this.items[0];\n    },\n    rear:function(){\n        return this.items[this.items.length-1];\n    },\n    clear:function(){\n        this.items = [];\n    },\n    length:function(){\n        return this.items.length;\n    },\n    displayAll:function(){\n        var str = '';\n        for(var i = 0;i < this.length();i++){\n            str += this.items[i];\n        }\n        return str;\n    }\n}\n```\n测试：\n```\nvar queue = new Queue();\nqueue.enqueue('aaa');\nqueue.enqueue('bbb');\nconsole.log(queue.length());//输出2\nqueue.dequeue();\nconsole.log(queue.displayAll());//输出bbb\n```\n-----------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","source":"_posts/【JavaScript实现数据结构】队列.md","raw":"---\ntitle: 【JavaScript实现数据结构】队列\ndate: 2016-03-21 17:42:51\ntags:\n- JavaScript\n- 数据结构\ncategories:\n- 数据结构与算法\n---\n队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。\n\nJavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：\n```\nfunction Queue(){\n    this.items = [];\n}\nQueue.prototype = {\n    enqueue:function(data){\n        this.items.push(data);\n    },\n    dequeue:function(){\n        return this.items.shift();\n    },\n    front:function(){\n        return this.items[0];\n    },\n    rear:function(){\n        return this.items[this.items.length-1];\n    },\n    clear:function(){\n        this.items = [];\n    },\n    length:function(){\n        return this.items.length;\n    },\n    displayAll:function(){\n        var str = '';\n        for(var i = 0;i < this.length();i++){\n            str += this.items[i];\n        }\n        return str;\n    }\n}\n```\n测试：\n```\nvar queue = new Queue();\nqueue.enqueue('aaa');\nqueue.enqueue('bbb');\nconsole.log(queue.length());//输出2\nqueue.dequeue();\nconsole.log(queue.displayAll());//输出bbb\n```\n-----------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","slug":"【JavaScript实现数据结构】队列","published":1,"updated":"2016-03-21T09:45:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko32001v0pk3dh85iqa6","content":"<p>队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。</p>\n<p>JavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Queue()&#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Queue.prototype = &#123;</span><br><span class=\"line\">    enqueue:function(data)&#123;</span><br><span class=\"line\">        this.items.push(data);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dequeue:function()&#123;</span><br><span class=\"line\">        return this.items.shift();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    front:function()&#123;</span><br><span class=\"line\">        return this.items[0];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    rear:function()&#123;</span><br><span class=\"line\">        return this.items[this.items.length-1];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    clear:function()&#123;</span><br><span class=\"line\">        this.items = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    length:function()&#123;</span><br><span class=\"line\">        return this.items.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    displayAll:function()&#123;</span><br><span class=\"line\">        var str = &apos;&apos;;</span><br><span class=\"line\">        for(var i = 0;i &lt; this.length();i++)&#123;</span><br><span class=\"line\">            str += this.items[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var queue = new Queue();</span><br><span class=\"line\">queue.enqueue(&apos;aaa&apos;);</span><br><span class=\"line\">queue.enqueue(&apos;bbb&apos;);</span><br><span class=\"line\">console.log(queue.length());//输出2</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">console.log(queue.displayAll());//输出bbb</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。</p>\n<p>JavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Queue()&#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Queue.prototype = &#123;</span><br><span class=\"line\">    enqueue:function(data)&#123;</span><br><span class=\"line\">        this.items.push(data);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dequeue:function()&#123;</span><br><span class=\"line\">        return this.items.shift();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    front:function()&#123;</span><br><span class=\"line\">        return this.items[0];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    rear:function()&#123;</span><br><span class=\"line\">        return this.items[this.items.length-1];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    clear:function()&#123;</span><br><span class=\"line\">        this.items = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    length:function()&#123;</span><br><span class=\"line\">        return this.items.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    displayAll:function()&#123;</span><br><span class=\"line\">        var str = &apos;&apos;;</span><br><span class=\"line\">        for(var i = 0;i &lt; this.length();i++)&#123;</span><br><span class=\"line\">            str += this.items[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var queue = new Queue();</span><br><span class=\"line\">queue.enqueue(&apos;aaa&apos;);</span><br><span class=\"line\">queue.enqueue(&apos;bbb&apos;);</span><br><span class=\"line\">console.log(queue.length());//输出2</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">console.log(queue.displayAll());//输出bbb</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n"},{"title":"【JavaScript实现算法】快速排序","date":"2016-03-22T13:13:54.000Z","_content":"快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。\n\n快速排序的算法如下:\n(1) 选择一个基准元素,将列表分隔成两个子序列;\n(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;\n(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。\n\n这个算法的JavaScript实现如下：\n```\n//工具函数：交换两个值\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    var pivot = this[start];\n    var pivotIdx = start;\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\n\n```\n测试一下快速排序的性能\n```\n// test\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort();\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:215ms\n```","source":"_posts/【JavaScript实现算法】快速排序.md","raw":"---\ntitle: 【JavaScript实现算法】快速排序\ndate: 2016-03-22 21:13:54\ntags:\n- JavaScript\n- 算法\ncategories:\n- 数据结构与算法\n---\n快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。\n\n快速排序的算法如下:\n(1) 选择一个基准元素,将列表分隔成两个子序列;\n(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;\n(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。\n\n这个算法的JavaScript实现如下：\n```\n//工具函数：交换两个值\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    var pivot = this[start];\n    var pivotIdx = start;\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\n\n```\n测试一下快速排序的性能\n```\n// test\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort();\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:215ms\n```","slug":"【JavaScript实现算法】快速排序","published":1,"updated":"2016-03-22T13:15:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3400200pk3hst20n82","content":"<p>快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。</p>\n<p>快速排序的算法如下:<br>(1) 选择一个基准元素,将列表分隔成两个子序列;<br>(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;<br>(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。</p>\n<p>这个算法的JavaScript实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//工具函数：交换两个值</span><br><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivot = this[start];</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下快速排序的性能<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// test</span><br><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort();</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:215ms</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。</p>\n<p>快速排序的算法如下:<br>(1) 选择一个基准元素,将列表分隔成两个子序列;<br>(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;<br>(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。</p>\n<p>这个算法的JavaScript实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//工具函数：交换两个值</span><br><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivot = this[start];</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下快速排序的性能<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// test</span><br><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort();</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:215ms</span><br></pre></td></tr></table></figure></p>\n"},{"title":"【译】2017 年要去学的 3 个 CSS 新属性","date":"2017-02-05T05:10:28.000Z","_content":"> * 原文地址：[3 New CSS Features to Learn in 2017](https://bitsofco.de/3-new-css-features-to-learn-in-2017/)\n* 原文作者：[ireaderinokun](https://twitter.com/ireaderinokun)\n* 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n* 译者： [熊贤仁](https://github.com/FrankXiong)\n* 校对者： [Professor-Z](https://github.com/Professor-Z) [aleen42](https://github.com/aleen42)\n\n# 2017 年要去学的 3 个 CSS 新属性\n\n## 1. 特性查询（Feature Queries）\n\n不久前，我写过一篇关于特性查询的文章 —— [《一个我十分期待的CSS特性 - the one CSS feature I really want》](https://bitsofco.de/the-one-css-feature/)。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。\n\n特性查询采用 `@supports` 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式\n```\n@supports ( display: flex ) {\n  .foo { display: flex; }\n}\n```\n另外，我们甚至可以使用像 `and` 和 `not` 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法\n```\n@supports ( display: flexbox )\n          and\n          ( not ( display: flex ) ) {\n  .foo { display: flexbox; }\n}\n```\n\n### 兼容性\n\n![](http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg)\n\n## 2. 栅格布局（Grid Layout）\n\n[CSS 栅格布局模块（CSS Grid Layout Module）](https://drafts.csswg.org/css-grid/) 定义了一个用于创建基于栅格布局的系统。它和 [弹性盒子布局模块（Flexbible Box Layout Module）](https://www.w3.org/TR/css-flexbox-1/) 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。\n\n### 显式定位元素\n\n一个栅格由栅格容器（由 `display: grid` 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。\n\n在[《CSS栅格实现圣杯布局》](https://bitsofco.de/holy-grail-layout-css-grid/)这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。\n\n![Holy Grail Layout Demo](https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif)\n\n下列 CSS 代码仅有 31 行\n\n```\n.hg__header { grid-area: header; }\n.hg__footer { grid-area: footer; }\n.hg__main { grid-area: main; }\n.hg__left { grid-area: navigation; }\n.hg__right { grid-area: ads; }\n\n.hg {\n    display: grid;\n    grid-template-areas: \"header header header\"\n                         \"navigation main ads\"\n                         \"footer footer footer\";\n    grid-template-columns: 150px 1fr 150px;\n    grid-template-rows: 100px\n                        1fr\n                        30px;\n    min-height: 100vh;\n}\n\n@media screen and (max-width: 600px) {\n    .hg {\n        grid-template-areas: \"header\"\n                             \"navigation\"\n                             \"main\"\n                             \"ads\"\n                             \"footer\";\n        grid-template-columns: 100%;\n        grid-template-rows: 100px\n                            50px\n                            1fr\n                            50px\n                            30px;\n    }\n}\n```\n\n### 弹性长度\n\nCSS 栅格模块引入了一个新的长度单位：`fr` ，用于表示栅格容器中所剩空间的占比。\n\n这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 `main` 区域占用两个边栏外的余下空间。\n```\n.hg {\n  grid-template-columns: 150px 1fr 150px;\n}\n```\n\n### 槽（Gutters）\n\n我们可以使用 `grid-row-gap`，`grid-column-gap`，和 `grid-gap` 属性来为栅格布局明确地定义槽。这些属性接受一个 [`<length-percentage>` 数据类型](https://bitsofco.de/generic-css-data-types/#percentages) 作为值，以表示内容区大小的相对百分比。\n\n比如设置一个 5% 的槽，我们可以这样写\n```\n.hg {\n  display: grid;\n  grid-column-gap: 5%;\n}\n```\n\n### 兼容性\n\nCSS 栅格模块最早将在今年三月份被浏览器们支持。\n\n![](http://i1.piimg.com/567571/229e6ea502a22d93.jpg)\n\n## 3. 原生变量（Native Variables）\n\n最后，原生 CSS 变量（[层叠变量模块（Cascading Variables Module）的自定义属性](https://drafts.csswg.org/css-variables/)）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。\n\n譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。\n\n```\n:root {\n  --theme-colour: cornflowerblue;\n}\n\nh1 { color: var(--theme-colour); }  \na { color: var(--theme-colour); }  \nstrong { color: var(--theme-colour); }\n```\n\n我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 --theme-colour 属性，我们只需要这样做\n```\nconst rootEl = document.documentElement;  \nrootEl.style.setProperty('--theme-colour','plum');\n```\n\n### 兼容性\n\n ![](http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg)\n\n\n## 关于兼容性？\n\n如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到\n\n[![JavaScript Array Methods -　Mutator](http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png)](https://player.vimeo.com/video/194815985)\n\n2017年有哪些 CSS 特性令你激动不已想要学习？\n","source":"_posts/【译】2017-年要去学的-3-个-CSS-新属性.md","raw":"---\ntitle: 【译】2017 年要去学的 3 个 CSS 新属性\ndate: 2017-02-05 13:10:28\ntags:\n- CSS\n- 翻译\ncategories:\n- 前端\n---\n> * 原文地址：[3 New CSS Features to Learn in 2017](https://bitsofco.de/3-new-css-features-to-learn-in-2017/)\n* 原文作者：[ireaderinokun](https://twitter.com/ireaderinokun)\n* 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n* 译者： [熊贤仁](https://github.com/FrankXiong)\n* 校对者： [Professor-Z](https://github.com/Professor-Z) [aleen42](https://github.com/aleen42)\n\n# 2017 年要去学的 3 个 CSS 新属性\n\n## 1. 特性查询（Feature Queries）\n\n不久前，我写过一篇关于特性查询的文章 —— [《一个我十分期待的CSS特性 - the one CSS feature I really want》](https://bitsofco.de/the-one-css-feature/)。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。\n\n特性查询采用 `@supports` 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式\n```\n@supports ( display: flex ) {\n  .foo { display: flex; }\n}\n```\n另外，我们甚至可以使用像 `and` 和 `not` 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法\n```\n@supports ( display: flexbox )\n          and\n          ( not ( display: flex ) ) {\n  .foo { display: flexbox; }\n}\n```\n\n### 兼容性\n\n![](http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg)\n\n## 2. 栅格布局（Grid Layout）\n\n[CSS 栅格布局模块（CSS Grid Layout Module）](https://drafts.csswg.org/css-grid/) 定义了一个用于创建基于栅格布局的系统。它和 [弹性盒子布局模块（Flexbible Box Layout Module）](https://www.w3.org/TR/css-flexbox-1/) 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。\n\n### 显式定位元素\n\n一个栅格由栅格容器（由 `display: grid` 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。\n\n在[《CSS栅格实现圣杯布局》](https://bitsofco.de/holy-grail-layout-css-grid/)这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。\n\n![Holy Grail Layout Demo](https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif)\n\n下列 CSS 代码仅有 31 行\n\n```\n.hg__header { grid-area: header; }\n.hg__footer { grid-area: footer; }\n.hg__main { grid-area: main; }\n.hg__left { grid-area: navigation; }\n.hg__right { grid-area: ads; }\n\n.hg {\n    display: grid;\n    grid-template-areas: \"header header header\"\n                         \"navigation main ads\"\n                         \"footer footer footer\";\n    grid-template-columns: 150px 1fr 150px;\n    grid-template-rows: 100px\n                        1fr\n                        30px;\n    min-height: 100vh;\n}\n\n@media screen and (max-width: 600px) {\n    .hg {\n        grid-template-areas: \"header\"\n                             \"navigation\"\n                             \"main\"\n                             \"ads\"\n                             \"footer\";\n        grid-template-columns: 100%;\n        grid-template-rows: 100px\n                            50px\n                            1fr\n                            50px\n                            30px;\n    }\n}\n```\n\n### 弹性长度\n\nCSS 栅格模块引入了一个新的长度单位：`fr` ，用于表示栅格容器中所剩空间的占比。\n\n这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 `main` 区域占用两个边栏外的余下空间。\n```\n.hg {\n  grid-template-columns: 150px 1fr 150px;\n}\n```\n\n### 槽（Gutters）\n\n我们可以使用 `grid-row-gap`，`grid-column-gap`，和 `grid-gap` 属性来为栅格布局明确地定义槽。这些属性接受一个 [`<length-percentage>` 数据类型](https://bitsofco.de/generic-css-data-types/#percentages) 作为值，以表示内容区大小的相对百分比。\n\n比如设置一个 5% 的槽，我们可以这样写\n```\n.hg {\n  display: grid;\n  grid-column-gap: 5%;\n}\n```\n\n### 兼容性\n\nCSS 栅格模块最早将在今年三月份被浏览器们支持。\n\n![](http://i1.piimg.com/567571/229e6ea502a22d93.jpg)\n\n## 3. 原生变量（Native Variables）\n\n最后，原生 CSS 变量（[层叠变量模块（Cascading Variables Module）的自定义属性](https://drafts.csswg.org/css-variables/)）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。\n\n譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。\n\n```\n:root {\n  --theme-colour: cornflowerblue;\n}\n\nh1 { color: var(--theme-colour); }  \na { color: var(--theme-colour); }  \nstrong { color: var(--theme-colour); }\n```\n\n我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 --theme-colour 属性，我们只需要这样做\n```\nconst rootEl = document.documentElement;  \nrootEl.style.setProperty('--theme-colour','plum');\n```\n\n### 兼容性\n\n ![](http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg)\n\n\n## 关于兼容性？\n\n如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到\n\n[![JavaScript Array Methods -　Mutator](http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png)](https://player.vimeo.com/video/194815985)\n\n2017年有哪些 CSS 特性令你激动不已想要学习？\n","slug":"【译】2017-年要去学的-3-个-CSS-新属性","published":1,"updated":"2017-03-11T18:28:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3600220pk3b8521rle","content":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://bitsofco.de/3-new-css-features-to-learn-in-2017/\" target=\"_blank\" rel=\"noopener\">3 New CSS Features to Learn in 2017</a></li>\n<li>原文作者：<a href=\"https://twitter.com/ireaderinokun\" target=\"_blank\" rel=\"noopener\">ireaderinokun</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>译者： <a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></li>\n<li>校对者： <a href=\"https://github.com/Professor-Z\" target=\"_blank\" rel=\"noopener\">Professor-Z</a> <a href=\"https://github.com/aleen42\" target=\"_blank\" rel=\"noopener\">aleen42</a></li>\n</ul>\n</blockquote>\n<h1 id=\"2017-年要去学的-3-个-CSS-新属性\"><a href=\"#2017-年要去学的-3-个-CSS-新属性\" class=\"headerlink\" title=\"2017 年要去学的 3 个 CSS 新属性\"></a>2017 年要去学的 3 个 CSS 新属性</h1><h2 id=\"1-特性查询（Feature-Queries）\"><a href=\"#1-特性查询（Feature-Queries）\" class=\"headerlink\" title=\"1. 特性查询（Feature Queries）\"></a>1. 特性查询（Feature Queries）</h2><p>不久前，我写过一篇关于特性查询的文章 —— <a href=\"https://bitsofco.de/the-one-css-feature/\" target=\"_blank\" rel=\"noopener\">《一个我十分期待的CSS特性 - the one CSS feature I really want》</a>。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。</p>\n<p>特性查询采用 <code>@supports</code> 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，我们甚至可以使用像 <code>and</code> 和 <code>not</code> 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flexbox )</span><br><span class=\"line\">          and</span><br><span class=\"line\">          ( not ( display: flex ) ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flexbox; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p><img src=\"http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg\" alt=\"\"></p>\n<h2 id=\"2-栅格布局（Grid-Layout）\"><a href=\"#2-栅格布局（Grid-Layout）\" class=\"headerlink\" title=\"2. 栅格布局（Grid Layout）\"></a>2. 栅格布局（Grid Layout）</h2><p><a href=\"https://drafts.csswg.org/css-grid/\" target=\"_blank\" rel=\"noopener\">CSS 栅格布局模块（CSS Grid Layout Module）</a> 定义了一个用于创建基于栅格布局的系统。它和 <a href=\"https://www.w3.org/TR/css-flexbox-1/\" target=\"_blank\" rel=\"noopener\">弹性盒子布局模块（Flexbible Box Layout Module）</a> 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。</p>\n<h3 id=\"显式定位元素\"><a href=\"#显式定位元素\" class=\"headerlink\" title=\"显式定位元素\"></a>显式定位元素</h3><p>一个栅格由栅格容器（由 <code>display: grid</code> 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。</p>\n<p>在<a href=\"https://bitsofco.de/holy-grail-layout-css-grid/\" target=\"_blank\" rel=\"noopener\">《CSS栅格实现圣杯布局》</a>这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。</p>\n<p><img src=\"https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif\" alt=\"Holy Grail Layout Demo\"></p>\n<p>下列 CSS 代码仅有 31 行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg__header &#123; grid-area: header; &#125;</span><br><span class=\"line\">.hg__footer &#123; grid-area: footer; &#125;</span><br><span class=\"line\">.hg__main &#123; grid-area: main; &#125;</span><br><span class=\"line\">.hg__left &#123; grid-area: navigation; &#125;</span><br><span class=\"line\">.hg__right &#123; grid-area: ads; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.hg &#123;</span><br><span class=\"line\">    display: grid;</span><br><span class=\"line\">    grid-template-areas: &quot;header header header&quot;</span><br><span class=\"line\">                         &quot;navigation main ads&quot;</span><br><span class=\"line\">                         &quot;footer footer footer&quot;;</span><br><span class=\"line\">    grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">    grid-template-rows: 100px</span><br><span class=\"line\">                        1fr</span><br><span class=\"line\">                        30px;</span><br><span class=\"line\">    min-height: 100vh;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media screen and (max-width: 600px) &#123;</span><br><span class=\"line\">    .hg &#123;</span><br><span class=\"line\">        grid-template-areas: &quot;header&quot;</span><br><span class=\"line\">                             &quot;navigation&quot;</span><br><span class=\"line\">                             &quot;main&quot;</span><br><span class=\"line\">                             &quot;ads&quot;</span><br><span class=\"line\">                             &quot;footer&quot;;</span><br><span class=\"line\">        grid-template-columns: 100%;</span><br><span class=\"line\">        grid-template-rows: 100px</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            1fr</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            30px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"弹性长度\"><a href=\"#弹性长度\" class=\"headerlink\" title=\"弹性长度\"></a>弹性长度</h3><p>CSS 栅格模块引入了一个新的长度单位：<code>fr</code> ，用于表示栅格容器中所剩空间的占比。</p>\n<p>这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 <code>main</code> 区域占用两个边栏外的余下空间。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"槽（Gutters）\"><a href=\"#槽（Gutters）\" class=\"headerlink\" title=\"槽（Gutters）\"></a>槽（Gutters）</h3><p>我们可以使用 <code>grid-row-gap</code>，<code>grid-column-gap</code>，和 <code>grid-gap</code> 属性来为栅格布局明确地定义槽。这些属性接受一个 <a href=\"https://bitsofco.de/generic-css-data-types/#percentages\" target=\"_blank\" rel=\"noopener\"><code>&lt;length-percentage&gt;</code> 数据类型</a> 作为值，以表示内容区大小的相对百分比。</p>\n<p>比如设置一个 5% 的槽，我们可以这样写<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-column-gap: 5%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-1\"><a href=\"#兼容性-1\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>CSS 栅格模块最早将在今年三月份被浏览器们支持。</p>\n<p><img src=\"http://i1.piimg.com/567571/229e6ea502a22d93.jpg\" alt=\"\"></p>\n<h2 id=\"3-原生变量（Native-Variables）\"><a href=\"#3-原生变量（Native-Variables）\" class=\"headerlink\" title=\"3. 原生变量（Native Variables）\"></a>3. 原生变量（Native Variables）</h2><p>最后，原生 CSS 变量（<a href=\"https://drafts.csswg.org/css-variables/\" target=\"_blank\" rel=\"noopener\">层叠变量模块（Cascading Variables Module）的自定义属性</a>）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。</p>\n<p>譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">  --theme-colour: cornflowerblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1 &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">a &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">strong &#123; color: var(--theme-colour); &#125;</span><br></pre></td></tr></table></figure>\n<p>我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 –theme-colour 属性，我们只需要这样做<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const rootEl = document.documentElement;  </span><br><span class=\"line\">rootEl.style.setProperty(&apos;--theme-colour&apos;,&apos;plum&apos;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-2\"><a href=\"#兼容性-2\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p> <img src=\"http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg\" alt=\"\"></p>\n<h2 id=\"关于兼容性？\"><a href=\"#关于兼容性？\" class=\"headerlink\" title=\"关于兼容性？\"></a>关于兼容性？</h2><p>如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到</p>\n<p><a href=\"https://player.vimeo.com/video/194815985\" target=\"_blank\" rel=\"noopener\"><img src=\"http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png\" alt=\"JavaScript Array Methods -　Mutator\"></a></p>\n<p>2017年有哪些 CSS 特性令你激动不已想要学习？</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://bitsofco.de/3-new-css-features-to-learn-in-2017/\" target=\"_blank\" rel=\"noopener\">3 New CSS Features to Learn in 2017</a></li>\n<li>原文作者：<a href=\"https://twitter.com/ireaderinokun\" target=\"_blank\" rel=\"noopener\">ireaderinokun</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>译者： <a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></li>\n<li>校对者： <a href=\"https://github.com/Professor-Z\" target=\"_blank\" rel=\"noopener\">Professor-Z</a> <a href=\"https://github.com/aleen42\" target=\"_blank\" rel=\"noopener\">aleen42</a></li>\n</ul>\n</blockquote>\n<h1 id=\"2017-年要去学的-3-个-CSS-新属性\"><a href=\"#2017-年要去学的-3-个-CSS-新属性\" class=\"headerlink\" title=\"2017 年要去学的 3 个 CSS 新属性\"></a>2017 年要去学的 3 个 CSS 新属性</h1><h2 id=\"1-特性查询（Feature-Queries）\"><a href=\"#1-特性查询（Feature-Queries）\" class=\"headerlink\" title=\"1. 特性查询（Feature Queries）\"></a>1. 特性查询（Feature Queries）</h2><p>不久前，我写过一篇关于特性查询的文章 —— <a href=\"https://bitsofco.de/the-one-css-feature/\" target=\"_blank\" rel=\"noopener\">《一个我十分期待的CSS特性 - the one CSS feature I really want》</a>。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。</p>\n<p>特性查询采用 <code>@supports</code> 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，我们甚至可以使用像 <code>and</code> 和 <code>not</code> 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flexbox )</span><br><span class=\"line\">          and</span><br><span class=\"line\">          ( not ( display: flex ) ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flexbox; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p><img src=\"http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg\" alt=\"\"></p>\n<h2 id=\"2-栅格布局（Grid-Layout）\"><a href=\"#2-栅格布局（Grid-Layout）\" class=\"headerlink\" title=\"2. 栅格布局（Grid Layout）\"></a>2. 栅格布局（Grid Layout）</h2><p><a href=\"https://drafts.csswg.org/css-grid/\" target=\"_blank\" rel=\"noopener\">CSS 栅格布局模块（CSS Grid Layout Module）</a> 定义了一个用于创建基于栅格布局的系统。它和 <a href=\"https://www.w3.org/TR/css-flexbox-1/\" target=\"_blank\" rel=\"noopener\">弹性盒子布局模块（Flexbible Box Layout Module）</a> 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。</p>\n<h3 id=\"显式定位元素\"><a href=\"#显式定位元素\" class=\"headerlink\" title=\"显式定位元素\"></a>显式定位元素</h3><p>一个栅格由栅格容器（由 <code>display: grid</code> 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。</p>\n<p>在<a href=\"https://bitsofco.de/holy-grail-layout-css-grid/\" target=\"_blank\" rel=\"noopener\">《CSS栅格实现圣杯布局》</a>这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。</p>\n<p><img src=\"https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif\" alt=\"Holy Grail Layout Demo\"></p>\n<p>下列 CSS 代码仅有 31 行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg__header &#123; grid-area: header; &#125;</span><br><span class=\"line\">.hg__footer &#123; grid-area: footer; &#125;</span><br><span class=\"line\">.hg__main &#123; grid-area: main; &#125;</span><br><span class=\"line\">.hg__left &#123; grid-area: navigation; &#125;</span><br><span class=\"line\">.hg__right &#123; grid-area: ads; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.hg &#123;</span><br><span class=\"line\">    display: grid;</span><br><span class=\"line\">    grid-template-areas: &quot;header header header&quot;</span><br><span class=\"line\">                         &quot;navigation main ads&quot;</span><br><span class=\"line\">                         &quot;footer footer footer&quot;;</span><br><span class=\"line\">    grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">    grid-template-rows: 100px</span><br><span class=\"line\">                        1fr</span><br><span class=\"line\">                        30px;</span><br><span class=\"line\">    min-height: 100vh;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media screen and (max-width: 600px) &#123;</span><br><span class=\"line\">    .hg &#123;</span><br><span class=\"line\">        grid-template-areas: &quot;header&quot;</span><br><span class=\"line\">                             &quot;navigation&quot;</span><br><span class=\"line\">                             &quot;main&quot;</span><br><span class=\"line\">                             &quot;ads&quot;</span><br><span class=\"line\">                             &quot;footer&quot;;</span><br><span class=\"line\">        grid-template-columns: 100%;</span><br><span class=\"line\">        grid-template-rows: 100px</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            1fr</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            30px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"弹性长度\"><a href=\"#弹性长度\" class=\"headerlink\" title=\"弹性长度\"></a>弹性长度</h3><p>CSS 栅格模块引入了一个新的长度单位：<code>fr</code> ，用于表示栅格容器中所剩空间的占比。</p>\n<p>这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 <code>main</code> 区域占用两个边栏外的余下空间。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"槽（Gutters）\"><a href=\"#槽（Gutters）\" class=\"headerlink\" title=\"槽（Gutters）\"></a>槽（Gutters）</h3><p>我们可以使用 <code>grid-row-gap</code>，<code>grid-column-gap</code>，和 <code>grid-gap</code> 属性来为栅格布局明确地定义槽。这些属性接受一个 <a href=\"https://bitsofco.de/generic-css-data-types/#percentages\" target=\"_blank\" rel=\"noopener\"><code>&lt;length-percentage&gt;</code> 数据类型</a> 作为值，以表示内容区大小的相对百分比。</p>\n<p>比如设置一个 5% 的槽，我们可以这样写<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-column-gap: 5%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-1\"><a href=\"#兼容性-1\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>CSS 栅格模块最早将在今年三月份被浏览器们支持。</p>\n<p><img src=\"http://i1.piimg.com/567571/229e6ea502a22d93.jpg\" alt=\"\"></p>\n<h2 id=\"3-原生变量（Native-Variables）\"><a href=\"#3-原生变量（Native-Variables）\" class=\"headerlink\" title=\"3. 原生变量（Native Variables）\"></a>3. 原生变量（Native Variables）</h2><p>最后，原生 CSS 变量（<a href=\"https://drafts.csswg.org/css-variables/\" target=\"_blank\" rel=\"noopener\">层叠变量模块（Cascading Variables Module）的自定义属性</a>）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。</p>\n<p>譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">  --theme-colour: cornflowerblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1 &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">a &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">strong &#123; color: var(--theme-colour); &#125;</span><br></pre></td></tr></table></figure>\n<p>我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 –theme-colour 属性，我们只需要这样做<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const rootEl = document.documentElement;  </span><br><span class=\"line\">rootEl.style.setProperty(&apos;--theme-colour&apos;,&apos;plum&apos;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-2\"><a href=\"#兼容性-2\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p> <img src=\"http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg\" alt=\"\"></p>\n<h2 id=\"关于兼容性？\"><a href=\"#关于兼容性？\" class=\"headerlink\" title=\"关于兼容性？\"></a>关于兼容性？</h2><p>如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到</p>\n<p><a href=\"https://player.vimeo.com/video/194815985\" target=\"_blank\" rel=\"noopener\"><img src=\"http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png\" alt=\"JavaScript Array Methods -　Mutator\"></a></p>\n<p>2017年有哪些 CSS 特性令你激动不已想要学习？</p>\n"},{"title":"【译】HLS架构简介","date":"2017-03-11T18:03:01.000Z","_content":"\n> - 原文：[HTTP Streaming Architecture](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html)\n- 译者：[熊贤仁](http://frankxiong.xyz)\n\n### 前言\n作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   \n\n### 概览\n在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。\n\nHLS 由三部分组成：服务器、分发组件（distribution component）和客户端。\n\n服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。\n\n分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。\n\n客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。\n\n在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。\n\n举个简单例子用于说明HTTP 流的配置\n\n![图1-1 基本配置](http://upload-images.jianshu.io/upload_images/192464-85b661e237015e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。\n\n只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。\n\n分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。\n\n### 服务器\n服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。\n\n**媒体编码器（Media Encoder）**\n\n媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。\n\n编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。[Audio Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2) 和 [Video Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6) 列出了支持的压缩格式。\n> 重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 **EXT-X-DISCONTINUITY** 标签\n\n**流分段器（Stream Segmenter）**\n\n流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。\n\n流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。\n\n媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。\n\n**文件分段器（File Segmenter）**\n\n如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。\n\n### 媒体段文件（Media Segment Files）\n媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。\n\n### 索引文件（播放列表）\n 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。\n> 注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。\n\n关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。\n```\n#EXT-X-VERSION:3\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:1\n\n# Old-style integer duration; avoid for newer clients.\n#EXTINF:10,\nhttp://media.example.com/segment0.ts\n\n# New-style floating-point duration; use for modern clients.\n#EXTINF:10.0,\nhttp://media.example.com/segment1.ts\n#EXTINF:9.5,\nhttp://media.example.com/segment2.ts\n#EXT-X-ENDLIST\n```\n当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。\n> 当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见[Media File Segmenter](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7)\n\n索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  [HTTP Live Streaming specification](http://tools.ietf.org/html/draft-pantos-http-live-streaming) 部分。\n\n索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。\n\n### 分发组件（Distribution Components）\n分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。\n\n更详细介绍见 [Deploying HTTP Live Streaming](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3)。\n\n### 客户端\n客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。\n\n客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。\n\n这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。\n","source":"_posts/【译】HLS架构简介.md","raw":"---\ntitle: 【译】HLS架构简介\ndate: 2017-03-12 02:03:01\ntags:\n- 直播\n- 翻译\ncategories:\n- 后端\n---\n\n> - 原文：[HTTP Streaming Architecture](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html)\n- 译者：[熊贤仁](http://frankxiong.xyz)\n\n### 前言\n作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   \n\n### 概览\n在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。\n\nHLS 由三部分组成：服务器、分发组件（distribution component）和客户端。\n\n服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。\n\n分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。\n\n客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。\n\n在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。\n\n举个简单例子用于说明HTTP 流的配置\n\n![图1-1 基本配置](http://upload-images.jianshu.io/upload_images/192464-85b661e237015e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。\n\n只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。\n\n分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。\n\n### 服务器\n服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。\n\n**媒体编码器（Media Encoder）**\n\n媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。\n\n编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。[Audio Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2) 和 [Video Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6) 列出了支持的压缩格式。\n> 重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 **EXT-X-DISCONTINUITY** 标签\n\n**流分段器（Stream Segmenter）**\n\n流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。\n\n流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。\n\n媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。\n\n**文件分段器（File Segmenter）**\n\n如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。\n\n### 媒体段文件（Media Segment Files）\n媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。\n\n### 索引文件（播放列表）\n 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。\n> 注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。\n\n关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。\n```\n#EXT-X-VERSION:3\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:1\n\n# Old-style integer duration; avoid for newer clients.\n#EXTINF:10,\nhttp://media.example.com/segment0.ts\n\n# New-style floating-point duration; use for modern clients.\n#EXTINF:10.0,\nhttp://media.example.com/segment1.ts\n#EXTINF:9.5,\nhttp://media.example.com/segment2.ts\n#EXT-X-ENDLIST\n```\n当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。\n> 当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见[Media File Segmenter](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7)\n\n索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  [HTTP Live Streaming specification](http://tools.ietf.org/html/draft-pantos-http-live-streaming) 部分。\n\n索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。\n\n### 分发组件（Distribution Components）\n分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。\n\n更详细介绍见 [Deploying HTTP Live Streaming](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3)。\n\n### 客户端\n客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。\n\n客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。\n\n这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。\n","slug":"【译】HLS架构简介","published":1,"updated":"2017-03-11T18:32:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3700250pk335rfcpgc","content":"<blockquote>\n<ul>\n<li>原文：<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html\" target=\"_blank\" rel=\"noopener\">HTTP Streaming Architecture</a></li>\n<li>译者：<a href=\"http://frankxiong.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></li>\n</ul>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   </p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。</p>\n<p>HLS 由三部分组成：服务器、分发组件（distribution component）和客户端。</p>\n<p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p>\n<p>分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。</p>\n<p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。</p>\n<p>在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。</p>\n<p>举个简单例子用于说明HTTP 流的配置</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-85b661e237015e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1-1 基本配置\"></p>\n<p>输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。</p>\n<p>只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。</p>\n<p>分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。</p>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。</p>\n<p><strong>媒体编码器（Media Encoder）</strong></p>\n<p>媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。</p>\n<p>编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。<a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2\" target=\"_blank\" rel=\"noopener\">Audio Technologies</a> 和 <a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6\" target=\"_blank\" rel=\"noopener\">Video Technologies</a> 列出了支持的压缩格式。</p>\n<blockquote>\n<p>重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 <strong>EXT-X-DISCONTINUITY</strong> 标签</p>\n</blockquote>\n<p><strong>流分段器（Stream Segmenter）</strong></p>\n<p>流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。</p>\n<p>流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。</p>\n<p>媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。</p>\n<p><strong>文件分段器（File Segmenter）</strong></p>\n<p>如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。</p>\n<h3 id=\"媒体段文件（Media-Segment-Files）\"><a href=\"#媒体段文件（Media-Segment-Files）\" class=\"headerlink\" title=\"媒体段文件（Media Segment Files）\"></a>媒体段文件（Media Segment Files）</h3><p>媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。</p>\n<h3 id=\"索引文件（播放列表）\"><a href=\"#索引文件（播放列表）\" class=\"headerlink\" title=\"索引文件（播放列表）\"></a>索引文件（播放列表）</h3><p> 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。</p>\n<blockquote>\n<p>注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。</p>\n</blockquote>\n<p>关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#EXT-X-VERSION:3</span><br><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-TARGETDURATION:10</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:1</span><br><span class=\"line\"></span><br><span class=\"line\"># Old-style integer duration; avoid for newer clients.</span><br><span class=\"line\">#EXTINF:10,</span><br><span class=\"line\">http://media.example.com/segment0.ts</span><br><span class=\"line\"></span><br><span class=\"line\"># New-style floating-point duration; use for modern clients.</span><br><span class=\"line\">#EXTINF:10.0,</span><br><span class=\"line\">http://media.example.com/segment1.ts</span><br><span class=\"line\">#EXTINF:9.5,</span><br><span class=\"line\">http://media.example.com/segment2.ts</span><br><span class=\"line\">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure></p>\n<p>当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。</p>\n<blockquote>\n<p>当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7\" target=\"_blank\" rel=\"noopener\">Media File Segmenter</a></p>\n</blockquote>\n<p>索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  <a href=\"http://tools.ietf.org/html/draft-pantos-http-live-streaming\" target=\"_blank\" rel=\"noopener\">HTTP Live Streaming specification</a> 部分。</p>\n<p>索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。</p>\n<h3 id=\"分发组件（Distribution-Components）\"><a href=\"#分发组件（Distribution-Components）\" class=\"headerlink\" title=\"分发组件（Distribution Components）\"></a>分发组件（Distribution Components）</h3><p>分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。</p>\n<p>更详细介绍见 <a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3\" target=\"_blank\" rel=\"noopener\">Deploying HTTP Live Streaming</a>。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。</p>\n<p>客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。</p>\n<p>这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>原文：<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html\" target=\"_blank\" rel=\"noopener\">HTTP Streaming Architecture</a></li>\n<li>译者：<a href=\"http://frankxiong.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></li>\n</ul>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   </p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。</p>\n<p>HLS 由三部分组成：服务器、分发组件（distribution component）和客户端。</p>\n<p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p>\n<p>分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。</p>\n<p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。</p>\n<p>在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。</p>\n<p>举个简单例子用于说明HTTP 流的配置</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-85b661e237015e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1-1 基本配置\"></p>\n<p>输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。</p>\n<p>只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。</p>\n<p>分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。</p>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。</p>\n<p><strong>媒体编码器（Media Encoder）</strong></p>\n<p>媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。</p>\n<p>编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。<a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2\" target=\"_blank\" rel=\"noopener\">Audio Technologies</a> 和 <a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6\" target=\"_blank\" rel=\"noopener\">Video Technologies</a> 列出了支持的压缩格式。</p>\n<blockquote>\n<p>重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 <strong>EXT-X-DISCONTINUITY</strong> 标签</p>\n</blockquote>\n<p><strong>流分段器（Stream Segmenter）</strong></p>\n<p>流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。</p>\n<p>流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。</p>\n<p>媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。</p>\n<p><strong>文件分段器（File Segmenter）</strong></p>\n<p>如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。</p>\n<h3 id=\"媒体段文件（Media-Segment-Files）\"><a href=\"#媒体段文件（Media-Segment-Files）\" class=\"headerlink\" title=\"媒体段文件（Media Segment Files）\"></a>媒体段文件（Media Segment Files）</h3><p>媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。</p>\n<h3 id=\"索引文件（播放列表）\"><a href=\"#索引文件（播放列表）\" class=\"headerlink\" title=\"索引文件（播放列表）\"></a>索引文件（播放列表）</h3><p> 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。</p>\n<blockquote>\n<p>注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。</p>\n</blockquote>\n<p>关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#EXT-X-VERSION:3</span><br><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-TARGETDURATION:10</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:1</span><br><span class=\"line\"></span><br><span class=\"line\"># Old-style integer duration; avoid for newer clients.</span><br><span class=\"line\">#EXTINF:10,</span><br><span class=\"line\">http://media.example.com/segment0.ts</span><br><span class=\"line\"></span><br><span class=\"line\"># New-style floating-point duration; use for modern clients.</span><br><span class=\"line\">#EXTINF:10.0,</span><br><span class=\"line\">http://media.example.com/segment1.ts</span><br><span class=\"line\">#EXTINF:9.5,</span><br><span class=\"line\">http://media.example.com/segment2.ts</span><br><span class=\"line\">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure></p>\n<p>当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。</p>\n<blockquote>\n<p>当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7\" target=\"_blank\" rel=\"noopener\">Media File Segmenter</a></p>\n</blockquote>\n<p>索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  <a href=\"http://tools.ietf.org/html/draft-pantos-http-live-streaming\" target=\"_blank\" rel=\"noopener\">HTTP Live Streaming specification</a> 部分。</p>\n<p>索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。</p>\n<h3 id=\"分发组件（Distribution-Components）\"><a href=\"#分发组件（Distribution-Components）\" class=\"headerlink\" title=\"分发组件（Distribution Components）\"></a>分发组件（Distribution Components）</h3><p>分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。</p>\n<p>更详细介绍见 <a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3\" target=\"_blank\" rel=\"noopener\">Deploying HTTP Live Streaming</a>。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。</p>\n<p>客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。</p>\n<p>这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。</p>\n"},{"title":"【译】为什么Vue.js不支持templateURL?","date":"2016-08-02T17:48:42.000Z","_content":"　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用`templateURL`吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。\n在Angular中，`templateURL`或者`ng-include`允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。\n<!-- more -->\n　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。\n　　其次，由于`templateURL`通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在`$templateCache`中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。\n　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以`<script type=\"x/template\">`的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 [Webpack](http://webpack.github.io/)或者[Browserify](http://browserify.org/)之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始**在单个文件中写Vue组件**时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。\n　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。\n　　**以组件的方式去思考，而不是模板。**\n\n---------\n作者：尤雨溪\n原文地址：http://cn.vuejs.org/2015/10/28/why-no-template-url/\n译者：[熊贤仁](http://voidman.xyz)\n","source":"_posts/【译】为什么Vue-js不支持templateURL.md","raw":"---\ntitle: 【译】为什么Vue.js不支持templateURL?\ndate: 2016-08-03 01:48:42\ntags:\n- JavaScript\n- Vue\n- 翻译\ncategories:\n- 前端\n---\n　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用`templateURL`吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。\n在Angular中，`templateURL`或者`ng-include`允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。\n<!-- more -->\n　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。\n　　其次，由于`templateURL`通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在`$templateCache`中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。\n　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以`<script type=\"x/template\">`的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 [Webpack](http://webpack.github.io/)或者[Browserify](http://browserify.org/)之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始**在单个文件中写Vue组件**时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。\n　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。\n　　**以组件的方式去思考，而不是模板。**\n\n---------\n作者：尤雨溪\n原文地址：http://cn.vuejs.org/2015/10/28/why-no-template-url/\n译者：[熊贤仁](http://voidman.xyz)\n","slug":"【译】为什么Vue-js不支持templateURL","published":1,"updated":"2017-02-05T05:12:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3900290pk3axfq8bhl","content":"<p>　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用<code>templateURL</code>吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。<br>在Angular中，<code>templateURL</code>或者<code>ng-include</code>允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。<br><a id=\"more\"></a><br>　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。<br>　　其次，由于<code>templateURL</code>通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在<code>$templateCache</code>中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。<br>　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以<code>&lt;script type=&quot;x/template&quot;&gt;</code>的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener\">Webpack</a>或者<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始<strong>在单个文件中写Vue组件</strong>时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。<br>　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。<br>　　<strong>以组件的方式去思考，而不是模板。</strong></p>\n<hr>\n<p>作者：尤雨溪<br>原文地址：<a href=\"http://cn.vuejs.org/2015/10/28/why-no-template-url/\" target=\"_blank\" rel=\"noopener\">http://cn.vuejs.org/2015/10/28/why-no-template-url/</a><br>译者：<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n","site":{"data":{}},"excerpt":"<p>　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用<code>templateURL</code>吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。<br>在Angular中，<code>templateURL</code>或者<code>ng-include</code>允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。<br>","more":"<br>　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。<br>　　其次，由于<code>templateURL</code>通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在<code>$templateCache</code>中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。<br>　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以<code>&lt;script type=&quot;x/template&quot;&gt;</code>的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener\">Webpack</a>或者<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始<strong>在单个文件中写Vue组件</strong>时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。<br>　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。<br>　　<strong>以组件的方式去思考，而不是模板。</strong></p>\n<hr>\n<p>作者：尤雨溪<br>原文地址：<a href=\"http://cn.vuejs.org/2015/10/28/why-no-template-url/\" target=\"_blank\" rel=\"noopener\">http://cn.vuejs.org/2015/10/28/why-no-template-url/</a><br>译者：<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>"},{"title":"【译】异步：现在与将来（并行篇）","date":"2017-03-31T16:15:40.000Z","_content":"### 并行线程\n人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。\n\n进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。\n\n相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。\n\n并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。\n\n比如：\n```\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n```\n虽然 `later()` 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，`answer = answer * 2` 要先加载 `answer` 的当前值，接着把 `2` 放在某处，然后做乘法计算，然后取出结果，并把结果存回 `answer` 中。\n\n在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为\n线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。\n\n考虑：\n```\nvar a = 20;\n\nfunction foo() {\n\ta = a + 1;\n}\n\nfunction bar() {\n\ta = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n鉴于 JavaScript 的单线程特性，如果 `foo()` 在 `bar()` 之前运行， `a` 计算的结果为 `42`，但如果 `bar()` 在 `foo()`之前运行，`a` 的结果将是 `41`。\n\n如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， `foo()` 和 `bar()` 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。\n\n线程 1 （`X` 和 `Y` 是临时内存地址）\n```\nfoo():\n  a. load value of `a` in `X`\n  b. store `1` in `Y`\n  c. add `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n线程 2 （`X` 和 `Y` 是临时内存地址）\n```\nbar():\n  a. load value of `a` in `X`\n  b. store `2` in `Y`\n  c. multiply `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 `X` 和 `Y` 。\n\n如果上述步骤是这样的， `a` 的最终结果又是什么呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n1b  (store `1` in `Y`   ==> `1`)\n2b  (store `2` in `Y`   ==> `2`)\n1c  (add `X` and `Y`, store result in `X`   ==> `22`)\n1d  (store value of `X` in `a`   ==> `22`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `44`)\n2d  (store value of `X` in `a`   ==> `44`)\n```\n`a` 的结果将是 44。那这样排列呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n2b  (store `2` in `Y`   ==> `2`)\n1b  (store `1` in `Y`   ==> `1`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `20`)\n1c  (add `X` and `Y`, store result in `X`   ==> `21`)\n1d  (store value of `X` in `a`   ==> `21`)\n2d  (store value of `X` in `a`   ==> `21`)\n```\n`a` 的结果将是 21。\n\n所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。\n\nJavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？`foo()` 和 `bar()` 的相对排列顺序导致了不同的结果（41 或 42）。\n\n**注意**： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。\n\n### 完整运行\n由于 JavaScript 的单线程特性，`foo()` 和 `bar()` 内部的代码是原子的，这意味着一旦 `foo()` 开始运行，必须要等到这段代码全部执行完毕， `bar()` 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。\n\n事实上，如果 `foo()` 和 `bar()` 包含更多的代码，完整运行的语义会更清晰，比如：\n```\nvar a = 1;\nvar b = 2;\n\nfunction foo() {\n\ta++;\n\tb = b * a;\n\ta = b + 3;\n}\n\nfunction bar() {\n\tb--;\n\ta = 8 + b;\n\tb = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n因为 `foo()` 不能被 `bar()` 中断，`bar()` 也不能被 `foo()` 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 `foo()` 和 `bar()` 中的语句可以交替运行的话，可能输出结果的数量将大大增加！\n\n块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。\n\n块 1：\n```\nvar a = 1;\nvar b = 2;\n```\n块 2（`foo()`）：\n```\na++;\nb = b * a;\na = b + 3;\n```\n块 3（`bar()`）：\n```\nb--;\na = 8 + b;\nb = a * 2;\n```\n块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：\n\n输出 1：\n```\nvar a = 1;\nvar b = 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\na; // 11\nb; // 22\n```\n输出 2：\n```\nvar a = 1;\nvar b = 2;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\na; // 183\nb; // 180\n```\n同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。\n\n在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。\n\n**注意：** 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！\n\n---------\n本系列下一部分将介绍 “并发”\n","source":"_posts/【译】异步：现在与将来（并行篇）.md","raw":"---\ntitle: '【译】异步：现在与将来（并行篇）'\ndate: 2017-04-01 00:15:40\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n### 并行线程\n人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。\n\n进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。\n\n相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。\n\n并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。\n\n比如：\n```\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n```\n虽然 `later()` 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，`answer = answer * 2` 要先加载 `answer` 的当前值，接着把 `2` 放在某处，然后做乘法计算，然后取出结果，并把结果存回 `answer` 中。\n\n在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为\n线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。\n\n考虑：\n```\nvar a = 20;\n\nfunction foo() {\n\ta = a + 1;\n}\n\nfunction bar() {\n\ta = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n鉴于 JavaScript 的单线程特性，如果 `foo()` 在 `bar()` 之前运行， `a` 计算的结果为 `42`，但如果 `bar()` 在 `foo()`之前运行，`a` 的结果将是 `41`。\n\n如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， `foo()` 和 `bar()` 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。\n\n线程 1 （`X` 和 `Y` 是临时内存地址）\n```\nfoo():\n  a. load value of `a` in `X`\n  b. store `1` in `Y`\n  c. add `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n线程 2 （`X` 和 `Y` 是临时内存地址）\n```\nbar():\n  a. load value of `a` in `X`\n  b. store `2` in `Y`\n  c. multiply `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 `X` 和 `Y` 。\n\n如果上述步骤是这样的， `a` 的最终结果又是什么呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n1b  (store `1` in `Y`   ==> `1`)\n2b  (store `2` in `Y`   ==> `2`)\n1c  (add `X` and `Y`, store result in `X`   ==> `22`)\n1d  (store value of `X` in `a`   ==> `22`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `44`)\n2d  (store value of `X` in `a`   ==> `44`)\n```\n`a` 的结果将是 44。那这样排列呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n2b  (store `2` in `Y`   ==> `2`)\n1b  (store `1` in `Y`   ==> `1`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `20`)\n1c  (add `X` and `Y`, store result in `X`   ==> `21`)\n1d  (store value of `X` in `a`   ==> `21`)\n2d  (store value of `X` in `a`   ==> `21`)\n```\n`a` 的结果将是 21。\n\n所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。\n\nJavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？`foo()` 和 `bar()` 的相对排列顺序导致了不同的结果（41 或 42）。\n\n**注意**： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。\n\n### 完整运行\n由于 JavaScript 的单线程特性，`foo()` 和 `bar()` 内部的代码是原子的，这意味着一旦 `foo()` 开始运行，必须要等到这段代码全部执行完毕， `bar()` 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。\n\n事实上，如果 `foo()` 和 `bar()` 包含更多的代码，完整运行的语义会更清晰，比如：\n```\nvar a = 1;\nvar b = 2;\n\nfunction foo() {\n\ta++;\n\tb = b * a;\n\ta = b + 3;\n}\n\nfunction bar() {\n\tb--;\n\ta = 8 + b;\n\tb = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n因为 `foo()` 不能被 `bar()` 中断，`bar()` 也不能被 `foo()` 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 `foo()` 和 `bar()` 中的语句可以交替运行的话，可能输出结果的数量将大大增加！\n\n块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。\n\n块 1：\n```\nvar a = 1;\nvar b = 2;\n```\n块 2（`foo()`）：\n```\na++;\nb = b * a;\na = b + 3;\n```\n块 3（`bar()`）：\n```\nb--;\na = 8 + b;\nb = a * 2;\n```\n块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：\n\n输出 1：\n```\nvar a = 1;\nvar b = 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\na; // 11\nb; // 22\n```\n输出 2：\n```\nvar a = 1;\nvar b = 2;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\na; // 183\nb; // 180\n```\n同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。\n\n在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。\n\n**注意：** 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！\n\n---------\n本系列下一部分将介绍 “并发”\n","slug":"【译】异步：现在与将来（并行篇）","published":1,"updated":"2017-04-05T08:46:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3a002d0pk3qpprwtq6","content":"<h3 id=\"并行线程\"><a href=\"#并行线程\" class=\"headerlink\" title=\"并行线程\"></a>并行线程</h3><p>人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。</p>\n<p>进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。</p>\n<p>相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。</p>\n<p>并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。</p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然 <code>later()</code> 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，<code>answer = answer * 2</code> 要先加载 <code>answer</code> 的当前值，接着把 <code>2</code> 放在某处，然后做乘法计算，然后取出结果，并把结果存回 <code>answer</code> 中。</p>\n<p>在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为<br>线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。</p>\n<p>考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta = a + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\ta = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>鉴于 JavaScript 的单线程特性，如果 <code>foo()</code> 在 <code>bar()</code> 之前运行， <code>a</code> 计算的结果为 <code>42</code>，但如果 <code>bar()</code> 在 <code>foo()</code>之前运行，<code>a</code> 的结果将是 <code>41</code>。</p>\n<p>如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， <code>foo()</code> 和 <code>bar()</code> 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。</p>\n<p>线程 1 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `1` in `Y`</span><br><span class=\"line\">  c. add `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>线程 2 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bar():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `2` in `Y`</span><br><span class=\"line\">  c. multiply `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 <code>X</code> 和 <code>Y</code> 。</p>\n<p>如果上述步骤是这样的， <code>a</code> 的最终结果又是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `22`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `22`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `44`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `44`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 44。那这样排列呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `20`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `21`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `21`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `21`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 21。</p>\n<p>所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。</p>\n<p>JavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？<code>foo()</code> 和 <code>bar()</code> 的相对排列顺序导致了不同的结果（41 或 42）。</p>\n<p><strong>注意</strong>： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。</p>\n<h3 id=\"完整运行\"><a href=\"#完整运行\" class=\"headerlink\" title=\"完整运行\"></a>完整运行</h3><p>由于 JavaScript 的单线程特性，<code>foo()</code> 和 <code>bar()</code> 内部的代码是原子的，这意味着一旦 <code>foo()</code> 开始运行，必须要等到这段代码全部执行完毕， <code>bar()</code> 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。</p>\n<p>事实上，如果 <code>foo()</code> 和 <code>bar()</code> 包含更多的代码，完整运行的语义会更清晰，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta++;</span><br><span class=\"line\">\tb = b * a;</span><br><span class=\"line\">\ta = b + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\tb--;</span><br><span class=\"line\">\ta = 8 + b;</span><br><span class=\"line\">\tb = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>因为 <code>foo()</code> 不能被 <code>bar()</code> 中断，<code>bar()</code> 也不能被 <code>foo()</code> 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 <code>foo()</code> 和 <code>bar()</code> 中的语句可以交替运行的话，可能输出结果的数量将大大增加！</p>\n<p>块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。</p>\n<p>块 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2（<code>foo()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br></pre></td></tr></table></figure></p>\n<p>块 3（<code>bar()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：</p>\n<p>输出 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 11</span><br><span class=\"line\">b; // 22</span><br></pre></td></tr></table></figure></p>\n<p>输出 2：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 183</span><br><span class=\"line\">b; // 180</span><br></pre></td></tr></table></figure></p>\n<p>同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。</p>\n<p>在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。</p>\n<p><strong>注意：</strong> 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！</p>\n<hr>\n<p>本系列下一部分将介绍 “并发”</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"并行线程\"><a href=\"#并行线程\" class=\"headerlink\" title=\"并行线程\"></a>并行线程</h3><p>人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。</p>\n<p>进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。</p>\n<p>相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。</p>\n<p>并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。</p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然 <code>later()</code> 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，<code>answer = answer * 2</code> 要先加载 <code>answer</code> 的当前值，接着把 <code>2</code> 放在某处，然后做乘法计算，然后取出结果，并把结果存回 <code>answer</code> 中。</p>\n<p>在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为<br>线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。</p>\n<p>考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta = a + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\ta = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>鉴于 JavaScript 的单线程特性，如果 <code>foo()</code> 在 <code>bar()</code> 之前运行， <code>a</code> 计算的结果为 <code>42</code>，但如果 <code>bar()</code> 在 <code>foo()</code>之前运行，<code>a</code> 的结果将是 <code>41</code>。</p>\n<p>如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， <code>foo()</code> 和 <code>bar()</code> 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。</p>\n<p>线程 1 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `1` in `Y`</span><br><span class=\"line\">  c. add `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>线程 2 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bar():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `2` in `Y`</span><br><span class=\"line\">  c. multiply `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 <code>X</code> 和 <code>Y</code> 。</p>\n<p>如果上述步骤是这样的， <code>a</code> 的最终结果又是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `22`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `22`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `44`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `44`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 44。那这样排列呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `20`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `21`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `21`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `21`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 21。</p>\n<p>所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。</p>\n<p>JavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？<code>foo()</code> 和 <code>bar()</code> 的相对排列顺序导致了不同的结果（41 或 42）。</p>\n<p><strong>注意</strong>： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。</p>\n<h3 id=\"完整运行\"><a href=\"#完整运行\" class=\"headerlink\" title=\"完整运行\"></a>完整运行</h3><p>由于 JavaScript 的单线程特性，<code>foo()</code> 和 <code>bar()</code> 内部的代码是原子的，这意味着一旦 <code>foo()</code> 开始运行，必须要等到这段代码全部执行完毕， <code>bar()</code> 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。</p>\n<p>事实上，如果 <code>foo()</code> 和 <code>bar()</code> 包含更多的代码，完整运行的语义会更清晰，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta++;</span><br><span class=\"line\">\tb = b * a;</span><br><span class=\"line\">\ta = b + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\tb--;</span><br><span class=\"line\">\ta = 8 + b;</span><br><span class=\"line\">\tb = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>因为 <code>foo()</code> 不能被 <code>bar()</code> 中断，<code>bar()</code> 也不能被 <code>foo()</code> 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 <code>foo()</code> 和 <code>bar()</code> 中的语句可以交替运行的话，可能输出结果的数量将大大增加！</p>\n<p>块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。</p>\n<p>块 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2（<code>foo()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br></pre></td></tr></table></figure></p>\n<p>块 3（<code>bar()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：</p>\n<p>输出 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 11</span><br><span class=\"line\">b; // 22</span><br></pre></td></tr></table></figure></p>\n<p>输出 2：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 183</span><br><span class=\"line\">b; // 180</span><br></pre></td></tr></table></figure></p>\n<p>同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。</p>\n<p>在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。</p>\n<p><strong>注意：</strong> 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！</p>\n<hr>\n<p>本系列下一部分将介绍 “并发”</p>\n"},{"title":"【译】异步：现在与将来（基础篇）","date":"2017-03-31T16:10:03.000Z","_content":"> 原文：https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\n译者：[熊贤仁](https://github.com/FrankXiong)\n\n使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。\n\n这不仅是 ` for ` 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。\n\n几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。\n\n事实上，程序中现在和将来的关系是异步编程的核心。\n\n毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。\n\n但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。\n\n刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种\n JavaScript 异步编程的技巧。\n\n但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。\n\n### 分块的程序 ###\n\n你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 `function`。\n\n大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。\n\n考虑这个例子：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\nvar data = ajax( \"http://some.url.1\" );\n\nconsole.log( data );\n// Oops! `data` generally won't have the Ajax results\n```\n你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 `ajax(..)` 函数现在还没有任何可以赋给 `data` 变量的返回值。如果 `ajax(..)` 可以在返回响应之前一直阻塞，那么 `data = .. ` 赋值将正常运行。\n\n但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。\n\n从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", function myCallbackFunction(data){\n\n\tconsole.log( data ); // Yay, I gots me some `data`!\n\n} );\n```\n**警告：** 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。\n\n你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。\n\n举个例子，考虑下列代码：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n\nvar answer = now();\n\nsetTimeout( later, 1000 ); // Meaning of life: 42\n```\n这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：\n现在：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() { .. }\n\nvar answer = now();\n\nsetTimeout( later, 1000 );\n```\n将来：\n```\nanswer = answer * 2;\nconsole.log( \"Meaning of life:\", answer );\n```\n现在这一块在程序运行后立刻执行。但是 `setTimeout(...)` 还设置了一个在将来执行的事件（定时），所以 `later()` 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。\n\n任何时候将一部分代码包裹进 `function` ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。\n\n### 异步控制台 ###\n关于 `console.*` 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。\n\n因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。\n\n特别是，在某些条件下，一些浏览器的 `console.log(...)` 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 `console` I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。\n\n一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：\n```\nvar a = {\n\tindex: 1\n};\n\n// later\nconsole.log( a ); // ??\n\n// even later\na.index++;\n```\n我们通常会认为 `a` 对象在 `console.log(...)` 语句执行的时候生成了快照，打印出像 `{ like: 1}` 这样的内容，然后当 `a.index++` 执行， 对其进行了修改，这句会严格的在输出  `a` 之后才执行。\n\n多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，`a.index++` 已经执行过了，因此会输出 `{ index: 2}`。\n\n究竟何时 `console` I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 `console.log(...)` 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。\n\n**注意：** 如果你遇到这种特殊情况，不要依赖 `console` 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 `JSON.stringify(...)`。\n\n### 事件循环 ###\n我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。\n\n什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。\n\n“需要”。谁需要？这就是重点所在！\n\nJS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。\n\n但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。\n\n换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。\n\n举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。\n\n浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。\n\n那么什么是事件循环？\n\n我们首先通过一些伪代码来说明：\n```\n// `eventLoop` is an array that acts as a queue (first-in, first-out)\nvar eventLoop = [ ];\nvar event;\n\n// keep going \"forever\"\nwhile (true) {\n\t// perform a \"tick\"\n\tif (eventLoop.length > 0) {\n\t\t// get the next event in the queue\n\t\tevent = eventLoop.shift();\n\n\t\t// now, execute the next event\n\t\ttry {\n\t\t\tevent();\n\t\t}\n\t\tcatch (err) {\n\t\t\treportError(err);\n\t\t}\n\t}\n}\n```\n当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。\n\n正如你所看到的，`while` 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。\n\n需要注意的是，`setTimeout(..)` 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。\n\n如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 `setTimeout(..)` 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。\n\n换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。\n\n**注意：** 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 `setTimeout(..0)` 的讨论 ）。\n\n------\n本系列下一部分将介绍并行线程。\n","source":"_posts/【译】异步：现在与将来（基础篇）.md","raw":"---\ntitle: 【译】异步：现在与将来（基础篇）\ndate: 2017-04-01 00:10:03\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n> 原文：https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\n译者：[熊贤仁](https://github.com/FrankXiong)\n\n使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。\n\n这不仅是 ` for ` 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。\n\n几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。\n\n事实上，程序中现在和将来的关系是异步编程的核心。\n\n毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。\n\n但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。\n\n刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种\n JavaScript 异步编程的技巧。\n\n但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。\n\n### 分块的程序 ###\n\n你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 `function`。\n\n大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。\n\n考虑这个例子：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\nvar data = ajax( \"http://some.url.1\" );\n\nconsole.log( data );\n// Oops! `data` generally won't have the Ajax results\n```\n你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 `ajax(..)` 函数现在还没有任何可以赋给 `data` 变量的返回值。如果 `ajax(..)` 可以在返回响应之前一直阻塞，那么 `data = .. ` 赋值将正常运行。\n\n但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。\n\n从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", function myCallbackFunction(data){\n\n\tconsole.log( data ); // Yay, I gots me some `data`!\n\n} );\n```\n**警告：** 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。\n\n你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。\n\n举个例子，考虑下列代码：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n\nvar answer = now();\n\nsetTimeout( later, 1000 ); // Meaning of life: 42\n```\n这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：\n现在：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() { .. }\n\nvar answer = now();\n\nsetTimeout( later, 1000 );\n```\n将来：\n```\nanswer = answer * 2;\nconsole.log( \"Meaning of life:\", answer );\n```\n现在这一块在程序运行后立刻执行。但是 `setTimeout(...)` 还设置了一个在将来执行的事件（定时），所以 `later()` 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。\n\n任何时候将一部分代码包裹进 `function` ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。\n\n### 异步控制台 ###\n关于 `console.*` 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。\n\n因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。\n\n特别是，在某些条件下，一些浏览器的 `console.log(...)` 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 `console` I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。\n\n一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：\n```\nvar a = {\n\tindex: 1\n};\n\n// later\nconsole.log( a ); // ??\n\n// even later\na.index++;\n```\n我们通常会认为 `a` 对象在 `console.log(...)` 语句执行的时候生成了快照，打印出像 `{ like: 1}` 这样的内容，然后当 `a.index++` 执行， 对其进行了修改，这句会严格的在输出  `a` 之后才执行。\n\n多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，`a.index++` 已经执行过了，因此会输出 `{ index: 2}`。\n\n究竟何时 `console` I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 `console.log(...)` 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。\n\n**注意：** 如果你遇到这种特殊情况，不要依赖 `console` 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 `JSON.stringify(...)`。\n\n### 事件循环 ###\n我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。\n\n什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。\n\n“需要”。谁需要？这就是重点所在！\n\nJS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。\n\n但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。\n\n换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。\n\n举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。\n\n浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。\n\n那么什么是事件循环？\n\n我们首先通过一些伪代码来说明：\n```\n// `eventLoop` is an array that acts as a queue (first-in, first-out)\nvar eventLoop = [ ];\nvar event;\n\n// keep going \"forever\"\nwhile (true) {\n\t// perform a \"tick\"\n\tif (eventLoop.length > 0) {\n\t\t// get the next event in the queue\n\t\tevent = eventLoop.shift();\n\n\t\t// now, execute the next event\n\t\ttry {\n\t\t\tevent();\n\t\t}\n\t\tcatch (err) {\n\t\t\treportError(err);\n\t\t}\n\t}\n}\n```\n当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。\n\n正如你所看到的，`while` 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。\n\n需要注意的是，`setTimeout(..)` 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。\n\n如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 `setTimeout(..)` 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。\n\n换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。\n\n**注意：** 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 `setTimeout(..0)` 的讨论 ）。\n\n------\n本系列下一部分将介绍并行线程。\n","slug":"【译】异步：现在与将来（基础篇）","published":1,"updated":"2017-04-05T08:47:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3c002h0pk35uxm177e","content":"<blockquote>\n<p>原文：<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md</a><br>译者：<a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n</blockquote>\n<p>使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。</p>\n<p>这不仅是 <code>for</code> 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。</p>\n<p>几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。</p>\n<p>事实上，程序中现在和将来的关系是异步编程的核心。</p>\n<p>毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。</p>\n<p>但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。</p>\n<p>刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种<br> JavaScript 异步编程的技巧。</p>\n<p>但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。</p>\n<h3 id=\"分块的程序\"><a href=\"#分块的程序\" class=\"headerlink\" title=\"分块的程序\"></a>分块的程序</h3><p>你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 <code>function</code>。</p>\n<p>大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。</p>\n<p>考虑这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">var data = ajax( &quot;http://some.url.1&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( data );</span><br><span class=\"line\">// Oops! `data` generally won&apos;t have the Ajax results</span><br></pre></td></tr></table></figure></p>\n<p>你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 <code>ajax(..)</code> 函数现在还没有任何可以赋给 <code>data</code> 变量的返回值。如果 <code>ajax(..)</code> 可以在返回响应之前一直阻塞，那么 <code>data = ..</code> 赋值将正常运行。</p>\n<p>但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。</p>\n<p>从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, function myCallbackFunction(data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log( data ); // Yay, I gots me some `data`!</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure></p>\n<p><strong>警告：</strong> 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。</p>\n<p>你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。</p>\n<p>举个例子，考虑下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 ); // Meaning of life: 42</span><br></pre></td></tr></table></figure></p>\n<p>这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：<br>现在：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123; .. &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 );</span><br></pre></td></tr></table></figure></p>\n<p>将来：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">answer = answer * 2;</span><br><span class=\"line\">console.log( &quot;Meaning of life:&quot;, answer );</span><br></pre></td></tr></table></figure></p>\n<p>现在这一块在程序运行后立刻执行。但是 <code>setTimeout(...)</code> 还设置了一个在将来执行的事件（定时），所以 <code>later()</code> 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。</p>\n<p>任何时候将一部分代码包裹进 <code>function</code> ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。</p>\n<h3 id=\"异步控制台\"><a href=\"#异步控制台\" class=\"headerlink\" title=\"异步控制台\"></a>异步控制台</h3><p>关于 <code>console.*</code> 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。</p>\n<p>因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。</p>\n<p>特别是，在某些条件下，一些浏览器的 <code>console.log(...)</code> 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 <code>console</code> I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。</p>\n<p>一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">\tindex: 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// later</span><br><span class=\"line\">console.log( a ); // ??</span><br><span class=\"line\"></span><br><span class=\"line\">// even later</span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></figure></p>\n<p>我们通常会认为 <code>a</code> 对象在 <code>console.log(...)</code> 语句执行的时候生成了快照，打印出像 <code>{ like: 1}</code> 这样的内容，然后当 <code>a.index++</code> 执行， 对其进行了修改，这句会严格的在输出  <code>a</code> 之后才执行。</p>\n<p>多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，<code>a.index++</code> 已经执行过了，因此会输出 <code>{ index: 2}</code>。</p>\n<p>究竟何时 <code>console</code> I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 <code>console.log(...)</code> 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。</p>\n<p><strong>注意：</strong> 如果你遇到这种特殊情况，不要依赖 <code>console</code> 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 <code>JSON.stringify(...)</code>。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。</p>\n<p>什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。</p>\n<p>“需要”。谁需要？这就是重点所在！</p>\n<p>JS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。</p>\n<p>但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。</p>\n<p>换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。</p>\n<p>举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。</p>\n<p>浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。</p>\n<p>那么什么是事件循环？</p>\n<p>我们首先通过一些伪代码来说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// `eventLoop` is an array that acts as a queue (first-in, first-out)</span><br><span class=\"line\">var eventLoop = [ ];</span><br><span class=\"line\">var event;</span><br><span class=\"line\"></span><br><span class=\"line\">// keep going &quot;forever&quot;</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">\t// perform a &quot;tick&quot;</span><br><span class=\"line\">\tif (eventLoop.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// get the next event in the queue</span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// now, execute the next event</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。</p>\n<p>正如你所看到的，<code>while</code> 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。</p>\n<p>需要注意的是，<code>setTimeout(..)</code> 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。</p>\n<p>如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 <code>setTimeout(..)</code> 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。</p>\n<p>换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。</p>\n<p><strong>注意：</strong> 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 <code>setTimeout(..0)</code> 的讨论 ）。</p>\n<hr>\n<p>本系列下一部分将介绍并行线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md</a><br>译者：<a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n</blockquote>\n<p>使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。</p>\n<p>这不仅是 <code>for</code> 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。</p>\n<p>几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。</p>\n<p>事实上，程序中现在和将来的关系是异步编程的核心。</p>\n<p>毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。</p>\n<p>但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。</p>\n<p>刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种<br> JavaScript 异步编程的技巧。</p>\n<p>但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。</p>\n<h3 id=\"分块的程序\"><a href=\"#分块的程序\" class=\"headerlink\" title=\"分块的程序\"></a>分块的程序</h3><p>你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 <code>function</code>。</p>\n<p>大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。</p>\n<p>考虑这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">var data = ajax( &quot;http://some.url.1&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( data );</span><br><span class=\"line\">// Oops! `data` generally won&apos;t have the Ajax results</span><br></pre></td></tr></table></figure></p>\n<p>你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 <code>ajax(..)</code> 函数现在还没有任何可以赋给 <code>data</code> 变量的返回值。如果 <code>ajax(..)</code> 可以在返回响应之前一直阻塞，那么 <code>data = ..</code> 赋值将正常运行。</p>\n<p>但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。</p>\n<p>从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, function myCallbackFunction(data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log( data ); // Yay, I gots me some `data`!</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure></p>\n<p><strong>警告：</strong> 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。</p>\n<p>你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。</p>\n<p>举个例子，考虑下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 ); // Meaning of life: 42</span><br></pre></td></tr></table></figure></p>\n<p>这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：<br>现在：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123; .. &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 );</span><br></pre></td></tr></table></figure></p>\n<p>将来：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">answer = answer * 2;</span><br><span class=\"line\">console.log( &quot;Meaning of life:&quot;, answer );</span><br></pre></td></tr></table></figure></p>\n<p>现在这一块在程序运行后立刻执行。但是 <code>setTimeout(...)</code> 还设置了一个在将来执行的事件（定时），所以 <code>later()</code> 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。</p>\n<p>任何时候将一部分代码包裹进 <code>function</code> ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。</p>\n<h3 id=\"异步控制台\"><a href=\"#异步控制台\" class=\"headerlink\" title=\"异步控制台\"></a>异步控制台</h3><p>关于 <code>console.*</code> 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。</p>\n<p>因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。</p>\n<p>特别是，在某些条件下，一些浏览器的 <code>console.log(...)</code> 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 <code>console</code> I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。</p>\n<p>一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">\tindex: 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// later</span><br><span class=\"line\">console.log( a ); // ??</span><br><span class=\"line\"></span><br><span class=\"line\">// even later</span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></figure></p>\n<p>我们通常会认为 <code>a</code> 对象在 <code>console.log(...)</code> 语句执行的时候生成了快照，打印出像 <code>{ like: 1}</code> 这样的内容，然后当 <code>a.index++</code> 执行， 对其进行了修改，这句会严格的在输出  <code>a</code> 之后才执行。</p>\n<p>多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，<code>a.index++</code> 已经执行过了，因此会输出 <code>{ index: 2}</code>。</p>\n<p>究竟何时 <code>console</code> I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 <code>console.log(...)</code> 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。</p>\n<p><strong>注意：</strong> 如果你遇到这种特殊情况，不要依赖 <code>console</code> 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 <code>JSON.stringify(...)</code>。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。</p>\n<p>什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。</p>\n<p>“需要”。谁需要？这就是重点所在！</p>\n<p>JS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。</p>\n<p>但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。</p>\n<p>换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。</p>\n<p>举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。</p>\n<p>浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。</p>\n<p>那么什么是事件循环？</p>\n<p>我们首先通过一些伪代码来说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// `eventLoop` is an array that acts as a queue (first-in, first-out)</span><br><span class=\"line\">var eventLoop = [ ];</span><br><span class=\"line\">var event;</span><br><span class=\"line\"></span><br><span class=\"line\">// keep going &quot;forever&quot;</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">\t// perform a &quot;tick&quot;</span><br><span class=\"line\">\tif (eventLoop.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// get the next event in the queue</span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// now, execute the next event</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。</p>\n<p>正如你所看到的，<code>while</code> 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。</p>\n<p>需要注意的是，<code>setTimeout(..)</code> 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。</p>\n<p>如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 <code>setTimeout(..)</code> 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。</p>\n<p>换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。</p>\n<p><strong>注意：</strong> 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 <code>setTimeout(..0)</code> 的讨论 ）。</p>\n<hr>\n<p>本系列下一部分将介绍并行线程。</p>\n"},{"title":"【译】异步：现在与将来（并发篇）","date":"2017-04-05T08:45:33.000Z","_content":"> 原文： https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\n译者：[熊贤仁](http://frankxiong.xyz)\n\n让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。\n\n**注意：** 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。\n\n当用户向下滚动页面后，第一个 “进程” 会响应 `onscroll` 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。\n\n显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 `onscroll` 事件被触发。因此你将得到快速触发并交错执行的`onscroll` 事件和 Ajax 响应事件。\n\n并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。\n\n**注意：** 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。\n\n对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：\n\n“进程” 1（`onscroll` 事件）:\n```\nonscroll, request 1\nonscroll, request 2\nonscroll, request 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nonscroll, request 7\n```\n“进程” 2（Ajax 响应事件）：\n```\nresponse 1\nresponse 2\nresponse 3\nresponse 4\nresponse 5\nresponse 6\nresponse 7\n```\n`onscroll` 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：\n```\nonscroll, request 1\nonscroll, request 2          response 1\nonscroll, request 3          response 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6          response 4\nonscroll, request 7\nresponse 6\nresponse 5\nresponse 7\n```\n但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，`onscroll` 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。\n\n我们设想所有这些事件在事件循环队列中交替执行。\n事件循环队列：\n```\nonscroll, request 1 <--- Process 1 starts\nonscroll, request 2\nresponse 1 <--- Process 2 starts\nonscroll, request 3\nresponse 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nresponse 4\nonscroll, request 7 <--- Process 1 finishes\nresponse 6\nresponse 5\nresponse 7 <--- Process 2 finishes\n```\n\n“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。\n\n顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？\n\n基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。\n\n### 非交互\n\n当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。**如果它们没有交互，程序的不确定性将相当低。**\n\n比如：\n```\nvar res = {};\n\nfunction foo(results) {\n\tres.foo = results;\n}\n\nfunction bar(results) {\n\tres.bar = results;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n\n`foo()` 和 `bar()` 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。\n\n这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。\n\n### 交互\n\n更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。\n\n这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序**有时会被破坏**：\n```\nvar res = [];\n\nfunction response(data) {\n\tres.push( data );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n并发 “进程” 是两个用于处理 Ajax 响应而调用的 `response()` 方法。它们任意一个都可以先执行。\n\n我们假设期待的行为是，`res[0]` 存放调用 `\"http://some.url.1\"` 的结果，`res[1]`存放调用 `\"http://some.url.2\"` 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。\n\n**注意：**  你要对这些情况保持极度警惕。比如，开发者如果观察到响应\n `\"http://some.url.2\"` **总是** 比 `\"http://some.url.1\"` 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。\n\n为了处理这种竞态条件，你可以调整交互顺序：\n```\nvar res = [];\n\nfunction response(data) {\n\tif (data.url == \"http://some.url.1\") {\n\t\tres[0] = data;\n\t}\n\telse if (data.url == \"http://some.url.2\") {\n\t\tres[1] = data;\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n无论先返回哪个 Ajax 响应，我们都要通过检查 `data.url` （当然，假设其中一个返回自服务器）来确定响应数据应该放在 `res` 数组的哪个位置。 `res[0]` 总是保存 `\"http://some.url.1\"` 返回的结果，`res[1]` 总是保存 `\"http://some.url.2\"` 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。\n\n如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 `<div>` 的内容，另一个更新 `<div>` 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。\n\n若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log(a + b);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n在这个例子中，不管是  `foo()` 还是 `bar()` 先执行，总是会造成 `baz()` 过早执行（`a` 和 `b` 都还是 `unfined`），但 `baz()` 的第二次调用会正常工作，因为 `a` 和 `b` 都已被初始化了。\n\n有多种方法可以处理此类情况。这里有一个简单的办法：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a + b );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n包裹着 `baz()` 调用的 `if (a && b)` 条件语句通常被称为一个 “门”，因为不确定 `a` 和`b` 的到达顺序，我们要在开门之前（调用 `baz()`）等待这两者的到达。\n\n另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。\n\n考虑这段有问题的代码：\n```\nvar a;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(x) {\n\ta = x / 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n无论哪个（`foo()` 或者 `bar()`）先执行，不仅 `a` 的赋值会被另一个覆盖，而且还会重复调用 `baz()` （很可能并不希望这样）。\n\n所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：\n```\nvar a;\n\nfunction foo(x) {\n\tif (a == undefined) {\n\t\ta = x * 2;\n\t\tbaz();\n\t}\n}\n\nfunction bar(x) {\n\tif (a == undefined) {\n\t\ta = x / 2;\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n`if (a == undefined)` 条件只会让 `foo()` 和 `bar()` 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！\n\n**注意：** 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。\n\n### 协作\n协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。\n\n举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 `Array.map(..)` 来简化代码：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `data` values doubled\n\t\tdata.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n如果 `\"http://some.url.1\"` 先得到返回结果，整个列表立即会被 map 进 `res`。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。\n\n当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(...) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。\n\n所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。\n\n这里有个很简单的方法：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// let's just do 1000 at a time\n\tvar chunk = data.splice( 0, 1000 );\n\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `chunk` values doubled\n\t\tchunk.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n\n\t// anything left to process?\n\tif (data.length > 0) {\n\t\t// async schedule next batch\n\t\tsetTimeout( function(){\n\t\t\tresponse( data );\n\t\t}, 0 );\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。\n\n当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 `res` 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。\n\n为了实现异步调度，我们使用了 `setTimeout(..0)`（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。\n\n**注意：** 严格来说，`setTimeout(..0)` 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 `setTimeout(..0)` 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 `process.nextTick(..)`。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。\n","source":"_posts/【译】异步：现在与将来（并发篇）.md","raw":"---\ntitle: 【译】异步：现在与将来（并发篇）\ndate: 2017-04-05 16:45:33\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n> 原文： https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\n译者：[熊贤仁](http://frankxiong.xyz)\n\n让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。\n\n**注意：** 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。\n\n当用户向下滚动页面后，第一个 “进程” 会响应 `onscroll` 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。\n\n显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 `onscroll` 事件被触发。因此你将得到快速触发并交错执行的`onscroll` 事件和 Ajax 响应事件。\n\n并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。\n\n**注意：** 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。\n\n对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：\n\n“进程” 1（`onscroll` 事件）:\n```\nonscroll, request 1\nonscroll, request 2\nonscroll, request 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nonscroll, request 7\n```\n“进程” 2（Ajax 响应事件）：\n```\nresponse 1\nresponse 2\nresponse 3\nresponse 4\nresponse 5\nresponse 6\nresponse 7\n```\n`onscroll` 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：\n```\nonscroll, request 1\nonscroll, request 2          response 1\nonscroll, request 3          response 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6          response 4\nonscroll, request 7\nresponse 6\nresponse 5\nresponse 7\n```\n但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，`onscroll` 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。\n\n我们设想所有这些事件在事件循环队列中交替执行。\n事件循环队列：\n```\nonscroll, request 1 <--- Process 1 starts\nonscroll, request 2\nresponse 1 <--- Process 2 starts\nonscroll, request 3\nresponse 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nresponse 4\nonscroll, request 7 <--- Process 1 finishes\nresponse 6\nresponse 5\nresponse 7 <--- Process 2 finishes\n```\n\n“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。\n\n顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？\n\n基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。\n\n### 非交互\n\n当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。**如果它们没有交互，程序的不确定性将相当低。**\n\n比如：\n```\nvar res = {};\n\nfunction foo(results) {\n\tres.foo = results;\n}\n\nfunction bar(results) {\n\tres.bar = results;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n\n`foo()` 和 `bar()` 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。\n\n这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。\n\n### 交互\n\n更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。\n\n这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序**有时会被破坏**：\n```\nvar res = [];\n\nfunction response(data) {\n\tres.push( data );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n并发 “进程” 是两个用于处理 Ajax 响应而调用的 `response()` 方法。它们任意一个都可以先执行。\n\n我们假设期待的行为是，`res[0]` 存放调用 `\"http://some.url.1\"` 的结果，`res[1]`存放调用 `\"http://some.url.2\"` 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。\n\n**注意：**  你要对这些情况保持极度警惕。比如，开发者如果观察到响应\n `\"http://some.url.2\"` **总是** 比 `\"http://some.url.1\"` 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。\n\n为了处理这种竞态条件，你可以调整交互顺序：\n```\nvar res = [];\n\nfunction response(data) {\n\tif (data.url == \"http://some.url.1\") {\n\t\tres[0] = data;\n\t}\n\telse if (data.url == \"http://some.url.2\") {\n\t\tres[1] = data;\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n无论先返回哪个 Ajax 响应，我们都要通过检查 `data.url` （当然，假设其中一个返回自服务器）来确定响应数据应该放在 `res` 数组的哪个位置。 `res[0]` 总是保存 `\"http://some.url.1\"` 返回的结果，`res[1]` 总是保存 `\"http://some.url.2\"` 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。\n\n如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 `<div>` 的内容，另一个更新 `<div>` 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。\n\n若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log(a + b);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n在这个例子中，不管是  `foo()` 还是 `bar()` 先执行，总是会造成 `baz()` 过早执行（`a` 和 `b` 都还是 `unfined`），但 `baz()` 的第二次调用会正常工作，因为 `a` 和 `b` 都已被初始化了。\n\n有多种方法可以处理此类情况。这里有一个简单的办法：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a + b );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n包裹着 `baz()` 调用的 `if (a && b)` 条件语句通常被称为一个 “门”，因为不确定 `a` 和`b` 的到达顺序，我们要在开门之前（调用 `baz()`）等待这两者的到达。\n\n另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。\n\n考虑这段有问题的代码：\n```\nvar a;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(x) {\n\ta = x / 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n无论哪个（`foo()` 或者 `bar()`）先执行，不仅 `a` 的赋值会被另一个覆盖，而且还会重复调用 `baz()` （很可能并不希望这样）。\n\n所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：\n```\nvar a;\n\nfunction foo(x) {\n\tif (a == undefined) {\n\t\ta = x * 2;\n\t\tbaz();\n\t}\n}\n\nfunction bar(x) {\n\tif (a == undefined) {\n\t\ta = x / 2;\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n`if (a == undefined)` 条件只会让 `foo()` 和 `bar()` 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！\n\n**注意：** 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。\n\n### 协作\n协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。\n\n举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 `Array.map(..)` 来简化代码：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `data` values doubled\n\t\tdata.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n如果 `\"http://some.url.1\"` 先得到返回结果，整个列表立即会被 map 进 `res`。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。\n\n当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(...) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。\n\n所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。\n\n这里有个很简单的方法：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// let's just do 1000 at a time\n\tvar chunk = data.splice( 0, 1000 );\n\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `chunk` values doubled\n\t\tchunk.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n\n\t// anything left to process?\n\tif (data.length > 0) {\n\t\t// async schedule next batch\n\t\tsetTimeout( function(){\n\t\t\tresponse( data );\n\t\t}, 0 );\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。\n\n当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 `res` 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。\n\n为了实现异步调度，我们使用了 `setTimeout(..0)`（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。\n\n**注意：** 严格来说，`setTimeout(..0)` 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 `setTimeout(..0)` 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 `process.nextTick(..)`。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。\n","slug":"【译】异步：现在与将来（并发篇）","published":1,"updated":"2017-04-05T08:55:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3e002k0pk31nwg4f2c","content":"<blockquote>\n<p>原文： <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency</a><br>译者：<a href=\"http://frankxiong.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n</blockquote>\n<p>让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。</p>\n<p><strong>注意：</strong> 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。</p>\n<p>当用户向下滚动页面后，第一个 “进程” 会响应 <code>onscroll</code> 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。</p>\n<p>显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 <code>onscroll</code> 事件被触发。因此你将得到快速触发并交错执行的<code>onscroll</code> 事件和 Ajax 响应事件。</p>\n<p>并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。</p>\n<p><strong>注意：</strong> 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。</p>\n<p>对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：</p>\n<p>“进程” 1（<code>onscroll</code> 事件）:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">onscroll, request 7</span><br></pre></td></tr></table></figure></p>\n<p>“进程” 2（Ajax 响应事件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">response 1</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">response 4</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p><code>onscroll</code> 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2          response 1</span><br><span class=\"line\">onscroll, request 3          response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6          response 4</span><br><span class=\"line\">onscroll, request 7</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p>但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，<code>onscroll</code> 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。</p>\n<p>我们设想所有这些事件在事件循环队列中交替执行。<br>事件循环队列：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1 &lt;--- Process 1 starts</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">response 1 &lt;--- Process 2 starts</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">response 4</span><br><span class=\"line\">onscroll, request 7 &lt;--- Process 1 finishes</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7 &lt;--- Process 2 finishes</span><br></pre></td></tr></table></figure></p>\n<p>“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。</p>\n<p>顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？</p>\n<p>基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。</p>\n<h3 id=\"非交互\"><a href=\"#非交互\" class=\"headerlink\" title=\"非交互\"></a>非交互</h3><p>当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。<strong>如果它们没有交互，程序的不确定性将相当低。</strong></p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(results) &#123;</span><br><span class=\"line\">\tres.foo = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(results) &#123;</span><br><span class=\"line\">\tres.bar = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>foo()</code> 和 <code>bar()</code> 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。</p>\n<p>这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。</p>\n<h3 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h3><p>更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。</p>\n<p>这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序<strong>有时会被破坏</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tres.push( data );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>并发 “进程” 是两个用于处理 Ajax 响应而调用的 <code>response()</code> 方法。它们任意一个都可以先执行。</p>\n<p>我们假设期待的行为是，<code>res[0]</code> 存放调用 <code>&quot;http://some.url.1&quot;</code> 的结果，<code>res[1]</code>存放调用 <code>&quot;http://some.url.2&quot;</code> 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。</p>\n<p><strong>注意：</strong>  你要对这些情况保持极度警惕。比如，开发者如果观察到响应<br> <code>&quot;http://some.url.2&quot;</code> <strong>总是</strong> 比 <code>&quot;http://some.url.1&quot;</code> 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。</p>\n<p>为了处理这种竞态条件，你可以调整交互顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tif (data.url == &quot;http://some.url.1&quot;) &#123;</span><br><span class=\"line\">\t\tres[0] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if (data.url == &quot;http://some.url.2&quot;) &#123;</span><br><span class=\"line\">\t\tres[1] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>无论先返回哪个 Ajax 响应，我们都要通过检查 <code>data.url</code> （当然，假设其中一个返回自服务器）来确定响应数据应该放在 <code>res</code> 数组的哪个位置。 <code>res[0]</code> 总是保存 <code>&quot;http://some.url.1&quot;</code> 返回的结果，<code>res[1]</code> 总是保存 <code>&quot;http://some.url.2&quot;</code> 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。</p>\n<p>如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 <code>&lt;div&gt;</code> 的内容，另一个更新 <code>&lt;div&gt;</code> 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。</p>\n<p>若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log(a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，不管是  <code>foo()</code> 还是 <code>bar()</code> 先执行，总是会造成 <code>baz()</code> 过早执行（<code>a</code> 和 <code>b</code> 都还是 <code>unfined</code>），但 <code>baz()</code> 的第二次调用会正常工作，因为 <code>a</code> 和 <code>b</code> 都已被初始化了。</p>\n<p>有多种方法可以处理此类情况。这里有一个简单的办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>包裹着 <code>baz()</code> 调用的 <code>if (a &amp;&amp; b)</code> 条件语句通常被称为一个 “门”，因为不确定 <code>a</code> 和<code>b</code> 的到达顺序，我们要在开门之前（调用 <code>baz()</code>）等待这两者的到达。</p>\n<p>另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。</p>\n<p>考虑这段有问题的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\ta = x / 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>无论哪个（<code>foo()</code> 或者 <code>bar()</code>）先执行，不仅 <code>a</code> 的赋值会被另一个覆盖，而且还会重复调用 <code>baz()</code> （很可能并不希望这样）。</p>\n<p>所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x * 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x / 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>if (a == undefined)</code> 条件只会让 <code>foo()</code> 和 <code>bar()</code> 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！</p>\n<p><strong>注意：</strong> 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。</p>\n<h3 id=\"协作\"><a href=\"#协作\" class=\"headerlink\" title=\"协作\"></a>协作</h3><p>协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。</p>\n<p>举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 <code>Array.map(..)</code> 来简化代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `data` values doubled</span><br><span class=\"line\">\t\tdata.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>&quot;http://some.url.1&quot;</code> 先得到返回结果，整个列表立即会被 map 进 <code>res</code>。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。</p>\n<p>当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(…) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。</p>\n<p>所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。</p>\n<p>这里有个很简单的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// let&apos;s just do 1000 at a time</span><br><span class=\"line\">\tvar chunk = data.splice( 0, 1000 );</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `chunk` values doubled</span><br><span class=\"line\">\t\tchunk.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// anything left to process?</span><br><span class=\"line\">\tif (data.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// async schedule next batch</span><br><span class=\"line\">\t\tsetTimeout( function()&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, 0 );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。</p>\n<p>当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 <code>res</code> 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。</p>\n<p>为了实现异步调度，我们使用了 <code>setTimeout(..0)</code>（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。</p>\n<p><strong>注意：</strong> 严格来说，<code>setTimeout(..0)</code> 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 <code>setTimeout(..0)</code> 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 <code>process.nextTick(..)</code>。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文： <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency</a><br>译者：<a href=\"http://frankxiong.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n</blockquote>\n<p>让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。</p>\n<p><strong>注意：</strong> 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。</p>\n<p>当用户向下滚动页面后，第一个 “进程” 会响应 <code>onscroll</code> 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。</p>\n<p>显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 <code>onscroll</code> 事件被触发。因此你将得到快速触发并交错执行的<code>onscroll</code> 事件和 Ajax 响应事件。</p>\n<p>并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。</p>\n<p><strong>注意：</strong> 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。</p>\n<p>对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：</p>\n<p>“进程” 1（<code>onscroll</code> 事件）:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">onscroll, request 7</span><br></pre></td></tr></table></figure></p>\n<p>“进程” 2（Ajax 响应事件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">response 1</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">response 4</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p><code>onscroll</code> 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2          response 1</span><br><span class=\"line\">onscroll, request 3          response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6          response 4</span><br><span class=\"line\">onscroll, request 7</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p>但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，<code>onscroll</code> 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。</p>\n<p>我们设想所有这些事件在事件循环队列中交替执行。<br>事件循环队列：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1 &lt;--- Process 1 starts</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">response 1 &lt;--- Process 2 starts</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">response 4</span><br><span class=\"line\">onscroll, request 7 &lt;--- Process 1 finishes</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7 &lt;--- Process 2 finishes</span><br></pre></td></tr></table></figure></p>\n<p>“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。</p>\n<p>顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？</p>\n<p>基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。</p>\n<h3 id=\"非交互\"><a href=\"#非交互\" class=\"headerlink\" title=\"非交互\"></a>非交互</h3><p>当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。<strong>如果它们没有交互，程序的不确定性将相当低。</strong></p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(results) &#123;</span><br><span class=\"line\">\tres.foo = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(results) &#123;</span><br><span class=\"line\">\tres.bar = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>foo()</code> 和 <code>bar()</code> 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。</p>\n<p>这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。</p>\n<h3 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h3><p>更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。</p>\n<p>这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序<strong>有时会被破坏</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tres.push( data );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>并发 “进程” 是两个用于处理 Ajax 响应而调用的 <code>response()</code> 方法。它们任意一个都可以先执行。</p>\n<p>我们假设期待的行为是，<code>res[0]</code> 存放调用 <code>&quot;http://some.url.1&quot;</code> 的结果，<code>res[1]</code>存放调用 <code>&quot;http://some.url.2&quot;</code> 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。</p>\n<p><strong>注意：</strong>  你要对这些情况保持极度警惕。比如，开发者如果观察到响应<br> <code>&quot;http://some.url.2&quot;</code> <strong>总是</strong> 比 <code>&quot;http://some.url.1&quot;</code> 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。</p>\n<p>为了处理这种竞态条件，你可以调整交互顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tif (data.url == &quot;http://some.url.1&quot;) &#123;</span><br><span class=\"line\">\t\tres[0] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if (data.url == &quot;http://some.url.2&quot;) &#123;</span><br><span class=\"line\">\t\tres[1] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>无论先返回哪个 Ajax 响应，我们都要通过检查 <code>data.url</code> （当然，假设其中一个返回自服务器）来确定响应数据应该放在 <code>res</code> 数组的哪个位置。 <code>res[0]</code> 总是保存 <code>&quot;http://some.url.1&quot;</code> 返回的结果，<code>res[1]</code> 总是保存 <code>&quot;http://some.url.2&quot;</code> 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。</p>\n<p>如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 <code>&lt;div&gt;</code> 的内容，另一个更新 <code>&lt;div&gt;</code> 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。</p>\n<p>若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log(a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，不管是  <code>foo()</code> 还是 <code>bar()</code> 先执行，总是会造成 <code>baz()</code> 过早执行（<code>a</code> 和 <code>b</code> 都还是 <code>unfined</code>），但 <code>baz()</code> 的第二次调用会正常工作，因为 <code>a</code> 和 <code>b</code> 都已被初始化了。</p>\n<p>有多种方法可以处理此类情况。这里有一个简单的办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>包裹着 <code>baz()</code> 调用的 <code>if (a &amp;&amp; b)</code> 条件语句通常被称为一个 “门”，因为不确定 <code>a</code> 和<code>b</code> 的到达顺序，我们要在开门之前（调用 <code>baz()</code>）等待这两者的到达。</p>\n<p>另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。</p>\n<p>考虑这段有问题的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\ta = x / 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>无论哪个（<code>foo()</code> 或者 <code>bar()</code>）先执行，不仅 <code>a</code> 的赋值会被另一个覆盖，而且还会重复调用 <code>baz()</code> （很可能并不希望这样）。</p>\n<p>所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x * 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x / 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>if (a == undefined)</code> 条件只会让 <code>foo()</code> 和 <code>bar()</code> 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！</p>\n<p><strong>注意：</strong> 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。</p>\n<h3 id=\"协作\"><a href=\"#协作\" class=\"headerlink\" title=\"协作\"></a>协作</h3><p>协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。</p>\n<p>举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 <code>Array.map(..)</code> 来简化代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `data` values doubled</span><br><span class=\"line\">\t\tdata.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>&quot;http://some.url.1&quot;</code> 先得到返回结果，整个列表立即会被 map 进 <code>res</code>。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。</p>\n<p>当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(…) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。</p>\n<p>所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。</p>\n<p>这里有个很简单的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// let&apos;s just do 1000 at a time</span><br><span class=\"line\">\tvar chunk = data.splice( 0, 1000 );</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `chunk` values doubled</span><br><span class=\"line\">\t\tchunk.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// anything left to process?</span><br><span class=\"line\">\tif (data.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// async schedule next batch</span><br><span class=\"line\">\t\tsetTimeout( function()&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, 0 );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。</p>\n<p>当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 <code>res</code> 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。</p>\n<p>为了实现异步调度，我们使用了 <code>setTimeout(..0)</code>（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。</p>\n<p><strong>注意：</strong> 严格来说，<code>setTimeout(..0)</code> 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 <code>setTimeout(..0)</code> 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 <code>process.nextTick(..)</code>。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。</p>\n"},{"title":"【译】真实的Virtual DOM","date":"2016-09-08T09:51:03.000Z","_content":"###### 为什么我们需要UI框架？\n　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。\n　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。\n　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。\n<!-- more -->\n###### 什么让React与众不同？\n　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。\n　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。\n###### DOM很慢？\n　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。\n　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。\n那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。\n###### Virtual DOM如何工作？\n　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。\n　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：\n**1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。**\n**2. 重新计算比较出新的和之前的Virtual DOM的差异。**\n**3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。**\n\n###### Virtual DOM慢吗？\n　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。\n　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。\n　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。\n　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。\n　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。\n###### 我们来看一些数字\n　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。\n　举个使用原生JS操作DOM的“Hello，world！”的例子：\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello JavaScript!</title>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    document.getElementById(\"example\").innerHTML = \"<h1>Hello, world!</h1>\";\n  </script>\n</body>\n</html>\n```\n　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\" />\n<title>Hello React!</title>\n<script src=\"build/react.js\"></script>\n<script src=\"build/react-dom.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script type=\"text/babel\">\n    ReactDOM.render(\n      <h1>Hello, world!</h1>,    \n      document.getElementById('example')\n    );\n  </script>\n</body>\n</html>\n```\n原生操作DOM总是会更快。我们来看一下证明过程。\n这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）\n\n![原生DOM操作](http://upload-images.jianshu.io/upload_images/192464-47f148936b3b9e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这是加载和渲染React“Hello，World”页面的timeline（chrome）\n\n![React DOM操作](http://upload-images.jianshu.io/upload_images/192464-d9dad58c3961dc76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nReact花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello jQuery!</title>\n  <script type=\"text/javascript\" src=\"scripts/vendor/jquery-1.12.3.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    $(document).ready(function(){\n      $(\"#example\").html(\"<h1>Hello, world!</h1>\"); }\n    );\n  </script>\n</body>\n</html>\n```\n\n![jQuery DOM操作](http://upload-images.jianshu.io/upload_images/192464-6ed99e94b0e681bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。\n###### 如何使用Virtual DOM\n　\"Hello,World\"例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。\n　**数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处**。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。\n　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。\n　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动--这可以节省大量的资源，显著地提升应用的性能。\n　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是**主要还是取决于你如何更好的优化应用。**\n　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。**这就是React带来的真正好处--性能和生产力**。\n\n--------------\n\n原文作者：[Chris Minnick](https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/)\n翻译：[熊贤仁](http://voidman.xyz)\n","source":"_posts/【译】真实的Virtual-DOM.md","raw":"---\ntitle: 【译】真实的Virtual DOM\ndate: 2016-09-08 17:51:03\ntags:\n- JavaScript\n- React\n- 翻译\ncategories:\n- 前端\n---\n###### 为什么我们需要UI框架？\n　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。\n　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。\n　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。\n<!-- more -->\n###### 什么让React与众不同？\n　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。\n　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。\n###### DOM很慢？\n　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。\n　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。\n那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。\n###### Virtual DOM如何工作？\n　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。\n　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：\n**1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。**\n**2. 重新计算比较出新的和之前的Virtual DOM的差异。**\n**3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。**\n\n###### Virtual DOM慢吗？\n　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。\n　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。\n　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。\n　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。\n　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。\n###### 我们来看一些数字\n　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。\n　举个使用原生JS操作DOM的“Hello，world！”的例子：\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello JavaScript!</title>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    document.getElementById(\"example\").innerHTML = \"<h1>Hello, world!</h1>\";\n  </script>\n</body>\n</html>\n```\n　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\" />\n<title>Hello React!</title>\n<script src=\"build/react.js\"></script>\n<script src=\"build/react-dom.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script type=\"text/babel\">\n    ReactDOM.render(\n      <h1>Hello, world!</h1>,    \n      document.getElementById('example')\n    );\n  </script>\n</body>\n</html>\n```\n原生操作DOM总是会更快。我们来看一下证明过程。\n这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）\n\n![原生DOM操作](http://upload-images.jianshu.io/upload_images/192464-47f148936b3b9e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这是加载和渲染React“Hello，World”页面的timeline（chrome）\n\n![React DOM操作](http://upload-images.jianshu.io/upload_images/192464-d9dad58c3961dc76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nReact花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello jQuery!</title>\n  <script type=\"text/javascript\" src=\"scripts/vendor/jquery-1.12.3.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    $(document).ready(function(){\n      $(\"#example\").html(\"<h1>Hello, world!</h1>\"); }\n    );\n  </script>\n</body>\n</html>\n```\n\n![jQuery DOM操作](http://upload-images.jianshu.io/upload_images/192464-6ed99e94b0e681bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。\n###### 如何使用Virtual DOM\n　\"Hello,World\"例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。\n　**数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处**。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。\n　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。\n　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动--这可以节省大量的资源，显著地提升应用的性能。\n　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是**主要还是取决于你如何更好的优化应用。**\n　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。**这就是React带来的真正好处--性能和生产力**。\n\n--------------\n\n原文作者：[Chris Minnick](https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/)\n翻译：[熊贤仁](http://voidman.xyz)\n","slug":"【译】真实的Virtual-DOM","published":1,"updated":"2017-02-05T05:12:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3f002o0pk3bqjtul6l","content":"<h6 id=\"为什么我们需要UI框架？\"><a href=\"#为什么我们需要UI框架？\" class=\"headerlink\" title=\"为什么我们需要UI框架？\"></a>为什么我们需要UI框架？</h6><p>　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。<br>　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。<br>　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。<br><a id=\"more\"></a></p>\n<h6 id=\"什么让React与众不同？\"><a href=\"#什么让React与众不同？\" class=\"headerlink\" title=\"什么让React与众不同？\"></a>什么让React与众不同？</h6><p>　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。<br>　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。</p>\n<h6 id=\"DOM很慢？\"><a href=\"#DOM很慢？\" class=\"headerlink\" title=\"DOM很慢？\"></a>DOM很慢？</h6><p>　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。<br>　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。<br>那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。</p>\n<h6 id=\"Virtual-DOM如何工作？\"><a href=\"#Virtual-DOM如何工作？\" class=\"headerlink\" title=\"Virtual DOM如何工作？\"></a>Virtual DOM如何工作？</h6><p>　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。<br>　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：<br><strong>1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。</strong><br><strong>2. 重新计算比较出新的和之前的Virtual DOM的差异。</strong><br><strong>3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。</strong></p>\n<h6 id=\"Virtual-DOM慢吗？\"><a href=\"#Virtual-DOM慢吗？\" class=\"headerlink\" title=\"Virtual DOM慢吗？\"></a>Virtual DOM慢吗？</h6><p>　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。<br>　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。<br>　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。<br>　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。<br>　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。</p>\n<h6 id=\"我们来看一些数字\"><a href=\"#我们来看一些数字\" class=\"headerlink\" title=\"我们来看一些数字\"></a>我们来看一些数字</h6><p>　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。<br>　举个使用原生JS操作DOM的“Hello，world！”的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello JavaScript!&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&quot;example&quot;).innerHTML = &quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;Hello React!&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">    ReactDOM.render(</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!&lt;/h1&gt;,    </span><br><span class=\"line\">      document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>原生操作DOM总是会更快。我们来看一下证明过程。<br>这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-47f148936b3b9e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"原生DOM操作\"><br>这是加载和渲染React“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-d9dad58c3961dc76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"React DOM操作\"><br>React花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello jQuery!&lt;/title&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot; src=&quot;scripts/vendor/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    $(document).ready(function()&#123;</span><br><span class=\"line\">      $(&quot;#example&quot;).html(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;); &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-6ed99e94b0e681bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"jQuery DOM操作\"><br>　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。</p>\n<h6 id=\"如何使用Virtual-DOM\"><a href=\"#如何使用Virtual-DOM\" class=\"headerlink\" title=\"如何使用Virtual DOM\"></a>如何使用Virtual DOM</h6><p>　“Hello,World”例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。<br>　<strong>数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处</strong>。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。<br>　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。<br>　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动–这可以节省大量的资源，显著地提升应用的性能。<br>　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是<strong>主要还是取决于你如何更好的优化应用。</strong><br>　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。<strong>这就是React带来的真正好处–性能和生产力</strong>。</p>\n<hr>\n<p>原文作者：<a href=\"https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/\" target=\"_blank\" rel=\"noopener\">Chris Minnick</a><br>翻译：<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n","site":{"data":{}},"excerpt":"<h6 id=\"为什么我们需要UI框架？\"><a href=\"#为什么我们需要UI框架？\" class=\"headerlink\" title=\"为什么我们需要UI框架？\"></a>为什么我们需要UI框架？</h6><p>　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。<br>　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。<br>　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。<br>","more":"</p>\n<h6 id=\"什么让React与众不同？\"><a href=\"#什么让React与众不同？\" class=\"headerlink\" title=\"什么让React与众不同？\"></a>什么让React与众不同？</h6><p>　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。<br>　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。</p>\n<h6 id=\"DOM很慢？\"><a href=\"#DOM很慢？\" class=\"headerlink\" title=\"DOM很慢？\"></a>DOM很慢？</h6><p>　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。<br>　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。<br>那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。</p>\n<h6 id=\"Virtual-DOM如何工作？\"><a href=\"#Virtual-DOM如何工作？\" class=\"headerlink\" title=\"Virtual DOM如何工作？\"></a>Virtual DOM如何工作？</h6><p>　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。<br>　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：<br><strong>1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。</strong><br><strong>2. 重新计算比较出新的和之前的Virtual DOM的差异。</strong><br><strong>3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。</strong></p>\n<h6 id=\"Virtual-DOM慢吗？\"><a href=\"#Virtual-DOM慢吗？\" class=\"headerlink\" title=\"Virtual DOM慢吗？\"></a>Virtual DOM慢吗？</h6><p>　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。<br>　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。<br>　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。<br>　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。<br>　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。</p>\n<h6 id=\"我们来看一些数字\"><a href=\"#我们来看一些数字\" class=\"headerlink\" title=\"我们来看一些数字\"></a>我们来看一些数字</h6><p>　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。<br>　举个使用原生JS操作DOM的“Hello，world！”的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello JavaScript!&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&quot;example&quot;).innerHTML = &quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;Hello React!&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">    ReactDOM.render(</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!&lt;/h1&gt;,    </span><br><span class=\"line\">      document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>原生操作DOM总是会更快。我们来看一下证明过程。<br>这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-47f148936b3b9e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"原生DOM操作\"><br>这是加载和渲染React“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-d9dad58c3961dc76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"React DOM操作\"><br>React花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello jQuery!&lt;/title&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot; src=&quot;scripts/vendor/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    $(document).ready(function()&#123;</span><br><span class=\"line\">      $(&quot;#example&quot;).html(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;); &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-6ed99e94b0e681bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"jQuery DOM操作\"><br>　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。</p>\n<h6 id=\"如何使用Virtual-DOM\"><a href=\"#如何使用Virtual-DOM\" class=\"headerlink\" title=\"如何使用Virtual DOM\"></a>如何使用Virtual DOM</h6><p>　“Hello,World”例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。<br>　<strong>数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处</strong>。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。<br>　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。<br>　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动–这可以节省大量的资源，显著地提升应用的性能。<br>　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是<strong>主要还是取决于你如何更好的优化应用。</strong><br>　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。<strong>这就是React带来的真正好处–性能和生产力</strong>。</p>\n<hr>\n<p>原文作者：<a href=\"https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/\" target=\"_blank\" rel=\"noopener\">Chris Minnick</a><br>翻译：<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>"},{"title":"一个优化的快速排序","date":"2016-04-17T07:59:49.000Z","_content":"快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。\n\n一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。\n\nJavaScript实现代码如下：\n```\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\n//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头\nArray.prototype.partionMedianOfThree = function(start,end){\n    var mid = Math.floor(start+(end-start)/2);\n    if(this[start]>this[end]){\n        this.swap(start,end);\n    }\n    if(this[mid]>this[end]){\n        this.swap(mid,end);\n    }\n    if(this[mid]>this[start]){\n        this.swap(mid,start);\n    }\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    this.partionMedianOfThree(start,end);\n    var pivotIdx = start;\n    var pivot = this[pivotIdx];\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n           //比轴值小则交换\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    //递归地对子数组进行排序\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\n\n```\n测试一下算法的性能：\n```\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort1(0,arr.length-1);\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:227ms\n```","source":"_posts/一个优化的快速排序.md","raw":"---\ntitle: 一个优化的快速排序\ndate: 2016-04-17 15:59:49\ntags:\n- JavaScript\n- 算法\ncategories:\n- 数据结构与算法\n---\n快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。\n\n一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。\n\nJavaScript实现代码如下：\n```\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\n//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头\nArray.prototype.partionMedianOfThree = function(start,end){\n    var mid = Math.floor(start+(end-start)/2);\n    if(this[start]>this[end]){\n        this.swap(start,end);\n    }\n    if(this[mid]>this[end]){\n        this.swap(mid,end);\n    }\n    if(this[mid]>this[start]){\n        this.swap(mid,start);\n    }\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    this.partionMedianOfThree(start,end);\n    var pivotIdx = start;\n    var pivot = this[pivotIdx];\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n           //比轴值小则交换\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    //递归地对子数组进行排序\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\n\n```\n测试一下算法的性能：\n```\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort1(0,arr.length-1);\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:227ms\n```","slug":"一个优化的快速排序","published":1,"updated":"2016-04-17T08:01:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3h002q0pk3qhffv3v3","content":"<p>快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。</p>\n<p>一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。</p>\n<p>JavaScript实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头</span><br><span class=\"line\">Array.prototype.partionMedianOfThree = function(start,end)&#123;</span><br><span class=\"line\">    var mid = Math.floor(start+(end-start)/2);</span><br><span class=\"line\">    if(this[start]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(start,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(mid,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[start])&#123;</span><br><span class=\"line\">        this.swap(mid,start);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.partionMedianOfThree(start,end);</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var pivot = this[pivotIdx];</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">           //比轴值小则交换</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //递归地对子数组进行排序</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下算法的性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort1(0,arr.length-1);</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:227ms</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。</p>\n<p>一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。</p>\n<p>JavaScript实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头</span><br><span class=\"line\">Array.prototype.partionMedianOfThree = function(start,end)&#123;</span><br><span class=\"line\">    var mid = Math.floor(start+(end-start)/2);</span><br><span class=\"line\">    if(this[start]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(start,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(mid,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[start])&#123;</span><br><span class=\"line\">        this.swap(mid,start);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.partionMedianOfThree(start,end);</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var pivot = this[pivotIdx];</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">           //比轴值小则交换</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //递归地对子数组进行排序</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下算法的性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort1(0,arr.length-1);</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:227ms</span><br></pre></td></tr></table></figure></p>\n"},{"title":"一个通用的事件监听器","date":"2016-04-29T10:03:38.000Z","_content":"```\ndefine(function(){\n    var Event = {\n        //页面加载完成后注册onload事件\n        readyEvent:function(fn){\n            if(fn == null){\n                fn = document;\n            }\n            var oldonload = window.onload;\n            if(typeof window.onload != 'function'){\n                window.onload = fn;\n            }else{\n                // 如果window.onload上已有事件绑定，则追加到它的后面\n                window.onload = function(){\n                    oldonload();\n                    fn();\n                }\n            }\n        },\n        bindEvent:function(target,type,handler){\n            if(target.addEventListener){\n                target.addEventListener(type,handler,false);\n            }else if(target.attachEvent){\n                target.attachEvent('on'+type,function(event){\n                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向\n                    return handler.call(target,event)\n                })\n            }else{\n                target['on'+type] = handler;\n            }\n        },\n        // 移除事件\n        removeEvent:function(target,type,handler){\n            if(target.removeEventListener){\n                target.removeEventListener(type,handler,false);\n            }else if(target.detachEvent){\n                target.detachEvent('on'+type,handler);\n            }else{\n                target['on'+type] = null;\n            }\n        },\n        // 阻止事件传播\n        stopPropagation:function(event){\n            if(event.stopPropagation){\n                event.stopPropagation();\n            }else{\n                event.cancelBubble = true;\n            }\n        },\n        // 取消事件默认行为\n        preventDefault:function(event){\n            if(event.preventDefault){\n                event.preventDefault();\n            }else{\n                event.returnValue = false;\n            }\n        },\n        // 获取事件目标\n        getTarget:function(event){\n            return event.target || event.srcElement;\n        },\n        // 获取事件对象的引用\n        getEvent:function(event){\n            var event = event || window.event;\n            if(!event){\n                // caller用于在函数内部获取调用getEvent的函数\n                var c = this.getEvent.caller;\n                while(c){\n                    event = c.arguments[0];\n                    if(event && Event == event.constructor){\n                        break;\n                    }\n                    c = c.caller;\n                }\n            }\n            return event;\n        }\n    }\n\n    return Event;\n})\n```\n\n\n\n","source":"_posts/一个通用的事件监听器.md","raw":"---\ntitle: 一个通用的事件监听器\ndate: 2016-04-29 18:03:38\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n```\ndefine(function(){\n    var Event = {\n        //页面加载完成后注册onload事件\n        readyEvent:function(fn){\n            if(fn == null){\n                fn = document;\n            }\n            var oldonload = window.onload;\n            if(typeof window.onload != 'function'){\n                window.onload = fn;\n            }else{\n                // 如果window.onload上已有事件绑定，则追加到它的后面\n                window.onload = function(){\n                    oldonload();\n                    fn();\n                }\n            }\n        },\n        bindEvent:function(target,type,handler){\n            if(target.addEventListener){\n                target.addEventListener(type,handler,false);\n            }else if(target.attachEvent){\n                target.attachEvent('on'+type,function(event){\n                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向\n                    return handler.call(target,event)\n                })\n            }else{\n                target['on'+type] = handler;\n            }\n        },\n        // 移除事件\n        removeEvent:function(target,type,handler){\n            if(target.removeEventListener){\n                target.removeEventListener(type,handler,false);\n            }else if(target.detachEvent){\n                target.detachEvent('on'+type,handler);\n            }else{\n                target['on'+type] = null;\n            }\n        },\n        // 阻止事件传播\n        stopPropagation:function(event){\n            if(event.stopPropagation){\n                event.stopPropagation();\n            }else{\n                event.cancelBubble = true;\n            }\n        },\n        // 取消事件默认行为\n        preventDefault:function(event){\n            if(event.preventDefault){\n                event.preventDefault();\n            }else{\n                event.returnValue = false;\n            }\n        },\n        // 获取事件目标\n        getTarget:function(event){\n            return event.target || event.srcElement;\n        },\n        // 获取事件对象的引用\n        getEvent:function(event){\n            var event = event || window.event;\n            if(!event){\n                // caller用于在函数内部获取调用getEvent的函数\n                var c = this.getEvent.caller;\n                while(c){\n                    event = c.arguments[0];\n                    if(event && Event == event.constructor){\n                        break;\n                    }\n                    c = c.caller;\n                }\n            }\n            return event;\n        }\n    }\n\n    return Event;\n})\n```\n\n\n\n","slug":"一个通用的事件监听器","published":1,"updated":"2016-05-02T13:54:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3j002u0pk3w9uzmb6f","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(function()&#123;</span><br><span class=\"line\">    var Event = &#123;</span><br><span class=\"line\">        //页面加载完成后注册onload事件</span><br><span class=\"line\">        readyEvent:function(fn)&#123;</span><br><span class=\"line\">            if(fn == null)&#123;</span><br><span class=\"line\">                fn = document;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var oldonload = window.onload;</span><br><span class=\"line\">            if(typeof window.onload != &apos;function&apos;)&#123;</span><br><span class=\"line\">                window.onload = fn;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                // 如果window.onload上已有事件绑定，则追加到它的后面</span><br><span class=\"line\">                window.onload = function()&#123;</span><br><span class=\"line\">                    oldonload();</span><br><span class=\"line\">                    fn();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.addEventListener)&#123;</span><br><span class=\"line\">                target.addEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.attachEvent)&#123;</span><br><span class=\"line\">                target.attachEvent(&apos;on&apos;+type,function(event)&#123;</span><br><span class=\"line\">                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向</span><br><span class=\"line\">                    return handler.call(target,event)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = handler;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 移除事件</span><br><span class=\"line\">        removeEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.removeEventListener)&#123;</span><br><span class=\"line\">                target.removeEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.detachEvent)&#123;</span><br><span class=\"line\">                target.detachEvent(&apos;on&apos;+type,handler);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 阻止事件传播</span><br><span class=\"line\">        stopPropagation:function(event)&#123;</span><br><span class=\"line\">            if(event.stopPropagation)&#123;</span><br><span class=\"line\">                event.stopPropagation();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.cancelBubble = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 取消事件默认行为</span><br><span class=\"line\">        preventDefault:function(event)&#123;</span><br><span class=\"line\">            if(event.preventDefault)&#123;</span><br><span class=\"line\">                event.preventDefault();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.returnValue = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件目标</span><br><span class=\"line\">        getTarget:function(event)&#123;</span><br><span class=\"line\">            return event.target || event.srcElement;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件对象的引用</span><br><span class=\"line\">        getEvent:function(event)&#123;</span><br><span class=\"line\">            var event = event || window.event;</span><br><span class=\"line\">            if(!event)&#123;</span><br><span class=\"line\">                // caller用于在函数内部获取调用getEvent的函数</span><br><span class=\"line\">                var c = this.getEvent.caller;</span><br><span class=\"line\">                while(c)&#123;</span><br><span class=\"line\">                    event = c.arguments[0];</span><br><span class=\"line\">                    if(event &amp;&amp; Event == event.constructor)&#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    c = c.caller;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return event;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Event;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(function()&#123;</span><br><span class=\"line\">    var Event = &#123;</span><br><span class=\"line\">        //页面加载完成后注册onload事件</span><br><span class=\"line\">        readyEvent:function(fn)&#123;</span><br><span class=\"line\">            if(fn == null)&#123;</span><br><span class=\"line\">                fn = document;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var oldonload = window.onload;</span><br><span class=\"line\">            if(typeof window.onload != &apos;function&apos;)&#123;</span><br><span class=\"line\">                window.onload = fn;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                // 如果window.onload上已有事件绑定，则追加到它的后面</span><br><span class=\"line\">                window.onload = function()&#123;</span><br><span class=\"line\">                    oldonload();</span><br><span class=\"line\">                    fn();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.addEventListener)&#123;</span><br><span class=\"line\">                target.addEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.attachEvent)&#123;</span><br><span class=\"line\">                target.attachEvent(&apos;on&apos;+type,function(event)&#123;</span><br><span class=\"line\">                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向</span><br><span class=\"line\">                    return handler.call(target,event)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = handler;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 移除事件</span><br><span class=\"line\">        removeEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.removeEventListener)&#123;</span><br><span class=\"line\">                target.removeEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.detachEvent)&#123;</span><br><span class=\"line\">                target.detachEvent(&apos;on&apos;+type,handler);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 阻止事件传播</span><br><span class=\"line\">        stopPropagation:function(event)&#123;</span><br><span class=\"line\">            if(event.stopPropagation)&#123;</span><br><span class=\"line\">                event.stopPropagation();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.cancelBubble = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 取消事件默认行为</span><br><span class=\"line\">        preventDefault:function(event)&#123;</span><br><span class=\"line\">            if(event.preventDefault)&#123;</span><br><span class=\"line\">                event.preventDefault();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.returnValue = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件目标</span><br><span class=\"line\">        getTarget:function(event)&#123;</span><br><span class=\"line\">            return event.target || event.srcElement;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件对象的引用</span><br><span class=\"line\">        getEvent:function(event)&#123;</span><br><span class=\"line\">            var event = event || window.event;</span><br><span class=\"line\">            if(!event)&#123;</span><br><span class=\"line\">                // caller用于在函数内部获取调用getEvent的函数</span><br><span class=\"line\">                var c = this.getEvent.caller;</span><br><span class=\"line\">                while(c)&#123;</span><br><span class=\"line\">                    event = c.arguments[0];</span><br><span class=\"line\">                    if(event &amp;&amp; Event == event.constructor)&#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    c = c.caller;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return event;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Event;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"什么是TCP连接的三次握手","date":"2016-03-09T05:46:12.000Z","_content":"第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认\n第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。\nTCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。\n","source":"_posts/什么是TCP连接的三次握手.md","raw":"---\ntitle: 什么是TCP连接的三次握手\ndate: 2016-03-09 13:46:12\ntags:\n- HTTP\ncategories:\n- 网络\n---\n第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认\n第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。\nTCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。\n","slug":"什么是TCP连接的三次握手","published":1,"updated":"2017-02-05T05:25:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3m002x0pk3m6300i4n","content":"<p>第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认<br>第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>\n<p>注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。<br>TCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认<br>第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>\n<p>注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。<br>TCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。</p>\n"},{"title":"你该逃课吗","date":"2016-05-29T11:57:44.000Z","_content":"　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。\n<!-- more -->\n　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。\n","source":"_posts/你该逃课吗.md","raw":"---\ntitle: 你该逃课吗\ndate: 2016-05-29 19:57:44\ntags:\n- 随笔\ncategories:\n- 随笔\n---\n　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。\n<!-- more -->\n　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。\n","slug":"你该逃课吗","published":1,"updated":"2016-09-04T08:40:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3o00310pk3cnv3z6i2","content":"<p>　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。<br><a id=\"more\"></a><br>　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。</p>\n","site":{"data":{}},"excerpt":"<p>　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。<br>","more":"<br>　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。</p>"},{"title":"实现JavaScript中的indexOf方法","date":"2016-03-21T09:43:49.000Z","_content":"> indexOf()方法是ES5中出现的数组方法，它有两个参数\narray.indexOf(value,start)\n第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。\n示例：['a','b','c'].indexOf('a',1)  //返回-1\n\n下面我们来自己实现这个方法，并保证其向下兼容性。\n```\nvar indexof = function(array,value,start){\n   if(array == null) return -1;\n   var i=0,length = array.length;\n   if(start){\n       if(typeof start == 'number'){\n           // 添加对start为负值时的处理\n           i = (start < 0 ? Math.max(0,length+start):start);\n        }\n   }\n   // 如果浏览器支持ES5 indexOf，则直接使用它\n   if(Array.prototype.indexOf && array.indexOf === Array.prototype.indexOf){\n        return array.indexOf(value,start);\n   }\n   // 遍历数组\n   for(;i < length;i++){\n       if(array[i]===value){\n           return i;\n       }\n   }\n   return -1;\n}\n//测试\nconsole.log(indexof([2,4,1,8,5],1,0));//输出2\n```\n如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。\n","source":"_posts/实现JavaScript中的indexOf方法.md","raw":"---\ntitle: 实现JavaScript中的indexOf方法\ndate: 2016-03-21 17:43:49\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> indexOf()方法是ES5中出现的数组方法，它有两个参数\narray.indexOf(value,start)\n第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。\n示例：['a','b','c'].indexOf('a',1)  //返回-1\n\n下面我们来自己实现这个方法，并保证其向下兼容性。\n```\nvar indexof = function(array,value,start){\n   if(array == null) return -1;\n   var i=0,length = array.length;\n   if(start){\n       if(typeof start == 'number'){\n           // 添加对start为负值时的处理\n           i = (start < 0 ? Math.max(0,length+start):start);\n        }\n   }\n   // 如果浏览器支持ES5 indexOf，则直接使用它\n   if(Array.prototype.indexOf && array.indexOf === Array.prototype.indexOf){\n        return array.indexOf(value,start);\n   }\n   // 遍历数组\n   for(;i < length;i++){\n       if(array[i]===value){\n           return i;\n       }\n   }\n   return -1;\n}\n//测试\nconsole.log(indexof([2,4,1,8,5],1,0));//输出2\n```\n如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。\n","slug":"实现JavaScript中的indexOf方法","published":1,"updated":"2017-02-05T05:24:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3p00340pk3xcgvt8wl","content":"<blockquote>\n<p>indexOf()方法是ES5中出现的数组方法，它有两个参数<br>array.indexOf(value,start)<br>第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。<br>示例：[‘a’,’b’,’c’].indexOf(‘a’,1)  //返回-1</p>\n</blockquote>\n<p>下面我们来自己实现这个方法，并保证其向下兼容性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var indexof = function(array,value,start)&#123;</span><br><span class=\"line\">   if(array == null) return -1;</span><br><span class=\"line\">   var i=0,length = array.length;</span><br><span class=\"line\">   if(start)&#123;</span><br><span class=\"line\">       if(typeof start == &apos;number&apos;)&#123;</span><br><span class=\"line\">           // 添加对start为负值时的处理</span><br><span class=\"line\">           i = (start &lt; 0 ? Math.max(0,length+start):start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果浏览器支持ES5 indexOf，则直接使用它</span><br><span class=\"line\">   if(Array.prototype.indexOf &amp;&amp; array.indexOf === Array.prototype.indexOf)&#123;</span><br><span class=\"line\">        return array.indexOf(value,start);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 遍历数组</span><br><span class=\"line\">   for(;i &lt; length;i++)&#123;</span><br><span class=\"line\">       if(array[i]===value)&#123;</span><br><span class=\"line\">           return i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//测试</span><br><span class=\"line\">console.log(indexof([2,4,1,8,5],1,0));//输出2</span><br></pre></td></tr></table></figure></p>\n<p>如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>indexOf()方法是ES5中出现的数组方法，它有两个参数<br>array.indexOf(value,start)<br>第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。<br>示例：[‘a’,’b’,’c’].indexOf(‘a’,1)  //返回-1</p>\n</blockquote>\n<p>下面我们来自己实现这个方法，并保证其向下兼容性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var indexof = function(array,value,start)&#123;</span><br><span class=\"line\">   if(array == null) return -1;</span><br><span class=\"line\">   var i=0,length = array.length;</span><br><span class=\"line\">   if(start)&#123;</span><br><span class=\"line\">       if(typeof start == &apos;number&apos;)&#123;</span><br><span class=\"line\">           // 添加对start为负值时的处理</span><br><span class=\"line\">           i = (start &lt; 0 ? Math.max(0,length+start):start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果浏览器支持ES5 indexOf，则直接使用它</span><br><span class=\"line\">   if(Array.prototype.indexOf &amp;&amp; array.indexOf === Array.prototype.indexOf)&#123;</span><br><span class=\"line\">        return array.indexOf(value,start);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 遍历数组</span><br><span class=\"line\">   for(;i &lt; length;i++)&#123;</span><br><span class=\"line\">       if(array[i]===value)&#123;</span><br><span class=\"line\">           return i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//测试</span><br><span class=\"line\">console.log(indexof([2,4,1,8,5],1,0));//输出2</span><br></pre></td></tr></table></figure></p>\n<p>如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。</p>\n"},{"title":"写给自己的鸡汤","date":"2017-03-18T20:50:01.000Z","_content":"时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿\n\n有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿\n\n 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿\n\n 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿\n\n\n\n2017.3.19 凌晨四点\n","source":"_posts/写给自己的鸡汤.md","raw":"---\ntitle: 写给自己的鸡汤\ndate: 2017-03-19 04:50:01\ntags:\n- 随笔\ncategories:\n- 随笔\n---\n时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿\n\n有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿\n\n 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿\n\n 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿\n\n\n\n2017.3.19 凌晨四点\n","slug":"写给自己的鸡汤","published":1,"updated":"2017-03-31T16:23:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3r00390pk32vc7dg0b","content":"<p>时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿</p>\n<p>有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿</p>\n<p> 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿</p>\n<p> 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿</p>\n<p>2017.3.19 凌晨四点</p>\n","site":{"data":{}},"excerpt":"","more":"<p>时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿</p>\n<p>有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿</p>\n<p> 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿</p>\n<p> 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿</p>\n<p>2017.3.19 凌晨四点</p>\n"},{"title":"我的HTTPS升级之旅","date":"2017-05-11T13:47:36.000Z","_content":"> 本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0\n\n### 前言\n先贴一个福利，也作为没有启用 HTTPS 的反面教材：\n\n![福利.png](http://upload-images.jianshu.io/upload_images/192464-fe05fdae9ecca705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。\n\n### 预备条件\n本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。\n\n### 获取证书\nHTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。\n\n我使用了大名鼎鼎的 Let's Encrypt 来生成证书。\n###### 1. 安装 certbot\ncertbot 是 Let's Encrypt 提供的一套自动化工具。 \n```\nyum install epel-release\nyum install certbot\n```\n###### 2. 生成证书\n这里采用 webroot 作为 Let's Encrypt 的认证方式。\n```\ncertbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com\n```\nwebroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：\n- cert.pem: 服务端证书\n- chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书\n- fullchain.pem: 包括了cert.pem和chain.pem的内容\n- privkey.pem: 证书私钥\n\n###### 3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\n为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。\n```\nopenssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\n```\n如果没有安装 openssl，这里要先安装一下。\n```\nyum install openssl\n```\n\n\n### 配置 Nginx\n编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。\n```\nserver {\n    listen 443 ssl;\n    # 启用http2\n    # 需要安装 Nginx Http2 Module\n    # listen 443 http2 ssl;\n    server_name example.com www.example.com;\n    #证书文件\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    #私钥文件\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    # 优先采取服务器算法\n    ssl_prefer_server_ciphers on;\n    # 定义算法\n    ssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\n    ssl_ecdh_curve secp384r1;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_tickets off;\n    ssl_stapling on;\n    ssl_stapling_verify on;\n    resolver 8.8.8.8 8.8.4.4 valid=300s;\n    resolver_timeout 5s;\n   \n    add_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    # 使用DH文件\n    ssl_dhparam /etc/ssl/certs/dhparam.pem;\n\n    location ~ /.well-known {\n        allow all;\n    }\n\n    root /your/project/path;\n    index index.html index.htm;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n```\n解释一下其中几项配置：\n```\nssl_stapling on;\n```\n开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。\n```\nadd_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n```\n启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接\n```\n    add_header X-Frame-Options DENY;\n```\n添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少[点击劫持 (clickjacking)攻击](https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/)。\n```\n    add_header X-Content-Type-Options nosniff;\n```\n添加 X-Content-Type-Options 响应头，防止 [MIME 类型嗅探攻击](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing)\n\n解释完毕。继续，来测试 nginx.conf 是否有语法错误\n```\nnginx -t\n```\n重启 Nginx\n```\nnginx -s reload\n```\n### 重定向 HTTP 到 HTTPS\n修改原来 HTTP 网站的 Nginx 配置。\n```\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    access_log /var/log/example/access.log;\n    error_log /var/log/example/error.log;\n    # 301 永久重定向\n    return 301 https://$host$request_uri;\n    location / {\n        root /your/project/path;\n        index index.html index.htm;\n    }\n}\n```\n这时再访问网站，浏览器地址栏就会出现一把小锁。\n![https.png](http://upload-images.jianshu.io/upload_images/192464-ccfdb88512841554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。\n\n最后可以使用 [ssllabs](https://www.ssllabs.com/ssltest/analyze.html) 测试一下网站的安全性，我的网站得了 A+😁\n\n---------\n参考链接：\n[Nginx 配置 HTTPS 服务器](https://aotu.io/notes/2016/08/16/nginx-https/)\n[How To Secure Nginx with Let's Encrypt on CentOS 7](https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7)","source":"_posts/我的HTTPS升级之旅.md","raw":"---\ntitle: 我的HTTPS升级之旅\ndate: 2017-05-11 21:47:36\ntags:\n- HTTP\ncategories:\n- 网络\n---\n> 本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0\n\n### 前言\n先贴一个福利，也作为没有启用 HTTPS 的反面教材：\n\n![福利.png](http://upload-images.jianshu.io/upload_images/192464-fe05fdae9ecca705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。\n\n### 预备条件\n本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。\n\n### 获取证书\nHTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。\n\n我使用了大名鼎鼎的 Let's Encrypt 来生成证书。\n###### 1. 安装 certbot\ncertbot 是 Let's Encrypt 提供的一套自动化工具。 \n```\nyum install epel-release\nyum install certbot\n```\n###### 2. 生成证书\n这里采用 webroot 作为 Let's Encrypt 的认证方式。\n```\ncertbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com\n```\nwebroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：\n- cert.pem: 服务端证书\n- chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书\n- fullchain.pem: 包括了cert.pem和chain.pem的内容\n- privkey.pem: 证书私钥\n\n###### 3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\n为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。\n```\nopenssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\n```\n如果没有安装 openssl，这里要先安装一下。\n```\nyum install openssl\n```\n\n\n### 配置 Nginx\n编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。\n```\nserver {\n    listen 443 ssl;\n    # 启用http2\n    # 需要安装 Nginx Http2 Module\n    # listen 443 http2 ssl;\n    server_name example.com www.example.com;\n    #证书文件\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    #私钥文件\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    # 优先采取服务器算法\n    ssl_prefer_server_ciphers on;\n    # 定义算法\n    ssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\n    ssl_ecdh_curve secp384r1;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_tickets off;\n    ssl_stapling on;\n    ssl_stapling_verify on;\n    resolver 8.8.8.8 8.8.4.4 valid=300s;\n    resolver_timeout 5s;\n   \n    add_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    # 使用DH文件\n    ssl_dhparam /etc/ssl/certs/dhparam.pem;\n\n    location ~ /.well-known {\n        allow all;\n    }\n\n    root /your/project/path;\n    index index.html index.htm;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n```\n解释一下其中几项配置：\n```\nssl_stapling on;\n```\n开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。\n```\nadd_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n```\n启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接\n```\n    add_header X-Frame-Options DENY;\n```\n添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少[点击劫持 (clickjacking)攻击](https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/)。\n```\n    add_header X-Content-Type-Options nosniff;\n```\n添加 X-Content-Type-Options 响应头，防止 [MIME 类型嗅探攻击](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing)\n\n解释完毕。继续，来测试 nginx.conf 是否有语法错误\n```\nnginx -t\n```\n重启 Nginx\n```\nnginx -s reload\n```\n### 重定向 HTTP 到 HTTPS\n修改原来 HTTP 网站的 Nginx 配置。\n```\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    access_log /var/log/example/access.log;\n    error_log /var/log/example/error.log;\n    # 301 永久重定向\n    return 301 https://$host$request_uri;\n    location / {\n        root /your/project/path;\n        index index.html index.htm;\n    }\n}\n```\n这时再访问网站，浏览器地址栏就会出现一把小锁。\n![https.png](http://upload-images.jianshu.io/upload_images/192464-ccfdb88512841554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。\n\n最后可以使用 [ssllabs](https://www.ssllabs.com/ssltest/analyze.html) 测试一下网站的安全性，我的网站得了 A+😁\n\n---------\n参考链接：\n[Nginx 配置 HTTPS 服务器](https://aotu.io/notes/2016/08/16/nginx-https/)\n[How To Secure Nginx with Let's Encrypt on CentOS 7](https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7)","slug":"我的HTTPS升级之旅","published":1,"updated":"2017-05-11T20:19:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3t003c0pk3m4o0hbee","content":"<blockquote>\n<p>本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>先贴一个福利，也作为没有启用 HTTPS 的反面教材：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-fe05fdae9ecca705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"福利.png\"><br>这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。</p>\n<h3 id=\"预备条件\"><a href=\"#预备条件\" class=\"headerlink\" title=\"预备条件\"></a>预备条件</h3><p>本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。</p>\n<h3 id=\"获取证书\"><a href=\"#获取证书\" class=\"headerlink\" title=\"获取证书\"></a>获取证书</h3><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。</p>\n<p>我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p>\n<h6 id=\"1-安装-certbot\"><a href=\"#1-安装-certbot\" class=\"headerlink\" title=\"1. 安装 certbot\"></a>1. 安装 certbot</h6><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install epel-release</span><br><span class=\"line\">yum install certbot</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h6><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</span><br></pre></td></tr></table></figure></p>\n<p>webroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p>\n<ul>\n<li>cert.pem: 服务端证书</li>\n<li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li>\n<li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li>\n<li>privkey.pem: 证书私钥</li>\n</ul>\n<h6 id=\"3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\"><a href=\"#3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\" class=\"headerlink\" title=\"3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\"></a>3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</h6><p>为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</span><br></pre></td></tr></table></figure></p>\n<p>如果没有安装 openssl，这里要先安装一下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install openssl</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置-Nginx\"><a href=\"#配置-Nginx\" class=\"headerlink\" title=\"配置 Nginx\"></a>配置 Nginx</h3><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    # 启用http2</span><br><span class=\"line\">    # 需要安装 Nginx Http2 Module</span><br><span class=\"line\">    # listen 443 http2 ssl;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    #证书文件</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class=\"line\">    #私钥文件</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    # 优先采取服务器算法</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    # 定义算法</span><br><span class=\"line\">    ssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;;</span><br><span class=\"line\">    ssl_ecdh_curve secp384r1;</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_tickets off;</span><br><span class=\"line\">    ssl_stapling on;</span><br><span class=\"line\">    ssl_stapling_verify on;</span><br><span class=\"line\">    resolver 8.8.8.8 8.8.4.4 valid=300s;</span><br><span class=\"line\">    resolver_timeout 5s;</span><br><span class=\"line\">   </span><br><span class=\"line\">    add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br><span class=\"line\">    add_header X-Frame-Options DENY;</span><br><span class=\"line\">    add_header X-Content-Type-Options nosniff;</span><br><span class=\"line\">    # 使用DH文件</span><br><span class=\"line\">    ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ /.well-known &#123;</span><br><span class=\"line\">        allow all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /your/project/path;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        try_files $uri $uri/ =404;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释一下其中几项配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssl_stapling on;</span><br></pre></td></tr></table></figure></p>\n<p>开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Frame-Options DENY;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少<a href=\"https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/\" target=\"_blank\" rel=\"noopener\">点击劫持 (clickjacking)攻击</a>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Content-Type-Options 响应头，防止 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing\" target=\"_blank\" rel=\"noopener\">MIME 类型嗅探攻击</a></p>\n<p>解释完毕。继续，来测试 nginx.conf 是否有语法错误<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure></p>\n<p>重启 Nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"重定向-HTTP-到-HTTPS\"><a href=\"#重定向-HTTP-到-HTTPS\" class=\"headerlink\" title=\"重定向 HTTP 到 HTTPS\"></a>重定向 HTTP 到 HTTPS</h3><p>修改原来 HTTP 网站的 Nginx 配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    access_log /var/log/example/access.log;</span><br><span class=\"line\">    error_log /var/log/example/error.log;</span><br><span class=\"line\">    # 301 永久重定向</span><br><span class=\"line\">    return 301 https://$host$request_uri;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root /your/project/path;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时再访问网站，浏览器地址栏就会出现一把小锁。<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-ccfdb88512841554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"https.png\"></p>\n<p>一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。</p>\n<p>最后可以使用 <a href=\"https://www.ssllabs.com/ssltest/analyze.html\" target=\"_blank\" rel=\"noopener\">ssllabs</a> 测试一下网站的安全性，我的网站得了 A+😁</p>\n<hr>\n<p>参考链接：<br><a href=\"https://aotu.io/notes/2016/08/16/nginx-https/\" target=\"_blank\" rel=\"noopener\">Nginx 配置 HTTPS 服务器</a><br><a href=\"https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7\" target=\"_blank\" rel=\"noopener\">How To Secure Nginx with Let’s Encrypt on CentOS 7</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>先贴一个福利，也作为没有启用 HTTPS 的反面教材：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-fe05fdae9ecca705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"福利.png\"><br>这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。</p>\n<h3 id=\"预备条件\"><a href=\"#预备条件\" class=\"headerlink\" title=\"预备条件\"></a>预备条件</h3><p>本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。</p>\n<h3 id=\"获取证书\"><a href=\"#获取证书\" class=\"headerlink\" title=\"获取证书\"></a>获取证书</h3><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。</p>\n<p>我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p>\n<h6 id=\"1-安装-certbot\"><a href=\"#1-安装-certbot\" class=\"headerlink\" title=\"1. 安装 certbot\"></a>1. 安装 certbot</h6><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install epel-release</span><br><span class=\"line\">yum install certbot</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h6><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</span><br></pre></td></tr></table></figure></p>\n<p>webroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p>\n<ul>\n<li>cert.pem: 服务端证书</li>\n<li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li>\n<li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li>\n<li>privkey.pem: 证书私钥</li>\n</ul>\n<h6 id=\"3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\"><a href=\"#3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\" class=\"headerlink\" title=\"3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\"></a>3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</h6><p>为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</span><br></pre></td></tr></table></figure></p>\n<p>如果没有安装 openssl，这里要先安装一下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install openssl</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置-Nginx\"><a href=\"#配置-Nginx\" class=\"headerlink\" title=\"配置 Nginx\"></a>配置 Nginx</h3><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    # 启用http2</span><br><span class=\"line\">    # 需要安装 Nginx Http2 Module</span><br><span class=\"line\">    # listen 443 http2 ssl;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    #证书文件</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class=\"line\">    #私钥文件</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    # 优先采取服务器算法</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    # 定义算法</span><br><span class=\"line\">    ssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;;</span><br><span class=\"line\">    ssl_ecdh_curve secp384r1;</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_tickets off;</span><br><span class=\"line\">    ssl_stapling on;</span><br><span class=\"line\">    ssl_stapling_verify on;</span><br><span class=\"line\">    resolver 8.8.8.8 8.8.4.4 valid=300s;</span><br><span class=\"line\">    resolver_timeout 5s;</span><br><span class=\"line\">   </span><br><span class=\"line\">    add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br><span class=\"line\">    add_header X-Frame-Options DENY;</span><br><span class=\"line\">    add_header X-Content-Type-Options nosniff;</span><br><span class=\"line\">    # 使用DH文件</span><br><span class=\"line\">    ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ /.well-known &#123;</span><br><span class=\"line\">        allow all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /your/project/path;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        try_files $uri $uri/ =404;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释一下其中几项配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssl_stapling on;</span><br></pre></td></tr></table></figure></p>\n<p>开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Frame-Options DENY;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少<a href=\"https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/\" target=\"_blank\" rel=\"noopener\">点击劫持 (clickjacking)攻击</a>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Content-Type-Options 响应头，防止 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing\" target=\"_blank\" rel=\"noopener\">MIME 类型嗅探攻击</a></p>\n<p>解释完毕。继续，来测试 nginx.conf 是否有语法错误<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure></p>\n<p>重启 Nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"重定向-HTTP-到-HTTPS\"><a href=\"#重定向-HTTP-到-HTTPS\" class=\"headerlink\" title=\"重定向 HTTP 到 HTTPS\"></a>重定向 HTTP 到 HTTPS</h3><p>修改原来 HTTP 网站的 Nginx 配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    access_log /var/log/example/access.log;</span><br><span class=\"line\">    error_log /var/log/example/error.log;</span><br><span class=\"line\">    # 301 永久重定向</span><br><span class=\"line\">    return 301 https://$host$request_uri;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root /your/project/path;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时再访问网站，浏览器地址栏就会出现一把小锁。<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-ccfdb88512841554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"https.png\"></p>\n<p>一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。</p>\n<p>最后可以使用 <a href=\"https://www.ssllabs.com/ssltest/analyze.html\" target=\"_blank\" rel=\"noopener\">ssllabs</a> 测试一下网站的安全性，我的网站得了 A+😁</p>\n<hr>\n<p>参考链接：<br><a href=\"https://aotu.io/notes/2016/08/16/nginx-https/\" target=\"_blank\" rel=\"noopener\">Nginx 配置 HTTPS 服务器</a><br><a href=\"https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7\" target=\"_blank\" rel=\"noopener\">How To Secure Nginx with Let’s Encrypt on CentOS 7</a></p>\n"},{"title":"正则表达式","date":"2016-03-10T08:11:39.000Z","_content":"JavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建\n如：` var re = /s$/;`这个正则表达式可以匹配以字符s结尾的字符串\n\n### 1.字符类 ###\n把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。\n如：`/[abc]/`与字母a、b、c中的任意一个都匹配。\n常见字符类\n`[abc]`  方括号内任意字符\n`[^abc]`  不在方括号内的任意字符\n`.`  除换行符和其他Unicode行终止符之外的任意字符\n`\\w`  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]  \n`\\W`  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n`\\s`  任何Unicode空白符\n`\\d`  任何ASCII数字\n### 2.重复 ###\n`{n,m}`　匹配前一项至少n次，至多m次\n`{n,}` 　  匹配前一项n次或更多次\n`{n}`　　匹配前一项n次\n`?`　　　匹配前一项0次或1次\n`+`　　 匹配前一项1次或多次\n`*`　　  匹配前一项0次或多次\n\n栗子：\n`/\\d{2,4}/`  匹配2-4个数字\n`/\\w{3}\\d?`  匹配3个字符和一个可选的数字\n### 3.分组 ###\n字符”|“用于分隔供选择的字符，如`/ab|cd|ef/`可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。\n圆括号\"()\"可用于把单独的项组合成子表达式\n\n### 4.修饰符 ###\n修饰符放在\"/\"之外，用语说明匹配模式。JavaScript支持三种修饰符\ni    执行不区分大小写的匹配\ng   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止\nm  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束\n### 5.指定匹配位置 ###\n^   匹配字符串的开头\n$   匹配字符串的结尾\n\\b  匹配单词的边界\n(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配\n`/Java(?!Script)/g `匹配以“Java”开头，但接下来的字符不是“Script”的字符串\n\n### 5.RegExp对象 ###\n- RegExp对象的属性\n  source：只读的字符串，包含正则表达式的源文本\n  lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。\n- RegExp对象的方法\n  exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null\n```\nvar str = 'Hello World';\nvar re = /Wo/g;\nvar result = re.exec(str);\nif(result != null){\n    console.log('Find '+result+' at '+result.index);//输出Find Wo at 6\n    console.log('next search begin at '+re.lastIndex);//输出next search begin at 8\n}\n```\ntest():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false\n### 6.支持正则表达式的String对象的方法 ###\nString对象支持4种使用正则表达式的方法。\n- search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。\n- replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。\n```\n//将Lebron James替换为James Lebron\nvar name = 'Lebron James';\nvar result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,'$2 $1');\nconsole.log(result);\n```\n- match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。\n```\n//匹配出字符串中的数字，将其保存到一个数组中\nvar str = 'rgb(237,13,235)';\nvar result = str.match(/\\d+/g);\nconsole.log(result);//输出[\"237\", \"13\", \"235\"]\n```\n- split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。","source":"_posts/正则表达式的模式匹配.md","raw":"---\ntitle: 正则表达式\ndate: 2016-03-10 16:11:39\ntags:\n- JavaScript\ncategories:\n- 前端\n---\nJavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建\n如：` var re = /s$/;`这个正则表达式可以匹配以字符s结尾的字符串\n\n### 1.字符类 ###\n把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。\n如：`/[abc]/`与字母a、b、c中的任意一个都匹配。\n常见字符类\n`[abc]`  方括号内任意字符\n`[^abc]`  不在方括号内的任意字符\n`.`  除换行符和其他Unicode行终止符之外的任意字符\n`\\w`  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]  \n`\\W`  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n`\\s`  任何Unicode空白符\n`\\d`  任何ASCII数字\n### 2.重复 ###\n`{n,m}`　匹配前一项至少n次，至多m次\n`{n,}` 　  匹配前一项n次或更多次\n`{n}`　　匹配前一项n次\n`?`　　　匹配前一项0次或1次\n`+`　　 匹配前一项1次或多次\n`*`　　  匹配前一项0次或多次\n\n栗子：\n`/\\d{2,4}/`  匹配2-4个数字\n`/\\w{3}\\d?`  匹配3个字符和一个可选的数字\n### 3.分组 ###\n字符”|“用于分隔供选择的字符，如`/ab|cd|ef/`可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。\n圆括号\"()\"可用于把单独的项组合成子表达式\n\n### 4.修饰符 ###\n修饰符放在\"/\"之外，用语说明匹配模式。JavaScript支持三种修饰符\ni    执行不区分大小写的匹配\ng   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止\nm  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束\n### 5.指定匹配位置 ###\n^   匹配字符串的开头\n$   匹配字符串的结尾\n\\b  匹配单词的边界\n(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配\n`/Java(?!Script)/g `匹配以“Java”开头，但接下来的字符不是“Script”的字符串\n\n### 5.RegExp对象 ###\n- RegExp对象的属性\n  source：只读的字符串，包含正则表达式的源文本\n  lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。\n- RegExp对象的方法\n  exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null\n```\nvar str = 'Hello World';\nvar re = /Wo/g;\nvar result = re.exec(str);\nif(result != null){\n    console.log('Find '+result+' at '+result.index);//输出Find Wo at 6\n    console.log('next search begin at '+re.lastIndex);//输出next search begin at 8\n}\n```\ntest():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false\n### 6.支持正则表达式的String对象的方法 ###\nString对象支持4种使用正则表达式的方法。\n- search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。\n- replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。\n```\n//将Lebron James替换为James Lebron\nvar name = 'Lebron James';\nvar result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,'$2 $1');\nconsole.log(result);\n```\n- match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。\n```\n//匹配出字符串中的数字，将其保存到一个数组中\nvar str = 'rgb(237,13,235)';\nvar result = str.match(/\\d+/g);\nconsole.log(result);//输出[\"237\", \"13\", \"235\"]\n```\n- split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。","slug":"正则表达式的模式匹配","published":1,"updated":"2016-03-10T11:55:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3u003g0pk3txdvn917","content":"<p>JavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建<br>如：<code>var re = /s$/;</code>这个正则表达式可以匹配以字符s结尾的字符串</p>\n<h3 id=\"1-字符类\"><a href=\"#1-字符类\" class=\"headerlink\" title=\"1.字符类\"></a>1.字符类</h3><p>把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。<br>如：<code>/[abc]/</code>与字母a、b、c中的任意一个都匹配。<br>常见字符类<br><code>[abc]</code>  方括号内任意字符<br><code>[^abc]</code>  不在方括号内的任意字符<br><code>.</code>  除换行符和其他Unicode行终止符之外的任意字符<br><code>\\w</code>  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]<br><code>\\W</code>  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]<br><code>\\s</code>  任何Unicode空白符<br><code>\\d</code>  任何ASCII数字</p>\n<h3 id=\"2-重复\"><a href=\"#2-重复\" class=\"headerlink\" title=\"2.重复\"></a>2.重复</h3><p><code>{n,m}</code>　匹配前一项至少n次，至多m次<br><code>{n,}</code> 　  匹配前一项n次或更多次<br><code>{n}</code>　　匹配前一项n次<br><code>?</code>　　　匹配前一项0次或1次<br><code>+</code>　　 匹配前一项1次或多次<br><code>*</code>　　  匹配前一项0次或多次</p>\n<p>栗子：<br><code>/\\d{2,4}/</code>  匹配2-4个数字<br><code>/\\w{3}\\d?</code>  匹配3个字符和一个可选的数字</p>\n<h3 id=\"3-分组\"><a href=\"#3-分组\" class=\"headerlink\" title=\"3.分组\"></a>3.分组</h3><p>字符”|“用于分隔供选择的字符，如<code>/ab|cd|ef/</code>可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。<br>圆括号”()”可用于把单独的项组合成子表达式</p>\n<h3 id=\"4-修饰符\"><a href=\"#4-修饰符\" class=\"headerlink\" title=\"4.修饰符\"></a>4.修饰符</h3><p>修饰符放在”/“之外，用语说明匹配模式。JavaScript支持三种修饰符<br>i    执行不区分大小写的匹配<br>g   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止<br>m  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束</p>\n<h3 id=\"5-指定匹配位置\"><a href=\"#5-指定匹配位置\" class=\"headerlink\" title=\"5.指定匹配位置\"></a>5.指定匹配位置</h3><p>^   匹配字符串的开头<br>$   匹配字符串的结尾<br>\\b  匹配单词的边界<br>(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配<br>(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配<br><code>/Java(?!Script)/g</code>匹配以“Java”开头，但接下来的字符不是“Script”的字符串</p>\n<h3 id=\"5-RegExp对象\"><a href=\"#5-RegExp对象\" class=\"headerlink\" title=\"5.RegExp对象\"></a>5.RegExp对象</h3><ul>\n<li>RegExp对象的属性<br>source：只读的字符串，包含正则表达式的源文本<br>lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。</li>\n<li>RegExp对象的方法<br>exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str = &apos;Hello World&apos;;</span><br><span class=\"line\">var re = /Wo/g;</span><br><span class=\"line\">var result = re.exec(str);</span><br><span class=\"line\">if(result != null)&#123;</span><br><span class=\"line\">    console.log(&apos;Find &apos;+result+&apos; at &apos;+result.index);//输出Find Wo at 6</span><br><span class=\"line\">    console.log(&apos;next search begin at &apos;+re.lastIndex);//输出next search begin at 8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>test():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false</p>\n<h3 id=\"6-支持正则表达式的String对象的方法\"><a href=\"#6-支持正则表达式的String对象的方法\" class=\"headerlink\" title=\"6.支持正则表达式的String对象的方法\"></a>6.支持正则表达式的String对象的方法</h3><p>String对象支持4种使用正则表达式的方法。</p>\n<ul>\n<li>search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。</li>\n<li><p>replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//将Lebron James替换为James Lebron</span><br><span class=\"line\">var name = &apos;Lebron James&apos;;</span><br><span class=\"line\">var result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,&apos;$2 $1&apos;);</span><br><span class=\"line\">console.log(result);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//匹配出字符串中的数字，将其保存到一个数组中</span><br><span class=\"line\">var str = &apos;rgb(237,13,235)&apos;;</span><br><span class=\"line\">var result = str.match(/\\d+/g);</span><br><span class=\"line\">console.log(result);//输出[&quot;237&quot;, &quot;13&quot;, &quot;235&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建<br>如：<code>var re = /s$/;</code>这个正则表达式可以匹配以字符s结尾的字符串</p>\n<h3 id=\"1-字符类\"><a href=\"#1-字符类\" class=\"headerlink\" title=\"1.字符类\"></a>1.字符类</h3><p>把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。<br>如：<code>/[abc]/</code>与字母a、b、c中的任意一个都匹配。<br>常见字符类<br><code>[abc]</code>  方括号内任意字符<br><code>[^abc]</code>  不在方括号内的任意字符<br><code>.</code>  除换行符和其他Unicode行终止符之外的任意字符<br><code>\\w</code>  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]<br><code>\\W</code>  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]<br><code>\\s</code>  任何Unicode空白符<br><code>\\d</code>  任何ASCII数字</p>\n<h3 id=\"2-重复\"><a href=\"#2-重复\" class=\"headerlink\" title=\"2.重复\"></a>2.重复</h3><p><code>{n,m}</code>　匹配前一项至少n次，至多m次<br><code>{n,}</code> 　  匹配前一项n次或更多次<br><code>{n}</code>　　匹配前一项n次<br><code>?</code>　　　匹配前一项0次或1次<br><code>+</code>　　 匹配前一项1次或多次<br><code>*</code>　　  匹配前一项0次或多次</p>\n<p>栗子：<br><code>/\\d{2,4}/</code>  匹配2-4个数字<br><code>/\\w{3}\\d?</code>  匹配3个字符和一个可选的数字</p>\n<h3 id=\"3-分组\"><a href=\"#3-分组\" class=\"headerlink\" title=\"3.分组\"></a>3.分组</h3><p>字符”|“用于分隔供选择的字符，如<code>/ab|cd|ef/</code>可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。<br>圆括号”()”可用于把单独的项组合成子表达式</p>\n<h3 id=\"4-修饰符\"><a href=\"#4-修饰符\" class=\"headerlink\" title=\"4.修饰符\"></a>4.修饰符</h3><p>修饰符放在”/“之外，用语说明匹配模式。JavaScript支持三种修饰符<br>i    执行不区分大小写的匹配<br>g   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止<br>m  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束</p>\n<h3 id=\"5-指定匹配位置\"><a href=\"#5-指定匹配位置\" class=\"headerlink\" title=\"5.指定匹配位置\"></a>5.指定匹配位置</h3><p>^   匹配字符串的开头<br>$   匹配字符串的结尾<br>\\b  匹配单词的边界<br>(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配<br>(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配<br><code>/Java(?!Script)/g</code>匹配以“Java”开头，但接下来的字符不是“Script”的字符串</p>\n<h3 id=\"5-RegExp对象\"><a href=\"#5-RegExp对象\" class=\"headerlink\" title=\"5.RegExp对象\"></a>5.RegExp对象</h3><ul>\n<li>RegExp对象的属性<br>source：只读的字符串，包含正则表达式的源文本<br>lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。</li>\n<li>RegExp对象的方法<br>exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str = &apos;Hello World&apos;;</span><br><span class=\"line\">var re = /Wo/g;</span><br><span class=\"line\">var result = re.exec(str);</span><br><span class=\"line\">if(result != null)&#123;</span><br><span class=\"line\">    console.log(&apos;Find &apos;+result+&apos; at &apos;+result.index);//输出Find Wo at 6</span><br><span class=\"line\">    console.log(&apos;next search begin at &apos;+re.lastIndex);//输出next search begin at 8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>test():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false</p>\n<h3 id=\"6-支持正则表达式的String对象的方法\"><a href=\"#6-支持正则表达式的String对象的方法\" class=\"headerlink\" title=\"6.支持正则表达式的String对象的方法\"></a>6.支持正则表达式的String对象的方法</h3><p>String对象支持4种使用正则表达式的方法。</p>\n<ul>\n<li>search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。</li>\n<li><p>replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//将Lebron James替换为James Lebron</span><br><span class=\"line\">var name = &apos;Lebron James&apos;;</span><br><span class=\"line\">var result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,&apos;$2 $1&apos;);</span><br><span class=\"line\">console.log(result);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//匹配出字符串中的数字，将其保存到一个数组中</span><br><span class=\"line\">var str = &apos;rgb(237,13,235)&apos;;</span><br><span class=\"line\">var result = str.match(/\\d+/g);</span><br><span class=\"line\">console.log(result);//输出[&quot;237&quot;, &quot;13&quot;, &quot;235&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。</p>\n</li>\n</ul>\n"},{"title":"数组去重","date":"2016-03-21T09:42:35.000Z","_content":"话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于[JavaScript数组相关的知识](http://www.w3cplus.com/blog/tags/538.html),趁此机会整理了一些有关于JavaScript数组去重的方法。\n\n下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。\n### 双重循环去重 ###\n-----------\n这个方法使用了两个for循环做遍历。整个思路是：\n- 构建一个空数组用来存放去重后的数组\n- 外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比\n- 如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中\n\n代码如下:\n```\nArray.prototype.unique1 = function () { \n　// 构建一个新数组，存放结果 var newArray = [this[0]]; \n　// for循环，每次从原数组中取出一个元素 \n　// 用取出的元素循环与结果数组对比 \n　for (var i = 1; i < this.length; i++) { \n　　var repeat = false; \n　　for (var j=0; j < newArray.length; j++) { \n　　// 原数组取出的元素与结果数组元素相同 \n　　　if(this[i] == newArray[j]) { \n　　　　repeat = true; break; \n　　　} \n　　} \n　　if(!repeat) { \n　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　\n　　　newArray.push(this[i]);\n　　} \n　} \n　return newArray;\n}\n```\n假设我们有一个这样的数组：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique1(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5]\n```\n据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：\n```\nfunction test () { \n　var arr = []; \n　for (var i = 0; i < 1000000; i++) { 　　\n　　arr.push(Math.round(Math.random(i) * 10000)); \n　} \n　doTest(arr, 1);\n}\nfunction doTest(arr, n) { \n　var tStart = (new Date()).getTime(); \n　var re = arr.unique1(); \n　var tEnd = (new Date()).getTime(); \n　console.log('双重循环去重方法使用时间是:' + (tEnd - tStart) + 'ms'); \n　return re;\n}\ntest();\n```\n在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。\n\n上面的方法可以使用forEach()方法和indexOf()方法模拟实现：\n```\nfunction unique1() { \n　var newArray = []; \n　this.forEach(function (index) { \n　　if (newArray.indexOf(index) == -1) { \n　　　newArray.push(index); \n　　} \n　}); \n　return newArray;\n}\n```\n通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。\n### 排序遍历去重 ###\n-----------\n先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。\n```\nArray.prototype.unique2 = function () { \n　// 原数组先排序 \n　this.sort(); \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　for (var i = 1; i < this.length; i++) { \n　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 \n　　// 因为排序了，所以重复元素会在相邻位置 \n　　if(this[i] !== newArray[newArray.length - 1]) { \n　　　// 如果不同，将元素放到结果数组中 \n　　　newArray.push(this[i]); \n　　} \n　} \n　return newArray;\n}\n```\n\n例如：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique2(); // [\"1\", 1, 2, \"2\", 3, 32, 34, 4, 5, 56, \"a\", \"b\", \"c\"]\n```\n\n这种方法有两个特色：\n去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如'1'和1\n\n使用同样的方法，测试所费时间：1232ms。\n### 对象键值对法 ###\n---------\n这种去重方法实现思路是：\n创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比\n如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object\n对象中该属性名的值设置为1\n\n代码如下:\n```\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n运行前面的示例：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique3(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，不同的键可能会被误认为一样；例如： a[1]、a[\"1\"]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。\n\n除了上面几种方法，还有其他几种方法如下：\n```\n// 方法四\nArray.prototype.unique4 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 遍历是否有重复的值 \n　　for (j = i + 1; j < this.length; j++) { \n　　　// 如果有相同元素，自增i变量，跳出i的循环 \n　　　if(this[i] === this[j]) { \n　　　　j = ++i; \n　　　}　 \n　　} \n　　// 如果没有相同元素，将元素推入到结果数组中 　\n　　newArray.push(this[i]); \n　} \n　return newArray;\n}\n```\nChrome测试结果\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique4(); // [\"a\", 1, 3, 4, 56, 32, 34, 2, \"b\", \"c\", 5, \"1\", \"2\"]\n```\n同样的，1和'1'无法区分。\n```\n// 方法五\nArray.prototype.unique5 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 如果当前数组的第i值保存到临时数组，那么跳过 \n　　var index = this[i]; \n　　// 如果数组项不在结果数组中，将这个值推入结果数组中 \n　　if (newArray.indexOf(index) === -1) { \n　　　newArray.push(index); \n　　} \n　} \n　return newArray;\n}\n```\nChrome测试结果:\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，类似于1和'1'无法区分。所费时间：14361ms。\n```\n// 方法六\nArray.prototype.unique6 = function () { \n　return this.reduce(function (newArray, index) { 　　\n　　if(newArray.indexOf(index) < 0) { \n　　　newArray.push(index); \n　　} \n　　return newArray; \n　},[]);\n}\n```\n测试结果如下：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：16490ms。\n```\n// 方法七\nArray.prototype.unique7 = function(){ \n　var newArray; \n　newArray = this.filter(function (ele,i,arr) { \n　　return arr.indexOf(ele) === i; }); \n　　return newArray;\n}\n```\n测试结果：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：13201ms。\n方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：\n```\n//方法三\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n但在ES6去重还有更简单，更优化的方案，比如：\n```\n// ES6\nfunction unique (arr) { \n　const seen = new Map() \n　return arr.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n// or\nfunction unique (arr) { \n　return Array.from(new Set(arr))\n}\n```\n----------\n转载自：http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\n","source":"_posts/数组去重.md","raw":"---\ntitle: 数组去重\ndate: 2016-03-21 17:42:35\ntags:\n- JavaScript\n- 算法\ncategories:\n- 数据结构与算法\n---\n话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于[JavaScript数组相关的知识](http://www.w3cplus.com/blog/tags/538.html),趁此机会整理了一些有关于JavaScript数组去重的方法。\n\n下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。\n### 双重循环去重 ###\n-----------\n这个方法使用了两个for循环做遍历。整个思路是：\n- 构建一个空数组用来存放去重后的数组\n- 外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比\n- 如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中\n\n代码如下:\n```\nArray.prototype.unique1 = function () { \n　// 构建一个新数组，存放结果 var newArray = [this[0]]; \n　// for循环，每次从原数组中取出一个元素 \n　// 用取出的元素循环与结果数组对比 \n　for (var i = 1; i < this.length; i++) { \n　　var repeat = false; \n　　for (var j=0; j < newArray.length; j++) { \n　　// 原数组取出的元素与结果数组元素相同 \n　　　if(this[i] == newArray[j]) { \n　　　　repeat = true; break; \n　　　} \n　　} \n　　if(!repeat) { \n　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　\n　　　newArray.push(this[i]);\n　　} \n　} \n　return newArray;\n}\n```\n假设我们有一个这样的数组：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique1(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5]\n```\n据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：\n```\nfunction test () { \n　var arr = []; \n　for (var i = 0; i < 1000000; i++) { 　　\n　　arr.push(Math.round(Math.random(i) * 10000)); \n　} \n　doTest(arr, 1);\n}\nfunction doTest(arr, n) { \n　var tStart = (new Date()).getTime(); \n　var re = arr.unique1(); \n　var tEnd = (new Date()).getTime(); \n　console.log('双重循环去重方法使用时间是:' + (tEnd - tStart) + 'ms'); \n　return re;\n}\ntest();\n```\n在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。\n\n上面的方法可以使用forEach()方法和indexOf()方法模拟实现：\n```\nfunction unique1() { \n　var newArray = []; \n　this.forEach(function (index) { \n　　if (newArray.indexOf(index) == -1) { \n　　　newArray.push(index); \n　　} \n　}); \n　return newArray;\n}\n```\n通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。\n### 排序遍历去重 ###\n-----------\n先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。\n```\nArray.prototype.unique2 = function () { \n　// 原数组先排序 \n　this.sort(); \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　for (var i = 1; i < this.length; i++) { \n　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 \n　　// 因为排序了，所以重复元素会在相邻位置 \n　　if(this[i] !== newArray[newArray.length - 1]) { \n　　　// 如果不同，将元素放到结果数组中 \n　　　newArray.push(this[i]); \n　　} \n　} \n　return newArray;\n}\n```\n\n例如：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique2(); // [\"1\", 1, 2, \"2\", 3, 32, 34, 4, 5, 56, \"a\", \"b\", \"c\"]\n```\n\n这种方法有两个特色：\n去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如'1'和1\n\n使用同样的方法，测试所费时间：1232ms。\n### 对象键值对法 ###\n---------\n这种去重方法实现思路是：\n创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比\n如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object\n对象中该属性名的值设置为1\n\n代码如下:\n```\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n运行前面的示例：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique3(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，不同的键可能会被误认为一样；例如： a[1]、a[\"1\"]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。\n\n除了上面几种方法，还有其他几种方法如下：\n```\n// 方法四\nArray.prototype.unique4 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 遍历是否有重复的值 \n　　for (j = i + 1; j < this.length; j++) { \n　　　// 如果有相同元素，自增i变量，跳出i的循环 \n　　　if(this[i] === this[j]) { \n　　　　j = ++i; \n　　　}　 \n　　} \n　　// 如果没有相同元素，将元素推入到结果数组中 　\n　　newArray.push(this[i]); \n　} \n　return newArray;\n}\n```\nChrome测试结果\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique4(); // [\"a\", 1, 3, 4, 56, 32, 34, 2, \"b\", \"c\", 5, \"1\", \"2\"]\n```\n同样的，1和'1'无法区分。\n```\n// 方法五\nArray.prototype.unique5 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 如果当前数组的第i值保存到临时数组，那么跳过 \n　　var index = this[i]; \n　　// 如果数组项不在结果数组中，将这个值推入结果数组中 \n　　if (newArray.indexOf(index) === -1) { \n　　　newArray.push(index); \n　　} \n　} \n　return newArray;\n}\n```\nChrome测试结果:\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，类似于1和'1'无法区分。所费时间：14361ms。\n```\n// 方法六\nArray.prototype.unique6 = function () { \n　return this.reduce(function (newArray, index) { 　　\n　　if(newArray.indexOf(index) < 0) { \n　　　newArray.push(index); \n　　} \n　　return newArray; \n　},[]);\n}\n```\n测试结果如下：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：16490ms。\n```\n// 方法七\nArray.prototype.unique7 = function(){ \n　var newArray; \n　newArray = this.filter(function (ele,i,arr) { \n　　return arr.indexOf(ele) === i; }); \n　　return newArray;\n}\n```\n测试结果：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：13201ms。\n方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：\n```\n//方法三\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n但在ES6去重还有更简单，更优化的方案，比如：\n```\n// ES6\nfunction unique (arr) { \n　const seen = new Map() \n　return arr.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n// or\nfunction unique (arr) { \n　return Array.from(new Set(arr))\n}\n```\n----------\n转载自：http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\n","slug":"数组去重","published":1,"updated":"2016-03-21T09:45:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3w003k0pk371qz35yk","content":"<p>话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于<a href=\"http://www.w3cplus.com/blog/tags/538.html\" target=\"_blank\" rel=\"noopener\">JavaScript数组相关的知识</a>,趁此机会整理了一些有关于JavaScript数组去重的方法。</p>\n<p>下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。</p>\n<h3 id=\"双重循环去重\"><a href=\"#双重循环去重\" class=\"headerlink\" title=\"双重循环去重\"></a>双重循环去重</h3><hr>\n<p>这个方法使用了两个for循环做遍历。整个思路是：</p>\n<ul>\n<li>构建一个空数组用来存放去重后的数组</li>\n<li>外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比</li>\n<li>如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中</li>\n</ul>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique1 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组，存放结果 var newArray = [this[0]]; </span><br><span class=\"line\">　// for循环，每次从原数组中取出一个元素 </span><br><span class=\"line\">　// 用取出的元素循环与结果数组对比 </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　var repeat = false; </span><br><span class=\"line\">　　for (var j=0; j &lt; newArray.length; j++) &#123; </span><br><span class=\"line\">　　// 原数组取出的元素与结果数组元素相同 </span><br><span class=\"line\">　　　if(this[i] == newArray[j]) &#123; </span><br><span class=\"line\">　　　　repeat = true; break; </span><br><span class=\"line\">　　　&#125; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　if(!repeat) &#123; </span><br><span class=\"line\">　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　</span><br><span class=\"line\">　　　newArray.push(this[i]);</span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设我们有一个这样的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique1(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5]</span><br></pre></td></tr></table></figure></p>\n<p>据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123; </span><br><span class=\"line\">　var arr = []; </span><br><span class=\"line\">　for (var i = 0; i &lt; 1000000; i++) &#123; 　　</span><br><span class=\"line\">　　arr.push(Math.round(Math.random(i) * 10000)); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123; </span><br><span class=\"line\">　var tStart = (new Date()).getTime(); </span><br><span class=\"line\">　var re = arr.unique1(); </span><br><span class=\"line\">　var tEnd = (new Date()).getTime(); </span><br><span class=\"line\">　console.log(&apos;双重循环去重方法使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;); </span><br><span class=\"line\">　return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure></p>\n<p>在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。</p>\n<p>上面的方法可以使用forEach()方法和indexOf()方法模拟实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function unique1() &#123; </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　this.forEach(function (index) &#123; </span><br><span class=\"line\">　　if (newArray.indexOf(index) == -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125;); </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。</p>\n<h3 id=\"排序遍历去重\"><a href=\"#排序遍历去重\" class=\"headerlink\" title=\"排序遍历去重\"></a>排序遍历去重</h3><hr>\n<p>先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique2 = function () &#123; </span><br><span class=\"line\">　// 原数组先排序 </span><br><span class=\"line\">　this.sort(); </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 </span><br><span class=\"line\">　　// 因为排序了，所以重复元素会在相邻位置 </span><br><span class=\"line\">　　if(this[i] !== newArray[newArray.length - 1]) &#123; </span><br><span class=\"line\">　　　// 如果不同，将元素放到结果数组中 </span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique2(); // [&quot;1&quot;, 1, 2, &quot;2&quot;, 3, 32, 34, 4, 5, 56, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>这种方法有两个特色：<br>去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如’1’和1</p>\n<p>使用同样的方法，测试所费时间：1232ms。</p>\n<h3 id=\"对象键值对法\"><a href=\"#对象键值对法\" class=\"headerlink\" title=\"对象键值对法\"></a>对象键值对法</h3><hr>\n<p>这种去重方法实现思路是：<br>创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比<br>如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object<br>对象中该属性名的值设置为1</p>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行前面的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique3(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，不同的键可能会被误认为一样；例如： a[1]、a[“1”]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。</p>\n<p>除了上面几种方法，还有其他几种方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法四</span><br><span class=\"line\">Array.prototype.unique4 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 遍历是否有重复的值 </span><br><span class=\"line\">　　for (j = i + 1; j &lt; this.length; j++) &#123; </span><br><span class=\"line\">　　　// 如果有相同元素，自增i变量，跳出i的循环 </span><br><span class=\"line\">　　　if(this[i] === this[j]) &#123; </span><br><span class=\"line\">　　　　j = ++i; </span><br><span class=\"line\">　　　&#125;　 </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　// 如果没有相同元素，将元素推入到结果数组中 　</span><br><span class=\"line\">　　newArray.push(this[i]); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique4(); // [&quot;a&quot;, 1, 3, 4, 56, 32, 34, 2, &quot;b&quot;, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，1和’1’无法区分。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法五</span><br><span class=\"line\">Array.prototype.unique5 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 如果当前数组的第i值保存到临时数组，那么跳过 </span><br><span class=\"line\">　　var index = this[i]; </span><br><span class=\"line\">　　// 如果数组项不在结果数组中，将这个值推入结果数组中 </span><br><span class=\"line\">　　if (newArray.indexOf(index) === -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，类似于1和’1’无法区分。所费时间：14361ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法六</span><br><span class=\"line\">Array.prototype.unique6 = function () &#123; </span><br><span class=\"line\">　return this.reduce(function (newArray, index) &#123; 　　</span><br><span class=\"line\">　　if(newArray.indexOf(index) &lt; 0) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　return newArray; </span><br><span class=\"line\">　&#125;,[]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：16490ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法七</span><br><span class=\"line\">Array.prototype.unique7 = function()&#123; </span><br><span class=\"line\">　var newArray; </span><br><span class=\"line\">　newArray = this.filter(function (ele,i,arr) &#123; </span><br><span class=\"line\">　　return arr.indexOf(ele) === i; &#125;); </span><br><span class=\"line\">　　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：13201ms。<br>方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//方法三</span><br><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但在ES6去重还有更简单，更优化的方案，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ES6</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　const seen = new Map() </span><br><span class=\"line\">　return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// or</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　return Array.from(new Set(arr))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>转载自：<a href=\"http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\" target=\"_blank\" rel=\"noopener\">http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于<a href=\"http://www.w3cplus.com/blog/tags/538.html\" target=\"_blank\" rel=\"noopener\">JavaScript数组相关的知识</a>,趁此机会整理了一些有关于JavaScript数组去重的方法。</p>\n<p>下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。</p>\n<h3 id=\"双重循环去重\"><a href=\"#双重循环去重\" class=\"headerlink\" title=\"双重循环去重\"></a>双重循环去重</h3><hr>\n<p>这个方法使用了两个for循环做遍历。整个思路是：</p>\n<ul>\n<li>构建一个空数组用来存放去重后的数组</li>\n<li>外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比</li>\n<li>如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中</li>\n</ul>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique1 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组，存放结果 var newArray = [this[0]]; </span><br><span class=\"line\">　// for循环，每次从原数组中取出一个元素 </span><br><span class=\"line\">　// 用取出的元素循环与结果数组对比 </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　var repeat = false; </span><br><span class=\"line\">　　for (var j=0; j &lt; newArray.length; j++) &#123; </span><br><span class=\"line\">　　// 原数组取出的元素与结果数组元素相同 </span><br><span class=\"line\">　　　if(this[i] == newArray[j]) &#123; </span><br><span class=\"line\">　　　　repeat = true; break; </span><br><span class=\"line\">　　　&#125; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　if(!repeat) &#123; </span><br><span class=\"line\">　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　</span><br><span class=\"line\">　　　newArray.push(this[i]);</span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设我们有一个这样的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique1(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5]</span><br></pre></td></tr></table></figure></p>\n<p>据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123; </span><br><span class=\"line\">　var arr = []; </span><br><span class=\"line\">　for (var i = 0; i &lt; 1000000; i++) &#123; 　　</span><br><span class=\"line\">　　arr.push(Math.round(Math.random(i) * 10000)); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123; </span><br><span class=\"line\">　var tStart = (new Date()).getTime(); </span><br><span class=\"line\">　var re = arr.unique1(); </span><br><span class=\"line\">　var tEnd = (new Date()).getTime(); </span><br><span class=\"line\">　console.log(&apos;双重循环去重方法使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;); </span><br><span class=\"line\">　return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure></p>\n<p>在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。</p>\n<p>上面的方法可以使用forEach()方法和indexOf()方法模拟实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function unique1() &#123; </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　this.forEach(function (index) &#123; </span><br><span class=\"line\">　　if (newArray.indexOf(index) == -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125;); </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。</p>\n<h3 id=\"排序遍历去重\"><a href=\"#排序遍历去重\" class=\"headerlink\" title=\"排序遍历去重\"></a>排序遍历去重</h3><hr>\n<p>先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique2 = function () &#123; </span><br><span class=\"line\">　// 原数组先排序 </span><br><span class=\"line\">　this.sort(); </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 </span><br><span class=\"line\">　　// 因为排序了，所以重复元素会在相邻位置 </span><br><span class=\"line\">　　if(this[i] !== newArray[newArray.length - 1]) &#123; </span><br><span class=\"line\">　　　// 如果不同，将元素放到结果数组中 </span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique2(); // [&quot;1&quot;, 1, 2, &quot;2&quot;, 3, 32, 34, 4, 5, 56, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>这种方法有两个特色：<br>去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如’1’和1</p>\n<p>使用同样的方法，测试所费时间：1232ms。</p>\n<h3 id=\"对象键值对法\"><a href=\"#对象键值对法\" class=\"headerlink\" title=\"对象键值对法\"></a>对象键值对法</h3><hr>\n<p>这种去重方法实现思路是：<br>创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比<br>如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object<br>对象中该属性名的值设置为1</p>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行前面的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique3(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，不同的键可能会被误认为一样；例如： a[1]、a[“1”]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。</p>\n<p>除了上面几种方法，还有其他几种方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法四</span><br><span class=\"line\">Array.prototype.unique4 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 遍历是否有重复的值 </span><br><span class=\"line\">　　for (j = i + 1; j &lt; this.length; j++) &#123; </span><br><span class=\"line\">　　　// 如果有相同元素，自增i变量，跳出i的循环 </span><br><span class=\"line\">　　　if(this[i] === this[j]) &#123; </span><br><span class=\"line\">　　　　j = ++i; </span><br><span class=\"line\">　　　&#125;　 </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　// 如果没有相同元素，将元素推入到结果数组中 　</span><br><span class=\"line\">　　newArray.push(this[i]); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique4(); // [&quot;a&quot;, 1, 3, 4, 56, 32, 34, 2, &quot;b&quot;, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，1和’1’无法区分。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法五</span><br><span class=\"line\">Array.prototype.unique5 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 如果当前数组的第i值保存到临时数组，那么跳过 </span><br><span class=\"line\">　　var index = this[i]; </span><br><span class=\"line\">　　// 如果数组项不在结果数组中，将这个值推入结果数组中 </span><br><span class=\"line\">　　if (newArray.indexOf(index) === -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，类似于1和’1’无法区分。所费时间：14361ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法六</span><br><span class=\"line\">Array.prototype.unique6 = function () &#123; </span><br><span class=\"line\">　return this.reduce(function (newArray, index) &#123; 　　</span><br><span class=\"line\">　　if(newArray.indexOf(index) &lt; 0) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　return newArray; </span><br><span class=\"line\">　&#125;,[]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：16490ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法七</span><br><span class=\"line\">Array.prototype.unique7 = function()&#123; </span><br><span class=\"line\">　var newArray; </span><br><span class=\"line\">　newArray = this.filter(function (ele,i,arr) &#123; </span><br><span class=\"line\">　　return arr.indexOf(ele) === i; &#125;); </span><br><span class=\"line\">　　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：13201ms。<br>方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//方法三</span><br><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但在ES6去重还有更简单，更优化的方案，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ES6</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　const seen = new Map() </span><br><span class=\"line\">　return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// or</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　return Array.from(new Set(arr))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>转载自：<a href=\"http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\" target=\"_blank\" rel=\"noopener\">http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html</a></p>\n"},{"title":"深入理解BFC","date":"2016-03-09T07:56:53.000Z","_content":"### BFC的定义 ###\n先看W3C文档\n> In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the['margin'](https://www.w3.org/TR/CSS2/box.html#propdef-margin) properties. Vertical margins between adjacent block-level boxes in a block formatting context [collapse](https://www.w3.org/TR/CSS2/box.html#collapsing-margins).\n\n>In a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's *line boxes* may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself [*may* become narrower](https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float) due to the floats).\n\nBlock Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。\n\n文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。\n\n通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n### 如何创建BFC ###\n再来看一下官方文档怎么说的\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n总结一下就是：\n- float属性不为none\n- overflow不为visible(可以是hidden、scroll、auto)\n- position为absolute或fixed\n- display为inline-block、table-cell、table-caption\n\n### BFC的作用\n**1. 清除内部浮动**\n我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。\n**2. 垂直margin合并**\n在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n折叠的结果：\n - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n - 两个外边距一正一负时，折叠结果是两者的相加的和。\n这个同样可以利用BFC解决。关于原理在前文已经讲过了。\n\n**3. 创建自适应两栏布局**\n在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。\n```\n//CSS\n*{\n        margin: 0;\n        padding: 0;\n    }\n    .box {\n        width:300px;\n        border: 1px solid #000;\n    }\n    .img {\n        float: left;\n    }\n    .info {\n        background: #f1f1f1;\n        color: #222;\n    }\n//HTML\n<\\div class=\"box\">\n        <\\img src=\"03.jpg\" alt=\"\" class=\"img\">\n        <\\p class=\"info\">信息信息信息信息信息信息</p>\n    </\\div>\n```\n一般情况下，它是这样的\n\n![图1](http://upload-images.jianshu.io/upload_images/192464-7422273b46506f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但是当文字多了以后...\n\n\n![图2](http://upload-images.jianshu.io/upload_images/192464-47f55b6a8de7b3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上overflow:hidden\n![图3](http://upload-images.jianshu.io/upload_images/192464-b2e09148be9db84c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n两栏布局就完成了。我们改变图片的大小：\n![图4](http://upload-images.jianshu.io/upload_images/192464-2620aa5e31bd83f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。\n\n参考链接：\n  [Visual formatting model](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)\n  [CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/?p=4588)","source":"_posts/深入理解BFC.md","raw":"---\ntitle: 深入理解BFC\ndate: 2016-03-09 15:56:53\ntags: \n- CSS\ncategories: \n- 前端\n---\n### BFC的定义 ###\n先看W3C文档\n> In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the['margin'](https://www.w3.org/TR/CSS2/box.html#propdef-margin) properties. Vertical margins between adjacent block-level boxes in a block formatting context [collapse](https://www.w3.org/TR/CSS2/box.html#collapsing-margins).\n\n>In a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's *line boxes* may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself [*may* become narrower](https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float) due to the floats).\n\nBlock Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。\n\n文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。\n\n通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n### 如何创建BFC ###\n再来看一下官方文档怎么说的\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n总结一下就是：\n- float属性不为none\n- overflow不为visible(可以是hidden、scroll、auto)\n- position为absolute或fixed\n- display为inline-block、table-cell、table-caption\n\n### BFC的作用\n**1. 清除内部浮动**\n我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。\n**2. 垂直margin合并**\n在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n折叠的结果：\n - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n - 两个外边距一正一负时，折叠结果是两者的相加的和。\n这个同样可以利用BFC解决。关于原理在前文已经讲过了。\n\n**3. 创建自适应两栏布局**\n在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。\n```\n//CSS\n*{\n        margin: 0;\n        padding: 0;\n    }\n    .box {\n        width:300px;\n        border: 1px solid #000;\n    }\n    .img {\n        float: left;\n    }\n    .info {\n        background: #f1f1f1;\n        color: #222;\n    }\n//HTML\n<\\div class=\"box\">\n        <\\img src=\"03.jpg\" alt=\"\" class=\"img\">\n        <\\p class=\"info\">信息信息信息信息信息信息</p>\n    </\\div>\n```\n一般情况下，它是这样的\n\n![图1](http://upload-images.jianshu.io/upload_images/192464-7422273b46506f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但是当文字多了以后...\n\n\n![图2](http://upload-images.jianshu.io/upload_images/192464-47f55b6a8de7b3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上overflow:hidden\n![图3](http://upload-images.jianshu.io/upload_images/192464-b2e09148be9db84c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n两栏布局就完成了。我们改变图片的大小：\n![图4](http://upload-images.jianshu.io/upload_images/192464-2620aa5e31bd83f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。\n\n参考链接：\n  [Visual formatting model](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)\n  [CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/?p=4588)","slug":"深入理解BFC","published":1,"updated":"2016-03-10T11:56:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko3y003o0pk31zn08t1u","content":"<h3 id=\"BFC的定义\"><a href=\"#BFC的定义\" class=\"headerlink\" title=\"BFC的定义\"></a>BFC的定义</h3><p>先看W3C文档</p>\n<blockquote>\n<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the<a href=\"https://www.w3.org/TR/CSS2/box.html#propdef-margin\" target=\"_blank\" rel=\"noopener\">‘margin’</a> properties. Vertical margins between adjacent block-level boxes in a block formatting context <a href=\"https://www.w3.org/TR/CSS2/box.html#collapsing-margins\" target=\"_blank\" rel=\"noopener\">collapse</a>.</p>\n<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s <em>line boxes</em> may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself <a href=\"https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float\" target=\"_blank\" rel=\"noopener\"><em>may</em> become narrower</a> due to the floats).</p>\n</blockquote>\n<p>Block Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。</p>\n<p>文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。</p>\n<p>通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h3 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h3><p>再来看一下官方文档怎么说的</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>总结一下就是：</p>\n<ul>\n<li>float属性不为none</li>\n<li>overflow不为visible(可以是hidden、scroll、auto)</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block、table-cell、table-caption</li>\n</ul>\n<h3 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h3><p><strong>1. 清除内部浮动</strong><br>我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。<br><strong>2. 垂直margin合并</strong><br>在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br>折叠的结果：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。<br>这个同样可以利用BFC解决。关于原理在前文已经讲过了。</li>\n</ul>\n<p><strong>3. 创建自适应两栏布局</strong><br>在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//CSS</span><br><span class=\"line\">*&#123;</span><br><span class=\"line\">        margin: 0;</span><br><span class=\"line\">        padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .box &#123;</span><br><span class=\"line\">        width:300px;</span><br><span class=\"line\">        border: 1px solid #000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .img &#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .info &#123;</span><br><span class=\"line\">        background: #f1f1f1;</span><br><span class=\"line\">        color: #222;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//HTML</span><br><span class=\"line\">&lt;\\div class=&quot;box&quot;&gt;</span><br><span class=\"line\">        &lt;\\img src=&quot;03.jpg&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;</span><br><span class=\"line\">        &lt;\\p class=&quot;info&quot;&gt;信息信息信息信息信息信息&lt;/p&gt;</span><br><span class=\"line\">    &lt;/\\div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>一般情况下，它是这样的</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-7422273b46506f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1\"></p>\n<p>但是当文字多了以后…</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-47f55b6a8de7b3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图2\"></p>\n<p>显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上overflow:hidden<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-b2e09148be9db84c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图3\"></p>\n<p>两栏布局就完成了。我们改变图片的大小：<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-2620aa5e31bd83f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图4\"><br>两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。</p>\n<p>参考链接：<br>  <a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\" target=\"_blank\" rel=\"noopener\">Visual formatting model</a><br>  <a href=\"http://www.zhangxinxu.com/wordpress/?p=4588\" target=\"_blank\" rel=\"noopener\">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"BFC的定义\"><a href=\"#BFC的定义\" class=\"headerlink\" title=\"BFC的定义\"></a>BFC的定义</h3><p>先看W3C文档</p>\n<blockquote>\n<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the<a href=\"https://www.w3.org/TR/CSS2/box.html#propdef-margin\" target=\"_blank\" rel=\"noopener\">‘margin’</a> properties. Vertical margins between adjacent block-level boxes in a block formatting context <a href=\"https://www.w3.org/TR/CSS2/box.html#collapsing-margins\" target=\"_blank\" rel=\"noopener\">collapse</a>.</p>\n<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s <em>line boxes</em> may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself <a href=\"https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float\" target=\"_blank\" rel=\"noopener\"><em>may</em> become narrower</a> due to the floats).</p>\n</blockquote>\n<p>Block Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。</p>\n<p>文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。</p>\n<p>通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h3 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h3><p>再来看一下官方文档怎么说的</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>总结一下就是：</p>\n<ul>\n<li>float属性不为none</li>\n<li>overflow不为visible(可以是hidden、scroll、auto)</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block、table-cell、table-caption</li>\n</ul>\n<h3 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h3><p><strong>1. 清除内部浮动</strong><br>我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。<br><strong>2. 垂直margin合并</strong><br>在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br>折叠的结果：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。<br>这个同样可以利用BFC解决。关于原理在前文已经讲过了。</li>\n</ul>\n<p><strong>3. 创建自适应两栏布局</strong><br>在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//CSS</span><br><span class=\"line\">*&#123;</span><br><span class=\"line\">        margin: 0;</span><br><span class=\"line\">        padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .box &#123;</span><br><span class=\"line\">        width:300px;</span><br><span class=\"line\">        border: 1px solid #000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .img &#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .info &#123;</span><br><span class=\"line\">        background: #f1f1f1;</span><br><span class=\"line\">        color: #222;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//HTML</span><br><span class=\"line\">&lt;\\div class=&quot;box&quot;&gt;</span><br><span class=\"line\">        &lt;\\img src=&quot;03.jpg&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;</span><br><span class=\"line\">        &lt;\\p class=&quot;info&quot;&gt;信息信息信息信息信息信息&lt;/p&gt;</span><br><span class=\"line\">    &lt;/\\div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>一般情况下，它是这样的</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-7422273b46506f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1\"></p>\n<p>但是当文字多了以后…</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-47f55b6a8de7b3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图2\"></p>\n<p>显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上overflow:hidden<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-b2e09148be9db84c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图3\"></p>\n<p>两栏布局就完成了。我们改变图片的大小：<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-2620aa5e31bd83f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图4\"><br>两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。</p>\n<p>参考链接：<br>  <a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\" target=\"_blank\" rel=\"noopener\">Visual formatting model</a><br>  <a href=\"http://www.zhangxinxu.com/wordpress/?p=4588\" target=\"_blank\" rel=\"noopener\">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p>\n"},{"title":"类数组转换为数组","date":"2016-05-02T13:51:06.000Z","_content":"一、什么是类数组对象\n**1.特征**\n特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数\n特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法\n**2.常见的类数组对象**\n```\ndocument.getElementsByClassName()\ndocument.getElementsByTagName()\ndocument.getElementsByName()\ndocument.querySelectorAll()\ndocument.stylesheets\nparentNode.childNodes\narguments\nvar arrayObj = {\n  0 : 'Benjamin01'\n  1 : 'Benjmain02'\n  length : 2\n};\n```\n**3.转换为数组对象**\nslice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。\n ```\nfunction convertArray(nodeList){\n    var arr = []\n    if(Array.prototype.slice){\n        arr = [].slice.call(nodeList);\n    }else{\n        for(var i=0,len = nodeList.length;i < len;i++){\n            arr.push(nodeList[i]);\n        }\n    }\n    return arr;    \n}\n```\n\n","source":"_posts/类数组转换为数组.md","raw":"---\ntitle: 类数组转换为数组\ndate: 2016-05-02 21:51:06\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n一、什么是类数组对象\n**1.特征**\n特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数\n特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法\n**2.常见的类数组对象**\n```\ndocument.getElementsByClassName()\ndocument.getElementsByTagName()\ndocument.getElementsByName()\ndocument.querySelectorAll()\ndocument.stylesheets\nparentNode.childNodes\narguments\nvar arrayObj = {\n  0 : 'Benjamin01'\n  1 : 'Benjmain02'\n  length : 2\n};\n```\n**3.转换为数组对象**\nslice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。\n ```\nfunction convertArray(nodeList){\n    var arr = []\n    if(Array.prototype.slice){\n        arr = [].slice.call(nodeList);\n    }else{\n        for(var i=0,len = nodeList.length;i < len;i++){\n            arr.push(nodeList[i]);\n        }\n    }\n    return arr;    \n}\n```\n\n","slug":"类数组转换为数组","published":1,"updated":"2016-05-02T13:51:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko41003r0pk3dyyxohaf","content":"<p>一、什么是类数组对象<br><strong>1.特征</strong><br>特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数<br>特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法<br><strong>2.常见的类数组对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">document.getElementsByClassName()</span><br><span class=\"line\">document.getElementsByTagName()</span><br><span class=\"line\">document.getElementsByName()</span><br><span class=\"line\">document.querySelectorAll()</span><br><span class=\"line\">document.stylesheets</span><br><span class=\"line\">parentNode.childNodes</span><br><span class=\"line\">arguments</span><br><span class=\"line\">var arrayObj = &#123;</span><br><span class=\"line\">  0 : &apos;Benjamin01&apos;</span><br><span class=\"line\">  1 : &apos;Benjmain02&apos;</span><br><span class=\"line\">  length : 2</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3.转换为数组对象</strong><br>slice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function convertArray(nodeList)&#123;</span><br><span class=\"line\">    var arr = []</span><br><span class=\"line\">    if(Array.prototype.slice)&#123;</span><br><span class=\"line\">        arr = [].slice.call(nodeList);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        for(var i=0,len = nodeList.length;i &lt; len;i++)&#123;</span><br><span class=\"line\">            arr.push(nodeList[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、什么是类数组对象<br><strong>1.特征</strong><br>特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数<br>特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法<br><strong>2.常见的类数组对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">document.getElementsByClassName()</span><br><span class=\"line\">document.getElementsByTagName()</span><br><span class=\"line\">document.getElementsByName()</span><br><span class=\"line\">document.querySelectorAll()</span><br><span class=\"line\">document.stylesheets</span><br><span class=\"line\">parentNode.childNodes</span><br><span class=\"line\">arguments</span><br><span class=\"line\">var arrayObj = &#123;</span><br><span class=\"line\">  0 : &apos;Benjamin01&apos;</span><br><span class=\"line\">  1 : &apos;Benjmain02&apos;</span><br><span class=\"line\">  length : 2</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3.转换为数组对象</strong><br>slice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function convertArray(nodeList)&#123;</span><br><span class=\"line\">    var arr = []</span><br><span class=\"line\">    if(Array.prototype.slice)&#123;</span><br><span class=\"line\">        arr = [].slice.call(nodeList);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        for(var i=0,len = nodeList.length;i &lt; len;i++)&#123;</span><br><span class=\"line\">            arr.push(nodeList[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"网站性能优化的14条规则","date":"2016-03-15T16:10:13.000Z","_content":"**1.减少HTTP请求**\n　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。\n\n**2.使用CDN（内容发布网络）**\n　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。\n\n**3.添加Expires头**\n　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。\n\n**4.启用Gzip**\n　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。\n\n**5.将CSS放在顶部**\n　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。\n\n**6.将脚本放在底部**\n　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。\n\n**7.避免CSS表达式**\n　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。\n\n**8.使用外部JavaScript和CSS**\n　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。\n\n**9.减少DNS查询**\n　　通过使用Keep-Alive和较少的域名可以减少DNS查询\n\n**10.精简JavaScript和CSS**\n　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。\n\n**11.避免重定向**\n　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。\n\n**12.移除重复脚本**\n**13.配置ETag**\n　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。\n\n**14.缓存Ajax**\n　　确保Ajax请求具有长久的Expires头","source":"_posts/网站性能优化的14条规则.md","raw":"---\ntitle: 网站性能优化的14条规则\ndate: 2016-03-16 00:10:13\ntags:\n- 性能优化\ncategories: \n- 前端\n---\n**1.减少HTTP请求**\n　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。\n\n**2.使用CDN（内容发布网络）**\n　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。\n\n**3.添加Expires头**\n　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。\n\n**4.启用Gzip**\n　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。\n\n**5.将CSS放在顶部**\n　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。\n\n**6.将脚本放在底部**\n　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。\n\n**7.避免CSS表达式**\n　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。\n\n**8.使用外部JavaScript和CSS**\n　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。\n\n**9.减少DNS查询**\n　　通过使用Keep-Alive和较少的域名可以减少DNS查询\n\n**10.精简JavaScript和CSS**\n　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。\n\n**11.避免重定向**\n　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。\n\n**12.移除重复脚本**\n**13.配置ETag**\n　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。\n\n**14.缓存Ajax**\n　　确保Ajax请求具有长久的Expires头","slug":"网站性能优化的14条规则","published":1,"updated":"2016-03-15T16:11:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko43003u0pk3qu75t30w","content":"<p><strong>1.减少HTTP请求</strong><br>　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。</p>\n<p><strong>2.使用CDN（内容发布网络）</strong><br>　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。</p>\n<p><strong>3.添加Expires头</strong><br>　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。</p>\n<p><strong>4.启用Gzip</strong><br>　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。</p>\n<p><strong>5.将CSS放在顶部</strong><br>　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。</p>\n<p><strong>6.将脚本放在底部</strong><br>　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。</p>\n<p><strong>7.避免CSS表达式</strong><br>　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。</p>\n<p><strong>8.使用外部JavaScript和CSS</strong><br>　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。</p>\n<p><strong>9.减少DNS查询</strong><br>　　通过使用Keep-Alive和较少的域名可以减少DNS查询</p>\n<p><strong>10.精简JavaScript和CSS</strong><br>　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。</p>\n<p><strong>11.避免重定向</strong><br>　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。</p>\n<p><strong>12.移除重复脚本</strong><br><strong>13.配置ETag</strong><br>　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。</p>\n<p><strong>14.缓存Ajax</strong><br>　　确保Ajax请求具有长久的Expires头</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>1.减少HTTP请求</strong><br>　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。</p>\n<p><strong>2.使用CDN（内容发布网络）</strong><br>　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。</p>\n<p><strong>3.添加Expires头</strong><br>　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。</p>\n<p><strong>4.启用Gzip</strong><br>　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。</p>\n<p><strong>5.将CSS放在顶部</strong><br>　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。</p>\n<p><strong>6.将脚本放在底部</strong><br>　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。</p>\n<p><strong>7.避免CSS表达式</strong><br>　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。</p>\n<p><strong>8.使用外部JavaScript和CSS</strong><br>　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。</p>\n<p><strong>9.减少DNS查询</strong><br>　　通过使用Keep-Alive和较少的域名可以减少DNS查询</p>\n<p><strong>10.精简JavaScript和CSS</strong><br>　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。</p>\n<p><strong>11.避免重定向</strong><br>　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。</p>\n<p><strong>12.移除重复脚本</strong><br><strong>13.配置ETag</strong><br>　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。</p>\n<p><strong>14.缓存Ajax</strong><br>　　确保Ajax请求具有长久的Expires头</p>\n"},{"title":"自定义复选框","date":"2016-05-18T05:47:27.000Z","_content":">思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。\n<!-- more -->\nHTML结构如下：\n```\n<input type=\"checkbox\" id=\"awesome\">\n<label for=\"awesome\">Awesome!</label>\n```\n首先，生成一个伪元素，先给这个伪元素添加一些样式。\n```\ninput[type=\"checkbox\"] + label::before{\n    content: '\\a0'; /*不换行空格*/\n    display: inline-block;\n    vertical-align: .2em;\n    width: .8em;\n    height: .8em;\n    margin-right: .2em;\n    border-radius: .2em;\n    background: silver;\n    text-indent: .15em;\n    line-height: .65;\n}\n```\n\n![左边是原生复选框，右边是经过我们初步自定义的复选框](/uploads/checkbox_1.png)\n然后给伪元素添加勾选状态下的样式\n```\ninput[type=\"checkbox\"]:checked + label::before{\n    content: '\\2713';\n    background: yellowgreen;\n}\n```\n\n![为伪元素添加选中状态下的样式](/uploads/checkbox_2.png)\n这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：\n```\ninput[type=\"checkbox\"]{\n    position: absolute;\n    clip:rect(0,0,0,0);\n}\n```\n这时候，我们自定义的复选框就已经完成了。\n\n![接近完成](/uploads/checkbox_3.png)\n\n最后，可以给这个复选框再加上聚焦和禁用状态下的样式。\n```\ninput[type=\"checkbox\"]:focus + label::before{\n    box-shadow: 0 0 .1em .1em #58a;\n}\ninput[type=\"checkbox\"]:disabled + label::before{\n    background: gray;\n    box-shadow: none;\n    color: #555;\n}\n```\n![最终效果](/uploads/checkbox_4.png)\n\n---------------\n参考：[《CSS揭秘》](http://www.ituring.com.cn/book/1695)\n","source":"_posts/自定义复选框.md","raw":"---\ntitle: 自定义复选框\ndate: 2016-05-18 13:47:27\ntags:\n- CSS\ncategories:\n- 前端\n---\n>思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。\n<!-- more -->\nHTML结构如下：\n```\n<input type=\"checkbox\" id=\"awesome\">\n<label for=\"awesome\">Awesome!</label>\n```\n首先，生成一个伪元素，先给这个伪元素添加一些样式。\n```\ninput[type=\"checkbox\"] + label::before{\n    content: '\\a0'; /*不换行空格*/\n    display: inline-block;\n    vertical-align: .2em;\n    width: .8em;\n    height: .8em;\n    margin-right: .2em;\n    border-radius: .2em;\n    background: silver;\n    text-indent: .15em;\n    line-height: .65;\n}\n```\n\n![左边是原生复选框，右边是经过我们初步自定义的复选框](/uploads/checkbox_1.png)\n然后给伪元素添加勾选状态下的样式\n```\ninput[type=\"checkbox\"]:checked + label::before{\n    content: '\\2713';\n    background: yellowgreen;\n}\n```\n\n![为伪元素添加选中状态下的样式](/uploads/checkbox_2.png)\n这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：\n```\ninput[type=\"checkbox\"]{\n    position: absolute;\n    clip:rect(0,0,0,0);\n}\n```\n这时候，我们自定义的复选框就已经完成了。\n\n![接近完成](/uploads/checkbox_3.png)\n\n最后，可以给这个复选框再加上聚焦和禁用状态下的样式。\n```\ninput[type=\"checkbox\"]:focus + label::before{\n    box-shadow: 0 0 .1em .1em #58a;\n}\ninput[type=\"checkbox\"]:disabled + label::before{\n    background: gray;\n    box-shadow: none;\n    color: #555;\n}\n```\n![最终效果](/uploads/checkbox_4.png)\n\n---------------\n参考：[《CSS揭秘》](http://www.ituring.com.cn/book/1695)\n","slug":"自定义复选框","published":1,"updated":"2016-09-04T08:41:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko45003y0pk3oi2kqi14","content":"<blockquote>\n<p>思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。<br><a id=\"more\"></a><br>HTML结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>首先，生成一个伪元素，先给这个伪元素添加一些样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;] + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\a0&apos;; /*不换行空格*/</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: .2em;</span><br><span class=\"line\">    width: .8em;</span><br><span class=\"line\">    height: .8em;</span><br><span class=\"line\">    margin-right: .2em;</span><br><span class=\"line\">    border-radius: .2em;</span><br><span class=\"line\">    background: silver;</span><br><span class=\"line\">    text-indent: .15em;</span><br><span class=\"line\">    line-height: .65;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/uploads/checkbox_1.png\" alt=\"左边是原生复选框，右边是经过我们初步自定义的复选框\"><br>然后给伪元素添加勾选状态下的样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:checked + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\2713&apos;;</span><br><span class=\"line\">    background: yellowgreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/uploads/checkbox_2.png\" alt=\"为伪元素添加选中状态下的样式\"><br>这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]&#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    clip:rect(0,0,0,0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候，我们自定义的复选框就已经完成了。</p>\n<p><img src=\"/uploads/checkbox_3.png\" alt=\"接近完成\"></p>\n<p>最后，可以给这个复选框再加上聚焦和禁用状态下的样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:focus + label::before&#123;</span><br><span class=\"line\">    box-shadow: 0 0 .1em .1em #58a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input[type=&quot;checkbox&quot;]:disabled + label::before&#123;</span><br><span class=\"line\">    background: gray;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">    color: #555;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/uploads/checkbox_4.png\" alt=\"最终效果\"></p>\n<hr>\n<p>参考：<a href=\"http://www.ituring.com.cn/book/1695\" target=\"_blank\" rel=\"noopener\">《CSS揭秘》</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。<br>","more":"<br>HTML结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>首先，生成一个伪元素，先给这个伪元素添加一些样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;] + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\a0&apos;; /*不换行空格*/</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: .2em;</span><br><span class=\"line\">    width: .8em;</span><br><span class=\"line\">    height: .8em;</span><br><span class=\"line\">    margin-right: .2em;</span><br><span class=\"line\">    border-radius: .2em;</span><br><span class=\"line\">    background: silver;</span><br><span class=\"line\">    text-indent: .15em;</span><br><span class=\"line\">    line-height: .65;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/uploads/checkbox_1.png\" alt=\"左边是原生复选框，右边是经过我们初步自定义的复选框\"><br>然后给伪元素添加勾选状态下的样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:checked + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\2713&apos;;</span><br><span class=\"line\">    background: yellowgreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/uploads/checkbox_2.png\" alt=\"为伪元素添加选中状态下的样式\"><br>这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]&#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    clip:rect(0,0,0,0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候，我们自定义的复选框就已经完成了。</p>\n<p><img src=\"/uploads/checkbox_3.png\" alt=\"接近完成\"></p>\n<p>最后，可以给这个复选框再加上聚焦和禁用状态下的样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:focus + label::before&#123;</span><br><span class=\"line\">    box-shadow: 0 0 .1em .1em #58a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input[type=&quot;checkbox&quot;]:disabled + label::before&#123;</span><br><span class=\"line\">    background: gray;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">    color: #555;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/uploads/checkbox_4.png\" alt=\"最终效果\"></p>\n<hr>\n<p>参考：<a href=\"http://www.ituring.com.cn/book/1695\" target=\"_blank\" rel=\"noopener\">《CSS揭秘》</a></p>"},{"title":"网页渲染中的重绘与重排","date":"2016-03-06T12:18:55.000Z","_content":"重绘\n\n当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。\n\n重排\n\n当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：\n\n- DOM操作（元素添加，删除，修改，或者元素顺序的改变）;\n- 内容变化，包括表单域内的文本改变;\n- CSS属性的计算或改变;\n- 添加或删除样式表;\n- 更改“类”的属性;\n- 浏览器窗口的操作（缩放，滚动）;\n- 伪类激活（：悬停）。\n","source":"_posts/网页渲染中的重绘与重排.md","raw":"---\ntitle: 网页渲染中的重绘与重排\ndate: 2016-03-06 20:18:55\ntags:\n- 浏览器\ncategories:\n- 前端\n---\n重绘\n\n当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。\n\n重排\n\n当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：\n\n- DOM操作（元素添加，删除，修改，或者元素顺序的改变）;\n- 内容变化，包括表单域内的文本改变;\n- CSS属性的计算或改变;\n- 添加或删除样式表;\n- 更改“类”的属性;\n- 浏览器窗口的操作（缩放，滚动）;\n- 伪类激活（：悬停）。\n","slug":"网页渲染中的重绘与重排","published":1,"updated":"2017-02-05T05:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko4600410pk31ke2ebqy","content":"<p>重绘</p>\n<p>当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。</p>\n<p>重排</p>\n<p>当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：</p>\n<ul>\n<li>DOM操作（元素添加，删除，修改，或者元素顺序的改变）;</li>\n<li>内容变化，包括表单域内的文本改变;</li>\n<li>CSS属性的计算或改变;</li>\n<li>添加或删除样式表;</li>\n<li>更改“类”的属性;</li>\n<li>浏览器窗口的操作（缩放，滚动）;</li>\n<li>伪类激活（：悬停）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>重绘</p>\n<p>当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。</p>\n<p>重排</p>\n<p>当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：</p>\n<ul>\n<li>DOM操作（元素添加，删除，修改，或者元素顺序的改变）;</li>\n<li>内容变化，包括表单域内的文本改变;</li>\n<li>CSS属性的计算或改变;</li>\n<li>添加或删除样式表;</li>\n<li>更改“类”的属性;</li>\n<li>浏览器窗口的操作（缩放，滚动）;</li>\n<li>伪类激活（：悬停）。</li>\n</ul>\n"},{"title":"让Ajax支持浏览器的前进后退","date":"2016-04-30T17:13:43.000Z","_content":"> 众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。\n\n<!-- more -->\n来看看这几个API\n1. **history.pushState(state, title, url)**\npushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.\n2. **window.onpopstate**\n用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。\n3. **history.replaceState(state,title,url)**\n用新的state和URL替换当前。不会造成页面刷新。\nstate：与要跳转到的URL对应的状态信息。\ntitle：标题\nurl：要跳转到的URL地址，不能跨域。\n\n实现原理如下：\n- 每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。\n- 浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。\n- 页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。\n\n除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。\n\n-------------------\n欢迎关注我博客:http://voidman.xyz\n","source":"_posts/让Ajax支持浏览器的前进后退.md","raw":"---\ntitle: 让Ajax支持浏览器的前进后退\ndate: 2016-05-01 01:13:43\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> 众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。\n\n<!-- more -->\n来看看这几个API\n1. **history.pushState(state, title, url)**\npushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.\n2. **window.onpopstate**\n用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。\n3. **history.replaceState(state,title,url)**\n用新的state和URL替换当前。不会造成页面刷新。\nstate：与要跳转到的URL对应的状态信息。\ntitle：标题\nurl：要跳转到的URL地址，不能跨域。\n\n实现原理如下：\n- 每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。\n- 浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。\n- 页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。\n\n除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。\n\n-------------------\n欢迎关注我博客:http://voidman.xyz\n","slug":"让Ajax支持浏览器的前进后退","published":1,"updated":"2017-02-05T05:28:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko4800450pk3ggpckh6u","content":"<blockquote>\n<p>众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>来看看这几个API</p>\n<ol>\n<li><strong>history.pushState(state, title, url)</strong><br>pushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.</li>\n<li><strong>window.onpopstate</strong><br>用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。</li>\n<li><strong>history.replaceState(state,title,url)</strong><br>用新的state和URL替换当前。不会造成页面刷新。<br>state：与要跳转到的URL对应的状态信息。<br>title：标题<br>url：要跳转到的URL地址，不能跨域。</li>\n</ol>\n<p>实现原理如下：</p>\n<ul>\n<li>每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。</li>\n<li>浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。</li>\n<li>页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。</li>\n</ul>\n<p>除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。</p>\n<hr>\n<p>欢迎关注我博客:<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">http://voidman.xyz</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。</p>\n</blockquote>","more":"<p>来看看这几个API</p>\n<ol>\n<li><strong>history.pushState(state, title, url)</strong><br>pushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.</li>\n<li><strong>window.onpopstate</strong><br>用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。</li>\n<li><strong>history.replaceState(state,title,url)</strong><br>用新的state和URL替换当前。不会造成页面刷新。<br>state：与要跳转到的URL对应的状态信息。<br>title：标题<br>url：要跳转到的URL地址，不能跨域。</li>\n</ol>\n<p>实现原理如下：</p>\n<ul>\n<li>每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。</li>\n<li>浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。</li>\n<li>页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。</li>\n</ul>\n<p>除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。</p>\n<hr>\n<p>欢迎关注我博客:<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">http://voidman.xyz</a></p>"},{"title":"部署Node项目到CentOS服务器","date":"2016-04-05T06:15:56.000Z","_content":"最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。\n\n通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的“MEAN”。不废话了，下面是正文。\n\n-----------\n\n#### 服务器配置\n- 阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）\n- 操作系统：CentOS 7.0 64位\n\n首先SSH连接服务器管理终端：\n![](http://upload-images.jianshu.io/upload_images/192464-f258d36c0aab64b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####安装Node\nNode.JS的安装方法很多，这里贴上一种方法以供参考。\nhttp://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\n\n####安装MongoDB\n在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。\n1.输入以下命令：curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\nmongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题...)\n\n![](http://upload-images.jianshu.io/upload_images/192464-3af8db48de752e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz\n文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb\n3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。\n\n![](http://upload-images.jianshu.io/upload_images/192464-cd05cbf5b83dfc89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4.添加环境变量\n\n![](http://upload-images.jianshu.io/upload_images/192464-56c75e56977202d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5.重新加载环境变量,验证结果。\n用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了\n\n![](http://upload-images.jianshu.io/upload_images/192464-fc61e6daca451fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 上传项目文件到服务器\nMac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。\n#### 启动MongoDB\n进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库\n```mongod --dbpath \"/developer/mongodb/imooc\"```\n#### 连接MongoDB\n在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。\n\n-----------\n下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问\n附一张这个网站的截图\n\n![电影详情页](http://upload-images.jianshu.io/upload_images/192464-a1274f936e3652de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n另：网站的Github地址 https://github.com/FrankXiong/imooc\n","source":"_posts/部署Node项目到CentOS服务器.md","raw":"---\ntitle: 部署Node项目到CentOS服务器\ndate: 2016-04-05 14:15:56\ntags:\n- 运维\ncategories:\n- Node.js\n---\n最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。\n\n通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的“MEAN”。不废话了，下面是正文。\n\n-----------\n\n#### 服务器配置\n- 阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）\n- 操作系统：CentOS 7.0 64位\n\n首先SSH连接服务器管理终端：\n![](http://upload-images.jianshu.io/upload_images/192464-f258d36c0aab64b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####安装Node\nNode.JS的安装方法很多，这里贴上一种方法以供参考。\nhttp://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\n\n####安装MongoDB\n在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。\n1.输入以下命令：curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\nmongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题...)\n\n![](http://upload-images.jianshu.io/upload_images/192464-3af8db48de752e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz\n文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb\n3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。\n\n![](http://upload-images.jianshu.io/upload_images/192464-cd05cbf5b83dfc89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4.添加环境变量\n\n![](http://upload-images.jianshu.io/upload_images/192464-56c75e56977202d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5.重新加载环境变量,验证结果。\n用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了\n\n![](http://upload-images.jianshu.io/upload_images/192464-fc61e6daca451fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 上传项目文件到服务器\nMac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。\n#### 启动MongoDB\n进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库\n```mongod --dbpath \"/developer/mongodb/imooc\"```\n#### 连接MongoDB\n在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。\n\n-----------\n下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问\n附一张这个网站的截图\n\n![电影详情页](http://upload-images.jianshu.io/upload_images/192464-a1274f936e3652de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n另：网站的Github地址 https://github.com/FrankXiong/imooc\n","slug":"部署Node项目到CentOS服务器","published":1,"updated":"2017-02-05T05:28:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko4900480pk3s631ee1r","content":"<p>最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。</p>\n<p>通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的“MEAN”。不废话了，下面是正文。</p>\n<hr>\n<h4 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h4><ul>\n<li>阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）</li>\n<li>操作系统：CentOS 7.0 64位</li>\n</ul>\n<p>首先SSH连接服务器管理终端：<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-f258d36c0aab64b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>####安装Node<br>Node.JS的安装方法很多，这里贴上一种方法以供参考。<br><a href=\"http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\" target=\"_blank\" rel=\"noopener\">http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html</a></p>\n<p>####安装MongoDB<br>在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。<br>1.输入以下命令：curl -O <a href=\"https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\" target=\"_blank\" rel=\"noopener\">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz</a><br>mongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题…)</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-3af8db48de752e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz<br>文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb<br>3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-cd05cbf5b83dfc89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>4.添加环境变量</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-56c75e56977202d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>5.重新加载环境变量,验证结果。<br>用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-fc61e6daca451fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"上传项目文件到服务器\"><a href=\"#上传项目文件到服务器\" class=\"headerlink\" title=\"上传项目文件到服务器\"></a>上传项目文件到服务器</h4><p>Mac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。</p>\n<h4 id=\"启动MongoDB\"><a href=\"#启动MongoDB\" class=\"headerlink\" title=\"启动MongoDB\"></a>启动MongoDB</h4><p>进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库<br><code>mongod --dbpath &quot;/developer/mongodb/imooc&quot;</code></p>\n<h4 id=\"连接MongoDB\"><a href=\"#连接MongoDB\" class=\"headerlink\" title=\"连接MongoDB\"></a>连接MongoDB</h4><p>在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。</p>\n<hr>\n<p>下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问<br>附一张这个网站的截图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-a1274f936e3652de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"电影详情页\"></p>\n<p>另：网站的Github地址 <a href=\"https://github.com/FrankXiong/imooc\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankXiong/imooc</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。</p>\n<p>通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的“MEAN”。不废话了，下面是正文。</p>\n<hr>\n<h4 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h4><ul>\n<li>阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）</li>\n<li>操作系统：CentOS 7.0 64位</li>\n</ul>\n<p>首先SSH连接服务器管理终端：<br><img src=\"http://upload-images.jianshu.io/upload_images/192464-f258d36c0aab64b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>####安装Node<br>Node.JS的安装方法很多，这里贴上一种方法以供参考。<br><a href=\"http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\" target=\"_blank\" rel=\"noopener\">http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html</a></p>\n<p>####安装MongoDB<br>在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。<br>1.输入以下命令：curl -O <a href=\"https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\" target=\"_blank\" rel=\"noopener\">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz</a><br>mongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题…)</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-3af8db48de752e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz<br>文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb<br>3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-cd05cbf5b83dfc89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>4.添加环境变量</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-56c75e56977202d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>5.重新加载环境变量,验证结果。<br>用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-fc61e6daca451fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"上传项目文件到服务器\"><a href=\"#上传项目文件到服务器\" class=\"headerlink\" title=\"上传项目文件到服务器\"></a>上传项目文件到服务器</h4><p>Mac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。</p>\n<h4 id=\"启动MongoDB\"><a href=\"#启动MongoDB\" class=\"headerlink\" title=\"启动MongoDB\"></a>启动MongoDB</h4><p>进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库<br><code>mongod --dbpath &quot;/developer/mongodb/imooc&quot;</code></p>\n<h4 id=\"连接MongoDB\"><a href=\"#连接MongoDB\" class=\"headerlink\" title=\"连接MongoDB\"></a>连接MongoDB</h4><p>在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。</p>\n<hr>\n<p>下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问<br>附一张这个网站的截图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/192464-a1274f936e3652de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"电影详情页\"></p>\n<p>另：网站的Github地址 <a href=\"https://github.com/FrankXiong/imooc\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankXiong/imooc</a></p>\n"},{"title":"随笔#1","date":"2016-03-06T12:10:10.000Z","_content":"现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。\n\n2016.3.6 傍晚\n","source":"_posts/随笔-1.md","raw":"---\ntitle: '随笔#1'\ndate: 2016-03-06 20:10:10\ntags: \n- 随笔\ncategories:\n- 随笔\n---\n现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。\n\n2016.3.6 傍晚\n","slug":"随笔-1","published":1,"updated":"2016-03-06T12:24:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko4c004c0pk3fnc10bfg","content":"<p>现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。</p>\n<p>2016.3.6 傍晚</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。</p>\n<p>2016.3.6 傍晚</p>\n"},{"title":"阿里前端实习电话面试（二）","date":"2016-03-16T14:22:52.000Z","_content":"今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。\n\n这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……\n\n1.自我介绍，描述你的项目\n\n2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)\n\n3.什么是重载与多态？如何用JS实现多态？(OOP)\n\n4.常见的数据结构？栈和队列的区别？(数据结构)\n\n5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)\n\n6.C语言中分配的几个空间(直接说了不知道……坑啊)\n\n7.JS中apply和call的用法(JS基础)\n\n8.什么是URL编码？(encodeUriComponent)\n\n9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)\n\n10.说出几个HTTP请求头(说了一堆，哈哈哈)\n\n11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)\n\n12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)\n\n13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)\n\n14.描述一下五层网络模型(easy~)\n\n15.了解HashMap吗？描述其原理(勉强答了上来)\n\n16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)\n\n17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)\n\n18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)\n\n\n\n感觉遗漏了很多问题，大致如此吧，共勉。","source":"_posts/阿里前端实习电话面试（二）.md","raw":"---\ntitle: 阿里前端实习电话面试（二）\ndate: 2016-03-16 22:22:52\ntags: \n- 面试\ncategories:\n- 面试\n---\n今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。\n\n这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……\n\n1.自我介绍，描述你的项目\n\n2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)\n\n3.什么是重载与多态？如何用JS实现多态？(OOP)\n\n4.常见的数据结构？栈和队列的区别？(数据结构)\n\n5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)\n\n6.C语言中分配的几个空间(直接说了不知道……坑啊)\n\n7.JS中apply和call的用法(JS基础)\n\n8.什么是URL编码？(encodeUriComponent)\n\n9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)\n\n10.说出几个HTTP请求头(说了一堆，哈哈哈)\n\n11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)\n\n12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)\n\n13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)\n\n14.描述一下五层网络模型(easy~)\n\n15.了解HashMap吗？描述其原理(勉强答了上来)\n\n16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)\n\n17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)\n\n18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)\n\n\n\n感觉遗漏了很多问题，大致如此吧，共勉。","slug":"阿里前端实习电话面试（二）","published":1,"updated":"2016-03-16T14:25:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd68ko4e004g0pk36duq4534","content":"<p>今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。</p>\n<p>这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……</p>\n<p>1.自我介绍，描述你的项目</p>\n<p>2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)</p>\n<p>3.什么是重载与多态？如何用JS实现多态？(OOP)</p>\n<p>4.常见的数据结构？栈和队列的区别？(数据结构)</p>\n<p>5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)</p>\n<p>6.C语言中分配的几个空间(直接说了不知道……坑啊)</p>\n<p>7.JS中apply和call的用法(JS基础)</p>\n<p>8.什么是URL编码？(encodeUriComponent)</p>\n<p>9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)</p>\n<p>10.说出几个HTTP请求头(说了一堆，哈哈哈)</p>\n<p>11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)</p>\n<p>12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)</p>\n<p>13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)</p>\n<p>14.描述一下五层网络模型(easy~)</p>\n<p>15.了解HashMap吗？描述其原理(勉强答了上来)</p>\n<p>16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)</p>\n<p>17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)</p>\n<p>18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)</p>\n<p>感觉遗漏了很多问题，大致如此吧，共勉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。</p>\n<p>这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……</p>\n<p>1.自我介绍，描述你的项目</p>\n<p>2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)</p>\n<p>3.什么是重载与多态？如何用JS实现多态？(OOP)</p>\n<p>4.常见的数据结构？栈和队列的区别？(数据结构)</p>\n<p>5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)</p>\n<p>6.C语言中分配的几个空间(直接说了不知道……坑啊)</p>\n<p>7.JS中apply和call的用法(JS基础)</p>\n<p>8.什么是URL编码？(encodeUriComponent)</p>\n<p>9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)</p>\n<p>10.说出几个HTTP请求头(说了一堆，哈哈哈)</p>\n<p>11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)</p>\n<p>12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)</p>\n<p>13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)</p>\n<p>14.描述一下五层网络模型(easy~)</p>\n<p>15.了解HashMap吗？描述其原理(勉强答了上来)</p>\n<p>16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)</p>\n<p>17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)</p>\n<p>18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)</p>\n<p>感觉遗漏了很多问题，大致如此吧，共勉。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjd68ko1v00010pk3koufyqmq","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko2f000g0pk3cv7ikdgv"},{"post_id":"cjd68ko2a000e0pk369yn9o1l","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko2j000m0pk3uvedcab1"},{"post_id":"cjd68ko1z00030pk33d0em4jc","category_id":"cjd68ko28000b0pk3rhe2wtxy","_id":"cjd68ko2l000q0pk3j1vn3olb"},{"post_id":"cjd68ko2400070pk38be4jbng","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko2m000s0pk3b9wr27es"},{"post_id":"cjd68ko2i000l0pk3s6yofeye","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko2p000w0pk3hkeh8wlv"},{"post_id":"cjd68ko2k000p0pk3f18wta7r","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko2q000z0pk3on0qkb1f"},{"post_id":"cjd68ko2600090pk36qwk0l9h","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko2s00140pk3jnqasl2s"},{"post_id":"cjd68ko2l000r0pk3wcroe6as","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko2t00170pk3oaw5h1f7"},{"post_id":"cjd68ko2n000v0pk326n6vij2","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko2v001c0pk37bkiyriq"},{"post_id":"cjd68ko27000a0pk35niks76d","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko2w001f0pk394x5xp90"},{"post_id":"cjd68ko2p000y0pk3idx8i0tg","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko2y001i0pk338ne9tnt"},{"post_id":"cjd68ko2r00120pk3mwaexhp6","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko2z001m0pk37y5h3kd1"},{"post_id":"cjd68ko2e000f0pk3s8tq7j3i","category_id":"cjd68ko2q00100pk3qf8avp1i","_id":"cjd68ko30001p0pk3f659h2bm"},{"post_id":"cjd68ko2s00160pk3rv0ha1zb","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko32001t0pk32ddpfioa"},{"post_id":"cjd68ko2u001a0pk3m8kbsapl","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko33001w0pk3mjogminz"},{"post_id":"cjd68ko2h000j0pk3jlb0ihpo","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3600210pk3sic4dpz6"},{"post_id":"cjd68ko2v001e0pk3xecofviq","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3700230pk3d3x2udyw"},{"post_id":"cjd68ko2x001h0pk3a6bgknt1","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3900270pk3dns1p8pm"},{"post_id":"cjd68ko30001o0pk3i7wm2t6b","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3a002a0pk3mohxnjz0"},{"post_id":"cjd68ko3600220pk3b8521rle","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3c002f0pk3mbqr60bg"},{"post_id":"cjd68ko31001s0pk3dfkx27pf","category_id":"cjd68ko33001x0pk38zjpp7hb","_id":"cjd68ko3d002i0pk3s5c4olv1"},{"post_id":"cjd68ko3900290pk3axfq8bhl","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3f002m0pk3zgd2aii5"},{"post_id":"cjd68ko32001v0pk3dh85iqa6","category_id":"cjd68ko33001x0pk38zjpp7hb","_id":"cjd68ko3h002p0pk3v9yxkdm6"},{"post_id":"cjd68ko3a002d0pk3qpprwtq6","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3j002s0pk30di7aklp"},{"post_id":"cjd68ko3c002h0pk35uxm177e","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3l002v0pk350sld17f"},{"post_id":"cjd68ko3400200pk3hst20n82","category_id":"cjd68ko33001x0pk38zjpp7hb","_id":"cjd68ko3n002z0pk3601p42w5"},{"post_id":"cjd68ko3e002k0pk31nwg4f2c","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3p00320pk3vh8xusn0"},{"post_id":"cjd68ko3f002o0pk3bqjtul6l","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3r00350pk300gqyey7"},{"post_id":"cjd68ko3700250pk335rfcpgc","category_id":"cjd68ko3e002l0pk3uzmcyb55","_id":"cjd68ko3s003a0pk3yzc2m3dr"},{"post_id":"cjd68ko3h002q0pk3qhffv3v3","category_id":"cjd68ko33001x0pk38zjpp7hb","_id":"cjd68ko3u003d0pk3o6dmc1mk"},{"post_id":"cjd68ko3j002u0pk3w9uzmb6f","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko3v003i0pk3vshjs0pj"},{"post_id":"cjd68ko3m002x0pk3m6300i4n","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko3y003l0pk3ax0kwk83"},{"post_id":"cjd68ko3p00340pk3xcgvt8wl","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko40003p0pk33nn4a7yi"},{"post_id":"cjd68ko3t003c0pk3m4o0hbee","category_id":"cjd68ko2200050pk3pl5dy0jq","_id":"cjd68ko43003s0pk3rfy05jc9"},{"post_id":"cjd68ko3o00310pk3cnv3z6i2","category_id":"cjd68ko3r00370pk3hb1xzh18","_id":"cjd68ko45003w0pk3m3lwfr19"},{"post_id":"cjd68ko3u003g0pk3txdvn917","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko46003z0pk3m3a3mard"},{"post_id":"cjd68ko3w003k0pk371qz35yk","category_id":"cjd68ko33001x0pk38zjpp7hb","_id":"cjd68ko4700420pk34tl3mp1r"},{"post_id":"cjd68ko3r00390pk32vc7dg0b","category_id":"cjd68ko3r00370pk3hb1xzh18","_id":"cjd68ko4900460pk3gpzu2sjp"},{"post_id":"cjd68ko3y003o0pk31zn08t1u","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko4b00490pk34xv12u7w"},{"post_id":"cjd68ko41003r0pk3dyyxohaf","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko4d004d0pk3j0zfo4r4"},{"post_id":"cjd68ko43003u0pk3qu75t30w","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko4f004h0pk39gx2qvsq"},{"post_id":"cjd68ko45003y0pk3oi2kqi14","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko4g004k0pk321z7joxx"},{"post_id":"cjd68ko4600410pk31ke2ebqy","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko4h004m0pk3z3vitsp6"},{"post_id":"cjd68ko4800450pk3ggpckh6u","category_id":"cjd68ko2j000n0pk33x06pni8","_id":"cjd68ko4i004p0pk3r3levq91"},{"post_id":"cjd68ko4c004c0pk3fnc10bfg","category_id":"cjd68ko3r00370pk3hb1xzh18","_id":"cjd68ko4i004r0pk3dpe3n1a1"},{"post_id":"cjd68ko4e004g0pk36duq4534","category_id":"cjd68ko28000b0pk3rhe2wtxy","_id":"cjd68ko4j004u0pk3lbh23114"},{"post_id":"cjd68ko4900480pk3s631ee1r","category_id":"cjd68ko4d004e0pk36ev9nuno","_id":"cjd68ko4j004w0pk3c0km8hj9"}],"PostTag":[{"post_id":"cjd68ko1v00010pk3koufyqmq","tag_id":"cjd68ko2300060pk3f3cgvzhy","_id":"cjd68ko29000d0pk3uqkd48vu"},{"post_id":"cjd68ko1z00030pk33d0em4jc","tag_id":"cjd68ko29000c0pk3tdph9oy1","_id":"cjd68ko2i000k0pk3lzkeyox5"},{"post_id":"cjd68ko2400070pk38be4jbng","tag_id":"cjd68ko2f000i0pk3rhmhw1ob","_id":"cjd68ko2p000x0pk3mec2a4q5"},{"post_id":"cjd68ko2400070pk38be4jbng","tag_id":"cjd68ko2k000o0pk306on5pir","_id":"cjd68ko2q00110pk373e8hdit"},{"post_id":"cjd68ko2p000y0pk3idx8i0tg","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko2s00150pk3n52jqr72"},{"post_id":"cjd68ko2600090pk36qwk0l9h","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko2t00180pk3o5qd01en"},{"post_id":"cjd68ko2r00120pk3mwaexhp6","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko2v001d0pk3bxdc015y"},{"post_id":"cjd68ko27000a0pk35niks76d","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko2x001g0pk3u6t7hysd"},{"post_id":"cjd68ko2u001a0pk3m8kbsapl","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko2y001k0pk31o5qg5la"},{"post_id":"cjd68ko2a000e0pk369yn9o1l","tag_id":"cjd68ko2u001b0pk3mljlb3ur","_id":"cjd68ko2z001n0pk35tdngsus"},{"post_id":"cjd68ko2x001h0pk3a6bgknt1","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko31001r0pk3ynfyeh2x"},{"post_id":"cjd68ko2e000f0pk3s8tq7j3i","tag_id":"cjd68ko2y001j0pk3q02vbtvc","_id":"cjd68ko32001u0pk3flp40vpf"},{"post_id":"cjd68ko30001o0pk3i7wm2t6b","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko34001y0pk3c4vvv73f"},{"post_id":"cjd68ko2h000j0pk3jlb0ihpo","tag_id":"cjd68ko31001q0pk32hvfarce","_id":"cjd68ko3900280pk30el6oeea"},{"post_id":"cjd68ko2h000j0pk3jlb0ihpo","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko3a002b0pk3410c6rty"},{"post_id":"cjd68ko2i000l0pk3s6yofeye","tag_id":"cjd68ko2u001b0pk3mljlb3ur","_id":"cjd68ko3c002g0pk3ew25sco5"},{"post_id":"cjd68ko2k000p0pk3f18wta7r","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko3f002n0pk3h1rg0i1a"},{"post_id":"cjd68ko2l000r0pk3wcroe6as","tag_id":"cjd68ko3d002j0pk34yp52csc","_id":"cjd68ko3j002t0pk3zaii3jj8"},{"post_id":"cjd68ko2l000r0pk3wcroe6as","tag_id":"cjd68ko2300060pk3f3cgvzhy","_id":"cjd68ko3l002w0pk30ia80x2v"},{"post_id":"cjd68ko3j002u0pk3w9uzmb6f","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko3o00300pk3qk6no094"},{"post_id":"cjd68ko2n000v0pk326n6vij2","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko3p00330pk3kt8lliah"},{"post_id":"cjd68ko3m002x0pk3m6300i4n","tag_id":"cjd68ko2u001b0pk3mljlb3ur","_id":"cjd68ko3r00380pk3fayo36y1"},{"post_id":"cjd68ko2s00160pk3rv0ha1zb","tag_id":"cjd68ko3n002y0pk3fhi202yw","_id":"cjd68ko3s003b0pk3vc7f8suj"},{"post_id":"cjd68ko3p00340pk3xcgvt8wl","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko3u003f0pk3wjsmdxvf"},{"post_id":"cjd68ko2v001e0pk3xecofviq","tag_id":"cjd68ko3r00360pk3wbl10hgd","_id":"cjd68ko3w003j0pk3p4b00208"},{"post_id":"cjd68ko3t003c0pk3m4o0hbee","tag_id":"cjd68ko2u001b0pk3mljlb3ur","_id":"cjd68ko3y003n0pk39dpzd8ol"},{"post_id":"cjd68ko3u003g0pk3txdvn917","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko41003q0pk30mp0pf3n"},{"post_id":"cjd68ko2y001l0pk34ccpoe8r","tag_id":"cjd68ko3u003e0pk374abcmln","_id":"cjd68ko43003t0pk396ttgioz"},{"post_id":"cjd68ko3y003o0pk31zn08t1u","tag_id":"cjd68ko3r00360pk3wbl10hgd","_id":"cjd68ko45003x0pk398m7jsmu"},{"post_id":"cjd68ko41003r0pk3dyyxohaf","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4600400pk3rkcyyu2n"},{"post_id":"cjd68ko43003u0pk3qu75t30w","tag_id":"cjd68ko2300060pk3f3cgvzhy","_id":"cjd68ko4800440pk3xf46dpb5"},{"post_id":"cjd68ko45003y0pk3oi2kqi14","tag_id":"cjd68ko3r00360pk3wbl10hgd","_id":"cjd68ko4900470pk33xppa4ze"},{"post_id":"cjd68ko31001s0pk3dfkx27pf","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4b004b0pk3z1vkpivn"},{"post_id":"cjd68ko31001s0pk3dfkx27pf","tag_id":"cjd68ko3y003m0pk3qt8wkuiv","_id":"cjd68ko4e004f0pk3fs0u9dbu"},{"post_id":"cjd68ko31001s0pk3dfkx27pf","tag_id":"cjd68ko44003v0pk3fn25cycq","_id":"cjd68ko4g004j0pk379zvpwwg"},{"post_id":"cjd68ko4800450pk3ggpckh6u","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4h004l0pk3yy00iwaf"},{"post_id":"cjd68ko32001v0pk3dh85iqa6","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4i004o0pk33z2uf9ud"},{"post_id":"cjd68ko32001v0pk3dh85iqa6","tag_id":"cjd68ko3y003m0pk3qt8wkuiv","_id":"cjd68ko4i004q0pk38yy64mkw"},{"post_id":"cjd68ko3400200pk3hst20n82","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4j004t0pk3pme16qkh"},{"post_id":"cjd68ko3400200pk3hst20n82","tag_id":"cjd68ko44003v0pk3fn25cycq","_id":"cjd68ko4j004v0pk3xiko1iog"},{"post_id":"cjd68ko4e004g0pk36duq4534","tag_id":"cjd68ko29000c0pk3tdph9oy1","_id":"cjd68ko4k004y0pk3ezngu1ha"},{"post_id":"cjd68ko3600220pk3b8521rle","tag_id":"cjd68ko3r00360pk3wbl10hgd","_id":"cjd68ko4k004z0pk3899ls8nx"},{"post_id":"cjd68ko3600220pk3b8521rle","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4n00510pk35ywa56lt"},{"post_id":"cjd68ko3700250pk335rfcpgc","tag_id":"cjd68ko4j004s0pk36l2d1ijm","_id":"cjd68ko4n00520pk31svv3jzs"},{"post_id":"cjd68ko3700250pk335rfcpgc","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4o00540pk3rvntnesk"},{"post_id":"cjd68ko3900290pk3axfq8bhl","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4o00550pk3qufyuh06"},{"post_id":"cjd68ko3900290pk3axfq8bhl","tag_id":"cjd68ko31001q0pk32hvfarce","_id":"cjd68ko4o00570pk3n4u0e7xo"},{"post_id":"cjd68ko3900290pk3axfq8bhl","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4p00580pk34nj6b74h"},{"post_id":"cjd68ko3a002d0pk3qpprwtq6","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4p005a0pk3qy2qnfam"},{"post_id":"cjd68ko3a002d0pk3qpprwtq6","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4p005b0pk3a878c83e"},{"post_id":"cjd68ko3c002h0pk35uxm177e","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4q005d0pk3y6zpkn0k"},{"post_id":"cjd68ko3c002h0pk35uxm177e","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4q005e0pk3a5ajoslg"},{"post_id":"cjd68ko3e002k0pk31nwg4f2c","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4q005f0pk33jty635o"},{"post_id":"cjd68ko3e002k0pk31nwg4f2c","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4r005h0pk3vtxl1vf3"},{"post_id":"cjd68ko3f002o0pk3bqjtul6l","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4r005j0pk3p76nqr3o"},{"post_id":"cjd68ko3f002o0pk3bqjtul6l","tag_id":"cjd68ko4q005c0pk38bzdppb3","_id":"cjd68ko4r005k0pk3fzp6fm3e"},{"post_id":"cjd68ko3f002o0pk3bqjtul6l","tag_id":"cjd68ko4h004n0pk361hrg3ia","_id":"cjd68ko4s005m0pk3abpocszf"},{"post_id":"cjd68ko3h002q0pk3qhffv3v3","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4s005n0pk3xwxa1o2c"},{"post_id":"cjd68ko3h002q0pk3qhffv3v3","tag_id":"cjd68ko44003v0pk3fn25cycq","_id":"cjd68ko4s005p0pk3vqrtt3zo"},{"post_id":"cjd68ko3o00310pk3cnv3z6i2","tag_id":"cjd68ko4r005l0pk359sd4w45","_id":"cjd68ko4s005q0pk37pspd1i5"},{"post_id":"cjd68ko3r00390pk32vc7dg0b","tag_id":"cjd68ko4r005l0pk359sd4w45","_id":"cjd68ko4t005s0pk3rf6tw1ti"},{"post_id":"cjd68ko3w003k0pk371qz35yk","tag_id":"cjd68ko2n000u0pk325sk6g68","_id":"cjd68ko4u005u0pk3sos9zw31"},{"post_id":"cjd68ko3w003k0pk371qz35yk","tag_id":"cjd68ko44003v0pk3fn25cycq","_id":"cjd68ko4u005v0pk360grk491"},{"post_id":"cjd68ko4600410pk31ke2ebqy","tag_id":"cjd68ko4t005t0pk37ruflnbk","_id":"cjd68ko4u005x0pk3930ko4mw"},{"post_id":"cjd68ko4900480pk3s631ee1r","tag_id":"cjd68ko4u005w0pk3m6jkg7b8","_id":"cjd68ko4v005z0pk3tsnrfwuw"},{"post_id":"cjd68ko4c004c0pk3fnc10bfg","tag_id":"cjd68ko4r005l0pk359sd4w45","_id":"cjd68ko4v00600pk38frbbrxz"}],"Tag":[{"name":"性能优化","_id":"cjd68ko2300060pk3f3cgvzhy"},{"name":"面试","_id":"cjd68ko29000c0pk3tdph9oy1"},{"name":"DNS","_id":"cjd68ko2f000i0pk3rhmhw1ob"},{"name":"web安全","_id":"cjd68ko2k000o0pk306on5pir"},{"name":"JavaScript","_id":"cjd68ko2n000u0pk325sk6g68"},{"name":"HTTP","_id":"cjd68ko2u001b0pk3mljlb3ur"},{"name":"Markdown","_id":"cjd68ko2y001j0pk3q02vbtvc"},{"name":"Vue","_id":"cjd68ko31001q0pk32hvfarce"},{"name":"TCP","_id":"cjd68ko3d002j0pk34yp52csc"},{"name":"IP","_id":"cjd68ko3n002y0pk3fhi202yw"},{"name":"CSS","_id":"cjd68ko3r00360pk3wbl10hgd"},{"name":"前端","_id":"cjd68ko3u003e0pk374abcmln"},{"name":"数据结构","_id":"cjd68ko3y003m0pk3qt8wkuiv"},{"name":"算法","_id":"cjd68ko44003v0pk3fn25cycq"},{"name":"翻译","_id":"cjd68ko4h004n0pk361hrg3ia"},{"name":"直播","_id":"cjd68ko4j004s0pk36l2d1ijm"},{"name":"React","_id":"cjd68ko4q005c0pk38bzdppb3"},{"name":"随笔","_id":"cjd68ko4r005l0pk359sd4w45"},{"name":"浏览器","_id":"cjd68ko4t005t0pk37ruflnbk"},{"name":"运维","_id":"cjd68ko4u005w0pk3m6jkg7b8"}]}}