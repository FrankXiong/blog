{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/Lights/source/offline.svg","path":"offline.svg","modified":1,"renderable":1},{"_id":"themes/Lights/source/offline.html","path":"offline.html","modified":1,"renderable":1},{"_id":"themes/Lights/source/sw.js","path":"sw.js","modified":1,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/avatar@2x.jpg","path":"images/avatar@2x.jpg","modified":1,"renderable":0},{"_id":"source/uploads/Puppeteer/2.png","path":"uploads/Puppeteer/2.png","modified":1,"renderable":0},{"_id":"source/uploads/Script-Streaming/2.png","path":"uploads/Script-Streaming/2.png","modified":1,"renderable":0},{"_id":"source/uploads/Script-Streaming/3.png","path":"uploads/Script-Streaming/3.png","modified":1,"renderable":0},{"_id":"source/uploads/Script-Streaming/4.png","path":"uploads/Script-Streaming/4.png","modified":1,"renderable":0},{"_id":"source/uploads/TCP/4.png","path":"uploads/TCP/4.png","modified":1,"renderable":0},{"_id":"source/uploads/css-checkbox/checkbox_1.png","path":"uploads/css-checkbox/checkbox_1.png","modified":1,"renderable":0},{"_id":"source/uploads/css-checkbox/checkbox_2.png","path":"uploads/css-checkbox/checkbox_2.png","modified":1,"renderable":0},{"_id":"source/uploads/css-checkbox/checkbox_3.png","path":"uploads/css-checkbox/checkbox_3.png","modified":1,"renderable":0},{"_id":"source/uploads/css-checkbox/checkbox_4.png","path":"uploads/css-checkbox/checkbox_4.png","modified":1,"renderable":0},{"_id":"source/uploads/css-line-break/fe-css-0.png","path":"uploads/css-line-break/fe-css-0.png","modified":1,"renderable":0},{"_id":"source/uploads/css-line-break/fe-css-1.jpg","path":"uploads/css-line-break/fe-css-1.jpg","modified":1,"renderable":0},{"_id":"source/uploads/css-line-break/fe-css-2.png","path":"uploads/css-line-break/fe-css-2.png","modified":1,"renderable":0},{"_id":"source/uploads/hls/1.png","path":"uploads/hls/1.png","modified":1,"renderable":0},{"_id":"source/uploads/https-upgrade/2.png","path":"uploads/https-upgrade/2.png","modified":1,"renderable":0},{"_id":"source/uploads/node-deploy/1.png","path":"uploads/node-deploy/1.png","modified":1,"renderable":0},{"_id":"source/uploads/node-deploy/2.png","path":"uploads/node-deploy/2.png","modified":1,"renderable":0},{"_id":"source/uploads/node-deploy/4.png","path":"uploads/node-deploy/4.png","modified":1,"renderable":0},{"_id":"source/uploads/node-deploy/3.png","path":"uploads/node-deploy/3.png","modified":1,"renderable":0},{"_id":"source/uploads/virtual-dom/1.png","path":"uploads/virtual-dom/1.png","modified":1,"renderable":0},{"_id":"source/uploads/virtual-dom/2.png","path":"uploads/virtual-dom/2.png","modified":1,"renderable":0},{"_id":"source/uploads/virtual-dom/3.png","path":"uploads/virtual-dom/3.png","modified":1,"renderable":0},{"_id":"themes/Lights/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/old style.css","path":"css/old style.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Lights/source/images/avatar@2x.png","path":"images/avatar@2x.png","modified":1,"renderable":1},{"_id":"themes/Lights/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":1,"renderable":1},{"_id":"source/uploads/Script-Streaming/1.png","path":"uploads/Script-Streaming/1.png","modified":1,"renderable":0},{"_id":"source/uploads/TCP/2.png","path":"uploads/TCP/2.png","modified":1,"renderable":0},{"_id":"source/uploads/bfc/2.png","path":"uploads/bfc/2.png","modified":1,"renderable":0},{"_id":"source/uploads/bfc/1.png","path":"uploads/bfc/1.png","modified":1,"renderable":0},{"_id":"source/uploads/bfc/3.png","path":"uploads/bfc/3.png","modified":1,"renderable":0},{"_id":"source/uploads/node-deploy/5.png","path":"uploads/node-deploy/5.png","modified":1,"renderable":0},{"_id":"source/uploads/nodejs-cluster/1.jpg","path":"uploads/nodejs-cluster/1.jpg","modified":1,"renderable":0},{"_id":"source/uploads/TCP/1.png","path":"uploads/TCP/1.png","modified":1,"renderable":0},{"_id":"themes/Lights/source/css/styles/a11y-dark.css","path":"css/styles/a11y-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/a11y-light.css","path":"css/styles/a11y-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/agate.css","path":"css/styles/agate.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/an-old-hope.css","path":"css/styles/an-old-hope.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/androidstudio.css","path":"css/styles/androidstudio.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/arduino-light.css","path":"css/styles/arduino-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/arta.css","path":"css/styles/arta.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/ascetic.css","path":"css/styles/ascetic.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-cave-dark.css","path":"css/styles/atelier-cave-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-cave-light.css","path":"css/styles/atelier-cave-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-dune-dark.css","path":"css/styles/atelier-dune-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-dune-light.css","path":"css/styles/atelier-dune-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-estuary-dark.css","path":"css/styles/atelier-estuary-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-estuary-light.css","path":"css/styles/atelier-estuary-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-forest-dark.css","path":"css/styles/atelier-forest-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-forest-light.css","path":"css/styles/atelier-forest-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-heath-dark.css","path":"css/styles/atelier-heath-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-heath-light.css","path":"css/styles/atelier-heath-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-lakeside-dark.css","path":"css/styles/atelier-lakeside-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-lakeside-light.css","path":"css/styles/atelier-lakeside-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-plateau-dark.css","path":"css/styles/atelier-plateau-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-plateau-light.css","path":"css/styles/atelier-plateau-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-savanna-light.css","path":"css/styles/atelier-savanna-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-seaside-dark.css","path":"css/styles/atelier-seaside-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-seaside-light.css","path":"css/styles/atelier-seaside-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-sulphurpool-dark.css","path":"css/styles/atelier-sulphurpool-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atelier-sulphurpool-light.css","path":"css/styles/atelier-sulphurpool-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atom-one-dark-reasonable.css","path":"css/styles/atom-one-dark-reasonable.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atom-one-dark.css","path":"css/styles/atom-one-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/atom-one-light.css","path":"css/styles/atom-one-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/brown-paper.css","path":"css/styles/brown-paper.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/brown-papersq.png","path":"css/styles/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/codepen-embed.css","path":"css/styles/codepen-embed.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/color-brewer.css","path":"css/styles/color-brewer.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/darcula.css","path":"css/styles/darcula.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/dark.css","path":"css/styles/dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/darkula.css","path":"css/styles/darkula.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/default.css","path":"css/styles/default.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/docco.css","path":"css/styles/docco.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/dracula.css","path":"css/styles/dracula.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/far.css","path":"css/styles/far.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/foundation.css","path":"css/styles/foundation.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/github-gist.css","path":"css/styles/github-gist.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/github.css","path":"css/styles/github.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/gml.css","path":"css/styles/gml.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/googlecode.css","path":"css/styles/googlecode.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/grayscale.css","path":"css/styles/grayscale.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/gruvbox-dark.css","path":"css/styles/gruvbox-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/gruvbox-light.css","path":"css/styles/gruvbox-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/hopscotch.css","path":"css/styles/hopscotch.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/hybrid.css","path":"css/styles/hybrid.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/idea.css","path":"css/styles/idea.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/ir-black.css","path":"css/styles/ir-black.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/isbl-editor-dark.css","path":"css/styles/isbl-editor-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/isbl-editor-light.css","path":"css/styles/isbl-editor-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/kimbie.dark.css","path":"css/styles/kimbie.dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/kimbie.light.css","path":"css/styles/kimbie.light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/lightfair.css","path":"css/styles/lightfair.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/magula.css","path":"css/styles/magula.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/mono-blue.css","path":"css/styles/mono-blue.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/monokai-sublime.css","path":"css/styles/monokai-sublime.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/monokai.css","path":"css/styles/monokai.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/nord.css","path":"css/styles/nord.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/obsidian.css","path":"css/styles/obsidian.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/ocean.css","path":"css/styles/ocean.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/paraiso-dark.css","path":"css/styles/paraiso-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/paraiso-light.css","path":"css/styles/paraiso-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/pojoaque.css","path":"css/styles/pojoaque.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/pojoaque.jpg","path":"css/styles/pojoaque.jpg","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/purebasic.css","path":"css/styles/purebasic.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/qtcreator_dark.css","path":"css/styles/qtcreator_dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/qtcreator_light.css","path":"css/styles/qtcreator_light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/railscasts.css","path":"css/styles/railscasts.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/rainbow.css","path":"css/styles/rainbow.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/routeros.css","path":"css/styles/routeros.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/school-book.css","path":"css/styles/school-book.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/school-book.png","path":"css/styles/school-book.png","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/shades-of-purple.css","path":"css/styles/shades-of-purple.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/solarized-dark.css","path":"css/styles/solarized-dark.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/solarized-light.css","path":"css/styles/solarized-light.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/sunburst.css","path":"css/styles/sunburst.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/tomorrow-night-blue.css","path":"css/styles/tomorrow-night-blue.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/tomorrow-night-bright.css","path":"css/styles/tomorrow-night-bright.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/tomorrow-night-eighties.css","path":"css/styles/tomorrow-night-eighties.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/tomorrow-night.css","path":"css/styles/tomorrow-night.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/tomorrow.css","path":"css/styles/tomorrow.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/vs.css","path":"css/styles/vs.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/vs2015.css","path":"css/styles/vs2015.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/xcode.css","path":"css/styles/xcode.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/xt256.css","path":"css/styles/xt256.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/css/styles/zenburn.css","path":"css/styles/zenburn.css","modified":1,"renderable":1},{"_id":"themes/Lights/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/Lights/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1},{"_id":"source/uploads/TCP/5.png","path":"uploads/TCP/5.png","modified":1,"renderable":0},{"_id":"source/uploads/bfc/4.png","path":"uploads/bfc/4.png","modified":1,"renderable":0},{"_id":"themes/Lights/source/css/styles/atelier-savanna-dark.css","path":"css/styles/atelier-savanna-dark.css","modified":1,"renderable":1},{"_id":"source/uploads/Puppeteer/1.png","path":"uploads/Puppeteer/1.png","modified":1,"renderable":0},{"_id":"source/uploads/TCP/3.png","path":"uploads/TCP/3.png","modified":1,"renderable":0},{"_id":"source/uploads/node-deploy/6.png","path":"uploads/node-deploy/6.png","modified":1,"renderable":0},{"_id":"source/uploads/https-upgrade/1.png","path":"uploads/https-upgrade/1.png","modified":1,"renderable":0},{"_id":"source/uploads/splice/3.jpg","path":"uploads/splice/3.jpg","modified":1,"renderable":0},{"_id":"source/uploads/splice/1.png","path":"uploads/splice/1.png","modified":1,"renderable":0},{"_id":"source/uploads/splice/2.png","path":"uploads/splice/2.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"495dc0d217dbc3e7cb0c015a4aa9af3e7011d37f","modified":1577330551478},{"_id":"source/404.html","hash":"f7d32c6d1ddac7caa964d346c19e920fa7b3986f","modified":1560694297257},{"_id":"source/CNAME","hash":"87eb67dc0e83d175b646aa565c07a460039107e8","modified":1560694297257},{"_id":"themes/Lights/.DS_Store","hash":"aca025f9e145bebced07ae8c5638200bd4474685","modified":1577329935778},{"_id":"themes/Lights/LICENSE","hash":"f604dbc0079b71127385f0e8fcd9e184676f07ce","modified":1577329935778},{"_id":"themes/Lights/README.md","hash":"5864a1ba67b6cb47d6703c2c80a5b451817d29d3","modified":1577329935779},{"_id":"themes/Lights/_config.yml","hash":"bc26cf08e12dd0087538709dfbddef991affaf66","modified":1577331718669},{"_id":"source/about/index.md","hash":"ec10677855d75e656e931fc0b8e0bae1c55610b6","modified":1577553148372},{"_id":"source/categories/index.md","hash":"b6a9db6ff22e5a7554b47258439a136e91b4d985","modified":1577328967045},{"_id":"source/_posts/2016阿里前端实习电话面试实录.md","hash":"5eccb46905345fe3d6ec4c90b76551591044b933","modified":1560694297258},{"_id":"source/_posts/CDN缓存原理.md","hash":"20388ea3bc2147a2f596c7d15ca73d5b8cbfcc44","modified":1577550174764},{"_id":"source/_posts/Cookie和Session的区别总结.md","hash":"9807500ccd1251f12a64939b78656b52da63cea5","modified":1577550381340},{"_id":"source/_posts/DNS劫持与DNS污染的原理.md","hash":"ccd745d0eb968b32d0c6422955f81b403e9443a0","modified":1577550376023},{"_id":"source/_posts/ES6语法总结.md","hash":"f0828814d5f182d694894df552aab480252d00ee","modified":1577554222680},{"_id":"source/_posts/HTTPS知识点.md","hash":"db280c734b2051b250275e9669f9fb8d85d8c196","modified":1577612999711},{"_id":"source/_posts/HTTP状态码大全.md","hash":"ce21896b740e1772439ede15d5fe89d0b421ad69","modified":1577550990052},{"_id":"source/_posts/JavaScript 设计模式汇总.md","hash":"ba665b095069e4b646da41ce663ad792b5dca788","modified":1577554381637},{"_id":"source/_posts/JavaScript数组去重.md","hash":"22453fca0063d2357bd67356cfbfac0db67d0c55","modified":1577612533145},{"_id":"source/_posts/Markdown简明语法.md","hash":"becfcba73e5b54870167f97336208c26942a87f2","modified":1577618893573},{"_id":"source/_posts/Node-js错误处理最佳实践.md","hash":"c6ccfb441841286e61f5913cb1f0b6eb4a0f98e7","modified":1577547598493},{"_id":"source/_posts/TCP性能优化浅析.md","hash":"9dac8f9add812c665fdc0caff305d45fd4ddb74e","modified":1577618893615},{"_id":"source/_posts/Vue2-0源码学习-0.md","hash":"62c3483c859d2298725e314425438cfdeb086651","modified":1577550170363},{"_id":"source/_posts/WebP技术原理及应用.md","hash":"acf932d9a210fefcaa58f9e2e309353083d98b44","modified":1577620372669},{"_id":"source/_posts/apply方法的妙用.md","hash":"6acd21f8a722f2e2a029da60ac676b58450ba660","modified":1577550186259},{"_id":"source/_posts/cookie.md","hash":"64969b6398013ddeca63ba56b46c4b7ebe7f896c","modified":1577550179645},{"_id":"source/_posts/localStorage详解.md","hash":"3a6c2a1771daaca0f1c62f2d39970ee60238d06f","modified":1577613249312},{"_id":"source/_posts/null和undefined的区别.md","hash":"bf25406daf07caec31e61bff55ed676f4b68db6c","modified":1577613226337},{"_id":"source/_posts/traceroute的原理.md","hash":"dc65d0633eaf7756fdb7130c2cc23ce540c083c4","modified":1577554639943},{"_id":"source/_posts/【CSS】文本换行的几个属性.md","hash":"ee933cd3a04d4ac876049ad38226557629a7e212","modified":1577618893573},{"_id":"source/_posts/【JavaScript】splice方法实现原理分析.md","hash":"b06ae48e71615d447d98927bfcf98f38607eccaa","modified":1577618893573},{"_id":"source/_posts/【JavaScript】变量作用域.md","hash":"51153a81e9adea73877ce958bff9042f750174a4","modified":1577613796181},{"_id":"source/_posts/【JavaScript】闭包的概念.md","hash":"90dc1b9030eae84d71a00bd6a5efc854e8a8d8fa","modified":1577613572982},{"_id":"source/_posts/【JavaScript实现数据结构】栈.md","hash":"39ff13014e38e8556d127d63962252e0993eb523","modified":1577550963595},{"_id":"source/_posts/【JavaScript实现数据结构】队列.md","hash":"07afd395fba6134f78eb933cf4edde243f9b9433","modified":1577550956043},{"_id":"source/_posts/【JavaScript实现算法】快速排序.md","hash":"6b4fbfde6ac5f781c9dc5a084dd0064b13d85290","modified":1577550967698},{"_id":"source/_posts/【译】2017-年要去学的-3-个-CSS-新属性.md","hash":"45d752d4ffa1d3d9507e0f835fdced326e0298f4","modified":1560694297267},{"_id":"source/_posts/【译】ES2018新特性：Promise-prototype-finally.md","hash":"258cae02b4e9d29028e2223ddfd69f53ec6d1250","modified":1560694297267},{"_id":"source/_posts/【译】ES2018新特性：Rest-Spread-特性.md","hash":"79cc46c74713de9b97b0fcae81d5e758ec1633da","modified":1560694297268},{"_id":"source/_posts/【译】HLS架构简介.md","hash":"a4f9cc3649d1bf4cfe9c507a8b6e49b9d6fc4152","modified":1577618893615},{"_id":"source/_posts/【译】为什么Vue-js不支持templateURL.md","hash":"a4ddc387a0dabd8afa39edf489e89c5210aba130","modified":1577611956300},{"_id":"source/_posts/【译】使用Script-Streaming提升页面加载性能.md","hash":"66cd754e0c077ffec54a5fbc190228e66e5231c8","modified":1577618893616},{"_id":"source/_posts/【译】异步：现在与将来（基础篇）.md","hash":"25a06ec489a520bc1e99167c7e4238861386ab28","modified":1560694297269},{"_id":"source/_posts/【译】异步：现在与将来（并发篇）.md","hash":"b99986ceb0538f71244679d388e174e5f5fb4921","modified":1577611169346},{"_id":"source/_posts/【译】异步：现在与将来（并行篇）.md","hash":"c259898e10228b4af2e4e113c014f644942968a6","modified":1560694297270},{"_id":"source/_posts/【译】无头Chrome：服务端渲染JS页面的一个解决方案.md","hash":"6be84d293a22390b0281a01bb7035738c6dc44aa","modified":1577618893615},{"_id":"source/_posts/【译】真实的Virtual-DOM.md","hash":"bb0c14a297845529b95ea57b11444eae721205a2","modified":1577618893598},{"_id":"source/_posts/一个优化的快速排序.md","hash":"9cdd5ccfb42fe6b9d0028dd631c076c1a14d5adc","modified":1560694297271},{"_id":"source/_posts/一个通用的事件监听器.md","hash":"9b91217c613d59cfb92d8217f89358f8a047b009","modified":1560694297272},{"_id":"source/_posts/什么是TCP连接的三次握手.md","hash":"ab97c2a3664defa63173d3a5a889a21d9f08ea53","modified":1577550213365},{"_id":"source/_posts/你不知道的eval.md","hash":"3e49e36d97fd11f5b1b42d849300cbb29db8679e","modified":1577549269808},{"_id":"source/_posts/你该逃课吗.md","hash":"0b2d7ed59536a9c08f44dad12d64bb81da05ea6c","modified":1560694297272},{"_id":"source/_posts/写给自己的鸡汤.md","hash":"f13830532a23b6496cdd8465feee2edadc54c1a1","modified":1560694297272},{"_id":"source/_posts/实现JavaScript中的indexOf方法.md","hash":"cd18985e139895817a34e4a0aaa2531eeac45573","modified":1577550209027},{"_id":"source/_posts/常用Git操作总结.md","hash":"aa5581a99b81f76b88f90ffa4540b74d06924c6d","modified":1577549492081},{"_id":"source/_posts/我的HTTPS升级之旅.md","hash":"55b877f5afc3b0d31036a536268346be1a35250f","modified":1577618893616},{"_id":"source/_posts/正则表达式的模式匹配.md","hash":"5e25799b690ed3372c263c451f77999193c34827","modified":1577612636491},{"_id":"source/_posts/深入浅出Node-js-Cluster.md","hash":"de63e95cb05d539204dcd170b2ddd29c566cfee7","modified":1577618893615},{"_id":"source/_posts/深入理解BFC.md","hash":"4aece391acb963ca2a25dd2b7d2851c3f1e16c30","modified":1577618893615},{"_id":"source/_posts/类数组转换为数组.md","hash":"b1b5ec1725dad9f468fdcfa003e30fb2211be27e","modified":1560694297275},{"_id":"source/_posts/网站性能优化的14条规则.md","hash":"50f51a3d083fe2761b735838f6fcb9994a58f8ab","modified":1577550201403},{"_id":"source/_posts/网页渲染中的重绘与重排.md","hash":"a38b7fb8f1f5adc0dd8c82f5bc19f28b0c169ff3","modified":1560694297275},{"_id":"source/_posts/自定义复选框.md","hash":"2421930fe31fba126d661893abc9efe7d1f46d47","modified":1577618893573},{"_id":"source/_posts/让Ajax支持浏览器的前进后退.md","hash":"ebacc7ac03c83ae48572feb3b595480b01230fed","modified":1577550224028},{"_id":"source/_posts/部署Node项目到CentOS服务器.md","hash":"9f54b1df60852f15d951e0510966bbdb833ecd81","modified":1577618893573},{"_id":"source/_posts/阿里前端实习电话面试（二）.md","hash":"ab9f83ecb86d2fce2bdef21737584a4c5cf28ea8","modified":1560694297277},{"_id":"source/_posts/随笔-1.md","hash":"6bf0d5b63b36e8e78381368ca4d882e919e26835","modified":1560694297277},{"_id":"source/tags/index.md","hash":"22383aebe72f65a008d35ad6a21fa5b221567a4e","modified":1560694297258},{"_id":"source/uploads/.DS_Store","hash":"61e3603b25ae63ed9fcb32367b6aa78ccd2e8714","modified":1577619915807},{"_id":"source/uploads/avatar.jpg","hash":"7ec3b70597f503e1e91aedfde92144b02503c18f","modified":1560694297278},{"_id":"source/works/index.md","hash":"9a50befd54c7f0ca35994ca2ebcbf161c7dd15b4","modified":1560694297281},{"_id":"themes/Lights/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1577329935771},{"_id":"themes/Lights/.git/config","hash":"55186b084e401dbcf222ced3362ae31fca5df905","modified":1577329935773},{"_id":"themes/Lights/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1577329929527},{"_id":"themes/Lights/.git/index","hash":"e0d50586bdd907c78ee647e5f7b80ee7df66dec3","modified":1577554665841},{"_id":"themes/Lights/.git/packed-refs","hash":"e8c452bf4a0c60cf1d9b6e8af077b0e9b9762f2c","modified":1577329935770},{"_id":"themes/Lights/languages/default.yml","hash":"d18904b6ff9c423366a6a7fea7f0b4dc9f641e0d","modified":1577329935781},{"_id":"themes/Lights/languages/zh-CN.yml","hash":"459bc26848db9ef48a7216a84ded5fe0c398b5f5","modified":1577329935781},{"_id":"themes/Lights/layout/.DS_Store","hash":"08a1b17f850059d18759b3e71604904807708396","modified":1577329935781},{"_id":"themes/Lights/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1577329935784},{"_id":"themes/Lights/layout/category.ejs","hash":"d4f01dcf7eb3dd6b47485177993d5055353dd626","modified":1577329935784},{"_id":"themes/Lights/layout/index.ejs","hash":"1c07239b191362a58d6214d99be37eed886e1531","modified":1577329935784},{"_id":"themes/Lights/layout/layout.ejs","hash":"90cb61c51136eed5b551bf17638fad87040fbc73","modified":1577329935784},{"_id":"themes/Lights/layout/page.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1577329935784},{"_id":"themes/Lights/layout/post.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1577329935784},{"_id":"themes/Lights/layout/tag.ejs","hash":"edda55ba4a91800cdf812a55f453488a162e75e2","modified":1577329935785},{"_id":"themes/Lights/source/.DS_Store","hash":"ee833b63a9bc7d38ddb62c6128d8cfe9d26bdea9","modified":1577329935785},{"_id":"themes/Lights/source/offline.svg","hash":"397df2cca991edc8b6d18a2746013a8c576b52c9","modified":1577329935812},{"_id":"themes/Lights/source/offline.html","hash":"3b3f36910f59c7250e86a2d9b6ff06ae6cf38f39","modified":1577329935812},{"_id":"themes/Lights/source/sw.js","hash":"8bbe7661ed4165c590829e9dd5d9bba95a5572fc","modified":1577329935812},{"_id":"source/images/avatar.jpg","hash":"43627f418e3f25722e7a50b6478b40219d3e6d86","modified":1577330405078},{"_id":"source/images/avatar@2x.jpg","hash":"43627f418e3f25722e7a50b6478b40219d3e6d86","modified":1577330405078},{"_id":"themes/Lights/demo.png","hash":"0dca783cf968a9651e47712ed5982752ce427071","modified":1577329935781},{"_id":"source/uploads/Puppeteer/2.png","hash":"ea5f7467e769bef225908696e5131a7afe6065ab","modified":1577610096218},{"_id":"source/uploads/Script-Streaming/2.png","hash":"f6bd8dc74f4a3d50080ebfe9a49c0872b9533521","modified":1577610567392},{"_id":"source/uploads/Script-Streaming/3.png","hash":"9914929de1060174f73fdccd79ed0c8d7a91614d","modified":1577610570836},{"_id":"source/uploads/Script-Streaming/4.png","hash":"a2b6279a9e5591a9d19108de2fccaa4c8d35800a","modified":1577610574837},{"_id":"source/uploads/TCP/4.png","hash":"f5ee6ceed49985865585d992a7b12568f4e74e25","modified":1577553844812},{"_id":"source/uploads/css-checkbox/checkbox_1.png","hash":"26c0c895d54c65e50005fb58943141a4de2bebc5","modified":1560694297278},{"_id":"source/uploads/css-checkbox/checkbox_2.png","hash":"657b36f7b2040da6d1af72afa867f35f983dc047","modified":1560694297279},{"_id":"source/uploads/css-checkbox/checkbox_3.png","hash":"7875434faeb6590c33e31ae60687dab88a32eed7","modified":1560694297279},{"_id":"source/uploads/css-checkbox/checkbox_4.png","hash":"18d784eda46c00ccffc595c695cb74a1c718b96f","modified":1560694297279},{"_id":"source/uploads/css-line-break/fe-css-0.png","hash":"499bcc1fa87f3b4ae98c750216972cc79df4f5d9","modified":1560694297279},{"_id":"source/uploads/css-line-break/fe-css-1.jpg","hash":"889ca1fa98dd91f37a23cfbe5c24c7f03b24e63d","modified":1560694297280},{"_id":"source/uploads/css-line-break/fe-css-2.png","hash":"939c40b72b69d4af5d787d771419577bbb558b4f","modified":1560694297281},{"_id":"source/uploads/hls/1.png","hash":"c54077e3bf6d7c135812dfd36101875ba3d2ea4c","modified":1577611321184},{"_id":"source/uploads/https-upgrade/2.png","hash":"ba87b884589e186ecf45e614ea27eb30c0a954a9","modified":1577610966893},{"_id":"source/uploads/node-deploy/1.png","hash":"dd506dafa7b22eafe0e789547b53b3638bedb2e5","modified":1577612377413},{"_id":"source/uploads/node-deploy/2.png","hash":"a6c38635117ac79fa42a0e350f7abb822c3b5af6","modified":1577612377418},{"_id":"source/uploads/node-deploy/4.png","hash":"652b4793da6a780deed340b69f8e51da4d9e2726","modified":1577612377426},{"_id":"source/uploads/node-deploy/3.png","hash":"9038a495d47a03c5f7f1e213fc24ea1540c23c40","modified":1577612377422},{"_id":"source/uploads/virtual-dom/1.png","hash":"8cb208058c97dc98ad3c4a5eb2441bf5e6c355fc","modified":1577611876202},{"_id":"source/uploads/virtual-dom/2.png","hash":"a8caad6ea36ad564ec5c60cb3bb10f8d4ad2950e","modified":1577611876209},{"_id":"source/uploads/virtual-dom/3.png","hash":"b353167ccaa48741ad0416b8fe6c69facaf91709","modified":1577611876235},{"_id":"themes/Lights/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1577329929528},{"_id":"themes/Lights/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1577329929527},{"_id":"themes/Lights/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1577329929528},{"_id":"themes/Lights/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1577329929529},{"_id":"themes/Lights/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1577329929530},{"_id":"themes/Lights/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1577329929528},{"_id":"themes/Lights/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1577329929530},{"_id":"themes/Lights/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1577329929527},{"_id":"themes/Lights/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1577329929529},{"_id":"themes/Lights/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1577329929529},{"_id":"themes/Lights/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1577329929530},{"_id":"themes/Lights/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1577329929526},{"_id":"themes/Lights/.git/logs/HEAD","hash":"1b63a3727f83d10d5c10d42e963726478f7b8a82","modified":1577329935772},{"_id":"themes/Lights/layout/_partial/archive-post.ejs","hash":"eebef78c3b6f0bb6a6ea44dfc8e092140cfa3855","modified":1577329935782},{"_id":"themes/Lights/layout/_partial/archive.ejs","hash":"975842aa791fc7eef5100c79e3a6d3d7bb5939e3","modified":1577329935782},{"_id":"themes/Lights/layout/_partial/article.ejs","hash":"5cd1caeba8e66c629d46aec320d5a273413b1f10","modified":1577551860670},{"_id":"themes/Lights/layout/_partial/comment.ejs","hash":"0a68f7edf0e27a463e4b8025dba6437f9b0f00f1","modified":1577331236846},{"_id":"themes/Lights/layout/_partial/footer.ejs","hash":"6ff4ed2446ca08e8efcc2a6de1125660e34bcd09","modified":1577614233995},{"_id":"themes/Lights/layout/_partial/head.ejs","hash":"9f97f596aab8b18b10d5db2a2a55080f9a3c80fd","modified":1577333127418},{"_id":"themes/Lights/layout/_partial/last.ejs","hash":"46cbd82ecc24962c1f3750f7187f326cafff8c03","modified":1577329935783},{"_id":"themes/Lights/layout/_partial/nav.ejs","hash":"3ac3490c4cdcf075f1d2ee3c01b22bbbbd51be45","modified":1577331197857},{"_id":"themes/Lights/layout/_partial/pagination.ejs","hash":"21748a681f1c1c6ca6f8d8ea6ba057e3de41a96f","modified":1577329935783},{"_id":"themes/Lights/layout/_partial/profile.ejs","hash":"7e06aa9a41f67091f5efbefcf57d399995a84e5f","modified":1577329935783},{"_id":"themes/Lights/layout/_partial/title.ejs","hash":"288075e3ea9f056883d95913796e9a05537137ed","modified":1577329935783},{"_id":"themes/Lights/source/css/.DS_Store","hash":"a046f87642084865692477513bd7f9c2e84a735d","modified":1577329935785},{"_id":"themes/Lights/source/css/default.css","hash":"af92c40c2b3d0454d65d3cac7add43b1bc2ae0ec","modified":1577329935789},{"_id":"themes/Lights/source/css/old style.css","hash":"8f2e3165ac6ab258f66bad8f1688ea0697abdedf","modified":1577329935789},{"_id":"themes/Lights/source/css/style.styl","hash":"032497da02ba46aeb9289b9a75f841d648a50d98","modified":1577329935789},{"_id":"themes/Lights/source/image/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1577329935808},{"_id":"themes/Lights/source/images/avatar@2x.png","hash":"5c4037565c516aaf6cfd411b55067fd568ba5d58","modified":1577329935809},{"_id":"themes/Lights/source/js/highlight.pack.js","hash":"ef8a23118829bee91f158a31622a6f5f0dbe6407","modified":1577329935811},{"_id":"source/uploads/Script-Streaming/1.png","hash":"acd494d660f64776efbed747eb28bfc560531e5f","modified":1577610560495},{"_id":"source/uploads/TCP/2.png","hash":"2a338358b3ef86301922481769e4a7cbbe03e499","modified":1577553832636},{"_id":"source/uploads/bfc/2.png","hash":"d59a18537d2c840b9a51095b9cce54dbca6f1524","modified":1577612886997},{"_id":"source/uploads/bfc/1.png","hash":"30efbf8cf77e12f45122f4998b94fa773744d278","modified":1577612886996},{"_id":"source/uploads/bfc/3.png","hash":"3ccdddc5b2a3d68c07483389eedadfcef4e47503","modified":1577612886999},{"_id":"source/uploads/node-deploy/5.png","hash":"9e4b28330f15a775e59b915a3d9ded5f293ac8ae","modified":1577612377446},{"_id":"source/uploads/nodejs-cluster/1.jpg","hash":"6d3b573037c7566e475dbcf2f59e2a9059e40bf4","modified":1577613929641},{"_id":"themes/Lights/source/css/_base/utils.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577329935786},{"_id":"source/uploads/TCP/1.png","hash":"0e349ba2647a4ad074b5450b4d4b3c47747e5750","modified":1577553827466},{"_id":"themes/Lights/.git/objects/pack/pack-b36ef3ab8e45a1451966a9d90f9058dd8ad2ad43.idx","hash":"603d25d97278c06482ad76c4cb60679ffbcffc44","modified":1577329935760},{"_id":"themes/Lights/.git/refs/heads/master","hash":"51f24d45ec20c3be615d5dc3add607f12c48523a","modified":1577329935772},{"_id":"themes/Lights/source/css/_base/layout.styl","hash":"3c36550ae6492c6a097c5535b97a2e2840d09c32","modified":1577553196921},{"_id":"themes/Lights/source/css/_base/variable.styl","hash":"7fbbcb70a9c9e1b494176a0d9e3a4b2fc064fd18","modified":1577331861502},{"_id":"themes/Lights/source/css/_partial/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1577329935786},{"_id":"themes/Lights/source/css/_partial/archive.styl","hash":"25c4eef1920caee96eb9831b6d933dc861f3b419","modified":1577329935786},{"_id":"themes/Lights/source/css/_partial/article.styl","hash":"f0f0106e544083c1b29b72ead81509fdf58bd596","modified":1577329935787},{"_id":"themes/Lights/source/css/_partial/comment.styl","hash":"58669a57c48ff096a075ce7550b1f7612a18ae7f","modified":1577329935787},{"_id":"themes/Lights/source/css/_partial/footer.styl","hash":"f8923ff72a0f28f426de5889125fcb9388f4f28d","modified":1577553094403},{"_id":"themes/Lights/source/css/_partial/head.styl","hash":"c6ba99c4ef7c9b26034f4911ecf85741896d809c","modified":1577329935787},{"_id":"themes/Lights/source/css/_partial/last.styl","hash":"57cc8dd8d2469f94e5388e9d8e113dc824b6dbd1","modified":1577329935788},{"_id":"themes/Lights/source/css/_partial/nav.styl","hash":"bcba90e6df93fa397171dc900d2ff716c3af5ab7","modified":1577329935788},{"_id":"themes/Lights/source/css/_partial/pagination.styl","hash":"3d256b7cf403318ada117d499d9c167a7a3d0bb7","modified":1577329935788},{"_id":"themes/Lights/source/css/_partial/profile.styl","hash":"7b18155016e5a4fbde07144adb44f8823e6bba2e","modified":1577329935788},{"_id":"themes/Lights/source/css/_partial/title.styl","hash":"bed4614a749121662d3fcb2114cfc8f39692a689","modified":1577329935789},{"_id":"themes/Lights/source/css/styles/a11y-dark.css","hash":"122f8c71ac1c35398e96bf209f20668195a9e144","modified":1577329935790},{"_id":"themes/Lights/source/css/styles/a11y-light.css","hash":"3f5cde8e2278a6d52e6e4f30509588c80a3ad5a6","modified":1577329935790},{"_id":"themes/Lights/source/css/styles/agate.css","hash":"8e122b0f00f5a7ec4e6dc492bf1560441eeef7f0","modified":1577329935790},{"_id":"themes/Lights/source/css/styles/an-old-hope.css","hash":"124d4856bbd6e2cfc164914080724f1a59b9899c","modified":1577329935790},{"_id":"themes/Lights/source/css/styles/androidstudio.css","hash":"958baa24814c06a625612a3b2b478d54bc1bf1b1","modified":1577329935791},{"_id":"themes/Lights/source/css/styles/arduino-light.css","hash":"c6e05580b51b755e229e99eb156940ad2cab192b","modified":1577329935791},{"_id":"themes/Lights/source/css/styles/arta.css","hash":"17b23b9fa57ef7a05a6aaeea9b5feb5442a8e584","modified":1577329935791},{"_id":"themes/Lights/source/css/styles/ascetic.css","hash":"6358377b5c25667886aca0d605cbc497cf02405f","modified":1577329935791},{"_id":"themes/Lights/source/css/styles/atelier-cave-dark.css","hash":"f397d4418ce88b998841fd9135242461ba1a79b5","modified":1577329935792},{"_id":"themes/Lights/source/css/styles/atelier-cave-light.css","hash":"2933f0247ac6d84c2954dd4946e359853abbf70a","modified":1577329935792},{"_id":"themes/Lights/source/css/styles/atelier-dune-dark.css","hash":"081d73e454db140cd41b2bb595be297cfcab25e0","modified":1577329935792},{"_id":"themes/Lights/source/css/styles/atelier-dune-light.css","hash":"7ba074de897e6a5e27d8b97f7cd06c1746474e72","modified":1577329935792},{"_id":"themes/Lights/source/css/styles/atelier-estuary-dark.css","hash":"a0c46a0f955e3864f5e967ea93f5e61519a17be8","modified":1577329935792},{"_id":"themes/Lights/source/css/styles/atelier-estuary-light.css","hash":"91ae4668c15a085ffce15ca21e93da445b5ecf3a","modified":1577329935792},{"_id":"themes/Lights/source/css/styles/atelier-forest-dark.css","hash":"d8a4dc060b3fc719aa2f7d7b3f1019a3964b8101","modified":1577329935793},{"_id":"themes/Lights/source/css/styles/atelier-forest-light.css","hash":"8a78a4eea0f32d094d1f9e316d59e990ba739d97","modified":1577329935793},{"_id":"themes/Lights/source/css/styles/atelier-heath-dark.css","hash":"b93c2241ff123e62d4edb3dfc20410e4d1da3e78","modified":1577329935793},{"_id":"themes/Lights/source/css/styles/atelier-heath-light.css","hash":"172b98f783d213a20211ec6aca9a3840ba524f55","modified":1577329935793},{"_id":"themes/Lights/source/css/styles/atelier-lakeside-dark.css","hash":"fa707b252d5d5caccc0589374522bed47b7ca100","modified":1577329935793},{"_id":"themes/Lights/source/css/styles/atelier-lakeside-light.css","hash":"8ba595b9ba6e8be6dc029bf80caab38e85aed686","modified":1577329935793},{"_id":"themes/Lights/source/css/styles/atelier-plateau-dark.css","hash":"240f79f4e1fd63485c13900875b64c5a0d1bd06d","modified":1577329935794},{"_id":"themes/Lights/source/css/styles/atelier-plateau-light.css","hash":"9731db1052f23351c983210701edd3f5ceed343f","modified":1577329935794},{"_id":"themes/Lights/source/css/styles/atelier-savanna-light.css","hash":"6bd3a62c32558476d436bd389500e5fbeb693d67","modified":1577329935794},{"_id":"themes/Lights/source/css/styles/atelier-seaside-dark.css","hash":"b2800804a21f729a3d0a16b3aadc17679fd0639c","modified":1577329935794},{"_id":"themes/Lights/source/css/styles/atelier-seaside-light.css","hash":"3e6b9e2a3a5de455490b8224401f19702df4cde9","modified":1577329935795},{"_id":"themes/Lights/source/css/styles/atelier-sulphurpool-dark.css","hash":"1f006f8bd28e2ffbb73f708769605ba766787fff","modified":1577329935795},{"_id":"themes/Lights/source/css/styles/atelier-sulphurpool-light.css","hash":"0319c3eea893601b79b6c57652ef49b9222cc9de","modified":1577329935795},{"_id":"themes/Lights/source/css/styles/atom-one-dark-reasonable.css","hash":"f82d3cde0b923047d05731fa6e009e3232703f69","modified":1577329935795},{"_id":"themes/Lights/source/css/styles/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1577329935795},{"_id":"themes/Lights/source/css/styles/atom-one-light.css","hash":"eda63d8cce440dbf3bb823e10577a134e9941deb","modified":1577329935796},{"_id":"themes/Lights/source/css/styles/brown-paper.css","hash":"a6817d890e58f80ce79d87620791dae821a70fff","modified":1577329935796},{"_id":"themes/Lights/source/css/styles/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1577329935796},{"_id":"themes/Lights/source/css/styles/codepen-embed.css","hash":"c4520e45d18259817b8942d17971f27c94f0fb09","modified":1577329935796},{"_id":"themes/Lights/source/css/styles/color-brewer.css","hash":"96332573db854e7b7411caa94ba29b238fede2d3","modified":1577329935796},{"_id":"themes/Lights/source/css/styles/darcula.css","hash":"7740224d07375ddc321147dffabbfa83e39f0d8b","modified":1577329935796},{"_id":"themes/Lights/source/css/styles/dark.css","hash":"fc77519d4f5d731054c5d4b7e7bbdbb510833271","modified":1577329935797},{"_id":"themes/Lights/source/css/styles/darkula.css","hash":"0be948bb84acc05f93a1e5e9b48fe34cf61673a0","modified":1577329935797},{"_id":"themes/Lights/source/css/styles/default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1577329935797},{"_id":"themes/Lights/source/css/styles/docco.css","hash":"1be7be09a1b927c22c7f11451becdb335145bdd2","modified":1577329935797},{"_id":"themes/Lights/source/css/styles/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1577329935797},{"_id":"themes/Lights/source/css/styles/far.css","hash":"67e0658b2376e91e4894636a3522a30c2aec42de","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/foundation.css","hash":"75b0674dd1ed35d61977bd5c35dc29ca35835a7b","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/github-gist.css","hash":"8cfbcbf4c0491e44e6b073c95a04cc401cb11ab2","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/gml.css","hash":"e5a29350c16a729e8e54e5abe08bef6d24246a60","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/googlecode.css","hash":"fed3d439d0c305b337dd9c0f68dcbfa51429f445","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/grayscale.css","hash":"5688658c28fc5799517e8f3c224ae3da3797ba44","modified":1577329935798},{"_id":"themes/Lights/source/css/styles/gruvbox-dark.css","hash":"aaf90d076e34bc44016462d70f83985e0e55c8dc","modified":1577329935799},{"_id":"themes/Lights/source/css/styles/gruvbox-light.css","hash":"084699ab0aa326fede86e38bf41ebe49edde3a90","modified":1577329935799},{"_id":"themes/Lights/source/css/styles/hopscotch.css","hash":"03e7b9ec74bbd375db8d476836aac3729a6c86e8","modified":1577329935799},{"_id":"themes/Lights/source/css/styles/hybrid.css","hash":"1e2d54598b5f948b597059909d4bd158b7df021f","modified":1577329935799},{"_id":"themes/Lights/source/css/styles/idea.css","hash":"164649ae1e7c891a0d88cca075521af28656e2a1","modified":1577329935799},{"_id":"themes/Lights/source/css/styles/ir-black.css","hash":"95aad65ba77183500ce0f7ad62a7535b647ee20c","modified":1577329935800},{"_id":"themes/Lights/source/css/styles/isbl-editor-dark.css","hash":"73d2282192e403868998cff2e77093ace8a6e5fb","modified":1577329935800},{"_id":"themes/Lights/source/css/styles/isbl-editor-light.css","hash":"92557e568d1fb352cf78a63679b9c431c0b6d407","modified":1577329935800},{"_id":"themes/Lights/source/css/styles/kimbie.dark.css","hash":"58ed061c204fbc09d221ee9135d66bad976e5fc3","modified":1577329935800},{"_id":"themes/Lights/source/css/styles/kimbie.light.css","hash":"b7aa9b1b21a25dfefcac7649a328962f84c47913","modified":1577329935800},{"_id":"themes/Lights/source/css/styles/lightfair.css","hash":"055ad4fbd468e37f3166c90521758475f525f22d","modified":1577329935801},{"_id":"themes/Lights/source/css/styles/magula.css","hash":"ebc291f90e456abeeccb16937e7f51735733f4f7","modified":1577329935801},{"_id":"themes/Lights/source/css/styles/mono-blue.css","hash":"fd0f39cd4c93ccb8d0bb2f6a1f359522e15a89cb","modified":1577329935801},{"_id":"themes/Lights/source/css/styles/monokai-sublime.css","hash":"e4f3df87cbfa634c86b489e9cc43acf44d415986","modified":1577329935801},{"_id":"themes/Lights/source/css/styles/monokai.css","hash":"f69df92e3ccdce28e6f811ec84f11698f2811198","modified":1577329935801},{"_id":"themes/Lights/source/css/styles/nord.css","hash":"98dfcd6eee4968fb4c634784cb048a98169b1bc8","modified":1577329935802},{"_id":"themes/Lights/source/css/styles/obsidian.css","hash":"6ed475813fe4886a58b236297862ff2f181e66f7","modified":1577329935802},{"_id":"themes/Lights/source/css/styles/ocean.css","hash":"fce6858e1c5eb9d2857cb5b5d24069c5994cfc91","modified":1577329935802},{"_id":"themes/Lights/source/css/styles/paraiso-dark.css","hash":"8f5445327ce3c83b62f6bf4c1a0d87fa6f036341","modified":1577329935802},{"_id":"themes/Lights/source/css/styles/paraiso-light.css","hash":"6eb3ab7a3337f9cad3a2e5fa6bf7dd83685228d8","modified":1577329935803},{"_id":"themes/Lights/source/css/styles/pojoaque.css","hash":"4e1e6a431212f5043a550474a1acda63362cdd6f","modified":1577329935803},{"_id":"themes/Lights/source/css/styles/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1577329935803},{"_id":"themes/Lights/source/css/styles/purebasic.css","hash":"f353a2cedf3f261a0676fce7c824bdd2e8197775","modified":1577329935803},{"_id":"themes/Lights/source/css/styles/qtcreator_dark.css","hash":"213a40d203c4986cdbcb1bdf7d0b9013b29041ba","modified":1577329935803},{"_id":"themes/Lights/source/css/styles/qtcreator_light.css","hash":"9a2a19ac2f6e6a7d5edd7fae67b7de4a3957e878","modified":1577329935804},{"_id":"themes/Lights/source/css/styles/railscasts.css","hash":"a6d2043478fae5915926914cbd96fe9b706d98a6","modified":1577329935804},{"_id":"themes/Lights/source/css/styles/rainbow.css","hash":"1b2d98ccdda36aa926d0e6d069b673fdacd2d33e","modified":1577329935804},{"_id":"themes/Lights/source/css/styles/routeros.css","hash":"fc5db7c8f18d6b31ad92df21a51e7867d459af19","modified":1577329935804},{"_id":"themes/Lights/source/css/styles/school-book.css","hash":"6c4198b6ffde866f5e2fe9172aee094065f9774a","modified":1577329935804},{"_id":"themes/Lights/source/css/styles/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1577329935805},{"_id":"themes/Lights/source/css/styles/shades-of-purple.css","hash":"3f712f68a0b3a9e6de4796da206a4975354beec4","modified":1577329935805},{"_id":"themes/Lights/source/css/styles/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1577329935805},{"_id":"themes/Lights/source/css/styles/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1577329935805},{"_id":"themes/Lights/source/css/styles/sunburst.css","hash":"8309eab2e5b1765dbee81a626baacbdad869b76a","modified":1577329935805},{"_id":"themes/Lights/source/css/styles/tomorrow-night-blue.css","hash":"cd257d7d6a37cd5a09419b5f5f9d34b6b282423f","modified":1577329935806},{"_id":"themes/Lights/source/css/styles/tomorrow-night-bright.css","hash":"04f0af30fdda5e5d6ebdeef5a860b6b7e49cfe89","modified":1577329935806},{"_id":"themes/Lights/source/css/styles/tomorrow-night-eighties.css","hash":"d82b84bcda0588105dbbc0e8e8ba5e62c208a061","modified":1577329935806},{"_id":"themes/Lights/source/css/styles/tomorrow-night.css","hash":"86264dd861d35a8b135f9fcb8ff2675e9fa69c16","modified":1577329935806},{"_id":"themes/Lights/source/css/styles/tomorrow.css","hash":"163593ad70770d0296c5e643fa62e58e63f1b340","modified":1577329935806},{"_id":"themes/Lights/source/css/styles/vs.css","hash":"2ac5e89ceb3d5a0e0fdab1ed6d9a411ec7d221aa","modified":1577329935807},{"_id":"themes/Lights/source/css/styles/vs2015.css","hash":"3c7fa677de2a785d90fc6c3f7520ac1b11bfd37a","modified":1577329935807},{"_id":"themes/Lights/source/css/styles/xcode.css","hash":"d8a1f18e5344c2edf97921ec21a54b02745997e9","modified":1577329935807},{"_id":"themes/Lights/source/css/styles/xt256.css","hash":"d9e0f7d8ab5cfd627ce085c16e7a90e1ad495516","modified":1577329935807},{"_id":"themes/Lights/source/css/styles/zenburn.css","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1577329935808},{"_id":"themes/Lights/source/images/avatar.png","hash":"918f200b256da5d85ffa5cbf09f537a6dec8ec2e","modified":1577329935809},{"_id":"themes/Lights/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1577329935811},{"_id":"source/uploads/TCP/5.png","hash":"493966d2114b003924b0a93d4cb3ec6da3ae1e3b","modified":1577553852011},{"_id":"source/uploads/bfc/4.png","hash":"547655bc854fecdbf60a6ba96674232c39b092e5","modified":1577612887000},{"_id":"themes/Lights/source/css/styles/atelier-savanna-dark.css","hash":"09d45a218f87b8cb55b5ca7f4e9d76ea89a9404a","modified":1577329935794},{"_id":"themes/Lights/.git/logs/refs/heads/master","hash":"1b63a3727f83d10d5c10d42e963726478f7b8a82","modified":1577329935773},{"_id":"themes/Lights/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1577329935771},{"_id":"source/uploads/Puppeteer/1.png","hash":"b7a6df37d5763074d9ffdd2de6387effa896ec9b","modified":1577610092283},{"_id":"source/uploads/TCP/3.png","hash":"17b4dda7b49f7d17100478efe0df38a86a662ffe","modified":1577553838777},{"_id":"themes/Lights/.git/logs/refs/remotes/origin/HEAD","hash":"1b63a3727f83d10d5c10d42e963726478f7b8a82","modified":1577329935771},{"_id":"source/uploads/node-deploy/6.png","hash":"a8852c8b30699c9d6c16ce21df840edf417b543e","modified":1577612377452},{"_id":"themes/Lights/.git/objects/pack/pack-b36ef3ab8e45a1451966a9d90f9058dd8ad2ad43.pack","hash":"4bad6658e424c6286738b0fac19a4f7fe7d87a5b","modified":1577329935759},{"_id":"source/uploads/https-upgrade/1.png","hash":"69aa7de26ce554031d9f6946ac3421e91bb0fae1","modified":1577610970583},{"_id":"source/uploads/splice/3.jpg","hash":"bafddf931dbc8b94713a46bab8e7bf4eeb4f0992","modified":1577611553887},{"_id":"source/uploads/splice/1.png","hash":"f46d62f7fa671da2f11dc4754eaddc183054a08a","modified":1577611538093},{"_id":"source/uploads/splice/2.png","hash":"501a15d39359a1fc3d03ad68f0a1f7dc9179596c","modified":1577611548155},{"_id":"public/atom.xml","hash":"5a0668dbc44352fcab4c9537eedc1a1f42992ae0","modified":1577620416936},{"_id":"public/sitemap.xml","hash":"ddc24ec4fb7890638b33f5b729c3c789e38d0145","modified":1577620416961},{"_id":"public/404.html","hash":"92db355141957f8499558f556f7dd43b48cb0bde","modified":1577620417163},{"_id":"public/about/index.html","hash":"fef179b74eae0a10daeaeb9e4889075d7bbd9545","modified":1577620417168},{"_id":"public/categories/index.html","hash":"d82be768937f01531fa65a0b8aec51c3abe30da3","modified":1577620417169},{"_id":"public/tags/index.html","hash":"57a2288ef901d85f5168f582dc5bacd5a8fbeb13","modified":1577620417169},{"_id":"public/article/常用Git操作总结/index.html","hash":"8d702c805696ade56f8947c0c4208317c7110a2a","modified":1577620417169},{"_id":"public/article/深入浅出Node-js-Cluster/index.html","hash":"2f45be2528f8cfd021fc2459ac268a68d5447c11","modified":1577620417169},{"_id":"public/article/你不知道的eval/index.html","hash":"b423f5801002f223b0715f79517fb29e4fdca1f8","modified":1577620417169},{"_id":"public/article/【译】使用Script-Streaming提升页面加载性能/index.html","hash":"b78d2b092abfb2d48df68e50b6b6070e7f5de742","modified":1577620417169},{"_id":"public/article/【译】ES2018新特性：Promise-prototype-finally/index.html","hash":"82a1c0da8b604ad7387f8474d2cb0b8ba8396410","modified":1577620417170},{"_id":"public/works/index.html","hash":"8027e96c25bcaf5116a94e6845cc1db33eecd5c7","modified":1577620417170},{"_id":"public/article/JavaScript 设计模式汇总/index.html","hash":"497b92fc34553fd371577441059f69f794578add","modified":1577620417170},{"_id":"public/article/ES6语法总结/index.html","hash":"e282de75ec29ce911b200123996257c359e92e40","modified":1577620417170},{"_id":"public/article/写给自己的鸡汤/index.html","hash":"507485d236eef2af3a3be2d20d10ff6d4b5eb945","modified":1577620417170},{"_id":"public/article/【译】HLS架构简介/index.html","hash":"44cebfee97539cb5e4cb58834368e183525f3a92","modified":1577620417170},{"_id":"public/article/【译】2017-年要去学的-3-个-CSS-新属性/index.html","hash":"9d05be2020fe8aedb603b588b70a62bdfaf5ef8f","modified":1577620417170},{"_id":"public/article/我的HTTPS升级之旅/index.html","hash":"234df15e4df9e16443fdd01fa08463fc840e6b76","modified":1577620417170},{"_id":"public/article/【译】异步：现在与将来（并行篇）/index.html","hash":"034f11fbbcdcef4822bef0a41af26b91077402d4","modified":1577620417170},{"_id":"public/article/【译】真实的Virtual-DOM/index.html","hash":"6b95e72135be4fca1a9a1c944bbd8baa6d3eb4b7","modified":1577620417170},{"_id":"public/article/【译】为什么Vue-js不支持templateURL/index.html","hash":"a401560fe66cdada36efd5ecde285aa36838a77d","modified":1577620417170},{"_id":"public/article/【JavaScript】splice方法实现原理分析/index.html","hash":"42fd6f000c3236aa5d77c6247ff28032700a04c9","modified":1577620417170},{"_id":"public/article/Cookie和Session的区别总结/index.html","hash":"d2a29f55fe033ce2f052779e62f8440c92a17c12","modified":1577620417170},{"_id":"public/article/traceroute的原理/index.html","hash":"8aa812ab3d5a019e08d0d5c53904504e9aa4ab58","modified":1577620417170},{"_id":"public/article/你该逃课吗/index.html","hash":"e16d741096dfd830351d667ae28173be62b5ae70","modified":1577620417170},{"_id":"public/article/自定义复选框/index.html","hash":"5845fabc7d3561ba2797efe0ed3a26c1e5ca6377","modified":1577620417171},{"_id":"public/article/类数组转换为数组/index.html","hash":"4bb50aed28ad086b36cca452ff1b2ddc2a4e346b","modified":1577620417171},{"_id":"public/article/TCP性能优化浅析/index.html","hash":"f1ed1a4869321fcc04a3970afecb2ef4fa9e6a88","modified":1577620417171},{"_id":"public/article/让Ajax支持浏览器的前进后退/index.html","hash":"faa936e86624c5006f1579ad9a2daf39e15887fd","modified":1577620417171},{"_id":"public/article/一个优化的快速排序/index.html","hash":"548568fc49dcc143c9c4131bab6083da04263e7a","modified":1577620417171},{"_id":"public/article/DNS劫持与DNS污染的原理/index.html","hash":"5ecd96eefc4a2ec07657ab2c47380a802c0a4a40","modified":1577620417171},{"_id":"public/article/Vue2-0源码学习-0/index.html","hash":"0f39e645710f9f700dd4bd6efc62a3e3d54a1338","modified":1577620417171},{"_id":"public/article/部署Node项目到CentOS服务器/index.html","hash":"35cb26ecd2f6faac30984c67dba16833bd687a7e","modified":1577620417171},{"_id":"public/article/【JavaScript实现算法】快速排序/index.html","hash":"21fa9f48072501c08c2164f93809820472775fe3","modified":1577620417171},{"_id":"public/article/实现JavaScript中的indexOf方法/index.html","hash":"a778a4e2d2e2c58118cebeef3480c2710465868f","modified":1577620417171},{"_id":"public/article/【JavaScript实现数据结构】队列/index.html","hash":"9e906f1a7a001a08d10cb2977ef09c4686d89d0b","modified":1577620417171},{"_id":"public/article/阿里前端实习电话面试（二）/index.html","hash":"d32daea7c1a51309ad025fc53f8d166b0add05cc","modified":1577620417171},{"_id":"public/article/CDN缓存原理/index.html","hash":"622116fb8775d1ea34abb21cf44728371161aa5a","modified":1577620417171},{"_id":"public/article/apply方法的妙用/index.html","hash":"c58a4d478592250eb2637168f346b8b0601df717","modified":1577620417171},{"_id":"public/article/网站性能优化的14条规则/index.html","hash":"a0e3029580c94e0682624679e60baec6e06dd8d0","modified":1577620417171},{"_id":"public/article/cookie/index.html","hash":"42eec54c29de8bb4e9a2ca3b6f7d1758ab1e74dc","modified":1577620417171},{"_id":"public/article/正则表达式的模式匹配/index.html","hash":"c1d78639fb846a45fdf16d922dce10ca4ed02f4b","modified":1577620417172},{"_id":"public/article/【JavaScript实现数据结构】栈/index.html","hash":"9e224603ee528648cc5ae534db85cfe048c2cd5d","modified":1577620417172},{"_id":"public/article/一个通用的事件监听器/index.html","hash":"a4b6f5d6500f5d70eb64002412a8dbb5cfd6f8fa","modified":1577620417172},{"_id":"public/article/2016阿里前端实习电话面试实录/index.html","hash":"b856fa6d2f82da3054a990552b8e2598ada2fdbc","modified":1577620417172},{"_id":"public/article/什么是TCP连接的三次握手/index.html","hash":"c14a9c45f3de6774265075e6c6bc3cd0c54f61b4","modified":1577620417172},{"_id":"public/article/HTTPS知识点/index.html","hash":"793d1007758525c2586ee48d8502167740a724bd","modified":1577620417172},{"_id":"public/article/localStorage详解/index.html","hash":"0e3bc8bdd9f9b5de876acddd599052752a512f8c","modified":1577620417172},{"_id":"public/article/HTTP状态码大全/index.html","hash":"fd9077156fd3d03dceb088795a418d1b38208f32","modified":1577620417172},{"_id":"public/article/【CSS】文本换行的几个属性/index.html","hash":"d39d5650deaa5b57ebb082b0cefcc90af268393e","modified":1577620417172},{"_id":"public/article/【JavaScript】闭包的概念/index.html","hash":"4f018885e123e60914f84b60a8eaf03923776760","modified":1577620417172},{"_id":"public/article/【JavaScript】变量作用域/index.html","hash":"ad4e0adefcbd0f37df870745c42b21a9f13c73b4","modified":1577620417172},{"_id":"public/article/Markdown简明语法/index.html","hash":"5ec13a5163d6c36a4ddcdb0bc62138bcf77243b1","modified":1577620417172},{"_id":"public/article/网页渲染中的重绘与重排/index.html","hash":"c0b52db19d10172fb866d2c536e47121fe987cc5","modified":1577620417172},{"_id":"public/article/随笔-1/index.html","hash":"56a873ee73fa42aa5ca7fafdd1db431a711d7eab","modified":1577620417172},{"_id":"public/article/深入理解BFC/index.html","hash":"c927eba9dbfa034148388b8f666578978f963fae","modified":1577620417172},{"_id":"public/article/null和undefined的区别/index.html","hash":"3b91e236bba1cf84b191e2d278a0ed48a6eb9204","modified":1577620417172},{"_id":"public/categories/网络/index.html","hash":"ecbb693fc783b4d2ea3941a9fdff263fd6cc5b1c","modified":1577620417172},{"_id":"public/categories/面试/index.html","hash":"1ef3377391f3f24504eb784fece3b03dab4cc00f","modified":1577620417173},{"_id":"public/categories/前端/index.html","hash":"58a36ff6489366e423c0f33b3b914cc8c8319840","modified":1577620417173},{"_id":"public/categories/前端/page/2/index.html","hash":"58a36ff6489366e423c0f33b3b914cc8c8319840","modified":1577620417173},{"_id":"public/categories/工具/index.html","hash":"fcb4344ac0fb922338540512872d0d7addcfdfed","modified":1577620417173},{"_id":"public/categories/数据结构与算法/index.html","hash":"15050b6893cee1e0d763710c56cdfeb82c38f717","modified":1577620417173},{"_id":"public/categories/随笔/index.html","hash":"2f80dc81a3e853b41c9dd59a400e0fb79c01f01e","modified":1577620417173},{"_id":"public/categories/Node-js/index.html","hash":"2d25fa8912d73abb8e6f9826ed898924990386fc","modified":1577620417173},{"_id":"public/categories/后端/index.html","hash":"ca810610043ab42cb695d85bd29478d5872a23b0","modified":1577620417173},{"_id":"public/page/2/index.html","hash":"b33c9b14d4e1efed638e9963a65548b2e83ebfac","modified":1577620417173},{"_id":"public/page/3/index.html","hash":"3f690ee9f3f3b04c4e970c71c4aebeb9bf429f26","modified":1577620417173},{"_id":"public/index.html","hash":"2f5b7ecea2e23b7c5ca34cc5defbac7b6296444c","modified":1577620417173},{"_id":"public/article/Node-js错误处理最佳实践/index.html","hash":"9972c537cad70691b732776985c672b7b05d26ec","modified":1577620417173},{"_id":"public/article/【译】无头Chrome：服务端渲染JS页面的一个解决方案/index.html","hash":"939625b39c24e0880d2ea5a5c2e07be4151d9abc","modified":1577620417173},{"_id":"public/article/【译】ES2018新特性：Rest-Spread-特性/index.html","hash":"76e980214366351d1a79c10750d8a352a8698e16","modified":1577620417174},{"_id":"public/article/【译】异步：现在与将来（并发篇）/index.html","hash":"19712af063f8c598b5cc61e9f3dd5447a3ba90bd","modified":1577620417174},{"_id":"public/article/【译】异步：现在与将来（基础篇）/index.html","hash":"e045bfc16739038b681a72294534bcd9fc35cce9","modified":1577620417174},{"_id":"public/article/JavaScript数组去重/index.html","hash":"9710e5c0d8b549b46a229c94cdf367230eee035f","modified":1577620417174},{"_id":"public/archives/index.html","hash":"911df74468cc84128cfcd1b5500b57df6416b7cd","modified":1577620417174},{"_id":"public/archives/page/2/index.html","hash":"911df74468cc84128cfcd1b5500b57df6416b7cd","modified":1577620417174},{"_id":"public/archives/page/3/index.html","hash":"911df74468cc84128cfcd1b5500b57df6416b7cd","modified":1577620417174},{"_id":"public/archives/2016/index.html","hash":"a9241814ed20e3bca1436422136e24810d67b81f","modified":1577620417174},{"_id":"public/archives/2016/page/2/index.html","hash":"a9241814ed20e3bca1436422136e24810d67b81f","modified":1577620417174},{"_id":"public/archives/2016/03/index.html","hash":"f194422ddf2836c0e8773bfe5b1a800a4b9f6c2a","modified":1577620417174},{"_id":"public/archives/2016/03/page/2/index.html","hash":"f194422ddf2836c0e8773bfe5b1a800a4b9f6c2a","modified":1577620417174},{"_id":"public/archives/2016/04/index.html","hash":"76fdc44aa6e1b8eca6403a5b747f20f423a909b8","modified":1577620417174},{"_id":"public/archives/2016/05/index.html","hash":"2fda717fe322c15a077b3aad141e9f88da1fd801","modified":1577620417174},{"_id":"public/archives/2016/06/index.html","hash":"b004c91fefcd7f06268c28f0d0ee4857ac65da86","modified":1577620417174},{"_id":"public/archives/2016/08/index.html","hash":"6fb55ace5634cc469932698a2134b2a84ea52509","modified":1577620417174},{"_id":"public/archives/2016/09/index.html","hash":"d88532709b8581aed2626d36d8cf9a36cff13aa4","modified":1577620417174},{"_id":"public/archives/2017/01/index.html","hash":"135bc4d514e0d9b69fc78292024957c932c74f3a","modified":1577620417174},{"_id":"public/archives/2017/index.html","hash":"0d3f5248283a40d8472c87581a3445caad71aba6","modified":1577620417175},{"_id":"public/archives/2017/02/index.html","hash":"18ceb1554629f8605ed517c09894fce97b138381","modified":1577620417175},{"_id":"public/archives/2017/03/index.html","hash":"b562bc5db5eb7572c2fd2f78494eed391675dec6","modified":1577620417175},{"_id":"public/archives/2017/04/index.html","hash":"bd445bcf29f2656c72866895c9dfd1dfc68ab9ce","modified":1577620417175},{"_id":"public/archives/2017/05/index.html","hash":"6b1c99584d0eb283cbe67c735f1f99a6877ebbf8","modified":1577620417175},{"_id":"public/archives/2018/index.html","hash":"2f9c7f3905652e74db8c24fa7ef726282e953e02","modified":1577620417175},{"_id":"public/archives/2018/01/index.html","hash":"ed80aa9ad69eae13cdb1e1098e5402ed0ea18841","modified":1577620417175},{"_id":"public/archives/2018/02/index.html","hash":"516830242a2a76c43a0c0cb6663a6e9fe7d68f17","modified":1577620417175},{"_id":"public/archives/2018/07/index.html","hash":"4f6b163cae09108a176f9c41c33353b7f2946b4c","modified":1577620417175},{"_id":"public/archives/2018/08/index.html","hash":"2a522db96484a9660507f7c08b27fe8a272372b6","modified":1577620417175},{"_id":"public/archives/2018/09/index.html","hash":"22582f6fd3733c8c7c77e79c2d74d54a54e2a627","modified":1577620417175},{"_id":"public/archives/2018/11/index.html","hash":"977e425cd730c9fefbb436398172912da566b3c4","modified":1577620417175},{"_id":"public/archives/2019/index.html","hash":"55ad62540fae7714a3141d94d7b17046d332414b","modified":1577620417175},{"_id":"public/archives/2019/03/index.html","hash":"438b27cbe1b5773a59d5a53bbb5c167034ec6993","modified":1577620417175},{"_id":"public/archives/2019/12/index.html","hash":"cbd9c2f07610147cf4d132c0263d7286e552c6cf","modified":1577620417175},{"_id":"public/tags/性能优化/index.html","hash":"26a52933d5b79c3c74a14e838528458cfd2a861f","modified":1577620417175},{"_id":"public/tags/面试/index.html","hash":"01d71185448f559ccd0e364823a2474e2dd1ea49","modified":1577620417175},{"_id":"public/tags/JavaScript/index.html","hash":"a2b37d3e1ecd075f775dd6b4325161f03638d3b6","modified":1577620417175},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"a2b37d3e1ecd075f775dd6b4325161f03638d3b6","modified":1577620417175},{"_id":"public/tags/DNS/index.html","hash":"c309337abf83734c05d4b7170864ec3bdb11bc21","modified":1577620417176},{"_id":"public/tags/web安全/index.html","hash":"c9f6453cdfbe8c5103a98ed10ad37b21a654c832","modified":1577620417176},{"_id":"public/tags/HTTP/index.html","hash":"d5f295d8d40fbf214e7f5de5eac8a00025c73fc0","modified":1577620417176},{"_id":"public/tags/设计模式/index.html","hash":"1b69fe2e49fcb2da2418114e7efea19de50c5d2b","modified":1577620417176},{"_id":"public/tags/Markdown/index.html","hash":"0fc95ecce337e132f0da19811094216f5d0ee3de","modified":1577620417176},{"_id":"public/tags/TCP/index.html","hash":"c59c6f1b66893611ebee8cdfd733e24f09118d35","modified":1577620417176},{"_id":"public/tags/Vue/index.html","hash":"b4f402bf9470a0960cd8518bf9a38c2b53fd31b1","modified":1577620417176},{"_id":"public/tags/IP/index.html","hash":"e0515f49952f1b531327d6a72e30583b482b31f2","modified":1577620417176},{"_id":"public/tags/CSS/index.html","hash":"331453efc173953332950067d37e20aa10867d47","modified":1577620417176},{"_id":"public/tags/数据结构/index.html","hash":"50b62ab37a493573f5e96eba6ec4e7caa70bee70","modified":1577620417176},{"_id":"public/tags/算法/index.html","hash":"3fc3e79f29c7039ef43d1cc6fd76ae70b31ce07b","modified":1577620417176},{"_id":"public/tags/翻译/index.html","hash":"7c7410e4ffb404c7e36c0d4377a59a53d3c4ee84","modified":1577620417176},{"_id":"public/tags/React/index.html","hash":"f509be47b1b5d84f7679e8d2d16086ccb2c67663","modified":1577620417176},{"_id":"public/tags/随笔/index.html","hash":"ddfd9e56fec78c463a2a492136478786cb0748af","modified":1577620417176},{"_id":"public/tags/Git/index.html","hash":"c0b5dcb735589f4454d01c0107c09595999bb1ea","modified":1577620417176},{"_id":"public/tags/Node-js/index.html","hash":"4182fc0a84e2a679c9162ca27a5b3bd9326ef391","modified":1577620417176},{"_id":"public/tags/浏览器/index.html","hash":"c25fc7b0b695b5beef0550ca743c2c8138bc6698","modified":1577620417176},{"_id":"public/tags/运维/index.html","hash":"125a1e4c562c4b32c3879a0d6e9bd2e2995df033","modified":1577620417177},{"_id":"public/tags/直播/index.html","hash":"267c964a4d6d256ac24629471a63e2af352aedbd","modified":1577620417177},{"_id":"public/tags/Chrome/index.html","hash":"b9ce3b93992afb98fa85ac59e0b7ae9706a9a33f","modified":1577620417177},{"_id":"public/tags/Puppeteer/index.html","hash":"e27b7bd5732d2085d26695a9edd71fde4f681813","modified":1577620417177},{"_id":"public/article/WebP技术原理及应用/index.html","hash":"215b29359cbdb10846f80133e954d5de90cd7089","modified":1577620417187},{"_id":"public/archives/2017/08/index.html","hash":"62124603d652a10b7d4cf8d10f29c195a48a6531","modified":1577620417187},{"_id":"public/tags/WebP/index.html","hash":"e298c3a1eb4d802f9b6e6d0dbcd0c112e8b02770","modified":1577620417187},{"_id":"public/CNAME","hash":"87eb67dc0e83d175b646aa565c07a460039107e8","modified":1577620417196},{"_id":"public/uploads/avatar.jpg","hash":"7ec3b70597f503e1e91aedfde92144b02503c18f","modified":1577620417196},{"_id":"public/offline.svg","hash":"397df2cca991edc8b6d18a2746013a8c576b52c9","modified":1577620417196},{"_id":"public/uploads/Puppeteer/2.png","hash":"ea5f7467e769bef225908696e5131a7afe6065ab","modified":1577620417196},{"_id":"public/uploads/Script-Streaming/3.png","hash":"9914929de1060174f73fdccd79ed0c8d7a91614d","modified":1577620417196},{"_id":"public/uploads/Script-Streaming/2.png","hash":"f6bd8dc74f4a3d50080ebfe9a49c0872b9533521","modified":1577620417197},{"_id":"public/uploads/Script-Streaming/4.png","hash":"a2b6279a9e5591a9d19108de2fccaa4c8d35800a","modified":1577620417197},{"_id":"public/uploads/css-checkbox/checkbox_2.png","hash":"657b36f7b2040da6d1af72afa867f35f983dc047","modified":1577620417197},{"_id":"public/uploads/css-checkbox/checkbox_3.png","hash":"7875434faeb6590c33e31ae60687dab88a32eed7","modified":1577620417197},{"_id":"public/uploads/TCP/4.png","hash":"f5ee6ceed49985865585d992a7b12568f4e74e25","modified":1577620417197},{"_id":"public/uploads/css-checkbox/checkbox_4.png","hash":"18d784eda46c00ccffc595c695cb74a1c718b96f","modified":1577620417197},{"_id":"public/uploads/css-line-break/fe-css-0.png","hash":"499bcc1fa87f3b4ae98c750216972cc79df4f5d9","modified":1577620417197},{"_id":"public/uploads/css-line-break/fe-css-1.jpg","hash":"889ca1fa98dd91f37a23cfbe5c24c7f03b24e63d","modified":1577620417197},{"_id":"public/uploads/css-line-break/fe-css-2.png","hash":"939c40b72b69d4af5d787d771419577bbb558b4f","modified":1577620417197},{"_id":"public/uploads/hls/1.png","hash":"c54077e3bf6d7c135812dfd36101875ba3d2ea4c","modified":1577620417197},{"_id":"public/uploads/https-upgrade/2.png","hash":"ba87b884589e186ecf45e614ea27eb30c0a954a9","modified":1577620417197},{"_id":"public/uploads/node-deploy/1.png","hash":"dd506dafa7b22eafe0e789547b53b3638bedb2e5","modified":1577620417198},{"_id":"public/uploads/node-deploy/2.png","hash":"a6c38635117ac79fa42a0e350f7abb822c3b5af6","modified":1577620417198},{"_id":"public/uploads/node-deploy/4.png","hash":"652b4793da6a780deed340b69f8e51da4d9e2726","modified":1577620417198},{"_id":"public/uploads/node-deploy/3.png","hash":"9038a495d47a03c5f7f1e213fc24ea1540c23c40","modified":1577620417198},{"_id":"public/uploads/virtual-dom/1.png","hash":"8cb208058c97dc98ad3c4a5eb2441bf5e6c355fc","modified":1577620417198},{"_id":"public/uploads/virtual-dom/2.png","hash":"a8caad6ea36ad564ec5c60cb3bb10f8d4ad2950e","modified":1577620417199},{"_id":"public/uploads/virtual-dom/3.png","hash":"b353167ccaa48741ad0416b8fe6c69facaf91709","modified":1577620417199},{"_id":"public/uploads/css-checkbox/checkbox_1.png","hash":"26c0c895d54c65e50005fb58943141a4de2bebc5","modified":1577620417199},{"_id":"public/uploads/nodejs-cluster/1.jpg","hash":"6d3b573037c7566e475dbcf2f59e2a9059e40bf4","modified":1577620417199},{"_id":"public/css/styles/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1577620417199},{"_id":"public/css/styles/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1577620417199},{"_id":"public/css/styles/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1577620417199},{"_id":"public/images/avatar@2x.png","hash":"5c4037565c516aaf6cfd411b55067fd568ba5d58","modified":1577620417199},{"_id":"public/images/avatar.jpg","hash":"43627f418e3f25722e7a50b6478b40219d3e6d86","modified":1577620417664},{"_id":"public/images/avatar@2x.jpg","hash":"43627f418e3f25722e7a50b6478b40219d3e6d86","modified":1577620417664},{"_id":"public/uploads/Script-Streaming/1.png","hash":"acd494d660f64776efbed747eb28bfc560531e5f","modified":1577620417667},{"_id":"public/uploads/bfc/1.png","hash":"30efbf8cf77e12f45122f4998b94fa773744d278","modified":1577620417667},{"_id":"public/uploads/TCP/2.png","hash":"2a338358b3ef86301922481769e4a7cbbe03e499","modified":1577620417667},{"_id":"public/uploads/bfc/2.png","hash":"d59a18537d2c840b9a51095b9cce54dbca6f1524","modified":1577620417667},{"_id":"public/uploads/bfc/3.png","hash":"3ccdddc5b2a3d68c07483389eedadfcef4e47503","modified":1577620417667},{"_id":"public/uploads/node-deploy/5.png","hash":"9e4b28330f15a775e59b915a3d9ded5f293ac8ae","modified":1577620417667},{"_id":"public/images/avatar.png","hash":"918f200b256da5d85ffa5cbf09f537a6dec8ec2e","modified":1577620417667},{"_id":"public/sw.js","hash":"8bbe7661ed4165c590829e9dd5d9bba95a5572fc","modified":1577620417679},{"_id":"public/offline.html","hash":"3b3f36910f59c7250e86a2d9b6ff06ae6cf38f39","modified":1577620417679},{"_id":"public/css/styles/a11y-dark.css","hash":"122f8c71ac1c35398e96bf209f20668195a9e144","modified":1577620417679},{"_id":"public/css/styles/agate.css","hash":"8e122b0f00f5a7ec4e6dc492bf1560441eeef7f0","modified":1577620417680},{"_id":"public/css/styles/a11y-light.css","hash":"3f5cde8e2278a6d52e6e4f30509588c80a3ad5a6","modified":1577620417680},{"_id":"public/css/styles/an-old-hope.css","hash":"124d4856bbd6e2cfc164914080724f1a59b9899c","modified":1577620417680},{"_id":"public/css/styles/androidstudio.css","hash":"958baa24814c06a625612a3b2b478d54bc1bf1b1","modified":1577620417680},{"_id":"public/css/styles/arduino-light.css","hash":"c6e05580b51b755e229e99eb156940ad2cab192b","modified":1577620417680},{"_id":"public/css/styles/arta.css","hash":"17b23b9fa57ef7a05a6aaeea9b5feb5442a8e584","modified":1577620417680},{"_id":"public/css/styles/ascetic.css","hash":"6358377b5c25667886aca0d605cbc497cf02405f","modified":1577620417680},{"_id":"public/css/styles/atelier-cave-dark.css","hash":"f397d4418ce88b998841fd9135242461ba1a79b5","modified":1577620417680},{"_id":"public/css/styles/atelier-cave-light.css","hash":"2933f0247ac6d84c2954dd4946e359853abbf70a","modified":1577620417680},{"_id":"public/css/styles/atelier-dune-dark.css","hash":"081d73e454db140cd41b2bb595be297cfcab25e0","modified":1577620417680},{"_id":"public/css/styles/atelier-dune-light.css","hash":"7ba074de897e6a5e27d8b97f7cd06c1746474e72","modified":1577620417680},{"_id":"public/css/styles/atelier-estuary-dark.css","hash":"a0c46a0f955e3864f5e967ea93f5e61519a17be8","modified":1577620417680},{"_id":"public/css/styles/atelier-estuary-light.css","hash":"91ae4668c15a085ffce15ca21e93da445b5ecf3a","modified":1577620417680},{"_id":"public/css/styles/atelier-forest-dark.css","hash":"d8a4dc060b3fc719aa2f7d7b3f1019a3964b8101","modified":1577620417680},{"_id":"public/css/styles/atelier-forest-light.css","hash":"8a78a4eea0f32d094d1f9e316d59e990ba739d97","modified":1577620417680},{"_id":"public/css/styles/atelier-heath-dark.css","hash":"b93c2241ff123e62d4edb3dfc20410e4d1da3e78","modified":1577620417680},{"_id":"public/css/styles/atelier-lakeside-dark.css","hash":"fa707b252d5d5caccc0589374522bed47b7ca100","modified":1577620417680},{"_id":"public/css/styles/atelier-heath-light.css","hash":"172b98f783d213a20211ec6aca9a3840ba524f55","modified":1577620417681},{"_id":"public/css/styles/atelier-lakeside-light.css","hash":"8ba595b9ba6e8be6dc029bf80caab38e85aed686","modified":1577620417681},{"_id":"public/css/styles/atelier-plateau-light.css","hash":"9731db1052f23351c983210701edd3f5ceed343f","modified":1577620417681},{"_id":"public/css/styles/atelier-plateau-dark.css","hash":"240f79f4e1fd63485c13900875b64c5a0d1bd06d","modified":1577620417681},{"_id":"public/css/styles/atelier-savanna-light.css","hash":"6bd3a62c32558476d436bd389500e5fbeb693d67","modified":1577620417681},{"_id":"public/css/styles/atelier-seaside-dark.css","hash":"b2800804a21f729a3d0a16b3aadc17679fd0639c","modified":1577620417681},{"_id":"public/css/styles/atelier-seaside-light.css","hash":"3e6b9e2a3a5de455490b8224401f19702df4cde9","modified":1577620417681},{"_id":"public/css/styles/atelier-sulphurpool-dark.css","hash":"1f006f8bd28e2ffbb73f708769605ba766787fff","modified":1577620417681},{"_id":"public/css/styles/atelier-sulphurpool-light.css","hash":"0319c3eea893601b79b6c57652ef49b9222cc9de","modified":1577620417681},{"_id":"public/css/styles/atom-one-dark-reasonable.css","hash":"f82d3cde0b923047d05731fa6e009e3232703f69","modified":1577620417681},{"_id":"public/css/styles/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1577620417681},{"_id":"public/css/styles/atom-one-light.css","hash":"eda63d8cce440dbf3bb823e10577a134e9941deb","modified":1577620417681},{"_id":"public/css/styles/brown-paper.css","hash":"a6817d890e58f80ce79d87620791dae821a70fff","modified":1577620417681},{"_id":"public/css/styles/codepen-embed.css","hash":"c4520e45d18259817b8942d17971f27c94f0fb09","modified":1577620417681},{"_id":"public/css/styles/color-brewer.css","hash":"96332573db854e7b7411caa94ba29b238fede2d3","modified":1577620417681},{"_id":"public/css/styles/dark.css","hash":"fc77519d4f5d731054c5d4b7e7bbdbb510833271","modified":1577620417681},{"_id":"public/css/styles/darkula.css","hash":"0be948bb84acc05f93a1e5e9b48fe34cf61673a0","modified":1577620417681},{"_id":"public/css/styles/darcula.css","hash":"7740224d07375ddc321147dffabbfa83e39f0d8b","modified":1577620417681},{"_id":"public/css/styles/docco.css","hash":"1be7be09a1b927c22c7f11451becdb335145bdd2","modified":1577620417681},{"_id":"public/css/styles/default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1577620417681},{"_id":"public/css/styles/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1577620417681},{"_id":"public/css/styles/far.css","hash":"67e0658b2376e91e4894636a3522a30c2aec42de","modified":1577620417681},{"_id":"public/css/styles/foundation.css","hash":"75b0674dd1ed35d61977bd5c35dc29ca35835a7b","modified":1577620417681},{"_id":"public/css/styles/github-gist.css","hash":"8cfbcbf4c0491e44e6b073c95a04cc401cb11ab2","modified":1577620417681},{"_id":"public/css/styles/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1577620417681},{"_id":"public/css/styles/gml.css","hash":"e5a29350c16a729e8e54e5abe08bef6d24246a60","modified":1577620417682},{"_id":"public/css/styles/googlecode.css","hash":"fed3d439d0c305b337dd9c0f68dcbfa51429f445","modified":1577620417682},{"_id":"public/css/styles/grayscale.css","hash":"5688658c28fc5799517e8f3c224ae3da3797ba44","modified":1577620417682},{"_id":"public/css/styles/gruvbox-dark.css","hash":"aaf90d076e34bc44016462d70f83985e0e55c8dc","modified":1577620417682},{"_id":"public/css/styles/gruvbox-light.css","hash":"084699ab0aa326fede86e38bf41ebe49edde3a90","modified":1577620417682},{"_id":"public/css/styles/hopscotch.css","hash":"03e7b9ec74bbd375db8d476836aac3729a6c86e8","modified":1577620417682},{"_id":"public/css/styles/hybrid.css","hash":"1e2d54598b5f948b597059909d4bd158b7df021f","modified":1577620417682},{"_id":"public/css/styles/ir-black.css","hash":"95aad65ba77183500ce0f7ad62a7535b647ee20c","modified":1577620417682},{"_id":"public/css/styles/idea.css","hash":"164649ae1e7c891a0d88cca075521af28656e2a1","modified":1577620417682},{"_id":"public/css/styles/isbl-editor-dark.css","hash":"73d2282192e403868998cff2e77093ace8a6e5fb","modified":1577620417682},{"_id":"public/css/styles/isbl-editor-light.css","hash":"92557e568d1fb352cf78a63679b9c431c0b6d407","modified":1577620417682},{"_id":"public/css/styles/kimbie.dark.css","hash":"58ed061c204fbc09d221ee9135d66bad976e5fc3","modified":1577620417682},{"_id":"public/css/styles/kimbie.light.css","hash":"b7aa9b1b21a25dfefcac7649a328962f84c47913","modified":1577620417682},{"_id":"public/css/styles/lightfair.css","hash":"055ad4fbd468e37f3166c90521758475f525f22d","modified":1577620417682},{"_id":"public/css/styles/magula.css","hash":"ebc291f90e456abeeccb16937e7f51735733f4f7","modified":1577620417682},{"_id":"public/css/styles/mono-blue.css","hash":"fd0f39cd4c93ccb8d0bb2f6a1f359522e15a89cb","modified":1577620417682},{"_id":"public/css/styles/monokai-sublime.css","hash":"e4f3df87cbfa634c86b489e9cc43acf44d415986","modified":1577620417682},{"_id":"public/css/styles/monokai.css","hash":"f69df92e3ccdce28e6f811ec84f11698f2811198","modified":1577620417682},{"_id":"public/css/styles/nord.css","hash":"98dfcd6eee4968fb4c634784cb048a98169b1bc8","modified":1577620417682},{"_id":"public/css/styles/obsidian.css","hash":"6ed475813fe4886a58b236297862ff2f181e66f7","modified":1577620417682},{"_id":"public/css/styles/ocean.css","hash":"fce6858e1c5eb9d2857cb5b5d24069c5994cfc91","modified":1577620417682},{"_id":"public/css/styles/paraiso-dark.css","hash":"8f5445327ce3c83b62f6bf4c1a0d87fa6f036341","modified":1577620417682},{"_id":"public/css/styles/paraiso-light.css","hash":"6eb3ab7a3337f9cad3a2e5fa6bf7dd83685228d8","modified":1577620417682},{"_id":"public/css/styles/pojoaque.css","hash":"4e1e6a431212f5043a550474a1acda63362cdd6f","modified":1577620417682},{"_id":"public/css/styles/purebasic.css","hash":"f353a2cedf3f261a0676fce7c824bdd2e8197775","modified":1577620417682},{"_id":"public/css/styles/qtcreator_dark.css","hash":"213a40d203c4986cdbcb1bdf7d0b9013b29041ba","modified":1577620417682},{"_id":"public/css/styles/qtcreator_light.css","hash":"9a2a19ac2f6e6a7d5edd7fae67b7de4a3957e878","modified":1577620417682},{"_id":"public/css/styles/rainbow.css","hash":"1b2d98ccdda36aa926d0e6d069b673fdacd2d33e","modified":1577620417682},{"_id":"public/css/styles/routeros.css","hash":"fc5db7c8f18d6b31ad92df21a51e7867d459af19","modified":1577620417683},{"_id":"public/css/styles/school-book.css","hash":"6c4198b6ffde866f5e2fe9172aee094065f9774a","modified":1577620417683},{"_id":"public/css/styles/railscasts.css","hash":"a6d2043478fae5915926914cbd96fe9b706d98a6","modified":1577620417683},{"_id":"public/css/styles/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1577620417683},{"_id":"public/css/styles/shades-of-purple.css","hash":"3f712f68a0b3a9e6de4796da206a4975354beec4","modified":1577620417683},{"_id":"public/css/styles/sunburst.css","hash":"8309eab2e5b1765dbee81a626baacbdad869b76a","modified":1577620417683},{"_id":"public/css/styles/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1577620417683},{"_id":"public/css/styles/tomorrow-night-blue.css","hash":"cd257d7d6a37cd5a09419b5f5f9d34b6b282423f","modified":1577620417683},{"_id":"public/css/styles/tomorrow-night-bright.css","hash":"04f0af30fdda5e5d6ebdeef5a860b6b7e49cfe89","modified":1577620417683},{"_id":"public/css/styles/vs.css","hash":"2ac5e89ceb3d5a0e0fdab1ed6d9a411ec7d221aa","modified":1577620417683},{"_id":"public/css/styles/tomorrow-night-eighties.css","hash":"d82b84bcda0588105dbbc0e8e8ba5e62c208a061","modified":1577620417683},{"_id":"public/css/styles/vs2015.css","hash":"3c7fa677de2a785d90fc6c3f7520ac1b11bfd37a","modified":1577620417683},{"_id":"public/css/styles/tomorrow.css","hash":"163593ad70770d0296c5e643fa62e58e63f1b340","modified":1577620417683},{"_id":"public/css/styles/xt256.css","hash":"d9e0f7d8ab5cfd627ce085c16e7a90e1ad495516","modified":1577620417683},{"_id":"public/css/styles/xcode.css","hash":"d8a1f18e5344c2edf97921ec21a54b02745997e9","modified":1577620417683},{"_id":"public/css/styles/tomorrow-night.css","hash":"86264dd861d35a8b135f9fcb8ff2675e9fa69c16","modified":1577620417683},{"_id":"public/css/styles/atelier-savanna-dark.css","hash":"09d45a218f87b8cb55b5ca7f4e9d76ea89a9404a","modified":1577620417683},{"_id":"public/css/styles/zenburn.css","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1577620417683},{"_id":"public/css/style.css","hash":"2bdd68f0305a23d77e8ab5f9a5a4d765e1356566","modified":1577620417683},{"_id":"public/uploads/TCP/1.png","hash":"0e349ba2647a4ad074b5450b4d4b3c47747e5750","modified":1577620417683},{"_id":"public/uploads/TCP/5.png","hash":"493966d2114b003924b0a93d4cb3ec6da3ae1e3b","modified":1577620417683},{"_id":"public/css/old style.css","hash":"8f2e3165ac6ab258f66bad8f1688ea0697abdedf","modified":1577620417703},{"_id":"public/uploads/bfc/4.png","hash":"547655bc854fecdbf60a6ba96674232c39b092e5","modified":1577620417703},{"_id":"public/css/default.css","hash":"af92c40c2b3d0454d65d3cac7add43b1bc2ae0ec","modified":1577620417705},{"_id":"public/uploads/Puppeteer/1.png","hash":"b7a6df37d5763074d9ffdd2de6387effa896ec9b","modified":1577620417710},{"_id":"public/uploads/TCP/3.png","hash":"17b4dda7b49f7d17100478efe0df38a86a662ffe","modified":1577620417714},{"_id":"public/js/highlight.pack.js","hash":"ef8a23118829bee91f158a31622a6f5f0dbe6407","modified":1577620417727},{"_id":"public/uploads/node-deploy/6.png","hash":"a8852c8b30699c9d6c16ce21df840edf417b543e","modified":1577620417728},{"_id":"public/uploads/https-upgrade/1.png","hash":"69aa7de26ce554031d9f6946ac3421e91bb0fae1","modified":1577620417735},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1577620417738},{"_id":"public/uploads/splice/3.jpg","hash":"bafddf931dbc8b94713a46bab8e7bf4eeb4f0992","modified":1577620417742},{"_id":"public/uploads/splice/1.png","hash":"f46d62f7fa671da2f11dc4754eaddc183054a08a","modified":1577620417763},{"_id":"public/uploads/splice/2.png","hash":"501a15d39359a1fc3d03ad68f0a1f7dc9179596c","modified":1577620417769}],"Category":[{"name":"网络","_id":"ck4qygn6s0005hns6x6yb1p7l"},{"name":"面试","_id":"ck4qygn77000chns6nqdxmb6r"},{"name":"前端","_id":"ck4qygn7e000ihns6vac84tvf"},{"name":"工具","_id":"ck4qygn7p000whns65prkra3b"},{"name":"数据结构与算法","_id":"ck4qygn89001uhns6aog6u7mi"},{"name":"随笔","_id":"ck4qygn8w0035hns6wcjhwefs"},{"name":"Node.js","_id":"ck4qygna6004fhns6wqpivfug"},{"name":"后端","_id":"ck4qygnbk0066hns661bprsoi"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"your site url \" homePageName=\"回到我的主页\"></script>\n\n</body>\n</html>","date":"2019-06-16T14:11:37.257Z","updated":"2019-06-16T14:11:37.257Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ck4qygn4m0000hns604nh03cl","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"></script>\n\n</body>\n</html>"},{"title":"About","date":"1995-10-13T12:35:04.000Z","layout":"about","_content":"<center><a href=\"mailto:xianrenxiong@qq.com\">邮箱</a></center>\n<center><a href=\"https://juejin.im/user/562f5a8e60b27cc2b9dc5b4b/posts\">掘金专栏</center>\n<center><a href=\"https://github.com/FrankXiong\">Github</a></center>\n\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 1995-10-13 20:35:04\nlayout: about\n---\n<center><a href=\"mailto:xianrenxiong@qq.com\">邮箱</a></center>\n<center><a href=\"https://juejin.im/user/562f5a8e60b27cc2b9dc5b4b/posts\">掘金专栏</center>\n<center><a href=\"https://github.com/FrankXiong\">Github</a></center>\n\n","updated":"2019-12-28T17:12:28.372Z","path":"about/index.html","comments":1,"_id":"ck4qygn680001hns6hy4kc492","content":"<center><a href=\"mailto:xianrenxiong@qq.com\" target=\"_blank\" rel=\"noopener\">邮箱</a></center><br><center><a href=\"https://juejin.im/user/562f5a8e60b27cc2b9dc5b4b/posts\" target=\"_blank\" rel=\"noopener\">掘金专栏</a></center><br><center><a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">Github</a></center>\n\n","site":{"data":{}},"excerpt":"","more":"<center><a href=\"mailto:xianrenxiong@qq.com\" target=\"_blank\" rel=\"noopener\">邮箱</a></center><br><center><a href=\"https://juejin.im/user/562f5a8e60b27cc2b9dc5b4b/posts\" target=\"_blank\" rel=\"noopener\">掘金专栏</a></center><br><center><a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">Github</a></center>\n\n"},{"title":"categories","date":"2019-12-26T02:55:46.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-12-26 10:55:46\ntype: \"categories\"\n---\n","updated":"2019-12-26T02:56:07.045Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck4qygn6h0003hns632k05v33","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Works","date":"2017-01-03T13:07:12.000Z","layout":"works","data":{"project":[{"title":"专家系统","data":"2016.12","img_link":""}]},"_content":"","source":"works/index.md","raw":"---\ntitle: Works\ndate: 2017-01-03 21:07:12\nlayout: works\ndata: {\n  project: [{\n      title: \"专家系统\",\n      data: \"2016.12\",\n      img_link: \"\"\n  }]\n}\n---\n","updated":"2019-06-16T14:11:37.281Z","path":"works/index.html","comments":1,"_id":"ck4qygn6y0007hns6y0eq4yck","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2016-12-15T10:21:17.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2016-12-15 18:21:17\nlayout: tags\n---\n","updated":"2019-06-16T14:11:37.258Z","path":"tags/index.html","comments":1,"_id":"ck4qygn710009hns6esmglgqf","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CDN 缓存原理","date":"2016-03-15T19:46:38.000Z","_content":"\n启用CDN缓存后浏览器访问的全过程：\n\n1.用户输入URL，浏览器将解析过后的域名发给DNS服务器\n\n2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。\n\n3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。\n\n4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。\n\n5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。\n\n6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。","source":"_posts/CDN缓存原理.md","raw":"---\ntitle: CDN 缓存原理\ndate: 2016-03-16 03:46:38\ntags:\n- 性能优化\ncategories: \n- 网络\n---\n\n启用CDN缓存后浏览器访问的全过程：\n\n1.用户输入URL，浏览器将解析过后的域名发给DNS服务器\n\n2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。\n\n3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。\n\n4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。\n\n5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。\n\n6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。","slug":"CDN缓存原理","published":1,"updated":"2019-12-28T16:22:54.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn6b0002hns6zay1ccd5","content":"<p>启用CDN缓存后浏览器访问的全过程：</p>\n<p>1.用户输入URL，浏览器将解析过后的域名发给DNS服务器</p>\n<p>2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。</p>\n<p>3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。</p>\n<p>4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。</p>\n<p>5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。</p>\n<p>6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>启用CDN缓存后浏览器访问的全过程：</p>\n<p>1.用户输入URL，浏览器将解析过后的域名发给DNS服务器</p>\n<p>2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。</p>\n<p>3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。</p>\n<p>4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。</p>\n<p>5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。</p>\n<p>6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。</p>\n"},{"title":"阿里前端实习电话面试（一）","date":"2016-03-09T12:28:43.000Z","_content":"一下子记不全，可能遗漏了一些问题......下面是正文\n\n0.你的项目团队中前端的人数？\n答：（此处略去20字）\n\n1.谈谈你在项目中用到的技术？\n答：全部采用原生CSS，JS，Ajax......\n\n2.CSS如何垂直居中？\n答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等\n\n3.如何清除浮动？\n答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC...\n\n4.好吧，你提到了BFC，那就解释一下BFC的特性吧？\n答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对...\n\n5.如何用原生JS实现jQuery选择器？\n答：querySelector和querySeletorAll\n\n6.如果不使用querySelector呢？如何实现对.a .b的选择？\n答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素...于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。\n\n7.如何给子元素到父元素依次绑定事件？\n答：不考虑兼容性的话，使用addEventListenr。\n\n8.addEventListenr有三个参数，解释一下最后一个参数？\n答：事件冒泡和事件捕获的区别\n\n9.解释一下事件冒泡和事件捕获\n答：（此处略去100字）\n\n10.我的问题问完了，你有什么要问我的吗？\n答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react...\n\n总结：问的问题都相当基础，正好我也只会这些基础的......希望后面能顺利，继续刷犀牛书去了^_^\n\n大致如此","source":"_posts/2016阿里前端实习电话面试实录.md","raw":"---\ntitle: 阿里前端实习电话面试（一）\ndate: 2016-03-09 20:28:43\ntags: \n- 面试\ncategories:\n- 面试\n---\n一下子记不全，可能遗漏了一些问题......下面是正文\n\n0.你的项目团队中前端的人数？\n答：（此处略去20字）\n\n1.谈谈你在项目中用到的技术？\n答：全部采用原生CSS，JS，Ajax......\n\n2.CSS如何垂直居中？\n答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等\n\n3.如何清除浮动？\n答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC...\n\n4.好吧，你提到了BFC，那就解释一下BFC的特性吧？\n答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对...\n\n5.如何用原生JS实现jQuery选择器？\n答：querySelector和querySeletorAll\n\n6.如果不使用querySelector呢？如何实现对.a .b的选择？\n答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素...于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。\n\n7.如何给子元素到父元素依次绑定事件？\n答：不考虑兼容性的话，使用addEventListenr。\n\n8.addEventListenr有三个参数，解释一下最后一个参数？\n答：事件冒泡和事件捕获的区别\n\n9.解释一下事件冒泡和事件捕获\n答：（此处略去100字）\n\n10.我的问题问完了，你有什么要问我的吗？\n答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react...\n\n总结：问的问题都相当基础，正好我也只会这些基础的......希望后面能顺利，继续刷犀牛书去了^_^\n\n大致如此","slug":"2016阿里前端实习电话面试实录","published":1,"updated":"2019-06-16T14:11:37.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn6i0004hns69pzy6o60","content":"<p>一下子记不全，可能遗漏了一些问题……下面是正文</p>\n<p>0.你的项目团队中前端的人数？<br>答：（此处略去20字）</p>\n<p>1.谈谈你在项目中用到的技术？<br>答：全部采用原生CSS，JS，Ajax……</p>\n<p>2.CSS如何垂直居中？<br>答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等</p>\n<p>3.如何清除浮动？<br>答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC…</p>\n<p>4.好吧，你提到了BFC，那就解释一下BFC的特性吧？<br>答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对…</p>\n<p>5.如何用原生JS实现jQuery选择器？<br>答：querySelector和querySeletorAll</p>\n<p>6.如果不使用querySelector呢？如何实现对.a .b的选择？<br>答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素…于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。</p>\n<p>7.如何给子元素到父元素依次绑定事件？<br>答：不考虑兼容性的话，使用addEventListenr。</p>\n<p>8.addEventListenr有三个参数，解释一下最后一个参数？<br>答：事件冒泡和事件捕获的区别</p>\n<p>9.解释一下事件冒泡和事件捕获<br>答：（此处略去100字）</p>\n<p>10.我的问题问完了，你有什么要问我的吗？<br>答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react…</p>\n<p>总结：问的问题都相当基础，正好我也只会这些基础的……希望后面能顺利，继续刷犀牛书去了^_^</p>\n<p>大致如此</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一下子记不全，可能遗漏了一些问题……下面是正文</p>\n<p>0.你的项目团队中前端的人数？<br>答：（此处略去20字）</p>\n<p>1.谈谈你在项目中用到的技术？<br>答：全部采用原生CSS，JS，Ajax……</p>\n<p>2.CSS如何垂直居中？<br>答：最新使用FlexBox比较多，其他的方法还有display:table-cell、vertical-align:center,position等等</p>\n<p>3.如何清除浮动？<br>答：clearfix(此处略去100字)，然后我就不知道哪根筋不对，提到了BFC…</p>\n<p>4.好吧，你提到了BFC，那就解释一下BFC的特性吧？<br>答：BFC就是一个容器，里面的元素再翻江倒海，都不会影响到外面。下午刚好看到张鑫旭那篇关于BFC的文章，就又谈到了用浮动+BFC做自适应布局，也不知道对不对…</p>\n<p>5.如何用原生JS实现jQuery选择器？<br>答：querySelector和querySeletorAll</p>\n<p>6.如果不使用querySelector呢？如何实现对.a .b的选择？<br>答：一开始跟他胡扯了一些利用标签名啊、id啊，后来发现他问的是如何在父元素中选择子元素…于是又乱扯了一些firstchild呐、silbing呐、childnodes啊。</p>\n<p>7.如何给子元素到父元素依次绑定事件？<br>答：不考虑兼容性的话，使用addEventListenr。</p>\n<p>8.addEventListenr有三个参数，解释一下最后一个参数？<br>答：事件冒泡和事件捕获的区别</p>\n<p>9.解释一下事件冒泡和事件捕获<br>答：（此处略去100字）</p>\n<p>10.我的问题问完了，你有什么要问我的吗？<br>答：问了下他们团队的技术路线，他说他们一般只用自己内部开发的框架，偶尔会用到react…</p>\n<p>总结：问的问题都相当基础，正好我也只会这些基础的……希望后面能顺利，继续刷犀牛书去了^_^</p>\n<p>大致如此</p>\n"},{"title":"Cookie 和 Session 的区别总结","date":"2016-06-26T05:55:10.000Z","_content":"二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。\n<!-- more -->\n创建Session过程：\n- 检查客户端请求中是否包含一个session标识（session id）\n- 若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session\n- 若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）\n\n若Cookie被禁止，必须有其他机制能够把session id回传给服务器\n回传session id至服务器：\n\n- URL重写：把session id直接附加在URL路径后面\n- 隐藏表单字段\n\nCookie和Session的区别：\n- **Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据**，甚至Java Bean乃至任何Java类、对象等\n- **隐私策略不同**。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险\n- **有效期不同**。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。\n- **服务器压力不同**。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。\n- **浏览器支持不同**。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。\n- **跨域支持不同**。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问\n\n------------\n参考：[理解Cookie和Session机制](http://www.lai18.com/content/7450273.html)\n","source":"_posts/Cookie和Session的区别总结.md","raw":"---\ntitle: Cookie 和 Session 的区别总结\ndate: 2016-06-26 13:55:10\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。\n<!-- more -->\n创建Session过程：\n- 检查客户端请求中是否包含一个session标识（session id）\n- 若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session\n- 若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）\n\n若Cookie被禁止，必须有其他机制能够把session id回传给服务器\n回传session id至服务器：\n\n- URL重写：把session id直接附加在URL路径后面\n- 隐藏表单字段\n\nCookie和Session的区别：\n- **Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据**，甚至Java Bean乃至任何Java类、对象等\n- **隐私策略不同**。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险\n- **有效期不同**。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。\n- **服务器压力不同**。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。\n- **浏览器支持不同**。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。\n- **跨域支持不同**。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问\n\n------------\n参考：[理解Cookie和Session机制](http://www.lai18.com/content/7450273.html)\n","slug":"Cookie和Session的区别总结","published":1,"updated":"2019-12-28T16:26:21.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn6z0008hns6db2m9h0a","content":"<p>二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。<br><a id=\"more\"></a><br>创建Session过程：</p>\n<ul>\n<li>检查客户端请求中是否包含一个session标识（session id）</li>\n<li>若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session</li>\n<li>若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）</li>\n</ul>\n<p>若Cookie被禁止，必须有其他机制能够把session id回传给服务器<br>回传session id至服务器：</p>\n<ul>\n<li>URL重写：把session id直接附加在URL路径后面</li>\n<li>隐藏表单字段</li>\n</ul>\n<p>Cookie和Session的区别：</p>\n<ul>\n<li><strong>Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据</strong>，甚至Java Bean乃至任何Java类、对象等</li>\n<li><strong>隐私策略不同</strong>。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险</li>\n<li><strong>有效期不同</strong>。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。</li>\n<li><strong>服务器压力不同</strong>。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。</li>\n<li><strong>浏览器支持不同</strong>。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。</li>\n<li><strong>跨域支持不同</strong>。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问</li>\n</ul>\n<hr>\n<p>参考：<a href=\"http://www.lai18.com/content/7450273.html\" target=\"_blank\" rel=\"noopener\">理解Cookie和Session机制</a></p>\n","site":{"data":{}},"excerpt":"<p>二者作用：解决HTTP协议无状态的缺陷，在客户端/服务器端保存会话状态。<br>","more":"<br>创建Session过程：</p>\n<ul>\n<li>检查客户端请求中是否包含一个session标识（session id）</li>\n<li>若包含，则说明之前已经为此客户端创建过session。服务器按照此session id检索出session</li>\n<li>若不包含，则为此客户端创建一个session，并生成一个session id。此session id将作为响应返回给客户端保存。（使用Cookie保存）</li>\n</ul>\n<p>若Cookie被禁止，必须有其他机制能够把session id回传给服务器<br>回传session id至服务器：</p>\n<ul>\n<li>URL重写：把session id直接附加在URL路径后面</li>\n<li>隐藏表单字段</li>\n</ul>\n<p>Cookie和Session的区别：</p>\n<ul>\n<li><strong>Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据</strong>，甚至Java Bean乃至任何Java类、对象等</li>\n<li><strong>隐私策略不同</strong>。Cookie存储在客户端，对客户端是可见的，可被客户端窥探、复制、修改。而Session存储在服务器上，不存在敏感信息泄露的风险</li>\n<li><strong>有效期不同</strong>。Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。</li>\n<li><strong>服务器压力不同</strong>。每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。</li>\n<li><strong>浏览器支持不同</strong>。Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。</li>\n<li><strong>跨域支持不同</strong>。Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问</li>\n</ul>\n<hr>\n<p>参考：<a href=\"http://www.lai18.com/content/7450273.html\" target=\"_blank\" rel=\"noopener\">理解Cookie和Session机制</a></p>"},{"title":"DNS 劫持与 DNS 污染的原理","date":"2016-04-28T14:24:01.000Z","_content":"DNS劫持就是通过**劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP**，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。\nDNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。\n\nDNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常**基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改**，**通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。**用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。\n\nDNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。\n\n区别：\nDNS劫持是劫持了DNS服务器，进而修改其解析结果。\nDNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。\n\n一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。","source":"_posts/DNS劫持与DNS污染的原理.md","raw":"---\ntitle: DNS 劫持与 DNS 污染的原理\ndate: 2016-04-28 22:24:01\ntags:\n- DNS\n- web安全\ncategories:\n- 网络\n---\nDNS劫持就是通过**劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP**，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。\nDNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。\n\nDNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常**基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改**，**通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。**用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。\n\nDNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。\n\n区别：\nDNS劫持是劫持了DNS服务器，进而修改其解析结果。\nDNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。\n\n一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。","slug":"DNS劫持与DNS污染的原理","published":1,"updated":"2019-12-28T16:26:16.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn72000ahns6wc5p59x2","content":"<p>DNS劫持就是通过<strong>劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP</strong>，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。<br>DNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>\n<p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常<strong>基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改</strong>，<strong>通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</strong>用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。</p>\n<p>DNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。</p>\n<p>区别：<br>DNS劫持是劫持了DNS服务器，进而修改其解析结果。<br>DNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。</p>\n<p>一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>DNS劫持就是通过<strong>劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP</strong>，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。<br>DNS劫持症状：连接宽带后首次打开的页面都是指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>\n<p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常<strong>基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改</strong>，<strong>通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</strong>用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。</p>\n<p>DNS污染症状：我们平时访问Youtube、Facebook之类网站等出现的状况。</p>\n<p>区别：<br>DNS劫持是劫持了DNS服务器，进而修改其解析结果。<br>DNS污染是国内的某些服务器对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。</p>\n<p>一个是劫持了DNS服务器，一个是伪装成DNS服务器。造成的结果都是返回错误的IP地址。</p>\n"},{"title":"ES6 语法总结","date":"2017-03-31T16:41:08.000Z","_content":"# Arrow Function\n箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）\n\n# Class\n原型链继承的一种语法糖，ES6 的类可以看作是构造函数的另一种写法。\n```\nclass Point {\n//...\n}\ntypeof Point //'function'\nPoint === Point.prototype.constructor\n```\n- 类内部定义的方法都不可枚举(non-enumerable)\n- 不存在变量提升(hoist)\n- 实现私有方法\n　　1. 将方法移出 Class，定义在全局作用域\n　　2. 将私有方法的名字命名为一个 Symbol 值\n\n```\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\nexport default class myClass{\n　// 公有方法\n　foo(baz) {\n　　this[bar](baz);\n　}\n　// 私有方法\n　[bar](baz) {\n　　return this[snaf] = baz;\n 　}\n　// ...\n};\n```\n- 允许继承原生构造函数\n- 添加静态属性，静态方法\n```\nclass Foo {\n　static classMethod() {\n　　return 'hello';\n　}\n}\nFoo.prop = 1;\nFoo.prop // 1\nFoo.classMethod() // 'hello'\n```\n\n# Promise\n- 三种状态 Pending、Resolved、Rejected。\n- 缺点：\n　　1. 无法中途取消 Promise。\n　　2. 如果不设置回调，内部抛出的错误无法反应到外部。\n　　3. 大量的 then() 语句导致语义不清楚。\n\n# Generator\n- yield 语句暂停函数执行。\n- generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。\n- 使用 for...of 遍历 Iterator 对象\n- generator 作用：\n　　1. 执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。\n　　2. 实现数组数据结构，每一项都是一个函数 。\n- generator 缺点：流程管理困难，需要手动执行。解决办法：\n　　1. Thunk 函数、传名调用。\n　　2. 使用 Co　\n　　3. 将异步操作包装成 Promise 对象，用 then 方法交出执行权。\n\n# Module\n- 编译时确定模块依赖，编译时加载，使得静态分析成为可能。\n- ES6 模块不是对象。\n- export 输出的是对外的接口。\n- 模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。\n- 循环加载：\n　　1. CommonJS 是加载时执行。当发生循环加载时，就只输出已经执行的部分。\n　　2. ES6 模块是动态引用。只要引用存在，代码就可以执行。\n","source":"_posts/ES6语法总结.md","raw":"---\ntitle: ES6 语法总结\ndate: 2017-04-01 00:41:08\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n# Arrow Function\n箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）\n\n# Class\n原型链继承的一种语法糖，ES6 的类可以看作是构造函数的另一种写法。\n```\nclass Point {\n//...\n}\ntypeof Point //'function'\nPoint === Point.prototype.constructor\n```\n- 类内部定义的方法都不可枚举(non-enumerable)\n- 不存在变量提升(hoist)\n- 实现私有方法\n　　1. 将方法移出 Class，定义在全局作用域\n　　2. 将私有方法的名字命名为一个 Symbol 值\n\n```\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\nexport default class myClass{\n　// 公有方法\n　foo(baz) {\n　　this[bar](baz);\n　}\n　// 私有方法\n　[bar](baz) {\n　　return this[snaf] = baz;\n 　}\n　// ...\n};\n```\n- 允许继承原生构造函数\n- 添加静态属性，静态方法\n```\nclass Foo {\n　static classMethod() {\n　　return 'hello';\n　}\n}\nFoo.prop = 1;\nFoo.prop // 1\nFoo.classMethod() // 'hello'\n```\n\n# Promise\n- 三种状态 Pending、Resolved、Rejected。\n- 缺点：\n　　1. 无法中途取消 Promise。\n　　2. 如果不设置回调，内部抛出的错误无法反应到外部。\n　　3. 大量的 then() 语句导致语义不清楚。\n\n# Generator\n- yield 语句暂停函数执行。\n- generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。\n- 使用 for...of 遍历 Iterator 对象\n- generator 作用：\n　　1. 执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。\n　　2. 实现数组数据结构，每一项都是一个函数 。\n- generator 缺点：流程管理困难，需要手动执行。解决办法：\n　　1. Thunk 函数、传名调用。\n　　2. 使用 Co　\n　　3. 将异步操作包装成 Promise 对象，用 then 方法交出执行权。\n\n# Module\n- 编译时确定模块依赖，编译时加载，使得静态分析成为可能。\n- ES6 模块不是对象。\n- export 输出的是对外的接口。\n- 模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。\n- 循环加载：\n　　1. CommonJS 是加载时执行。当发生循环加载时，就只输出已经执行的部分。\n　　2. ES6 模块是动态引用。只要引用存在，代码就可以执行。\n","slug":"ES6语法总结","published":1,"updated":"2019-12-28T17:30:22.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn76000bhns6yt5ypqpm","content":"<h1 id=\"Arrow-Function\"><a href=\"#Arrow-Function\" class=\"headerlink\" title=\"Arrow Function\"></a>Arrow Function</h1><p>箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）</p>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><p>原型链继承的一种语法糖，ES6 的类可以看作是构造函数的另一种写法。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">typeof Point //&apos;function&apos;</span><br><span class=\"line\">Point === Point.prototype.constructor</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>类内部定义的方法都不可枚举(non-enumerable)</li>\n<li>不存在变量提升(hoist)</li>\n<li>实现私有方法<br>　　1. 将方法移出 Class，定义在全局作用域<br>　　2. 将私有方法的名字命名为一个 Symbol 值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const bar = Symbol(&apos;bar&apos;);</span><br><span class=\"line\">const snaf = Symbol(&apos;snaf&apos;);</span><br><span class=\"line\">export default class myClass&#123;</span><br><span class=\"line\">　// 公有方法</span><br><span class=\"line\">　foo(baz) &#123;</span><br><span class=\"line\">　　this[bar](baz);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　// 私有方法</span><br><span class=\"line\">　[bar](baz) &#123;</span><br><span class=\"line\">　　return this[snaf] = baz;</span><br><span class=\"line\"> 　&#125;</span><br><span class=\"line\">　// ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>允许继承原生构造函数</li>\n<li>添加静态属性，静态方法<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">　static classMethod() &#123;</span><br><span class=\"line\">　　return &apos;hello&apos;;</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prop = 1;</span><br><span class=\"line\">Foo.prop // 1</span><br><span class=\"line\">Foo.classMethod() // &apos;hello&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><ul>\n<li>三种状态 Pending、Resolved、Rejected。</li>\n<li>缺点：<br>　　1. 无法中途取消 Promise。<br>　　2. 如果不设置回调，内部抛出的错误无法反应到外部。<br>　　3. 大量的 then() 语句导致语义不清楚。</li>\n</ul>\n<h1 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h1><ul>\n<li>yield 语句暂停函数执行。</li>\n<li>generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。</li>\n<li>使用 for…of 遍历 Iterator 对象</li>\n<li>generator 作用：<br>　　1. 执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。<br>　　2. 实现数组数据结构，每一项都是一个函数 。</li>\n<li>generator 缺点：流程管理困难，需要手动执行。解决办法：<br>　　1. Thunk 函数、传名调用。<br>　　2. 使用 Co　<br>　　3. 将异步操作包装成 Promise 对象，用 then 方法交出执行权。</li>\n</ul>\n<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><ul>\n<li>编译时确定模块依赖，编译时加载，使得静态分析成为可能。</li>\n<li>ES6 模块不是对象。</li>\n<li>export 输出的是对外的接口。</li>\n<li>模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。</li>\n<li>循环加载：<br>　　1. CommonJS 是加载时执行。当发生循环加载时，就只输出已经执行的部分。<br>　　2. ES6 模块是动态引用。只要引用存在，代码就可以执行。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Arrow-Function\"><a href=\"#Arrow-Function\" class=\"headerlink\" title=\"Arrow Function\"></a>Arrow Function</h1><p>箭头函数可以让 this 绑定函数定义时所在的作用域，而不是指向运行时所在的作用域，利用这个特性可以解决一些在匿名回调函数中 this 指向的问题（以前通常用 var that = this 来缓存 this）</p>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><p>原型链继承的一种语法糖，ES6 的类可以看作是构造函数的另一种写法。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">typeof Point //&apos;function&apos;</span><br><span class=\"line\">Point === Point.prototype.constructor</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>类内部定义的方法都不可枚举(non-enumerable)</li>\n<li>不存在变量提升(hoist)</li>\n<li>实现私有方法<br>　　1. 将方法移出 Class，定义在全局作用域<br>　　2. 将私有方法的名字命名为一个 Symbol 值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const bar = Symbol(&apos;bar&apos;);</span><br><span class=\"line\">const snaf = Symbol(&apos;snaf&apos;);</span><br><span class=\"line\">export default class myClass&#123;</span><br><span class=\"line\">　// 公有方法</span><br><span class=\"line\">　foo(baz) &#123;</span><br><span class=\"line\">　　this[bar](baz);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　// 私有方法</span><br><span class=\"line\">　[bar](baz) &#123;</span><br><span class=\"line\">　　return this[snaf] = baz;</span><br><span class=\"line\"> 　&#125;</span><br><span class=\"line\">　// ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>允许继承原生构造函数</li>\n<li>添加静态属性，静态方法<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">　static classMethod() &#123;</span><br><span class=\"line\">　　return &apos;hello&apos;;</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prop = 1;</span><br><span class=\"line\">Foo.prop // 1</span><br><span class=\"line\">Foo.classMethod() // &apos;hello&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><ul>\n<li>三种状态 Pending、Resolved、Rejected。</li>\n<li>缺点：<br>　　1. 无法中途取消 Promise。<br>　　2. 如果不设置回调，内部抛出的错误无法反应到外部。<br>　　3. 大量的 then() 语句导致语义不清楚。</li>\n</ul>\n<h1 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h1><ul>\n<li>yield 语句暂停函数执行。</li>\n<li>generator 返回一个迭代器对象，通过 next() 手动执行迭代器，将指针移向下一个状态。next() 返回一个对象 { done:true, value:xxx}，其中 value 属性的值等于 yield 后面的语句返回的值。</li>\n<li>使用 for…of 遍历 Iterator 对象</li>\n<li>generator 作用：<br>　　1. 执行异步操作，将异步操作放在 yield 语句下，等到 next() 方法调用再执行。<br>　　2. 实现数组数据结构，每一项都是一个函数 。</li>\n<li>generator 缺点：流程管理困难，需要手动执行。解决办法：<br>　　1. Thunk 函数、传名调用。<br>　　2. 使用 Co　<br>　　3. 将异步操作包装成 Promise 对象，用 then 方法交出执行权。</li>\n</ul>\n<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><ul>\n<li>编译时确定模块依赖，编译时加载，使得静态分析成为可能。</li>\n<li>ES6 模块不是对象。</li>\n<li>export 输出的是对外的接口。</li>\n<li>模块加载实质：CommonJS 输出值的拷贝，ES6 输出值的引用。</li>\n<li>循环加载：<br>　　1. CommonJS 是加载时执行。当发生循环加载时，就只输出已经执行的部分。<br>　　2. ES6 模块是动态引用。只要引用存在，代码就可以执行。</li>\n</ul>\n"},{"title":"HTTPS 知识点","date":"2016-03-09T05:02:05.000Z","_content":"1.网景公司首创，所有主要浏览器和服务器都支持此协议\n2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。\n3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。\n4.数字加密\n　1）对称密钥加密（DES、RC2、RC4）\n　　　加密和解密使用相同的密钥。\n　　　优点:加密解密的效率比较高    \n　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销\n　2）非对称密钥加密（RSA）\n　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。\n　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。\n　　　**问题1：数据传输仅单向安全**。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。\n　　　　　整个加密通信的流程如下：\n　　　　　　１．小明访问XX,XX将自己的证书发给浏览器\n　　　　　　２．浏览器从证书中拿到XX的公钥A\n　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX\n　　　　　　４．XX通过私钥解密，拿到对称密钥B\n　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密\n\n　　　　　如此，也解决了非对称密钥加解密效率低的问题。\n　　　问题2：公钥如何获取，如何保证不被篡改。**HTTPS将公钥放在数字证书中**，只要数字证书是可信的，公钥就是可信的。    \n　3）数字签名\n　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。\n　　　数字签名通常是用非对称密钥技术产生\n　4）数字证书\n　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证\n　　　数字证书的主要内容包括：\n　　　　1. 对象的名称\n　　　　2. 过期时间\n　　　　3. 证书发布者\n　　　　4. 来自证书发布者的数字签名\n\n------\n参考链接： \n1. [HTTPS科普扫盲帖](https://segmentfault.com/a/1190000004523659)\n2. [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n          ","source":"_posts/HTTPS知识点.md","raw":"---\ntitle: HTTPS 知识点\ndate: 2016-03-09 13:02:05\ntags:\n- HTTP\ncategories:\n- 网络\n---\n1.网景公司首创，所有主要浏览器和服务器都支持此协议\n2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。\n3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。\n4.数字加密\n　1）对称密钥加密（DES、RC2、RC4）\n　　　加密和解密使用相同的密钥。\n　　　优点:加密解密的效率比较高    \n　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销\n　2）非对称密钥加密（RSA）\n　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。\n　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。\n　　　**问题1：数据传输仅单向安全**。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。\n　　　　　整个加密通信的流程如下：\n　　　　　　１．小明访问XX,XX将自己的证书发给浏览器\n　　　　　　２．浏览器从证书中拿到XX的公钥A\n　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX\n　　　　　　４．XX通过私钥解密，拿到对称密钥B\n　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密\n\n　　　　　如此，也解决了非对称密钥加解密效率低的问题。\n　　　问题2：公钥如何获取，如何保证不被篡改。**HTTPS将公钥放在数字证书中**，只要数字证书是可信的，公钥就是可信的。    \n　3）数字签名\n　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。\n　　　数字签名通常是用非对称密钥技术产生\n　4）数字证书\n　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证\n　　　数字证书的主要内容包括：\n　　　　1. 对象的名称\n　　　　2. 过期时间\n　　　　3. 证书发布者\n　　　　4. 来自证书发布者的数字签名\n\n------\n参考链接： \n1. [HTTPS科普扫盲帖](https://segmentfault.com/a/1190000004523659)\n2. [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n          ","slug":"HTTPS知识点","published":1,"updated":"2019-12-29T09:49:59.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn79000fhns6bfc7cvn4","content":"<p>1.网景公司首创，所有主要浏览器和服务器都支持此协议<br>2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。<br>3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。<br>4.数字加密<br>　1）对称密钥加密（DES、RC2、RC4）<br>　　　加密和解密使用相同的密钥。<br>　　　优点:加密解密的效率比较高<br>　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销<br>　2）非对称密钥加密（RSA）<br>　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。<br>　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。<br>　　　<strong>问题1：数据传输仅单向安全</strong>。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。<br>　　　　　整个加密通信的流程如下：<br>　　　　　　１．小明访问XX,XX将自己的证书发给浏览器<br>　　　　　　２．浏览器从证书中拿到XX的公钥A<br>　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX<br>　　　　　　４．XX通过私钥解密，拿到对称密钥B<br>　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密</p>\n<p>　　　　　如此，也解决了非对称密钥加解密效率低的问题。<br>　　　问题2：公钥如何获取，如何保证不被篡改。<strong>HTTPS将公钥放在数字证书中</strong>，只要数字证书是可信的，公钥就是可信的。<br>　3）数字签名<br>　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。<br>　　　数字签名通常是用非对称密钥技术产生<br>　4）数字证书<br>　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证<br>　　　数字证书的主要内容包括：<br>　　　　1. 对象的名称<br>　　　　2. 过期时间<br>　　　　3. 证书发布者<br>　　　　4. 来自证书发布者的数字签名</p>\n<hr>\n<p>参考链接： </p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000004523659\" target=\"_blank\" rel=\"noopener\">HTTPS科普扫盲帖</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL/TLS协议运行机制的概述</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>1.网景公司首创，所有主要浏览器和服务器都支持此协议<br>2.使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP和TCP之间加入了一个传输级的安全层，可以使用SSL或者TLS。TLS/SSL中使用了非对称加密、对称加密、Hash算法等。<br>3.密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。<br>4.数字加密<br>　1）对称密钥加密（DES、RC2、RC4）<br>　　　加密和解密使用相同的密钥。<br>　　　优点:加密解密的效率比较高<br>　　　缺点：发送端和接收端需要共享一把密钥。对于有多个数据交换需求的个体，两两之间需要分配并维护一把密钥，带来巨大的成本开销<br>　2）非对称密钥加密（RSA）<br>　　　使用两个不同的密钥进行编码和解码，编码密钥是公开的，但只有主机才知道私有的解密密钥。<br>　　　公钥加密的数据只能通过私钥解开，私钥加密的数据只能通过公钥解开。<br>　　　<strong>问题1：数据传输仅单向安全</strong>。因为公钥也可以解开私钥加密的数据，而公钥又是公开的，那么只要中间代理拿到公钥后就可以在数据发回浏览器的途中解开数据。HTTPS结合使用了非对称加密、对称加密，避免了这个问题。<br>　　　　　整个加密通信的流程如下：<br>　　　　　　１．小明访问XX,XX将自己的证书发给浏览器<br>　　　　　　２．浏览器从证书中拿到XX的公钥A<br>　　　　　　３．浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX<br>　　　　　　４．XX通过私钥解密，拿到对称密钥B<br>　　　　　　５．浏览器、XX之间的数据通信，都通过密钥B进行加密</p>\n<p>　　　　　如此，也解决了非对称密钥加解密效率低的问题。<br>　　　问题2：公钥如何获取，如何保证不被篡改。<strong>HTTPS将公钥放在数字证书中</strong>，只要数字证书是可信的，公钥就是可信的。<br>　3）数字签名<br>　　　对传输的内容，通过hash算法计算出一段固定长度的串，这段字符串就是“摘要”。然后通过CA的私钥对这段摘要进行加密，加密得到的结果就是数字签名。数字签名用于说明是谁编写的报文，同时证明报文未被篡改过。<br>　　　数字签名通常是用非对称密钥技术产生<br>　4）数字证书<br>　　　包含了由某个受信任组织担保的用户或公司的相关信息，相当于网站的身份证<br>　　　数字证书的主要内容包括：<br>　　　　1. 对象的名称<br>　　　　2. 过期时间<br>　　　　3. 证书发布者<br>　　　　4. 来自证书发布者的数字签名</p>\n<hr>\n<p>参考链接： </p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000004523659\" target=\"_blank\" rel=\"noopener\">HTTPS科普扫盲帖</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL/TLS协议运行机制的概述</a></li>\n</ol>\n"},{"title":"HTTP 状态码大全","date":"2016-03-12T17:08:51.000Z","_content":"**HTTP状态码被分成了五类。**\n100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。\n 500-599 用于支持服务器错误。 \n********\n**100-199：信息性状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n| 100    |  continue   | 说明收到了请求的初始部分，请客户端继续发送 |\n|101    |  switch protocols    |    说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议 |\n\n**200-299：成功状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|200|      ok|    请求成功|\n|201|      created|       用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象\n|202  |  accepted|  请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。\n|203   | non-authoritative information|  实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。\n|204    |no content|  响应报文中包含若干首部和一个状态行，但没有实体的主体部分\n|205    |reset content| 负责告知浏览器清除当前页面中所有的HTML表单元素\n\n**300-399：重定向状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|300|  Multiple choices|   客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。\n|301|  move permanently | 被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL\n|302  |found|   请求的资源现在临时从不同的 URI 响应请求。\n|303 | see other |告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去\n|304 | not modified|  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。\n|305|  use proxy|   用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。\n|307|  temporary redirect|  请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n\n**400-499:客户端错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|400  |bad request | 用于告知客户端它发送了一个错误的请求\n|401  |unauthorized | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。\n|403| forbidden| 服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用\n|404|  not found  |无法找到指定位置的资源。\n|405    |Method Not Allowed|    请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。\n|406    |Not Acceptable|    表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。\n|408    |Request Timeout|   请求超时\n**500-599:服务器错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |-------| -------------------------|\n|500  |  Internal Server Error | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\n|501  | Not Implemented | 客户端使用了服务器未实现的请求方法\n|502  | Bad Gateway | 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。\n|503  | Service Unavailable | 用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 \n|504 |Gateway Timeout|该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。\n|505 |HTTP Version Not Supported|服务器不支持在请求中所标明 HTTP 版本。\n\n\n参考：\n    《HTTP权威指南》\n","source":"_posts/HTTP状态码大全.md","raw":"---\ntitle: HTTP 状态码大全\ndate: 2016-03-13 01:08:51\ntags:\n- HTTP\ncategories:\n- 网络\n---\n**HTTP状态码被分成了五类。**\n100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。\n 500-599 用于支持服务器错误。 \n********\n**100-199：信息性状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n| 100    |  continue   | 说明收到了请求的初始部分，请客户端继续发送 |\n|101    |  switch protocols    |    说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议 |\n\n**200-299：成功状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|200|      ok|    请求成功|\n|201|      created|       用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象\n|202  |  accepted|  请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。\n|203   | non-authoritative information|  实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。\n|204    |no content|  响应报文中包含若干首部和一个状态行，但没有实体的主体部分\n|205    |reset content| 负责告知浏览器清除当前页面中所有的HTML表单元素\n\n**300-399：重定向状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|300|  Multiple choices|   客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。\n|301|  move permanently | 被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL\n|302  |found|   请求的资源现在临时从不同的 URI 响应请求。\n|303 | see other |告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去\n|304 | not modified|  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。\n|305|  use proxy|   用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。\n|307|  temporary redirect|  请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n\n**400-499:客户端错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |----| ---------|\n|400  |bad request | 用于告知客户端它发送了一个错误的请求\n|401  |unauthorized | 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。\n|403| forbidden| 服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用\n|404|  not found  |无法找到指定位置的资源。\n|405    |Method Not Allowed|    请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。\n|406    |Not Acceptable|    表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。\n|408    |Request Timeout|   请求超时\n**500-599:服务器错误状态码**\n\n| 状态码  | 原因短语  |   含义 |\n| ----- |-------| -------------------------|\n|500  |  Internal Server Error | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\n|501  | Not Implemented | 客户端使用了服务器未实现的请求方法\n|502  | Bad Gateway | 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。\n|503  | Service Unavailable | 用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 \n|504 |Gateway Timeout|该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。\n|505 |HTTP Version Not Supported|服务器不支持在请求中所标明 HTTP 版本。\n\n\n参考：\n    《HTTP权威指南》\n","slug":"HTTP状态码大全","published":1,"updated":"2019-12-28T16:36:30.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7c000ghns69py1o2cw","content":"<p><strong>HTTP状态码被分成了五类。</strong><br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br> 500-599 用于支持服务器错误。 </p>\n<hr>\n<p><strong>100-199：信息性状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>continue</td>\n<td>说明收到了请求的初始部分，请客户端继续发送</td>\n</tr>\n<tr>\n<td>101</td>\n<td>switch protocols</td>\n<td>说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议</td>\n</tr>\n</tbody>\n</table>\n<p><strong>200-299：成功状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>ok</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>created</td>\n<td>用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象</td>\n</tr>\n<tr>\n<td>202</td>\n<td>accepted</td>\n<td>请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>non-authoritative information</td>\n<td>实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>no content</td>\n<td>响应报文中包含若干首部和一个状态行，但没有实体的主体部分</td>\n</tr>\n<tr>\n<td>205</td>\n<td>reset content</td>\n<td>负责告知浏览器清除当前页面中所有的HTML表单元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>300-399：重定向状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>300</td>\n<td>Multiple choices</td>\n<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>move permanently</td>\n<td>被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL</td>\n</tr>\n<tr>\n<td>302</td>\n<td>found</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>see other</td>\n<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去</td>\n</tr>\n<tr>\n<td>304</td>\n<td>not modified</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>use proxy</td>\n<td>用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>temporary redirect</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>400-499:客户端错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>bad request</td>\n<td>用于告知客户端它发送了一个错误的请求</td>\n</tr>\n<tr>\n<td>401</td>\n<td>unauthorized</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>forbidden</td>\n<td>服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用</td>\n</tr>\n<tr>\n<td>404</td>\n<td>not found</td>\n<td>无法找到指定位置的资源。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>请求超时</td>\n</tr>\n</tbody>\n</table>\n<p><strong>500-599:服务器错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>客户端使用了服务器未实现的请求方法</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 </td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Timeout</td>\n<td>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version Not Supported</td>\n<td>服务器不支持在请求中所标明 HTTP 版本。</td>\n</tr>\n</tbody>\n</table>\n<p>参考：<br>    《HTTP权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>HTTP状态码被分成了五类。</strong><br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br> 500-599 用于支持服务器错误。 </p>\n<hr>\n<p><strong>100-199：信息性状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>continue</td>\n<td>说明收到了请求的初始部分，请客户端继续发送</td>\n</tr>\n<tr>\n<td>101</td>\n<td>switch protocols</td>\n<td>说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议</td>\n</tr>\n</tbody>\n</table>\n<p><strong>200-299：成功状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>ok</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>created</td>\n<td>用于创建服务器对象的请求（比如put）响应的实体主体部分中应该包含了各种引用了已创建的资源的URL。服务器必须在发送这个状态码之前创建好对象</td>\n</tr>\n<tr>\n<td>202</td>\n<td>accepted</td>\n<td>请求已被接收，但服务器还未对其执行任何动作。最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>non-authoritative information</td>\n<td>实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>no content</td>\n<td>响应报文中包含若干首部和一个状态行，但没有实体的主体部分</td>\n</tr>\n<tr>\n<td>205</td>\n<td>reset content</td>\n<td>负责告知浏览器清除当前页面中所有的HTML表单元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>300-399：重定向状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>300</td>\n<td>Multiple choices</td>\n<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项。</td>\n</tr>\n<tr>\n<td>301</td>\n<td>move permanently</td>\n<td>被请求的资源已永久移动到新位置，在请求的URL已被移除时使用。响应的location首部中应该包含资源现在所处的URL</td>\n</tr>\n<tr>\n<td>302</td>\n<td>found</td>\n<td>请求的资源现在临时从不同的 URI 响应请求。</td>\n</tr>\n<tr>\n<td>303</td>\n<td>see other</td>\n<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部。其主要目的是允许post请求的响应将客户端定向到某个资源上去</td>\n</tr>\n<tr>\n<td>304</td>\n<td>not modified</td>\n<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</td>\n</tr>\n<tr>\n<td>305</td>\n<td>use proxy</td>\n<td>用来说明必须使用一个代理来访问资源，代理的位置由location首部给出。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>temporary redirect</td>\n<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>400-499:客户端错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>bad request</td>\n<td>用于告知客户端它发送了一个错误的请求</td>\n</tr>\n<tr>\n<td>401</td>\n<td>unauthorized</td>\n<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>forbidden</td>\n<td>服务器已经理解请求，但是拒绝执行它。如果服务器想说明拒绝原因，可以在包含实体的主体部分来对原因进行描述。但这个状态码通常在服务器不想说明拒绝原因时使用</td>\n</tr>\n<tr>\n<td>404</td>\n<td>not found</td>\n<td>无法找到指定位置的资源。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>请求超时</td>\n</tr>\n</tbody>\n</table>\n<p><strong>500-599:服务器错误状态码</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>客户端使用了服务器未实现的请求方法</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>用于说明服务器现在无法为请求提供服务。但将来可以，服务器可提供一个Retry-After头信息告诉客户端什么时候资源可用。 </td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Timeout</td>\n<td>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version Not Supported</td>\n<td>服务器不支持在请求中所标明 HTTP 版本。</td>\n</tr>\n</tbody>\n</table>\n<p>参考：<br>    《HTTP权威指南》</p>\n"},{"title":"JavaScript 设计模式汇总","date":"2018-01-22T16:04:48.000Z","_content":"\n# 单例模式\n单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象`var o = {}`，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。\n实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：\n```\nvar getInstance = function() {\n  var _instance;\n  return function() {\n    if (!_instance) {\n      _instance = new Dialog();\n    }\n    return _instance;\n  }\n}\n```\n其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。\n\n# 发布-订阅模式\n发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。\n```\nvar Event = (function(){\n  var list = {};\n  var listen = function(type, fn) {\n    if (!list[type]) {\n      list[type] = [];\n    } \n    list[type].push(fn);\n  }\n  var trigger = function() {\n    var type = Array.prototype.shift.call(arguments);\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    }\n    for (var i = 0; i < fns.length; i++) {\n      fns[i].apply(this, arguments);\n    }\n  }\n  var remove = function(type, fn) {\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    } \n    fns.forEach(function(_fn, i) {\n      if (_fn == fn) {\n        fns.splice(i, 1);\n      }\n    })\n  }\n  return {\n    listen: listen,\n    trigger: trigger,\n    remove: remove\n  }\n})();\n\nEvent.listen('click', function(data) {\n  console.log('you clicked: ' + data);\n})\nEvent.trigger('click', 'hahaha');\n```\n\n# 代理模式\n\n待续...\n\n","source":"_posts/JavaScript 设计模式汇总.md","raw":"---\ntitle: JavaScript 设计模式汇总\ndate: 2018-01-23 00:04:48\ntags: \n- 设计模式\ncategories:\n- 前端\n---\n\n# 单例模式\n单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象`var o = {}`，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。\n实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：\n```\nvar getInstance = function() {\n  var _instance;\n  return function() {\n    if (!_instance) {\n      _instance = new Dialog();\n    }\n    return _instance;\n  }\n}\n```\n其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。\n\n# 发布-订阅模式\n发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。\n```\nvar Event = (function(){\n  var list = {};\n  var listen = function(type, fn) {\n    if (!list[type]) {\n      list[type] = [];\n    } \n    list[type].push(fn);\n  }\n  var trigger = function() {\n    var type = Array.prototype.shift.call(arguments);\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    }\n    for (var i = 0; i < fns.length; i++) {\n      fns[i].apply(this, arguments);\n    }\n  }\n  var remove = function(type, fn) {\n    var fns = list[type];\n    if (!fns || !fns.length) {\n      return false;\n    } \n    fns.forEach(function(_fn, i) {\n      if (_fn == fn) {\n        fns.splice(i, 1);\n      }\n    })\n  }\n  return {\n    listen: listen,\n    trigger: trigger,\n    remove: remove\n  }\n})();\n\nEvent.listen('click', function(data) {\n  console.log('you clicked: ' + data);\n})\nEvent.trigger('click', 'hahaha');\n```\n\n# 代理模式\n\n待续...\n\n","slug":"JavaScript 设计模式汇总","published":1,"updated":"2019-12-28T17:33:01.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7f000khns66ba6wang","content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象<code>var o = {}</code>，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。<br>实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var getInstance = function() &#123;</span><br><span class=\"line\">  var _instance;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    if (!_instance) &#123;</span><br><span class=\"line\">      _instance = new Dialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。</p>\n<h1 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布-订阅模式\"></a>发布-订阅模式</h1><p>发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var Event = (function()&#123;</span><br><span class=\"line\">  var list = &#123;&#125;;</span><br><span class=\"line\">  var listen = function(type, fn) &#123;</span><br><span class=\"line\">    if (!list[type]) &#123;</span><br><span class=\"line\">      list[type] = [];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    list[type].push(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var trigger = function() &#123;</span><br><span class=\"line\">    var type = Array.prototype.shift.call(arguments);</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 0; i &lt; fns.length; i++) &#123;</span><br><span class=\"line\">      fns[i].apply(this, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var remove = function(type, fn) &#123;</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    fns.forEach(function(_fn, i) &#123;</span><br><span class=\"line\">      if (_fn == fn) &#123;</span><br><span class=\"line\">        fns.splice(i, 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    listen: listen,</span><br><span class=\"line\">    trigger: trigger,</span><br><span class=\"line\">    remove: remove</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Event.listen(&apos;click&apos;, function(data) &#123;</span><br><span class=\"line\">  console.log(&apos;you clicked: &apos; + data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Event.trigger(&apos;click&apos;, &apos;hahaha&apos;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>待续…</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>单例模式算是最简单的一种设计模式，也是 JavaScript 中特别常见一种设计模式。比如创建一个对象<code>var o = {}</code>，当对象 o 作为一个全局变量共享时，可以算作一种单例模式。单例模式的核心是确保只有一个实例，并提供全局访问。<br>实际应用中，对话框等全局唯一的UI组件，会使用到单例模式。以 Dialog 组件为例，我通常会为一个 Dialog 类写一个 getInstance() 的静态方法。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var getInstance = function() &#123;</span><br><span class=\"line\">  var _instance;</span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    if (!_instance) &#123;</span><br><span class=\"line\">      _instance = new Dialog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实就是利用了闭包，将创建的实例缓存了起来，这样保证同一个页面只会存在一个 Dialog 实例。</p>\n<h1 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布-订阅模式\"></a>发布-订阅模式</h1><p>发布-订阅模式，又称观察者模式。它定义了对象间一种一对多的关系。JavaScript中发布-订阅模式可以说无处不在。比如最常见的事件机制，就是一种发布-订阅模式。下面，我们来实现一个简单的事件机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var Event = (function()&#123;</span><br><span class=\"line\">  var list = &#123;&#125;;</span><br><span class=\"line\">  var listen = function(type, fn) &#123;</span><br><span class=\"line\">    if (!list[type]) &#123;</span><br><span class=\"line\">      list[type] = [];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    list[type].push(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var trigger = function() &#123;</span><br><span class=\"line\">    var type = Array.prototype.shift.call(arguments);</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 0; i &lt; fns.length; i++) &#123;</span><br><span class=\"line\">      fns[i].apply(this, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var remove = function(type, fn) &#123;</span><br><span class=\"line\">    var fns = list[type];</span><br><span class=\"line\">    if (!fns || !fns.length) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    fns.forEach(function(_fn, i) &#123;</span><br><span class=\"line\">      if (_fn == fn) &#123;</span><br><span class=\"line\">        fns.splice(i, 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    listen: listen,</span><br><span class=\"line\">    trigger: trigger,</span><br><span class=\"line\">    remove: remove</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Event.listen(&apos;click&apos;, function(data) &#123;</span><br><span class=\"line\">  console.log(&apos;you clicked: &apos; + data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Event.trigger(&apos;click&apos;, &apos;hahaha&apos;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>待续…</p>\n"},{"title":"Markdown 简明语法","date":"2016-03-07T08:37:23.000Z","_content":"### 标题\n在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。\n`# 一级标题`\n`## 二级标题`\n`### 三级标题`\n`#### 四级标题`\n`##### 五级标题`\n`###### 六级标题`\n\n### 列表\n\n在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\n`_列表内容`\n`1. 列表内容`\n\n无序列表使用 \\* + 和 - 来做为列表的项目标记，这些符号是都可以使用的\n\n### 修辞和强调\nMarkdown 使用 * 和 _ 来标记需要强调的区段。\n\n`*需要强调的内容*`\n`**需要强调的内容**`\n\n### 引用\n只需要在文本前加入 > 这种尖括号（大于号）即可\n`> 引用的内容`\n\n### 图片与链接\n###### 链接\nMarkdown 支持两种形式的链接语法： **行内** 和 **参考** 两种形式，两种都是使用[ ]来把文字转成连结。\n1. 行内形式是直接在后面用括号直接接上链接：\nThis is an \\[example link\\]\\(http://example.com\\).\n2. 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：\nI get 10 times more traffic from [Google] than from[Yahoo] or [MSN]: \nhttp://google.com/ \"Google\": \nhttp://search.msn.com/ \"MSN\"\n\n###### 图片\n图片的语法和链接很像。\n\n1. 行内形式（title 可选）：\n\\[imgUrl (\"Title\")]\n2. 参考形式：\n\\![alt text][id]\n\\[id]: imgUrl \"Title\"\n\n上面两种方法都会输出 图片 为：\n![avatar.jpg](https://mares.oss-cn-qingdao.aliyuncs.com/blog/avatar.jpg)\n\n### 代码\n在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 & 、< 和 > 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：\n\n``I strongly recommend against using any `<blink>` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.``\n\n如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &、< 和 > 也一样会自动转成 HTML 实体。\n\n    If you want your page to validate under XHTML 1.0 Strict,you've got to put paragraph tags in your blockquotes:<blockquote><p>For example.</p></blockquote>","source":"_posts/Markdown简明语法.md","raw":"---\ntitle: Markdown 简明语法\ndate: 2016-03-07 16:37:23\ntags: \n- Markdown\ncategories:\n- 工具\n---\n### 标题\n在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。\n`# 一级标题`\n`## 二级标题`\n`### 三级标题`\n`#### 四级标题`\n`##### 五级标题`\n`###### 六级标题`\n\n### 列表\n\n在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\n`_列表内容`\n`1. 列表内容`\n\n无序列表使用 \\* + 和 - 来做为列表的项目标记，这些符号是都可以使用的\n\n### 修辞和强调\nMarkdown 使用 * 和 _ 来标记需要强调的区段。\n\n`*需要强调的内容*`\n`**需要强调的内容**`\n\n### 引用\n只需要在文本前加入 > 这种尖括号（大于号）即可\n`> 引用的内容`\n\n### 图片与链接\n###### 链接\nMarkdown 支持两种形式的链接语法： **行内** 和 **参考** 两种形式，两种都是使用[ ]来把文字转成连结。\n1. 行内形式是直接在后面用括号直接接上链接：\nThis is an \\[example link\\]\\(http://example.com\\).\n2. 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：\nI get 10 times more traffic from [Google] than from[Yahoo] or [MSN]: \nhttp://google.com/ \"Google\": \nhttp://search.msn.com/ \"MSN\"\n\n###### 图片\n图片的语法和链接很像。\n\n1. 行内形式（title 可选）：\n\\[imgUrl (\"Title\")]\n2. 参考形式：\n\\![alt text][id]\n\\[id]: imgUrl \"Title\"\n\n上面两种方法都会输出 图片 为：\n![avatar.jpg](https://mares.oss-cn-qingdao.aliyuncs.com/blog/avatar.jpg)\n\n### 代码\n在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 & 、< 和 > 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：\n\n``I strongly recommend against using any `<blink>` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.``\n\n如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &、< 和 > 也一样会自动转成 HTML 实体。\n\n    If you want your page to validate under XHTML 1.0 Strict,you've got to put paragraph tags in your blockquotes:<blockquote><p>For example.</p></blockquote>","slug":"Markdown简明语法","published":1,"updated":"2019-12-29T11:28:13.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7h000nhns6xerdthhf","content":"<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。<br><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。<br><code>_列表内容</code><br><code>1. 列表内容</code></p>\n<p>无序列表使用 * + 和 - 来做为列表的项目标记，这些符号是都可以使用的</p>\n<h3 id=\"修辞和强调\"><a href=\"#修辞和强调\" class=\"headerlink\" title=\"修辞和强调\"></a>修辞和强调</h3><p>Markdown 使用 * 和 _ 来标记需要强调的区段。</p>\n<p><code>*需要强调的内容*</code><br><code>**需要强调的内容**</code></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可<br><code>&gt; 引用的内容</code></p>\n<h3 id=\"图片与链接\"><a href=\"#图片与链接\" class=\"headerlink\" title=\"图片与链接\"></a>图片与链接</h3><h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>Markdown 支持两种形式的链接语法： <strong>行内</strong> 和 <strong>参考</strong> 两种形式，两种都是使用[ ]来把文字转成连结。</p>\n<ol>\n<li>行内形式是直接在后面用括号直接接上链接：<br>This is an [example link](<a href=\"http://example.com\\\" target=\"_blank\" rel=\"noopener\">http://example.com\\</a>).</li>\n<li>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：<br>I get 10 times more traffic from [Google] than from[Yahoo] or [MSN]:<br><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">http://google.com/</a> “Google”:<br><a href=\"http://search.msn.com/\" target=\"_blank\" rel=\"noopener\">http://search.msn.com/</a> “MSN”</li>\n</ol>\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>图片的语法和链接很像。</p>\n<ol>\n<li>行内形式（title 可选）：<br>[imgUrl (“Title”)]</li>\n<li>参考形式：<br>![alt text][id]<br>[id]: imgUrl “Title”</li>\n</ol>\n<p>上面两种方法都会输出 图片 为：<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/avatar.jpg\" alt=\"avatar.jpg\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 &amp; 、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>\n<p><code>I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.</code></p>\n<p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。</p>\n<pre><code>If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;blockquote&gt;&lt;p&gt;For example.&lt;/p&gt;&lt;/blockquote&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。<br><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。<br><code>_列表内容</code><br><code>1. 列表内容</code></p>\n<p>无序列表使用 * + 和 - 来做为列表的项目标记，这些符号是都可以使用的</p>\n<h3 id=\"修辞和强调\"><a href=\"#修辞和强调\" class=\"headerlink\" title=\"修辞和强调\"></a>修辞和强调</h3><p>Markdown 使用 * 和 _ 来标记需要强调的区段。</p>\n<p><code>*需要强调的内容*</code><br><code>**需要强调的内容**</code></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可<br><code>&gt; 引用的内容</code></p>\n<h3 id=\"图片与链接\"><a href=\"#图片与链接\" class=\"headerlink\" title=\"图片与链接\"></a>图片与链接</h3><h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><p>Markdown 支持两种形式的链接语法： <strong>行内</strong> 和 <strong>参考</strong> 两种形式，两种都是使用[ ]来把文字转成连结。</p>\n<ol>\n<li>行内形式是直接在后面用括号直接接上链接：<br>This is an [example link](<a href=\"http://example.com\\\" target=\"_blank\" rel=\"noopener\">http://example.com\\</a>).</li>\n<li>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：<br>I get 10 times more traffic from [Google] than from[Yahoo] or [MSN]:<br><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">http://google.com/</a> “Google”:<br><a href=\"http://search.msn.com/\" target=\"_blank\" rel=\"noopener\">http://search.msn.com/</a> “MSN”</li>\n</ol>\n<h6 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h6><p>图片的语法和链接很像。</p>\n<ol>\n<li>行内形式（title 可选）：<br>[imgUrl (“Title”)]</li>\n<li>参考形式：<br>![alt text][id]<br>[id]: imgUrl “Title”</li>\n</ol>\n<p>上面两种方法都会输出 图片 为：<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/avatar.jpg\" alt=\"avatar.jpg\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 &amp; 、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>\n<p><code>I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `—`instead of decimal-encoded entites like `—\\`.</code></p>\n<p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。</p>\n<pre><code>If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;blockquote&gt;&lt;p&gt;For example.&lt;/p&gt;&lt;/blockquote&gt;\n</code></pre>"},{"title":"TCP 性能优化浅析","date":"2018-02-02T10:38:42.000Z","_content":"\n### 前言\nTCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。\n\n### 三次握手\n众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。\n\n![图1](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/1.png)\n\n\n三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。\n\n既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。\n\n除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。\n![图2](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/2.png)\n\nLinux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。\n\nPS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/3.png)\n\n### 流量控制\n流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。\n\n大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) * round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) * 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。\n\n为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：\n```\nsysctl net.ipv4.tcp_rmem\n// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456\n// 从左到右一次为最小值、默认值、最大值\n```\n \n### 慢启动\n\n流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。\n\n慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。\n\n一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。\n\n此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则\n cwnd=4，也就是 cwnd = cwnd*2。\n\n以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。\n![图3](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/4.png)\n\n随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。\n![图4](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/5.png)\n\n为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。\n\n### 总结\n本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。\n \n----------------\n参考文献：\n1. [《Web性能权威指南》](https://book.douban.com/subject/25856314/)\n2. [《TCP/IP详解，卷1:协议》](https://book.douban.com/subject/1088054/)\n3. [浅谈TCP优化](https://huoding.com/2013/11/21/299)\n4. [TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎](\nhttps://www.zhihu.com/question/24886217/answer/149903688)\n\n","source":"_posts/TCP性能优化浅析.md","raw":"---\ntitle: TCP 性能优化浅析\ndate: 2018-02-02 18:38:42\ntags:\n- TCP\n- 性能优化\ncategories:\n- 网络\n---\n\n### 前言\nTCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。\n\n### 三次握手\n众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。\n\n![图1](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/1.png)\n\n\n三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。\n\n既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。\n\n除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。\n![图2](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/2.png)\n\nLinux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。\n\nPS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/3.png)\n\n### 流量控制\n流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。\n\n大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) * round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) * 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。\n\n为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：\n```\nsysctl net.ipv4.tcp_rmem\n// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456\n// 从左到右一次为最小值、默认值、最大值\n```\n \n### 慢启动\n\n流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。\n\n慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。\n\n一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。\n\n此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则\n cwnd=4，也就是 cwnd = cwnd*2。\n\n以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。\n![图3](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/4.png)\n\n随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。\n![图4](https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/5.png)\n\n为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。\n\n### 总结\n本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。\n \n----------------\n参考文献：\n1. [《Web性能权威指南》](https://book.douban.com/subject/25856314/)\n2. [《TCP/IP详解，卷1:协议》](https://book.douban.com/subject/1088054/)\n3. [浅谈TCP优化](https://huoding.com/2013/11/21/299)\n4. [TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎](\nhttps://www.zhihu.com/question/24886217/answer/149903688)\n\n","slug":"TCP性能优化浅析","published":1,"updated":"2019-12-29T11:28:13.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7k000rhns6xasmogd7","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>TCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/1.png\" alt=\"图1\"></p>\n<p>三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。</p>\n<p>既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。</p>\n<p>除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/2.png\" alt=\"图2\"></p>\n<p>Linux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。</p>\n<p>PS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/3.png\" alt=\"\"></p>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><p>流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。</p>\n<p>大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) <em> round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) </em> 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。</p>\n<p>为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_rmem</span><br><span class=\"line\">// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456</span><br><span class=\"line\">// 从左到右一次为最小值、默认值、最大值</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"慢启动\"><a href=\"#慢启动\" class=\"headerlink\" title=\"慢启动\"></a>慢启动</h3><p>流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。</p>\n<p>慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。</p>\n<p>一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。</p>\n<p>此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则<br> cwnd=4，也就是 cwnd = cwnd*2。</p>\n<p>以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/4.png\" alt=\"图3\"></p>\n<p>随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/5.png\" alt=\"图4\"></p>\n<p>为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。</p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/25856314/\" target=\"_blank\" rel=\"noopener\">《Web性能权威指南》</a></li>\n<li><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"noopener\">《TCP/IP详解，卷1:协议》</a></li>\n<li><a href=\"https://huoding.com/2013/11/21/299\" target=\"_blank\" rel=\"noopener\">浅谈TCP优化</a></li>\n<li><a href=\"https://www.zhihu.com/question/24886217/answer/149903688\" target=\"_blank\" rel=\"noopener\">TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>TCP 作为一种最常用的传输层协议，它的作用是在不可靠的传输信道上，提供可靠地数据传输。在各层网络协议中，只要有一层协议是可靠的，那么整个网络传输就是安全可靠的。现实中，几乎所有的 HTTP 流量都是经过 TCP 传输。因此，我们要进行 web 性能优化，TCP 是其中的关键一环。要针对 TCP 进行性能优化，就得理解其工作原理。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>众所周知，建立一次 TCP 连接需要进行三次握手。关于三次握手，一图胜千言。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/1.png\" alt=\"图1\"></p>\n<p>三次握手给 TCP 带来了很大的延迟，不过这个握手过程是必不可少的。因为如果没有三次握手，有可能会出现一些已经失效的请求包突然又传到服务端，服务端认为这是客户端发起的一次新的连接，于是发出确认包，表示同意建立连接。而客户端并不会有响应，导致服务器出现空等，白白浪费服务器资源。</p>\n<p>既然三次握手的过程不可避免，那么我们只能通过重用 TCP 连接，减少三次握手的次数。HTTP 1.1 引入了长连接，通过在请求头中加入 Connection: keep-alive， 来告诉请求响应完毕后，不要关闭连接。不过 HTTP 长连接也是有限制的，服务器通常会设置 keep-alive 超时时间和最大请求数，如果请求超时或者超过最大请求数，服务器会主动关闭连接。</p>\n<p>除此之外，TFO(TCP Fast Open，TCP 快速打开)这种机制也被设计用于优化三次握手过程。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/2.png\" alt=\"图2\"></p>\n<p>Linux 3.7 及以后的内核在客户端及服务器中支持 TFO， 对于移动端，Android 和 iOS 9+ 都支持 TFO，不过 iOS 并未默认启用。</p>\n<p>PS: 推荐大家装一个 wireshark，可以非常直观的观察到三次握手的过程。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/3.png\" alt=\"\"></p>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><p>流量控制是一种预防发送端向接受端发送过多数据的机制。它的主要目的是为了防止接收端服务过载，从而出现丢包。为了实现流量控制，TCP 连接的每一方都要声明自己的通告窗口（rwnd），表示自己的缓冲区最多能接收多少数据。如果其中一端跟不上对方的发送速度，就通知对方一个较小的窗口。如果窗口大小为 0，应用层必须先清空缓冲区，才能继续接收数据。这就是所谓的滑动窗口协议。</p>\n<p>大家可能经常遇到这种情况，自己明明是百兆宽带，实际下载速度每秒却只有几M。这种情况有可能就是通告窗口（rwnd）设置的不合理造成的。最初的 TCP 规范分配给接收窗口大小的字段是 16 位，也就是 64KB（2 的 16 次方）。实际上，rwnd 的大小应该由 BDP（带宽延迟积） 而定。BDP(bit) = bandwidth(b/s) <em> round-trip time(s)。比如一个 100Mbps 的宽带，RTT 是100 ms，那么 BDP =  (100 / 8) </em> 0.1 = 1.25M。此时，要想提高网络传输吞吐量，rwnd 应该为 1.25 M。</p>\n<p>为了解决这个问题，TCP 窗口缩放（TCP Window Scaling）出现了，它将窗口大小由 16 位扩展到 32 位。Linux 上自带了缓冲大小调优机制，如下命令，可以查看 Linux 初始窗口大小：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_rmem</span><br><span class=\"line\">// 输出 net.ipv4.tcp_rmem = 4096\t87380    6291456</span><br><span class=\"line\">// 从左到右一次为最小值、默认值、最大值</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"慢启动\"><a href=\"#慢启动\" class=\"headerlink\" title=\"慢启动\"></a>慢启动</h3><p>流量控制机制可以防止发送端和接收端之间的服务过载，但无法防止任何一端向某个网络的发送数据过载，因此还需要一个估算机制，根据网络环境动态改变数据传输速度，这就是慢启动出现的原因。</p>\n<p>慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口（congestion window）,记为 cwnd。当与另一个网络的主机建立 TCP 连接时，cwnd 初始化为 1 个 TCP 段。每收到一个 ACK，cwnd 就增加一个 TCP 段。发送端取 cwnd 和 rwnd 中的最小值作为发送上限。可以这样理解，拥塞窗口是发送端使用的流量控制，而通告窗口是接收端使用的流量控制。</p>\n<p>一开始 cwnd 为 1，发送方只发送一个 mss（最大报文段长度） 大小的数据包，收到 ack 后，cwnd 加 1，cwnd=2。</p>\n<p>此时 cwnd 2，则发送方要发送两个 mss 大小的数据包，发送方会收到两个 ack，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则<br> cwnd=4，也就是 cwnd = cwnd*2。</p>\n<p>以此类推，每次 rtt 后，cwnd 都会变成上次发送前的 2 倍。因此，cwnd 的大小是呈指数级在递增。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/4.png\" alt=\"图3\"></p>\n<p>随着 cwnd 的增加，会发送网络过载，此时会出现丢包。一旦发现有这种问题，cwnd 会成倍减少。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/TCP/5.png\" alt=\"图4\"></p>\n<p>为了减少往返次数，初始拥塞窗口的大小设定就尤为重要。默认情况下(RFC 2581)，初始 cwnd 为 4 个 MSS。Google 建议将初始窗口改为 10 个 MSS。根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 MSS。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文介绍了 TCP 的部分工作原理，包括三次握手、流量控制、慢启动，并阐述了 TCP 快速打开、窗口缩放、增加初始拥塞窗口大小等优化手段。内容有点偏理论，还是需要多多实践，才能合理掌握各种优化手段。</p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/25856314/\" target=\"_blank\" rel=\"noopener\">《Web性能权威指南》</a></li>\n<li><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"noopener\">《TCP/IP详解，卷1:协议》</a></li>\n<li><a href=\"https://huoding.com/2013/11/21/299\" target=\"_blank\" rel=\"noopener\">浅谈TCP优化</a></li>\n<li><a href=\"https://www.zhihu.com/question/24886217/answer/149903688\" target=\"_blank\" rel=\"noopener\">TCP慢启动中cwnd的增长问题? - one no的回答 - 知乎</a></li>\n</ol>\n"},{"title":"Vue2.0 源码学习#0","date":"2016-09-06T19:37:41.000Z","_content":"> 近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。\n\n<!-- more -->\n作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。\n```\nimport config from './config'\n//加载初始全局API\nimport { initGlobalAPI } from './global-api/index'\n//类的初始化入口\nimport Vue from './instance/index'\n\ninitGlobalAPI(Vue)\n//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染\n//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR\n//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性\n//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因\n//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: () => config._isServer\n})\n//定义Vue版本号\nVue.version = '2.0.0-rc.4'\n\nexport default Vue\n```\n以下就是config的源码\n```\n//Vue使用了Flow做静态类型检查\n//Flow可以在代码运行前检查出参数、返回值、变量等类型异常\n//方便我们在代码运行前进行部分debug\n/* @flow */\nimport { no, noop } from 'shared/util'\nexport type Config = {\n  optionMergeStrategies: { [key: string]: Function };\n  silent: boolean;\n  devtools: boolean;\n  errorHandler: ?Function;\n  ignoredElements: ?Array<string>;\n  keyCodes: { [key: string]: number };\n  // platform\n  isReservedTag: (x?: string) => boolean;\n  isUnknownElement: (x?: string) => boolean;\n  getTagNamespace: (x?: string) => string | void;\n  mustUseProp: (x?: string) => boolean;\n  // internal\n  _assetTypes: Array<string>;\n  _lifecycleHooks: Array<string>;\n  _maxUpdateCount: number;\n  _isServer: boolean;\n}\nconst config: Config = {\n  optionMergeStrategies: Object.create(null),\n  //是否显示warning,默认显示\n  silent: false,\n  //是否启动devtool\n  devtools: process.env.NODE_ENV !== 'production',\n  errorHandler: null,\n  ignoredElements: null,\n  keyCodes: Object.create(null),\n  isReservedTag: no,\n  isUnknownElement: no,\n  getTagNamespace: noop,\n  mustUseProp: no,\n //组件的默认类型\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n //定义组件的各种生命周期\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n //规定组件在一次刷新中的最大循环更新次数\n  _maxUpdateCount: 100,\n  //判断全局环境是否为server\n  _isServer: process.env.VUE_ENV === 'server'\n}\nexport default config\n\n```\n再来看Vue实例由哪些部分构成，这部分代码在`src/instance`，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：\n```\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\n\nfunction Vue (options) {\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：\n```\n//为了说明，这里是其简化版\nexport function eventsMixin (Vue: Class<Component>) {\n  //实现事件绑定的方法，将其添加到原型上\n  Vue.prototype.$on = function (event: string, fn: Function): Component {\n    const vm: Component = this\n   //支持绑定多个事件\n    ;(vm._events[event] || (vm._events[event] = [])).push(fn)\n    return vm\n  }\n```\n\n###### 总结：\n1. Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。\n2. Vue使用了[Flow](https://flowtype.org/)做静态类型检查，有助于提前发现bug\n3. 实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。\n\n------------------------\n参考链接：\n [Object.defineProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters)\n [Flow | A Static Type Checker For JavaScript](https://flowtype.org/)\n","source":"_posts/Vue2-0源码学习-0.md","raw":"---\ntitle: 'Vue2.0 源码学习#0'\ndate: 2016-09-07 03:37:41\ntags:\n- Vue\n- JavaScript\ncategories:\n- 前端\n---\n> 近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。\n\n<!-- more -->\n作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。\n```\nimport config from './config'\n//加载初始全局API\nimport { initGlobalAPI } from './global-api/index'\n//类的初始化入口\nimport Vue from './instance/index'\n\ninitGlobalAPI(Vue)\n//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染\n//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR\n//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性\n//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因\n//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: () => config._isServer\n})\n//定义Vue版本号\nVue.version = '2.0.0-rc.4'\n\nexport default Vue\n```\n以下就是config的源码\n```\n//Vue使用了Flow做静态类型检查\n//Flow可以在代码运行前检查出参数、返回值、变量等类型异常\n//方便我们在代码运行前进行部分debug\n/* @flow */\nimport { no, noop } from 'shared/util'\nexport type Config = {\n  optionMergeStrategies: { [key: string]: Function };\n  silent: boolean;\n  devtools: boolean;\n  errorHandler: ?Function;\n  ignoredElements: ?Array<string>;\n  keyCodes: { [key: string]: number };\n  // platform\n  isReservedTag: (x?: string) => boolean;\n  isUnknownElement: (x?: string) => boolean;\n  getTagNamespace: (x?: string) => string | void;\n  mustUseProp: (x?: string) => boolean;\n  // internal\n  _assetTypes: Array<string>;\n  _lifecycleHooks: Array<string>;\n  _maxUpdateCount: number;\n  _isServer: boolean;\n}\nconst config: Config = {\n  optionMergeStrategies: Object.create(null),\n  //是否显示warning,默认显示\n  silent: false,\n  //是否启动devtool\n  devtools: process.env.NODE_ENV !== 'production',\n  errorHandler: null,\n  ignoredElements: null,\n  keyCodes: Object.create(null),\n  isReservedTag: no,\n  isUnknownElement: no,\n  getTagNamespace: noop,\n  mustUseProp: no,\n //组件的默认类型\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n //定义组件的各种生命周期\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n //规定组件在一次刷新中的最大循环更新次数\n  _maxUpdateCount: 100,\n  //判断全局环境是否为server\n  _isServer: process.env.VUE_ENV === 'server'\n}\nexport default config\n\n```\n再来看Vue实例由哪些部分构成，这部分代码在`src/instance`，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：\n```\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\n\nfunction Vue (options) {\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：\n```\n//为了说明，这里是其简化版\nexport function eventsMixin (Vue: Class<Component>) {\n  //实现事件绑定的方法，将其添加到原型上\n  Vue.prototype.$on = function (event: string, fn: Function): Component {\n    const vm: Component = this\n   //支持绑定多个事件\n    ;(vm._events[event] || (vm._events[event] = [])).push(fn)\n    return vm\n  }\n```\n\n###### 总结：\n1. Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。\n2. Vue使用了[Flow](https://flowtype.org/)做静态类型检查，有助于提前发现bug\n3. 实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。\n\n------------------------\n参考链接：\n [Object.defineProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters)\n [Flow | A Static Type Checker For JavaScript](https://flowtype.org/)\n","slug":"Vue2-0源码学习-0","published":1,"updated":"2019-12-28T16:22:50.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7n000uhns6zf1fjazq","content":"<blockquote>\n<p>近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import config from &apos;./config&apos;</span><br><span class=\"line\">//加载初始全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">//类的初始化入口</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染</span><br><span class=\"line\">//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR</span><br><span class=\"line\">//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性</span><br><span class=\"line\">//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因</span><br><span class=\"line\">//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: () =&gt; config._isServer</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//定义Vue版本号</span><br><span class=\"line\">Vue.version = &apos;2.0.0-rc.4&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>以下就是config的源码<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Vue使用了Flow做静态类型检查</span><br><span class=\"line\">//Flow可以在代码运行前检查出参数、返回值、变量等类型异常</span><br><span class=\"line\">//方便我们在代码运行前进行部分debug</span><br><span class=\"line\">/* @flow */</span><br><span class=\"line\">import &#123; no, noop &#125; from &apos;shared/util&apos;</span><br><span class=\"line\">export type Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: &#123; [key: string]: Function &#125;;</span><br><span class=\"line\">  silent: boolean;</span><br><span class=\"line\">  devtools: boolean;</span><br><span class=\"line\">  errorHandler: ?Function;</span><br><span class=\"line\">  ignoredElements: ?Array&lt;string&gt;;</span><br><span class=\"line\">  keyCodes: &#123; [key: string]: number &#125;;</span><br><span class=\"line\">  // platform</span><br><span class=\"line\">  isReservedTag: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  isUnknownElement: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  getTagNamespace: (x?: string) =&gt; string | void;</span><br><span class=\"line\">  mustUseProp: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  // internal</span><br><span class=\"line\">  _assetTypes: Array&lt;string&gt;;</span><br><span class=\"line\">  _lifecycleHooks: Array&lt;string&gt;;</span><br><span class=\"line\">  _maxUpdateCount: number;</span><br><span class=\"line\">  _isServer: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const config: Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: Object.create(null),</span><br><span class=\"line\">  //是否显示warning,默认显示</span><br><span class=\"line\">  silent: false,</span><br><span class=\"line\">  //是否启动devtool</span><br><span class=\"line\">  devtools: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class=\"line\">  errorHandler: null,</span><br><span class=\"line\">  ignoredElements: null,</span><br><span class=\"line\">  keyCodes: Object.create(null),</span><br><span class=\"line\">  isReservedTag: no,</span><br><span class=\"line\">  isUnknownElement: no,</span><br><span class=\"line\">  getTagNamespace: noop,</span><br><span class=\"line\">  mustUseProp: no,</span><br><span class=\"line\"> //组件的默认类型</span><br><span class=\"line\">  _assetTypes: [</span><br><span class=\"line\">    &apos;component&apos;,</span><br><span class=\"line\">    &apos;directive&apos;,</span><br><span class=\"line\">    &apos;filter&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //定义组件的各种生命周期</span><br><span class=\"line\">  _lifecycleHooks: [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //规定组件在一次刷新中的最大循环更新次数</span><br><span class=\"line\">  _maxUpdateCount: 100,</span><br><span class=\"line\">  //判断全局环境是否为server</span><br><span class=\"line\">  _isServer: process.env.VUE_ENV === &apos;server&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default config</span><br></pre></td></tr></table></figure></p>\n<p>再来看Vue实例由哪些部分构成，这部分代码在<code>src/instance</code>，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class=\"line\">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class=\"line\">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class=\"line\">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//为了说明，这里是其简化版</span><br><span class=\"line\">export function eventsMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  //实现事件绑定的方法，将其添加到原型上</span><br><span class=\"line\">  Vue.prototype.$on = function (event: string, fn: Function): Component &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">   //支持绑定多个事件</span><br><span class=\"line\">    ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class=\"line\">    return vm</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h6><ol>\n<li>Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。</li>\n<li>Vue使用了<a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>做静态类型检查，有助于提前发现bug</li>\n<li>实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。</li>\n</ol>\n<hr>\n<p>参考链接：<br> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters\" target=\"_blank\" rel=\"noopener\">Object.defineProperty()</a><br> <a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow | A Static Type Checker For JavaScript</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>近来没什么事，准备把Vue的源码通读一遍，2.0中加入了Serve-Side-Render、Virtual-Dom等新特性，看一看实现原理，顺便记录一下学习的过程，毕竟好记性不如烂笔头。</p>\n</blockquote>","more":"<p>作为源码解读系列第一篇文章，先从整个框架的入口开始看吧。Vue使用了部分ES6语法，比如module机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import config from &apos;./config&apos;</span><br><span class=\"line\">//加载初始全局API</span><br><span class=\"line\">import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;</span><br><span class=\"line\">//类的初始化入口</span><br><span class=\"line\">import Vue from &apos;./instance/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">initGlobalAPI(Vue)</span><br><span class=\"line\">//在Vue类的原型上定义$isServer属性，用于判断是否支持服务端渲染</span><br><span class=\"line\">//这样在Vue实例上调用vue.$isServer就可以知道是否开启了SSR</span><br><span class=\"line\">//关于Object.defineProperty，这是一个ES5的方法，可以直接在对象上定义属性</span><br><span class=\"line\">//Vue的数据绑定机制就是用的Object.defineProperty，这也是Vue不支持IE8及以下版本的原因</span><br><span class=\"line\">//将data对象的属性转成getter和setter，具体原理见http://cn.vuejs.org/guide/reactivity.html</span><br><span class=\"line\">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class=\"line\">  get: () =&gt; config._isServer</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//定义Vue版本号</span><br><span class=\"line\">Vue.version = &apos;2.0.0-rc.4&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>以下就是config的源码<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Vue使用了Flow做静态类型检查</span><br><span class=\"line\">//Flow可以在代码运行前检查出参数、返回值、变量等类型异常</span><br><span class=\"line\">//方便我们在代码运行前进行部分debug</span><br><span class=\"line\">/* @flow */</span><br><span class=\"line\">import &#123; no, noop &#125; from &apos;shared/util&apos;</span><br><span class=\"line\">export type Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: &#123; [key: string]: Function &#125;;</span><br><span class=\"line\">  silent: boolean;</span><br><span class=\"line\">  devtools: boolean;</span><br><span class=\"line\">  errorHandler: ?Function;</span><br><span class=\"line\">  ignoredElements: ?Array&lt;string&gt;;</span><br><span class=\"line\">  keyCodes: &#123; [key: string]: number &#125;;</span><br><span class=\"line\">  // platform</span><br><span class=\"line\">  isReservedTag: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  isUnknownElement: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  getTagNamespace: (x?: string) =&gt; string | void;</span><br><span class=\"line\">  mustUseProp: (x?: string) =&gt; boolean;</span><br><span class=\"line\">  // internal</span><br><span class=\"line\">  _assetTypes: Array&lt;string&gt;;</span><br><span class=\"line\">  _lifecycleHooks: Array&lt;string&gt;;</span><br><span class=\"line\">  _maxUpdateCount: number;</span><br><span class=\"line\">  _isServer: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const config: Config = &#123;</span><br><span class=\"line\">  optionMergeStrategies: Object.create(null),</span><br><span class=\"line\">  //是否显示warning,默认显示</span><br><span class=\"line\">  silent: false,</span><br><span class=\"line\">  //是否启动devtool</span><br><span class=\"line\">  devtools: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class=\"line\">  errorHandler: null,</span><br><span class=\"line\">  ignoredElements: null,</span><br><span class=\"line\">  keyCodes: Object.create(null),</span><br><span class=\"line\">  isReservedTag: no,</span><br><span class=\"line\">  isUnknownElement: no,</span><br><span class=\"line\">  getTagNamespace: noop,</span><br><span class=\"line\">  mustUseProp: no,</span><br><span class=\"line\"> //组件的默认类型</span><br><span class=\"line\">  _assetTypes: [</span><br><span class=\"line\">    &apos;component&apos;,</span><br><span class=\"line\">    &apos;directive&apos;,</span><br><span class=\"line\">    &apos;filter&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //定义组件的各种生命周期</span><br><span class=\"line\">  _lifecycleHooks: [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\"> //规定组件在一次刷新中的最大循环更新次数</span><br><span class=\"line\">  _maxUpdateCount: 100,</span><br><span class=\"line\">  //判断全局环境是否为server</span><br><span class=\"line\">  _isServer: process.env.VUE_ENV === &apos;server&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default config</span><br></pre></td></tr></table></figure></p>\n<p>再来看Vue实例由哪些部分构成，这部分代码在<code>src/instance</code>，这个文件夹下有events.js,init.js,lifecycle.js,proxy.js,render.js,state.js`等文件，可以看到，一个Vue instance由这几部分构成。为了将这些模块组织在一起，Vue使用了Mixin模式。以下是index.js的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class=\"line\">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class=\"line\">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class=\"line\">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initMixin(Vue)</span><br><span class=\"line\">stateMixin(Vue)</span><br><span class=\"line\">eventsMixin(Vue)</span><br><span class=\"line\">lifecycleMixin(Vue)</span><br><span class=\"line\">renderMixin(Vue)</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>这里的Mixin利用了每个JavaScript对象都有一个原型，通过原型可以继承更多的属性，实现Vue类上方法的重用。在每个mixin方法中，将Vue类作为参数传递进去，并在其原型上定义各种内置方法。以eventsMixin方法为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//为了说明，这里是其简化版</span><br><span class=\"line\">export function eventsMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  //实现事件绑定的方法，将其添加到原型上</span><br><span class=\"line\">  Vue.prototype.$on = function (event: string, fn: Function): Component &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">   //支持绑定多个事件</span><br><span class=\"line\">    ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class=\"line\">    return vm</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h6><ol>\n<li>Vue中大量使用Object.property，包括利用它生成访问器，实现数据绑定。</li>\n<li>Vue使用了<a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>做静态类型检查，有助于提前发现bug</li>\n<li>实现Vue类的过程中使用了Mixin这种设计模式，基于JavaScript原型继承的特性，可以方便的扩展Vue实例的功能。</li>\n</ol>\n<hr>\n<p>参考链接：<br> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters\" target=\"_blank\" rel=\"noopener\">Object.defineProperty()</a><br> <a href=\"https://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow | A Static Type Checker For JavaScript</a></p>"},{"title":"apply 方法的妙用","date":"2016-03-15T16:37:39.000Z","_content":"我们可以使用数组的 push() 方法来合并数组\n```\nvar a = [1,2,3];\nvar b = [4,5,6];\nArray.prototype.push.apply(a,b);\nconsole.log(a);//输出1,2,3,4,5,6\n```\npush方法本身没有提供push一个数组，但它提供了push(param1,parm2...)，支持传入多个参数。\n而**apply方法可以将一个数组转换为一个参数列表**，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。\n\n此外，找出数组中的最大值、最小值也均可使用此方法。\n如求出数组中的最大值：\n```\nvar a = [3,4,1,5,9];\nvar max = Math.max.apply(null,a);\nconsole.log(max);//输出9\n```","source":"_posts/apply方法的妙用.md","raw":"---\ntitle: apply 方法的妙用\ndate: 2016-03-16 00:37:39\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n我们可以使用数组的 push() 方法来合并数组\n```\nvar a = [1,2,3];\nvar b = [4,5,6];\nArray.prototype.push.apply(a,b);\nconsole.log(a);//输出1,2,3,4,5,6\n```\npush方法本身没有提供push一个数组，但它提供了push(param1,parm2...)，支持传入多个参数。\n而**apply方法可以将一个数组转换为一个参数列表**，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。\n\n此外，找出数组中的最大值、最小值也均可使用此方法。\n如求出数组中的最大值：\n```\nvar a = [3,4,1,5,9];\nvar max = Math.max.apply(null,a);\nconsole.log(max);//输出9\n```","slug":"apply方法的妙用","published":1,"updated":"2019-12-28T16:23:06.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7p000yhns63atoxi3i","content":"<p>我们可以使用数组的 push() 方法来合并数组<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [1,2,3];</span><br><span class=\"line\">var b = [4,5,6];</span><br><span class=\"line\">Array.prototype.push.apply(a,b);</span><br><span class=\"line\">console.log(a);//输出1,2,3,4,5,6</span><br></pre></td></tr></table></figure></p>\n<p>push方法本身没有提供push一个数组，但它提供了push(param1,parm2…)，支持传入多个参数。<br>而<strong>apply方法可以将一个数组转换为一个参数列表</strong>，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。</p>\n<p>此外，找出数组中的最大值、最小值也均可使用此方法。<br>如求出数组中的最大值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [3,4,1,5,9];</span><br><span class=\"line\">var max = Math.max.apply(null,a);</span><br><span class=\"line\">console.log(max);//输出9</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们可以使用数组的 push() 方法来合并数组<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [1,2,3];</span><br><span class=\"line\">var b = [4,5,6];</span><br><span class=\"line\">Array.prototype.push.apply(a,b);</span><br><span class=\"line\">console.log(a);//输出1,2,3,4,5,6</span><br></pre></td></tr></table></figure></p>\n<p>push方法本身没有提供push一个数组，但它提供了push(param1,parm2…)，支持传入多个参数。<br>而<strong>apply方法可以将一个数组转换为一个参数列表</strong>，apply的第一个参数用于改变this对象，将数组a传给它，也就相当于在a上调用了push方法。第二个参数是一个数组，它将作为参数传给push()方法。</p>\n<p>此外，找出数组中的最大值、最小值也均可使用此方法。<br>如求出数组中的最大值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [3,4,1,5,9];</span><br><span class=\"line\">var max = Math.max.apply(null,a);</span><br><span class=\"line\">console.log(max);//输出9</span><br></pre></td></tr></table></figure></p>\n"},{"title":"cookie 详解","date":"2016-03-10T16:55:28.000Z","_content":">**前言：**\n- Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。\n- 检测Cookie是否可用：navigator.cookieEnabled\n\n### Cookie的有效期和作用域\n　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。\n　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。**默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见**。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。\n　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。\n　　同时要注意的是，Cookie的**domain只能设置为当前服务器的域**。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。\n### 创建和存储Cookie\n对Cookie的所有操作都要通过**读写document对象的Cookie属性**来完成。Cookie的值都是以键值对的形式存储。\n```\n//创建一个名字Cookie，同时设置它的过期时间\nfunction setCookie(c_name,value,expiredays){\n     var exdate=new Date();\n     exdate.setDate(exdate.getDate()+expiredays);\n     //encodeURIComponent() 对 URI 进行编码\n     document.cookie=c_name+ \"=\" +encodeURIComponent(value)+\n((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());\n}\n```\n同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　\n　　;path=path\n### 读取Cookie\n使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。\n```\nfunction getCookie(){\n    // 初始化要返回的对象\n    var cookie = {};\n    var all = document.cookie;\n    if(all === null){\n        return cookie;\n    }\n    //分离出Cookie的各个属性\n    var list = all.split(';');\n    for(var i = 0;i < list.length;i++){\n        // 查询出等号所在的位置\n        var p = list[i].indexOf('=');\n        // 分离出名字和值\n        var name = list[i].substring(0,p);\n        var value = list[i].substring(p+1);\n        //对值进行解码\n        value = decodeURIComponent(value);\n        // 将名值对存储到对象中\n        cookie[name] = value;\n    }\n    return cookie;\n}\n```\n### Cookie的局限性\n1. Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。\n2. JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。","source":"_posts/cookie.md","raw":"---\ntitle: cookie 详解\ndate: 2016-03-11 00:55:28\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n>**前言：**\n- Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。\n- 检测Cookie是否可用：navigator.cookieEnabled\n\n### Cookie的有效期和作用域\n　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。\n　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。**默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见**。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。\n　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。\n　　同时要注意的是，Cookie的**domain只能设置为当前服务器的域**。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。\n### 创建和存储Cookie\n对Cookie的所有操作都要通过**读写document对象的Cookie属性**来完成。Cookie的值都是以键值对的形式存储。\n```\n//创建一个名字Cookie，同时设置它的过期时间\nfunction setCookie(c_name,value,expiredays){\n     var exdate=new Date();\n     exdate.setDate(exdate.getDate()+expiredays);\n     //encodeURIComponent() 对 URI 进行编码\n     document.cookie=c_name+ \"=\" +encodeURIComponent(value)+\n((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());\n}\n```\n同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　\n　　;path=path\n### 读取Cookie\n使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。\n```\nfunction getCookie(){\n    // 初始化要返回的对象\n    var cookie = {};\n    var all = document.cookie;\n    if(all === null){\n        return cookie;\n    }\n    //分离出Cookie的各个属性\n    var list = all.split(';');\n    for(var i = 0;i < list.length;i++){\n        // 查询出等号所在的位置\n        var p = list[i].indexOf('=');\n        // 分离出名字和值\n        var name = list[i].substring(0,p);\n        var value = list[i].substring(p+1);\n        //对值进行解码\n        value = decodeURIComponent(value);\n        // 将名值对存储到对象中\n        cookie[name] = value;\n    }\n    return cookie;\n}\n```\n### Cookie的局限性\n1. Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。\n2. JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。","slug":"cookie","published":1,"updated":"2019-12-28T16:22:59.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7r0010hns68pp2nkqo","content":"<blockquote>\n<p><strong>前言：</strong></p>\n<ul>\n<li>Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。</li>\n<li>检测Cookie是否可用：navigator.cookieEnabled</li>\n</ul>\n</blockquote>\n<h3 id=\"Cookie的有效期和作用域\"><a href=\"#Cookie的有效期和作用域\" class=\"headerlink\" title=\"Cookie的有效期和作用域\"></a>Cookie的有效期和作用域</h3><p>　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。<br>　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。<strong>默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见</strong>。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。<br>　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。<br>　　同时要注意的是，Cookie的<strong>domain只能设置为当前服务器的域</strong>。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。</p>\n<h3 id=\"创建和存储Cookie\"><a href=\"#创建和存储Cookie\" class=\"headerlink\" title=\"创建和存储Cookie\"></a>创建和存储Cookie</h3><p>对Cookie的所有操作都要通过<strong>读写document对象的Cookie属性</strong>来完成。Cookie的值都是以键值对的形式存储。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建一个名字Cookie，同时设置它的过期时间</span><br><span class=\"line\">function setCookie(c_name,value,expiredays)&#123;</span><br><span class=\"line\">     var exdate=new Date();</span><br><span class=\"line\">     exdate.setDate(exdate.getDate()+expiredays);</span><br><span class=\"line\">     //encodeURIComponent() 对 URI 进行编码</span><br><span class=\"line\">     document.cookie=c_name+ &quot;=&quot; +encodeURIComponent(value)+</span><br><span class=\"line\">((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　<br>　　;path=path</p>\n<h3 id=\"读取Cookie\"><a href=\"#读取Cookie\" class=\"headerlink\" title=\"读取Cookie\"></a>读取Cookie</h3><p>使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getCookie()&#123;</span><br><span class=\"line\">    // 初始化要返回的对象</span><br><span class=\"line\">    var cookie = &#123;&#125;;</span><br><span class=\"line\">    var all = document.cookie;</span><br><span class=\"line\">    if(all === null)&#123;</span><br><span class=\"line\">        return cookie;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //分离出Cookie的各个属性</span><br><span class=\"line\">    var list = all.split(&apos;;&apos;);</span><br><span class=\"line\">    for(var i = 0;i &lt; list.length;i++)&#123;</span><br><span class=\"line\">        // 查询出等号所在的位置</span><br><span class=\"line\">        var p = list[i].indexOf(&apos;=&apos;);</span><br><span class=\"line\">        // 分离出名字和值</span><br><span class=\"line\">        var name = list[i].substring(0,p);</span><br><span class=\"line\">        var value = list[i].substring(p+1);</span><br><span class=\"line\">        //对值进行解码</span><br><span class=\"line\">        value = decodeURIComponent(value);</span><br><span class=\"line\">        // 将名值对存储到对象中</span><br><span class=\"line\">        cookie[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cookie;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Cookie的局限性\"><a href=\"#Cookie的局限性\" class=\"headerlink\" title=\"Cookie的局限性\"></a>Cookie的局限性</h3><ol>\n<li>Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。</li>\n<li>JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>前言：</strong></p>\n<ul>\n<li>Cookie是指web浏览器存储的少量数据，它与具体的web站点相关。Cookie数据会自动在浏览器和服务器之间传输，因此服务器端也可以读写存储在客户端的Cookie值。在JavaScript中，Cookie用于保存状态，以及为浏览器提供一种身份识别机制。</li>\n<li>检测Cookie是否可用：navigator.cookieEnabled</li>\n</ul>\n</blockquote>\n<h3 id=\"Cookie的有效期和作用域\"><a href=\"#Cookie的有效期和作用域\" class=\"headerlink\" title=\"Cookie的有效期和作用域\"></a>Cookie的有效期和作用域</h3><p>　　Cookie默认的有效期很短暂，只能持续在浏览器的会话期间。如果想要延长Cookie的有效期，可以通过设置max-age属性。<br>　　Cookie的作用域和localStorage类似，也是通过文档源和文档路径来确定。<strong>默认情况下，Cookie对于创建它的页面，以及与该页面同目录或子目录下的其他web页面可见</strong>。可以通过设置Cookie的path属性来修改Cookie的作用域，如果把path设为“/”，就等同于让Cookie拥有了localStorage的作用域，即整个文档源。<br>　　Cookie的作用域默认限制在文档源之内，如果想实现同一服务器之下不同子域的跨域访问Cookie，如a.example.com想访问b.example.com设置的Cookie，这时候就可以通过设置Cookie的domain属性来实现。在a.example.com下的一个页面设置了Cookie，将其path设为“/”，并将domain设为“.example.com”，这样该Cookie就对example.com域下的所有页面可见。<br>　　同时要注意的是，Cookie的<strong>domain只能设置为当前服务器的域</strong>。如想实现Cookie在不同父域下的跨域访问，可参考其他跨域方式，如script标签、隐藏iframe等。</p>\n<h3 id=\"创建和存储Cookie\"><a href=\"#创建和存储Cookie\" class=\"headerlink\" title=\"创建和存储Cookie\"></a>创建和存储Cookie</h3><p>对Cookie的所有操作都要通过<strong>读写document对象的Cookie属性</strong>来完成。Cookie的值都是以键值对的形式存储。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建一个名字Cookie，同时设置它的过期时间</span><br><span class=\"line\">function setCookie(c_name,value,expiredays)&#123;</span><br><span class=\"line\">     var exdate=new Date();</span><br><span class=\"line\">     exdate.setDate(exdate.getDate()+expiredays);</span><br><span class=\"line\">     //encodeURIComponent() 对 URI 进行编码</span><br><span class=\"line\">     document.cookie=c_name+ &quot;=&quot; +encodeURIComponent(value)+</span><br><span class=\"line\">((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样的，如果要设置path、domain等属性，只须以如下形式追加到Cookie值的后面:　<br>　　;path=path</p>\n<h3 id=\"读取Cookie\"><a href=\"#读取Cookie\" class=\"headerlink\" title=\"读取Cookie\"></a>读取Cookie</h3><p>使用document.cookie可以获取到Cookie的值，不过这个值是一个字符串，为了更好地查看Cookie的值，往往会采用split()方法将Cookie中的名值对分离出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getCookie()&#123;</span><br><span class=\"line\">    // 初始化要返回的对象</span><br><span class=\"line\">    var cookie = &#123;&#125;;</span><br><span class=\"line\">    var all = document.cookie;</span><br><span class=\"line\">    if(all === null)&#123;</span><br><span class=\"line\">        return cookie;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //分离出Cookie的各个属性</span><br><span class=\"line\">    var list = all.split(&apos;;&apos;);</span><br><span class=\"line\">    for(var i = 0;i &lt; list.length;i++)&#123;</span><br><span class=\"line\">        // 查询出等号所在的位置</span><br><span class=\"line\">        var p = list[i].indexOf(&apos;=&apos;);</span><br><span class=\"line\">        // 分离出名字和值</span><br><span class=\"line\">        var name = list[i].substring(0,p);</span><br><span class=\"line\">        var value = list[i].substring(p+1);</span><br><span class=\"line\">        //对值进行解码</span><br><span class=\"line\">        value = decodeURIComponent(value);</span><br><span class=\"line\">        // 将名值对存储到对象中</span><br><span class=\"line\">        cookie[name] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cookie;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Cookie的局限性\"><a href=\"#Cookie的局限性\" class=\"headerlink\" title=\"Cookie的局限性\"></a>Cookie的局限性</h3><ol>\n<li>Cookie只能存储少量的数据，每个Cookie的大小不超过4KB。RFC标准不允许浏览器保存超过300个Cookie，为每个web服务器保存的Cookie数不超过20个。</li>\n<li>JavaScript中使用Cookie不会采用任何加密机制，因此它们是不安全的。</li>\n</ol>\n"},{"title":"localStorage 详解","date":"2016-03-07T13:07:48.000Z","_content":"> 前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。\n\n好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。\n\n以一个留言板为例,直接上代码：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>localStorage demo</title>\n</head>\n<body>\n  <div>\n    <h3>简单的web存储留言板</h3>\n    <textarea id=\"textarea\"></textarea>\n    <input type=\"button\" onclick=\"addInfo()\" value=\"留言\" />\n    <input type=\"button\" onclick=\"cleanInfo()\" value=\"清除留言\" />\n  </div>\n  <script type=\"text/javascript\">\n        function upInfo() {\n            if(window.localStorage){\n                var lStorage = window.localStorage;\n                var textarea = window.document.getElementById(\"textarea\");\n                var text = lStorage.getItem(\"text\");\n                if (text) {\n                    textarea.value = text;\n                }else {\n                    textarea.value = \"还没有留言\";\n                }\n            }\n        }\n        function addInfo() {\n            if(window.localStorage){\n                var textarea = window.document.getElementById(\"textarea\");\n                var lStorage = window.localStorage;\n                lStorage.setItem(\"text\",textarea.value);\n                upInfo();\n            }\n        }\n        function cleanInfo() {\n            window.localStorage.removeItem(\"text\");\n            upInfo();\n        }\n        upInfo();\n  </script>\n</body>\n</html>\n```\n这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。\n\n这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。\n\n目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。\n\n实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。\n\n**localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同**。**localStorage存储的数据是永久性的**，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。\n\n而**sessionStorage的有效期仅存在于浏览器的标签页**。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。**sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中**，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。","source":"_posts/localStorage详解.md","raw":"---\ntitle: localStorage 详解\ndate: 2016-03-07 21:07:48\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> 前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。\n\n好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。\n\n以一个留言板为例,直接上代码：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>localStorage demo</title>\n</head>\n<body>\n  <div>\n    <h3>简单的web存储留言板</h3>\n    <textarea id=\"textarea\"></textarea>\n    <input type=\"button\" onclick=\"addInfo()\" value=\"留言\" />\n    <input type=\"button\" onclick=\"cleanInfo()\" value=\"清除留言\" />\n  </div>\n  <script type=\"text/javascript\">\n        function upInfo() {\n            if(window.localStorage){\n                var lStorage = window.localStorage;\n                var textarea = window.document.getElementById(\"textarea\");\n                var text = lStorage.getItem(\"text\");\n                if (text) {\n                    textarea.value = text;\n                }else {\n                    textarea.value = \"还没有留言\";\n                }\n            }\n        }\n        function addInfo() {\n            if(window.localStorage){\n                var textarea = window.document.getElementById(\"textarea\");\n                var lStorage = window.localStorage;\n                lStorage.setItem(\"text\",textarea.value);\n                upInfo();\n            }\n        }\n        function cleanInfo() {\n            window.localStorage.removeItem(\"text\");\n            upInfo();\n        }\n        upInfo();\n  </script>\n</body>\n</html>\n```\n这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。\n\n这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。\n\n目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。\n\n实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。\n\n**localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同**。**localStorage存储的数据是永久性的**，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。\n\n而**sessionStorage的有效期仅存在于浏览器的标签页**。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。**sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中**，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。","slug":"localStorage详解","published":1,"updated":"2019-12-29T09:54:09.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7t0013hns6gyozmakv","content":"<blockquote>\n<p>前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。</p>\n</blockquote>\n<p>好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。</p>\n<p>以一个留言板为例,直接上代码：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>localStorage demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>简单的web存储留言板<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"textarea\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"addInfo()\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"留言\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"cleanInfo()\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"清除留言\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        function upInfo() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            if(window.localStorage)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                var lStorage = window.localStorage;</span></span><br><span class=\"line\"><span class=\"undefined\">                var textarea = window.document.getElementById(\"textarea\");</span></span><br><span class=\"line\"><span class=\"undefined\">                var text = lStorage.getItem(\"text\");</span></span><br><span class=\"line\"><span class=\"undefined\">                if (text) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    textarea.value = text;</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;else &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    textarea.value = \"还没有留言\";</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        function addInfo() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            if(window.localStorage)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                var textarea = window.document.getElementById(\"textarea\");</span></span><br><span class=\"line\"><span class=\"undefined\">                var lStorage = window.localStorage;</span></span><br><span class=\"line\"><span class=\"undefined\">                lStorage.setItem(\"text\",textarea.value);</span></span><br><span class=\"line\"><span class=\"undefined\">                upInfo();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        function cleanInfo() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            window.localStorage.removeItem(\"text\");</span></span><br><span class=\"line\"><span class=\"undefined\">            upInfo();</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        upInfo();</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。</p>\n<p>这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。</p>\n<p>目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。</p>\n<p>实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。</p>\n<p><strong>localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同</strong>。<strong>localStorage存储的数据是永久性的</strong>，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。</p>\n<p>而<strong>sessionStorage的有效期仅存在于浏览器的标签页</strong>。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。<strong>sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中</strong>，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>前言：在HTML5出现之前，为了保存用户在网站中一些操作状态，以便于下次打开页面时恢复到上次访问时的一些状态，在浏览器端常常使用Cookie来存储一些信息。最典型的应用是判断用户是否登录过网站。但是，Cookie的大小受限，每个Cookie的大小不超过4KB，浏览器一般只允许存放300个Cookie，而且Cookie也存在安全性问题。</p>\n</blockquote>\n<p>好在HTML5为我们带来了全新的本地存储方式：localStorage，有5M大小，而且从IE8就开始支持了。也就是说IE6、7是不支持localStorage的，Cookie可以成为IE6、7下的一种替代方案。</p>\n<p>以一个留言板为例,直接上代码：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>localStorage demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>简单的web存储留言板<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"textarea\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"addInfo()\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"留言\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"cleanInfo()\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"清除留言\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        function upInfo() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            if(window.localStorage)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                var lStorage = window.localStorage;</span></span><br><span class=\"line\"><span class=\"undefined\">                var textarea = window.document.getElementById(\"textarea\");</span></span><br><span class=\"line\"><span class=\"undefined\">                var text = lStorage.getItem(\"text\");</span></span><br><span class=\"line\"><span class=\"undefined\">                if (text) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    textarea.value = text;</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;else &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    textarea.value = \"还没有留言\";</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        function addInfo() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            if(window.localStorage)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                var textarea = window.document.getElementById(\"textarea\");</span></span><br><span class=\"line\"><span class=\"undefined\">                var lStorage = window.localStorage;</span></span><br><span class=\"line\"><span class=\"undefined\">                lStorage.setItem(\"text\",textarea.value);</span></span><br><span class=\"line\"><span class=\"undefined\">                upInfo();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        function cleanInfo() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            window.localStorage.removeItem(\"text\");</span></span><br><span class=\"line\"><span class=\"undefined\">            upInfo();</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        upInfo();</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这是用localStorage实现的一个简易留言板，留言板上的信息可以永久保存，即使关闭页面后再次打开。同时也可以清除留言板的内容。</p>\n<p>这里我调用了setItem()方法，将对应的名值对传进去，实现数据的存储。调用getItem()方法，将名字传进去，可以获取到对应的值。调用removeItem()方法，将名字传进去，可以删除对应的数据。除此之外，如果想要删除存储对象的所有键值对的话，可以调用removeItem()方法。</p>\n<p>目前浏览器似乎只支持存储字符串类型的数据，所以我们想要存储其他类型的数据，不得不自己手动进行编码和解码。</p>\n<p>实现了“Web存储”标准的浏览器在window对象上定义了两个属性：localStorage和sessionStorage，这两个属性都代表同一个Storage对象,因此他们具有相同的API。Storage对象的属性值为字符串。</p>\n<p><strong>localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同</strong>。<strong>localStorage存储的数据是永久性的</strong>，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。</p>\n<p>而<strong>sessionStorage的有效期仅存在于浏览器的标签页</strong>。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。<strong>sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中</strong>，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个iframe元素，这两者之间也是可以共享sessionStorage的。</p>\n"},{"title":"null 和 undefined 的区别","date":"2016-03-08T13:52:17.000Z","_content":" 1.null和undefined都被用来表示空值，**当使用不严格等于号（==）做判断时，他们是等价的**。\n```js\nconsole.log(null == undefined); // 输出true\nconsole.log(null === undefined); // 输出false\n```\n这也是为什么我们在代码中判断相等时避免使用==\n\n2.当对null执行typeof运算时，结果返回object，也就是说**null是一个对象**，表示“空对象”\nnull的典型用法包括：\n- 作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据\n- 作为对象原型链的终点。在使用for in遍历原型链的会用到。\n```js\nconsole.log(Object.getPrototypeOf(Object.prototype)); // 输出null\n```\n\n3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。\nundefined的用法包括：\n- 变量被声明了，但没有赋值时，等于undefined\nJavaScript函数作用域中会发生变量申明提前\n```js\nvar func = function(){\n  console.log(a); // 输出undefined\n  var a = \"hello\";\n};\nfunc();\n```\n等价于\n```js\nvar func = function(){\n  var a;\n  console.log(a); // 输出undefined\n  a = \"hello\";\n};\nfunc();\n```\n- 查询数组元素或对象属性时返回undefined，表示该元素或属性不存在\n在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined\n```js\nvar mycars = new Array();\nmycars[0] = \"Saab\"; \nmycars[2] = \"Volvo\"; \nmycars[4] = \"BMW\";\nfor (y = 0; y < mycars.length; y++) { \n  console.log(mycars[y]); // 输出Saab,undefind,Volvo,undefined,BMW\n}\n```\n但是用for in遍历时，并不会输出undefined\n```js\nfor (y in mycars) { \n  console.log(mycars[y]); // 输出Saab,Volvo，BMW\n}\n```\n所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。\n- 函数没有返回值，返回undefined\n- 调用函数时，应该提供的参数没有提供，该参数等于undefined\n","source":"_posts/null和undefined的区别.md","raw":"---\ntitle: null 和 undefined 的区别\ndate: 2016-03-08 21:52:17\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n 1.null和undefined都被用来表示空值，**当使用不严格等于号（==）做判断时，他们是等价的**。\n```js\nconsole.log(null == undefined); // 输出true\nconsole.log(null === undefined); // 输出false\n```\n这也是为什么我们在代码中判断相等时避免使用==\n\n2.当对null执行typeof运算时，结果返回object，也就是说**null是一个对象**，表示“空对象”\nnull的典型用法包括：\n- 作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据\n- 作为对象原型链的终点。在使用for in遍历原型链的会用到。\n```js\nconsole.log(Object.getPrototypeOf(Object.prototype)); // 输出null\n```\n\n3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。\nundefined的用法包括：\n- 变量被声明了，但没有赋值时，等于undefined\nJavaScript函数作用域中会发生变量申明提前\n```js\nvar func = function(){\n  console.log(a); // 输出undefined\n  var a = \"hello\";\n};\nfunc();\n```\n等价于\n```js\nvar func = function(){\n  var a;\n  console.log(a); // 输出undefined\n  a = \"hello\";\n};\nfunc();\n```\n- 查询数组元素或对象属性时返回undefined，表示该元素或属性不存在\n在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined\n```js\nvar mycars = new Array();\nmycars[0] = \"Saab\"; \nmycars[2] = \"Volvo\"; \nmycars[4] = \"BMW\";\nfor (y = 0; y < mycars.length; y++) { \n  console.log(mycars[y]); // 输出Saab,undefind,Volvo,undefined,BMW\n}\n```\n但是用for in遍历时，并不会输出undefined\n```js\nfor (y in mycars) { \n  console.log(mycars[y]); // 输出Saab,Volvo，BMW\n}\n```\n所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。\n- 函数没有返回值，返回undefined\n- 调用函数时，应该提供的参数没有提供，该参数等于undefined\n","slug":"null和undefined的区别","published":1,"updated":"2019-12-29T09:53:46.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7w0017hns6f80zsfvi","content":"<p> 1.null和undefined都被用来表示空值，<strong>当使用不严格等于号（==）做判断时，他们是等价的</strong>。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>); <span class=\"comment\">// 输出true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> === <span class=\"literal\">undefined</span>); <span class=\"comment\">// 输出false</span></span><br></pre></td></tr></table></figure></p>\n<p>这也是为什么我们在代码中判断相等时避免使用==</p>\n<p>2.当对null执行typeof运算时，结果返回object，也就是说<strong>null是一个对象</strong>，表示“空对象”<br>null的典型用法包括：</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据</li>\n<li>作为对象原型链的终点。在使用for in遍历原型链的会用到。<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)); <span class=\"comment\">// 输出null</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。<br>undefined的用法包括：</p>\n<ul>\n<li>变量被声明了，但没有赋值时，等于undefined<br>JavaScript函数作用域中会发生变量申明提前<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等价于<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\">  a = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>查询数组元素或对象属性时返回undefined，表示该元素或属性不存在<br>在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mycars = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">mycars[<span class=\"number\">0</span>] = <span class=\"string\">\"Saab\"</span>; </span><br><span class=\"line\">mycars[<span class=\"number\">2</span>] = <span class=\"string\">\"Volvo\"</span>; </span><br><span class=\"line\">mycars[<span class=\"number\">4</span>] = <span class=\"string\">\"BMW\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (y = <span class=\"number\">0</span>; y &lt; mycars.length; y++) &#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mycars[y]); <span class=\"comment\">// 输出Saab,undefind,Volvo,undefined,BMW</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>但是用for in遍历时，并不会输出undefined<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (y <span class=\"keyword\">in</span> mycars) &#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mycars[y]); <span class=\"comment\">// 输出Saab,Volvo，BMW</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。</p>\n<ul>\n<li>函数没有返回值，返回undefined</li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p> 1.null和undefined都被用来表示空值，<strong>当使用不严格等于号（==）做判断时，他们是等价的</strong>。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>); <span class=\"comment\">// 输出true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">null</span> === <span class=\"literal\">undefined</span>); <span class=\"comment\">// 输出false</span></span><br></pre></td></tr></table></figure></p>\n<p>这也是为什么我们在代码中判断相等时避免使用==</p>\n<p>2.当对null执行typeof运算时，结果返回object，也就是说<strong>null是一个对象</strong>，表示“空对象”<br>null的典型用法包括：</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象。比如在使用Ajax进行get时，我们常用request.send(null)表示不发送数据</li>\n<li>作为对象原型链的终点。在使用for in遍历原型链的会用到。<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype)); <span class=\"comment\">// 输出null</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>3.undefined，顾名思义表示“未定义”，它是变量的一种取值，表示变量没有初始化。<br>undefined的用法包括：</p>\n<ul>\n<li>变量被声明了，但没有赋值时，等于undefined<br>JavaScript函数作用域中会发生变量申明提前<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等价于<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\">  a = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>查询数组元素或对象属性时返回undefined，表示该元素或属性不存在<br>在使用标准for遍历数组时，如果数组中某个元素未定义，就会输出undefined<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mycars = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">mycars[<span class=\"number\">0</span>] = <span class=\"string\">\"Saab\"</span>; </span><br><span class=\"line\">mycars[<span class=\"number\">2</span>] = <span class=\"string\">\"Volvo\"</span>; </span><br><span class=\"line\">mycars[<span class=\"number\">4</span>] = <span class=\"string\">\"BMW\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (y = <span class=\"number\">0</span>; y &lt; mycars.length; y++) &#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mycars[y]); <span class=\"comment\">// 输出Saab,undefind,Volvo,undefined,BMW</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>但是用for in遍历时，并不会输出undefined<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (y <span class=\"keyword\">in</span> mycars) &#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mycars[y]); <span class=\"comment\">// 输出Saab,Volvo，BMW</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以有人推荐不使用for in，其实还有更深层次的原因。因为for in是对整个原型链的遍历，如果我们修改了数组的原型，那么遍历出的结果就不仅仅是数组中的元素了。</p>\n<ul>\n<li>函数没有返回值，返回undefined</li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>\n</ul>\n"},{"title":"traceroute 的原理","date":"2016-05-23T13:49:09.000Z","_content":"\n# 什么是 traceroute?\n traceroute， Linux 系统称为 tracepath，Windows 系统称为 tracert，是一种计算机网络工具。它可显示数据包在 IP 网络经过的路由器的 IP 地址。通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。\n<!-- more -->\ntraceroute 有不同的实现版本：常规的 traceroute(基于 UDP 和 ICMP)和 tcptraceroute(基于 TCP)\n\n# traceroute 原理\n常规的 traceroute 和 tcptraceroute 具有相同的工作原理：\n>1. 发送一个 TTL(Time-To-Live) 相当小的包，TTL 经过每一跳时会递减。当它减为 0 时，数据包就被丢弃。\n2. 当 TTL 失效后，看哪个路由器返回一个带有表明的 ICMP “time exceeded”\n3. 如果返回的路由器就是最终的目的地，停止 trace\n4. 否则，TTL 加 1 并返回到步骤 1\n\n两者的不同点：\n>- 常规的 traceroute 使用 UDP 包或 ICMP “Echo” 包，这两种包都可能会被防火墙拦截。\n- tcptraceroute 使用 TCP “SYN” 包。发送带SYN标志位的数据段是 TCP 建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的 TCP 包。\n- 基于 TCP 的 traceroute 拥有更高的访问权限。以 amazon.com 为例。基于 UDP 的 traceroute 停在 205.251.248.5，这个地址很可能是某种防火墙。基于 TCP 的 traceroute 访问 80 端口，这是 amazon.com 的默认端口，然后进入下一步，最终停在 72.21.194.212\n","source":"_posts/traceroute的原理.md","raw":"---\ntitle: traceroute 的原理\ndate: 2016-05-23 21:49:09\ntags:\n- IP\ncategories:\n- 网络\n---\n\n# 什么是 traceroute?\n traceroute， Linux 系统称为 tracepath，Windows 系统称为 tracert，是一种计算机网络工具。它可显示数据包在 IP 网络经过的路由器的 IP 地址。通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。\n<!-- more -->\ntraceroute 有不同的实现版本：常规的 traceroute(基于 UDP 和 ICMP)和 tcptraceroute(基于 TCP)\n\n# traceroute 原理\n常规的 traceroute 和 tcptraceroute 具有相同的工作原理：\n>1. 发送一个 TTL(Time-To-Live) 相当小的包，TTL 经过每一跳时会递减。当它减为 0 时，数据包就被丢弃。\n2. 当 TTL 失效后，看哪个路由器返回一个带有表明的 ICMP “time exceeded”\n3. 如果返回的路由器就是最终的目的地，停止 trace\n4. 否则，TTL 加 1 并返回到步骤 1\n\n两者的不同点：\n>- 常规的 traceroute 使用 UDP 包或 ICMP “Echo” 包，这两种包都可能会被防火墙拦截。\n- tcptraceroute 使用 TCP “SYN” 包。发送带SYN标志位的数据段是 TCP 建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的 TCP 包。\n- 基于 TCP 的 traceroute 拥有更高的访问权限。以 amazon.com 为例。基于 UDP 的 traceroute 停在 205.251.248.5，这个地址很可能是某种防火墙。基于 TCP 的 traceroute 访问 80 端口，这是 amazon.com 的默认端口，然后进入下一步，最终停在 72.21.194.212\n","slug":"traceroute的原理","published":1,"updated":"2019-12-28T17:37:19.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7y001ahns6kw3rj5qp","content":"<h1 id=\"什么是-traceroute\"><a href=\"#什么是-traceroute\" class=\"headerlink\" title=\"什么是 traceroute?\"></a>什么是 traceroute?</h1><p> traceroute， Linux 系统称为 tracepath，Windows 系统称为 tracert，是一种计算机网络工具。它可显示数据包在 IP 网络经过的路由器的 IP 地址。通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。<br><a id=\"more\"></a><br>traceroute 有不同的实现版本：常规的 traceroute(基于 UDP 和 ICMP)和 tcptraceroute(基于 TCP)</p>\n<h1 id=\"traceroute-原理\"><a href=\"#traceroute-原理\" class=\"headerlink\" title=\"traceroute 原理\"></a>traceroute 原理</h1><p>常规的 traceroute 和 tcptraceroute 具有相同的工作原理：</p>\n<blockquote>\n<ol>\n<li>发送一个 TTL(Time-To-Live) 相当小的包，TTL 经过每一跳时会递减。当它减为 0 时，数据包就被丢弃。</li>\n<li>当 TTL 失效后，看哪个路由器返回一个带有表明的 ICMP “time exceeded”</li>\n<li>如果返回的路由器就是最终的目的地，停止 trace</li>\n<li>否则，TTL 加 1 并返回到步骤 1</li>\n</ol>\n</blockquote>\n<p>两者的不同点：</p>\n<blockquote>\n<ul>\n<li>常规的 traceroute 使用 UDP 包或 ICMP “Echo” 包，这两种包都可能会被防火墙拦截。</li>\n<li>tcptraceroute 使用 TCP “SYN” 包。发送带SYN标志位的数据段是 TCP 建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的 TCP 包。</li>\n<li>基于 TCP 的 traceroute 拥有更高的访问权限。以 amazon.com 为例。基于 UDP 的 traceroute 停在 205.251.248.5，这个地址很可能是某种防火墙。基于 TCP 的 traceroute 访问 80 端口，这是 amazon.com 的默认端口，然后进入下一步，最终停在 72.21.194.212</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是-traceroute\"><a href=\"#什么是-traceroute\" class=\"headerlink\" title=\"什么是 traceroute?\"></a>什么是 traceroute?</h1><p> traceroute， Linux 系统称为 tracepath，Windows 系统称为 tracert，是一种计算机网络工具。它可显示数据包在 IP 网络经过的路由器的 IP 地址。通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。<br>","more":"<br>traceroute 有不同的实现版本：常规的 traceroute(基于 UDP 和 ICMP)和 tcptraceroute(基于 TCP)</p>\n<h1 id=\"traceroute-原理\"><a href=\"#traceroute-原理\" class=\"headerlink\" title=\"traceroute 原理\"></a>traceroute 原理</h1><p>常规的 traceroute 和 tcptraceroute 具有相同的工作原理：</p>\n<blockquote>\n<ol>\n<li>发送一个 TTL(Time-To-Live) 相当小的包，TTL 经过每一跳时会递减。当它减为 0 时，数据包就被丢弃。</li>\n<li>当 TTL 失效后，看哪个路由器返回一个带有表明的 ICMP “time exceeded”</li>\n<li>如果返回的路由器就是最终的目的地，停止 trace</li>\n<li>否则，TTL 加 1 并返回到步骤 1</li>\n</ol>\n</blockquote>\n<p>两者的不同点：</p>\n<blockquote>\n<ul>\n<li>常规的 traceroute 使用 UDP 包或 ICMP “Echo” 包，这两种包都可能会被防火墙拦截。</li>\n<li>tcptraceroute 使用 TCP “SYN” 包。发送带SYN标志位的数据段是 TCP 建立连接时进行“三次握手”的第一次握手，只要目标地址是被允许访问的，通常这种包不会被防火墙拦截。但是防火墙会拦截其他的不是用于建立连接的 TCP 包。</li>\n<li>基于 TCP 的 traceroute 拥有更高的访问权限。以 amazon.com 为例。基于 UDP 的 traceroute 停在 205.251.248.5，这个地址很可能是某种防火墙。基于 TCP 的 traceroute 访问 80 端口，这是 amazon.com 的默认端口，然后进入下一步，最终停在 72.21.194.212</li>\n</ul>\n</blockquote>"},{"title":"【CSS】文本换行的几个属性","date":"2016-03-07T08:58:29.000Z","_content":"**word-wrap:normal | break-word; (内容换行)**         \n* normal:默认的属性值（允许内容顶开指定的容器边界）\n* break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）\n\n**word-break:normal | break-all | keep-all (词内换行)**\n\n* normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。\n* break-all : 强行换行,将截断英文单词。\n* keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。\n\n参数：\nnormal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\nbreak-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。\n\n说明：\n设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。\n\n**text-overflow:clip | ellipsis (文本溢出)**\n\n* clip : 　不显示省略标记（...），而是简单的裁切\n* ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（...）\n\n**white-space: normal | pre | nowrap (内容不换行)**\n* normal 默认。空白会被浏览器忽略。 \n* pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 \n* nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）\n***\n\n例子：\n让文本单行显示，并在溢出时，显示省略标记：\n```css\nwhite-space: nowrap;\ntext-overflow: ellipsis;\noverflow: hidden;\n```\n生成效果如下：\n\n![图0.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-0.png)\n\n\n另一个腾讯NBA官网的例子（看NBA视频无意间发现的...）\n\n![图1.jpg](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-1.jpg)\n在这里，腾讯用了上述的三个属性\n```css\nwhite-space: nowrap;\nword-break: keep-all;\noverflow: hidden;\n```\n　　这里的文本只能单行显示，多余的文本将被截断。其实`word-break:keep-all`这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上`overflow:hidden`后依然会截断超出盒子宽度的文字。\n　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。\n![图2.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-2.png)","source":"_posts/【CSS】文本换行的几个属性.md","raw":"---\ntitle: 【CSS】文本换行的几个属性\ndate: 2016-03-07 16:58:29\ntags:\n- CSS\ncategories:\n- 前端\n---\n**word-wrap:normal | break-word; (内容换行)**         \n* normal:默认的属性值（允许内容顶开指定的容器边界）\n* break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）\n\n**word-break:normal | break-all | keep-all (词内换行)**\n\n* normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。\n* break-all : 强行换行,将截断英文单词。\n* keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。\n\n参数：\nnormal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\nbreak-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。\n\n说明：\n设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。\n\n**text-overflow:clip | ellipsis (文本溢出)**\n\n* clip : 　不显示省略标记（...），而是简单的裁切\n* ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（...）\n\n**white-space: normal | pre | nowrap (内容不换行)**\n* normal 默认。空白会被浏览器忽略。 \n* pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 \n* nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）\n***\n\n例子：\n让文本单行显示，并在溢出时，显示省略标记：\n```css\nwhite-space: nowrap;\ntext-overflow: ellipsis;\noverflow: hidden;\n```\n生成效果如下：\n\n![图0.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-0.png)\n\n\n另一个腾讯NBA官网的例子（看NBA视频无意间发现的...）\n\n![图1.jpg](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-1.jpg)\n在这里，腾讯用了上述的三个属性\n```css\nwhite-space: nowrap;\nword-break: keep-all;\noverflow: hidden;\n```\n　　这里的文本只能单行显示，多余的文本将被截断。其实`word-break:keep-all`这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上`overflow:hidden`后依然会截断超出盒子宽度的文字。\n　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。\n![图2.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-2.png)","slug":"【CSS】文本换行的几个属性","published":1,"updated":"2019-12-29T11:28:13.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn7z001ehns6yjv9h9rk","content":"<p><strong>word-wrap:normal | break-word; (内容换行)</strong>         </p>\n<ul>\n<li>normal:默认的属性值（允许内容顶开指定的容器边界）</li>\n<li>break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）</li>\n</ul>\n<p><strong>word-break:normal | break-all | keep-all (词内换行)</strong></p>\n<ul>\n<li>normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。</li>\n<li>break-all : 强行换行,将截断英文单词。</li>\n<li>keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。</li>\n</ul>\n<p>参数：<br>normal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行<br>break-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本</p>\n<p>keep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</p>\n<p>说明：<br>设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。</p>\n<p><strong>text-overflow:clip | ellipsis (文本溢出)</strong></p>\n<ul>\n<li>clip : 　不显示省略标记（…），而是简单的裁切</li>\n<li>ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（…）</li>\n</ul>\n<p><strong>white-space: normal | pre | nowrap (内容不换行)</strong></p>\n<ul>\n<li>normal 默认。空白会被浏览器忽略。 </li>\n<li>pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 </li>\n<li>nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）</li>\n</ul>\n<hr>\n<p>例子：<br>让文本单行显示，并在溢出时，显示省略标记：<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">white-space</span>: <span class=\"selector-tag\">nowrap</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-overflow</span>: <span class=\"selector-tag\">ellipsis</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br></pre></td></tr></table></figure></p>\n<p>生成效果如下：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-0.png\" alt=\"图0.png\"></p>\n<p>另一个腾讯NBA官网的例子（看NBA视频无意间发现的…）</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-1.jpg\" alt=\"图1.jpg\"><br>在这里，腾讯用了上述的三个属性<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">white-space</span>: <span class=\"selector-tag\">nowrap</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">word-break</span>: <span class=\"selector-tag\">keep-all</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br></pre></td></tr></table></figure></p>\n<p>　　这里的文本只能单行显示，多余的文本将被截断。其实<code>word-break:keep-all</code>这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上<code>overflow:hidden</code>后依然会截断超出盒子宽度的文字。<br>　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-2.png\" alt=\"图2.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>word-wrap:normal | break-word; (内容换行)</strong>         </p>\n<ul>\n<li>normal:默认的属性值（允许内容顶开指定的容器边界）</li>\n<li>break-word:内容将在边界内换行（不截断英文单词换行，截断英文单词下面的属性才具备这个功能）</li>\n</ul>\n<p><strong>word-break:normal | break-all | keep-all (词内换行)</strong></p>\n<ul>\n<li>normal:如果是中文则到边界处的汉字换行,如果是英文整个词换行,注意:如果出现某个英文字符串长度超过边界,则后面的部分将撑开边框,如果边框为固定属性,则后面部分将无法显示。</li>\n<li>break-all : 强行换行,将截断英文单词。</li>\n<li>keep-all : 不允许字断开。如果是中文，将把前后标点符号内的一个汉字短语整个换行，英文单词也整个换行，注意：如果出现某个英文字符串长度超过边界，则后面的部分将撑开边框,如果边框为固定属性，则后面部分将无法显示。</li>\n</ul>\n<p>参数：<br>normal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行<br>break-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本</p>\n<p>keep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</p>\n<p>说明：<br>设置或检索对象内文本的字内换行行为。尤其在出现多种语言时。对于中文，应该使用break-all 。对应的脚本特性为wordBreak。</p>\n<p><strong>text-overflow:clip | ellipsis (文本溢出)</strong></p>\n<ul>\n<li>clip : 　不显示省略标记（…），而是简单的裁切</li>\n<li>ellipsis : 　当对象内文本溢出时（超过width部分）显示省略标记（…）</li>\n</ul>\n<p><strong>white-space: normal | pre | nowrap (内容不换行)</strong></p>\n<ul>\n<li>normal 默认。空白会被浏览器忽略。 </li>\n<li>pre 空白会被浏览器保留。其行为方式类似 HTML 中的pre 标签。 </li>\n<li>nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。（层中放一个表格，如果层的float：none 则表格和层间会有空隙，这种问题的解决办法是在层的style里面加上white-space: nowrap）</li>\n</ul>\n<hr>\n<p>例子：<br>让文本单行显示，并在溢出时，显示省略标记：<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">white-space</span>: <span class=\"selector-tag\">nowrap</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-overflow</span>: <span class=\"selector-tag\">ellipsis</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br></pre></td></tr></table></figure></p>\n<p>生成效果如下：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-0.png\" alt=\"图0.png\"></p>\n<p>另一个腾讯NBA官网的例子（看NBA视频无意间发现的…）</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-1.jpg\" alt=\"图1.jpg\"><br>在这里，腾讯用了上述的三个属性<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">white-space</span>: <span class=\"selector-tag\">nowrap</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">word-break</span>: <span class=\"selector-tag\">keep-all</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br></pre></td></tr></table></figure></p>\n<p>　　这里的文本只能单行显示，多余的文本将被截断。其实<code>word-break:keep-all</code>这行在这里是多余的，它的作用是控制所有字不能断开，但在后面加上<code>overflow:hidden</code>后依然会截断超出盒子宽度的文字。<br>　　我把其中一行文本替换为一段英文，可以发现英文单词依然被直接截断。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-line-break/fe-css-2.png\" alt=\"图2.png\"></p>\n"},{"title":"【JavaScript】splice 方法实现原理分析","date":"2017-01-08T22:58:12.000Z","_content":"> 近日在[LeetCode](https://leetcode.com/problems/ransom-note/)上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。\n\n**函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )**\n\n　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。\n　那么JavaScript究竟是如何做到这一切的呢？通过翻阅[ECMA5.1文档](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1)，我找到了答案。以下是splice()运行时执行的具体步骤：\n0. Let A = new Array()\n1.  将'length'作为参数传递给[[Get]]内建方法，得到数组的长度len\n2.  Let *relativeStart* be [ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*start*).\n3. 如果relativeStart < 0，那么actualStart = max((*len* + *relativeStart*),0)。也就是说，**当第一个参数start为负时，实际上是从右往左开始计算的**。否则，actualStart = min(*relativeStart*, *len*)。\n4. Let *actualDeleteCount* = min(max([ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*deleteCount*),0), *len* – *actualStart*).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，**防止出现数组越界操作**。\n5. Let *k* = 0\n6. Repeat, while(k < actualDeleteCount)\n　a. 获取数组在当前位置的元素值fromValue\n　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法[DefineOwnProperty()](http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9)，这个方法有三个参数：ToString(k)、 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)、false。在 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: **true**, Enumerable: **true**, Configurable: **true**。用过Object.defineProperty()的同学应该对这些不陌生。\n　c. k++\n**这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回**。\n7. 定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。\n8. 令itemCount 为 items的元素个数\n9. If itemCount < actualDeleteCount, then\n　a. Let k = actualStart.\n　b. Repeat, while k < (len - actualDeleteCount)\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*actualDeleteCount*).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*itemCount*).\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k++\n　c. Let k = len\n　d. Repeat, while k > (len - actualDeleteCount + itemCount)\n　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素\n　　ⅱ k--\n　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：\n1) 只删除元素\n2) 只插入元素\n3) 同时删除和插入元素\n\n![只删除元素](https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/1.png)\n　如果itemCount = 0且actualDeleteCount > 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。\n![只插入元素](https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/2.png)\n　如果itemCount > 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。\n![同时删除和插入](https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/3.jpg)\n　如果itemCount > 0 且 actualDeleteCount > 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。\n可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。\n\n11 . Else if *itemCount* > *actualDeleteCount*\n　a. Let *k* = (*len* – *actualDeleteCount*).\n　b. Repeat, while *k* > *actualStart*\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *actualDeleteCount* – 1).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *itemCount* – 1)\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k--\n这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。\n\n12 . Let k = actualStart\n13 . Repeat, while items is not empty\n　a. 删除items的第一个元素E\n　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E\n　c. k++\n这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。\n14 . 再次调用数组的内建方法[[Put]]来更新数组的'length'属性，length = *len* – *actualDeleteCount* + *itemCount*\n15 . 返回数组A\n\n　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。**它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。**splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的**新数组**。\n　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过**DefineOwnProperty()**这一内建方法来为自己添加元素，它的 **Property Descriptor中Writable、Enumerable、Configurable等属性都为true**，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。\n　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。\n\n　\n","source":"_posts/【JavaScript】splice方法实现原理分析.md","raw":"---\ntitle: 【JavaScript】splice 方法实现原理分析\ndate: 2017-01-09 06:58:12\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> 近日在[LeetCode](https://leetcode.com/problems/ransom-note/)上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。\n\n**函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )**\n\n　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。\n　那么JavaScript究竟是如何做到这一切的呢？通过翻阅[ECMA5.1文档](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1)，我找到了答案。以下是splice()运行时执行的具体步骤：\n0. Let A = new Array()\n1.  将'length'作为参数传递给[[Get]]内建方法，得到数组的长度len\n2.  Let *relativeStart* be [ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*start*).\n3. 如果relativeStart < 0，那么actualStart = max((*len* + *relativeStart*),0)。也就是说，**当第一个参数start为负时，实际上是从右往左开始计算的**。否则，actualStart = min(*relativeStart*, *len*)。\n4. Let *actualDeleteCount* = min(max([ToInteger](http://www.ecma-international.org/ecma-262/5.1/#sec-9.4)(*deleteCount*),0), *len* – *actualStart*).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，**防止出现数组越界操作**。\n5. Let *k* = 0\n6. Repeat, while(k < actualDeleteCount)\n　a. 获取数组在当前位置的元素值fromValue\n　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法[DefineOwnProperty()](http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9)，这个方法有三个参数：ToString(k)、 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)、false。在 [Property Descriptor](http://www.ecma-international.org/ecma-262/5.1/#sec-8.10)里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: **true**, Enumerable: **true**, Configurable: **true**。用过Object.defineProperty()的同学应该对这些不陌生。\n　c. k++\n**这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回**。\n7. 定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。\n8. 令itemCount 为 items的元素个数\n9. If itemCount < actualDeleteCount, then\n　a. Let k = actualStart.\n　b. Repeat, while k < (len - actualDeleteCount)\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*actualDeleteCount*).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k*+*itemCount*).\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k++\n　c. Let k = len\n　d. Repeat, while k > (len - actualDeleteCount + itemCount)\n　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素\n　　ⅱ k--\n　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：\n1) 只删除元素\n2) 只插入元素\n3) 同时删除和插入元素\n\n![只删除元素](https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/1.png)\n　如果itemCount = 0且actualDeleteCount > 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。\n![只插入元素](https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/2.png)\n　如果itemCount > 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。\n![同时删除和插入](https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/3.jpg)\n　如果itemCount > 0 且 actualDeleteCount > 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。\n可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。\n\n11 . Else if *itemCount* > *actualDeleteCount*\n　a. Let *k* = (*len* – *actualDeleteCount*).\n　b. Repeat, while *k* > *actualStart*\n　　ⅰ Let *from* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *actualDeleteCount* – 1).\n　　ⅱ Let *to* = [ToString](http://www.ecma-international.org/ecma-262/5.1/#sec-9.8)(*k* + *itemCount* – 1)\n　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　\n　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。\n　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。\n　　ⅵ  k--\n这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。\n\n12 . Let k = actualStart\n13 . Repeat, while items is not empty\n　a. 删除items的第一个元素E\n　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E\n　c. k++\n这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。\n14 . 再次调用数组的内建方法[[Put]]来更新数组的'length'属性，length = *len* – *actualDeleteCount* + *itemCount*\n15 . 返回数组A\n\n　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。**它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。**splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的**新数组**。\n　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过**DefineOwnProperty()**这一内建方法来为自己添加元素，它的 **Property Descriptor中Writable、Enumerable、Configurable等属性都为true**，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。\n　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。\n\n　\n","slug":"【JavaScript】splice方法实现原理分析","published":1,"updated":"2019-12-29T11:28:13.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn80001hhns6cdizu8wd","content":"<blockquote>\n<p>近日在<a href=\"https://leetcode.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。</p>\n</blockquote>\n<p><strong>函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )</strong></p>\n<p>　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。<br>　那么JavaScript究竟是如何做到这一切的呢？通过翻阅<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1\" target=\"_blank\" rel=\"noopener\">ECMA5.1文档</a>，我找到了答案。以下是splice()运行时执行的具体步骤：</p>\n<ol>\n<li>Let A = new Array()</li>\n<li>将’length’作为参数传递给[[Get]]内建方法，得到数组的长度len</li>\n<li>Let <em>relativeStart</em> be <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>start</em>).</li>\n<li>如果relativeStart &lt; 0，那么actualStart = max((<em>len</em> + <em>relativeStart</em>),0)。也就是说，<strong>当第一个参数start为负时，实际上是从右往左开始计算的</strong>。否则，actualStart = min(<em>relativeStart</em>, <em>len</em>)。</li>\n<li>Let <em>actualDeleteCount</em> = min(max(<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>deleteCount</em>),0), <em>len</em> – <em>actualStart</em>).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，<strong>防止出现数组越界操作</strong>。</li>\n<li>Let <em>k</em> = 0</li>\n<li>Repeat, while(k &lt; actualDeleteCount)<br>　a. 获取数组在当前位置的元素值fromValue<br>　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9\" target=\"_blank\" rel=\"noopener\">DefineOwnProperty()</a>，这个方法有三个参数：ToString(k)、 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>、false。在 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: <strong>true</strong>, Enumerable: <strong>true</strong>, Configurable: <strong>true</strong>。用过Object.defineProperty()的同学应该对这些不陌生。<br>　c. k++<br><strong>这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回</strong>。</li>\n<li>定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。</li>\n<li>令itemCount 为 items的元素个数</li>\n<li>If itemCount &lt; actualDeleteCount, then<br>　a. Let k = actualStart.<br>　b. Repeat, while k &lt; (len - actualDeleteCount)<br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>actualDeleteCount</em>).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>itemCount</em>).<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k++<br>　c. Let k = len<br>　d. Repeat, while k &gt; (len - actualDeleteCount + itemCount)<br>　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素<br>　　ⅱ k–<br>　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：<br>1) 只删除元素<br>2) 只插入元素<br>3) 同时删除和插入元素</li>\n</ol>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/1.png\" alt=\"只删除元素\"><br>　如果itemCount = 0且actualDeleteCount &gt; 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/2.png\" alt=\"只插入元素\"><br>　如果itemCount &gt; 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/3.jpg\" alt=\"同时删除和插入\"><br>　如果itemCount &gt; 0 且 actualDeleteCount &gt; 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。<br>可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。</p>\n<p>11 . Else if <em>itemCount</em> &gt; <em>actualDeleteCount</em><br>　a. Let <em>k</em> = (<em>len</em> – <em>actualDeleteCount</em>).<br>　b. Repeat, while <em>k</em> &gt; <em>actualStart</em><br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>actualDeleteCount</em> – 1).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>itemCount</em> – 1)<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k–<br>这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。</p>\n<p>12 . Let k = actualStart<br>13 . Repeat, while items is not empty<br>　a. 删除items的第一个元素E<br>　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E<br>　c. k++<br>这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。<br>14 . 再次调用数组的内建方法[[Put]]来更新数组的’length’属性，length = <em>len</em> – <em>actualDeleteCount</em> + <em>itemCount</em><br>15 . 返回数组A</p>\n<p>　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。<strong>它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。</strong>splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的<strong>新数组</strong>。<br>　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过<strong>DefineOwnProperty()</strong>这一内建方法来为自己添加元素，它的 <strong>Property Descriptor中Writable、Enumerable、Configurable等属性都为true</strong>，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。<br>　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。</p>\n<p>　</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>近日在<a href=\"https://leetcode.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上刷题，一个题目提交代码后提示Time Limit Exceeded，分析了下发现是splice()方法拖慢了执行速度。之前经常使用这个方法去操作数组，但从未思考过它的底层实现，于是借此机会揭开splice()的庐山真面目。</p>\n</blockquote>\n<p><strong>函数原型：Array.prototype.splice (start, deleteCount, item1, item2, …  )</strong></p>\n<p>　splice至少有2个参数，第一个参数start是开始插入或删除处的元素索引，deleteCount是要删除的元素个数，从start开始，包含start处的元素。如果deleteCount为0，那表示就是插入元素，将后面参数值插入到start位置后。比如：[1,2,3].splice(1,2)会删除原数组的arr[1],arr[2]处的元素，并将其返回。<br>　那么JavaScript究竟是如何做到这一切的呢？通过翻阅<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.1\" target=\"_blank\" rel=\"noopener\">ECMA5.1文档</a>，我找到了答案。以下是splice()运行时执行的具体步骤：</p>\n<ol>\n<li>Let A = new Array()</li>\n<li>将’length’作为参数传递给[[Get]]内建方法，得到数组的长度len</li>\n<li>Let <em>relativeStart</em> be <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>start</em>).</li>\n<li>如果relativeStart &lt; 0，那么actualStart = max((<em>len</em> + <em>relativeStart</em>),0)。也就是说，<strong>当第一个参数start为负时，实际上是从右往左开始计算的</strong>。否则，actualStart = min(<em>relativeStart</em>, <em>len</em>)。</li>\n<li>Let <em>actualDeleteCount</em> = min(max(<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\" target=\"_blank\" rel=\"noopener\">ToInteger</a>(<em>deleteCount</em>),0), <em>len</em> – <em>actualStart</em>).这一步的作用和上一步是一样的，都是为了确保我们要操作的元素在一个合理的范围内，<strong>防止出现数组越界操作</strong>。</li>\n<li>Let <em>k</em> = 0</li>\n<li>Repeat, while(k &lt; actualDeleteCount)<br>　a. 获取数组在当前位置的元素值fromValue<br>　b.将fromValue添加到数组A中。具体实现上，是通过调用A的内建方法<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.9\" target=\"_blank\" rel=\"noopener\">DefineOwnProperty()</a>，这个方法有三个参数：ToString(k)、 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>、false。在 <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.10\" target=\"_blank\" rel=\"noopener\">Property Descriptor</a>里，将fromValue设置为该属性的值，同时设置property的配置属性 Writable: <strong>true</strong>, Enumerable: <strong>true</strong>, Configurable: <strong>true</strong>。用过Object.defineProperty()的同学应该对这些不陌生。<br>　c. k++<br><strong>这一步是为了将所有删除的元素添加到一个新的数组中，以便最后将其返回</strong>。</li>\n<li>定义items为一个内部List，将item1及以后的所有参数（也就是我们要插入到数组中的元素）添加到items中。</li>\n<li>令itemCount 为 items的元素个数</li>\n<li>If itemCount &lt; actualDeleteCount, then<br>　a. Let k = actualStart.<br>　b. Repeat, while k &lt; (len - actualDeleteCount)<br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>actualDeleteCount</em>).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em>+<em>itemCount</em>).<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。这样就实现了数组元素的移动。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k++<br>　c. Let k = len<br>　d. Repeat, while k &gt; (len - actualDeleteCount + itemCount)<br>　　ⅰ 调用数组内建方法[[Delete]]来删除k-1位置上的元素<br>　　ⅱ k–<br>　这里可能有点不太好理解，我们可以画图分析一下。splice()的运行可能出现三种情况：<br>1) 只删除元素<br>2) 只插入元素<br>3) 同时删除和插入元素</li>\n</ol>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/1.png\" alt=\"只删除元素\"><br>　如果itemCount = 0且actualDeleteCount &gt; 0，即不插入元素，只删除元素，那么from及其后面的所有元素会被移动的k位置后面，因为此时to = k。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/2.png\" alt=\"只插入元素\"><br>　如果itemCount &gt; 0 且 actualDeleteCount = 0，即只插入元素的情况。此时from = k，即把k后面的所有元素移动到to后面，to = k + itemCount。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/splice/3.jpg\" alt=\"同时删除和插入\"><br>　如果itemCount &gt; 0 且 actualDeleteCount &gt; 0，既删除元素，也在插入元素。将from后面的元素移动到to后面。<br>可以看到，这一步就是在插入元素数少于删除元素数时，进行元素的移动。</p>\n<p>11 . Else if <em>itemCount</em> &gt; <em>actualDeleteCount</em><br>　a. Let <em>k</em> = (<em>len</em> – <em>actualDeleteCount</em>).<br>　b. Repeat, while <em>k</em> &gt; <em>actualStart</em><br>　　ⅰ Let <em>from</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>actualDeleteCount</em> – 1).<br>　　ⅱ Let <em>to</em> = <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.8\" target=\"_blank\" rel=\"noopener\">ToString</a>(<em>k</em> + <em>itemCount</em> – 1)<br>　　ⅲ 将from作为参数传递给内建方法HasProperty，fromPresent为其返回的结果　<br>　　ⅳ 如果 fromPresent 为 true，获取数组在当前位置的元素值fromValue。然后调用数组内建方法[[Put]]，将to、fromValue、true作为参数传入。<br>　　ⅴ 如果 fromPresent 为 false，调用数组的内建方法[[Delete]]，将to处的元素删除。<br>　　ⅵ  k–<br>这一步处理的是插入元素多于删除元素时，进行元素的位置移动。思路和上一步差不多。</p>\n<p>12 . Let k = actualStart<br>13 . Repeat, while items is not empty<br>　a. 删除items的第一个元素E<br>　b. 调用数组的内建方法[[Put]]，将k位置的元素更新为E<br>　c. k++<br>这一步实现了元素的插入。items实际上是一个队列，按照FIFO的顺序依次插入到actualStart后面。<br>14 . 再次调用数组的内建方法[[Put]]来更新数组的’length’属性，length = <em>len</em> – <em>actualDeleteCount</em> + <em>itemCount</em><br>15 . 返回数组A</p>\n<p>　以上就是splice()方法的工作原理。看到这里，你应该明白splice()效率不高的原因了吧。<strong>它的每次删除操作都涉及到大量元素的重新排列，而在插入元素时，引入了一个队列来管理。</strong>splice()只要涉及到删除操作，它的返回值都是一个包含所有删除元素的<strong>新数组</strong>。<br>　在分析过程中，我对JavaScript中Array是对象这一概念也有了更深的了解。数组通过<strong>DefineOwnProperty()</strong>这一内建方法来为自己添加元素，它的 <strong>Property Descriptor中Writable、Enumerable、Configurable等属性都为true</strong>，其实就和普通的对象属性是一样的，因此数组元素的值都可以被动态地修改。<br>　另外，splice()的所有操作都是在原数组上进行的。JavaScript还提供了一个数组方法slice()，它不会修改原数组，函数式编程爱好者比较喜欢它。</p>\n<p>　</p>\n"},{"title":"【JavaScript】变量作用域","date":"2016-03-07T08:51:45.000Z","_content":"背景知识：\n*  编程语言中，作用域控制变量与参数的可见性和生命周期\n* 函数体内，局部变量的优先级高于同名的全局变量\n* 块级作用域：花括号内的每一段代码都具有各自的作用域\n\n1.**JavaScript不支持块级作用域**\nJavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的\n```js\nfunction hello() {\n  for (var i = 0; i < 10; i++) {\n    // doSomething...\n  }\n  //输出10，在支持块级作用域的语言中这里会报错\n  console.log(i);\n}\n```\n\n2.声明提前：**JavaScript函数里申明的所有变量都被提前至函数体顶部**\n```js\nvar scope = 'global';\nfunction test() {\n  // 输出undefined，这里scope只是申明，还没有被赋初值\n  console.log(scope);\n  //scope在这里被赋初值，但scoop的申明发生在函数体顶部\n  var scope = 'local';\n  // 输出local\n  console.log(scope);\n}\n```\n\n该函数等价于：\n```js\nvar scope = 'global';\nfunction test() {\n  var scope;\n  console.log(scope);\n  scope = 'local';\n  console.log(scope);\n}\n```","source":"_posts/【JavaScript】变量作用域.md","raw":"---\ntitle: 【JavaScript】变量作用域\ndate: 2016-03-07 16:51:45\ntags: \n- JavaScript\ncategories:\n- 前端\n---\n背景知识：\n*  编程语言中，作用域控制变量与参数的可见性和生命周期\n* 函数体内，局部变量的优先级高于同名的全局变量\n* 块级作用域：花括号内的每一段代码都具有各自的作用域\n\n1.**JavaScript不支持块级作用域**\nJavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的\n```js\nfunction hello() {\n  for (var i = 0; i < 10; i++) {\n    // doSomething...\n  }\n  //输出10，在支持块级作用域的语言中这里会报错\n  console.log(i);\n}\n```\n\n2.声明提前：**JavaScript函数里申明的所有变量都被提前至函数体顶部**\n```js\nvar scope = 'global';\nfunction test() {\n  // 输出undefined，这里scope只是申明，还没有被赋初值\n  console.log(scope);\n  //scope在这里被赋初值，但scoop的申明发生在函数体顶部\n  var scope = 'local';\n  // 输出local\n  console.log(scope);\n}\n```\n\n该函数等价于：\n```js\nvar scope = 'global';\nfunction test() {\n  var scope;\n  console.log(scope);\n  scope = 'local';\n  console.log(scope);\n}\n```","slug":"【JavaScript】变量作用域","published":1,"updated":"2019-12-29T10:03:16.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn82001lhns6kvn4en28","content":"<p>背景知识：</p>\n<ul>\n<li>编程语言中，作用域控制变量与参数的可见性和生命周期</li>\n<li>函数体内，局部变量的优先级高于同名的全局变量</li>\n<li>块级作用域：花括号内的每一段代码都具有各自的作用域</li>\n</ul>\n<p>1.<strong>JavaScript不支持块级作用域</strong><br>JavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// doSomething...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//输出10，在支持块级作用域的语言中这里会报错</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.声明提前：<strong>JavaScript函数里申明的所有变量都被提前至函数体顶部</strong><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 输出undefined，这里scope只是申明，还没有被赋初值</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">  <span class=\"comment\">//scope在这里被赋初值，但scoop的申明发生在函数体顶部</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 输出local</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该函数等价于：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">  scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景知识：</p>\n<ul>\n<li>编程语言中，作用域控制变量与参数的可见性和生命周期</li>\n<li>函数体内，局部变量的优先级高于同名的全局变量</li>\n<li>块级作用域：花括号内的每一段代码都具有各自的作用域</li>\n</ul>\n<p>1.<strong>JavaScript不支持块级作用域</strong><br>JavaScript的<b>函数作用域</b>：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// doSomething...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//输出10，在支持块级作用域的语言中这里会报错</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.声明提前：<strong>JavaScript函数里申明的所有变量都被提前至函数体顶部</strong><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 输出undefined，这里scope只是申明，还没有被赋初值</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">  <span class=\"comment\">//scope在这里被赋初值，但scoop的申明发生在函数体顶部</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 输出local</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该函数等价于：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scope;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">  scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(scope);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"【JavaScript 实现数据结构】栈","date":"2016-03-21T09:39:09.000Z","_content":"堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。\n代码如下：\n```\n//数组实现\nfunction Stack(){\n   this.items = [];\n   this.size = 0;\n}\nStack.prototype = {\n   constructor:Stack,\n   push:function(data){\n       this.items[this.size++] = data;\n   },\n   pop:function(){\n       return this.items[--this.size];\n   },\n   clear:function(){\n       this.size = 0;\n       this.items = [];\n   },\n   perk:function(){\n       return this.items[this.size-1];\n   }\n}\n```\n\n```\n//链表实现\n    function Stack(){\n        this.top = null;\n        this.size = 0;\n    }\n    Stack.prototype = {\n        constructor:Stack,\n        push:function(data){\n            var node = {\n                data:data,\n                next:null\n            };\n            node.next = this.top;\n            this.top = node;\n            this.size++;\n        },\n        pop:function(){\n            if(this.top === null){\n                return null;\n            }\n            var out = this.top;\n            this.top = this.top.next;\n            if(this.size > 0){\n                this.size--;    \n            }\n            return out.data;\n        },\n        perk:function(){\n            return this.top === null ? null:this.top.data; \n        },\n        clear:function(){\n            this.top = null;\n            this.size = 0;\n        }\n```\n测试：\n```\nvar stack = new Stack();\nstack.push('k');\nstack.push('b');\nconsole.log(stack.perk());//输出b\nstack.pop();\nconsole.log(stack.perk());//输出k\n```\n-----------\n### 栈的应用\n例子：数值进制转换\n算法思想如下：\n(1)  最高位为 n % b,将此位压入栈。\n(2)  使用 n/b 代替 n。\n(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。\n(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。\n\n具体代码实现：\n```    \nfunction mulBase(num,base){\n    var stack = new Stack();\n    do{\n        stack.push(num % base); \n        num = Math.floor(num / base);\n    }while(num>0);\n    var result = '';\n    while(stack.size > 0){\n        result += stack.pop();\n    }\n    return result;\n}\nconsole.log(mulBase(234,2)); //输出11101010\n```\n------------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","source":"_posts/【JavaScript实现数据结构】栈.md","raw":"---\ntitle: 【JavaScript 实现数据结构】栈\ndate: 2016-03-21 17:39:09\ntags:\n- JavaScript\n- 数据结构\n- 算法\ncategories:\n- 数据结构与算法\n---\n堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。\n代码如下：\n```\n//数组实现\nfunction Stack(){\n   this.items = [];\n   this.size = 0;\n}\nStack.prototype = {\n   constructor:Stack,\n   push:function(data){\n       this.items[this.size++] = data;\n   },\n   pop:function(){\n       return this.items[--this.size];\n   },\n   clear:function(){\n       this.size = 0;\n       this.items = [];\n   },\n   perk:function(){\n       return this.items[this.size-1];\n   }\n}\n```\n\n```\n//链表实现\n    function Stack(){\n        this.top = null;\n        this.size = 0;\n    }\n    Stack.prototype = {\n        constructor:Stack,\n        push:function(data){\n            var node = {\n                data:data,\n                next:null\n            };\n            node.next = this.top;\n            this.top = node;\n            this.size++;\n        },\n        pop:function(){\n            if(this.top === null){\n                return null;\n            }\n            var out = this.top;\n            this.top = this.top.next;\n            if(this.size > 0){\n                this.size--;    \n            }\n            return out.data;\n        },\n        perk:function(){\n            return this.top === null ? null:this.top.data; \n        },\n        clear:function(){\n            this.top = null;\n            this.size = 0;\n        }\n```\n测试：\n```\nvar stack = new Stack();\nstack.push('k');\nstack.push('b');\nconsole.log(stack.perk());//输出b\nstack.pop();\nconsole.log(stack.perk());//输出k\n```\n-----------\n### 栈的应用\n例子：数值进制转换\n算法思想如下：\n(1)  最高位为 n % b,将此位压入栈。\n(2)  使用 n/b 代替 n。\n(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。\n(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。\n\n具体代码实现：\n```    \nfunction mulBase(num,base){\n    var stack = new Stack();\n    do{\n        stack.push(num % base); \n        num = Math.floor(num / base);\n    }while(num>0);\n    var result = '';\n    while(stack.size > 0){\n        result += stack.pop();\n    }\n    return result;\n}\nconsole.log(mulBase(234,2)); //输出11101010\n```\n------------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","slug":"【JavaScript实现数据结构】栈","published":1,"updated":"2019-12-28T16:36:03.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn84001ohns68sgii6ww","content":"<p>堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//数组实现</span><br><span class=\"line\">function Stack()&#123;</span><br><span class=\"line\">   this.items = [];</span><br><span class=\"line\">   this.size = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Stack.prototype = &#123;</span><br><span class=\"line\">   constructor:Stack,</span><br><span class=\"line\">   push:function(data)&#123;</span><br><span class=\"line\">       this.items[this.size++] = data;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   pop:function()&#123;</span><br><span class=\"line\">       return this.items[--this.size];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   clear:function()&#123;</span><br><span class=\"line\">       this.size = 0;</span><br><span class=\"line\">       this.items = [];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   perk:function()&#123;</span><br><span class=\"line\">       return this.items[this.size-1];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//链表实现</span><br><span class=\"line\">    function Stack()&#123;</span><br><span class=\"line\">        this.top = null;</span><br><span class=\"line\">        this.size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack.prototype = &#123;</span><br><span class=\"line\">        constructor:Stack,</span><br><span class=\"line\">        push:function(data)&#123;</span><br><span class=\"line\">            var node = &#123;</span><br><span class=\"line\">                data:data,</span><br><span class=\"line\">                next:null</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            node.next = this.top;</span><br><span class=\"line\">            this.top = node;</span><br><span class=\"line\">            this.size++;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        pop:function()&#123;</span><br><span class=\"line\">            if(this.top === null)&#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var out = this.top;</span><br><span class=\"line\">            this.top = this.top.next;</span><br><span class=\"line\">            if(this.size &gt; 0)&#123;</span><br><span class=\"line\">                this.size--;    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return out.data;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        perk:function()&#123;</span><br><span class=\"line\">            return this.top === null ? null:this.top.data; </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        clear:function()&#123;</span><br><span class=\"line\">            this.top = null;</span><br><span class=\"line\">            this.size = 0;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var stack = new Stack();</span><br><span class=\"line\">stack.push(&apos;k&apos;);</span><br><span class=\"line\">stack.push(&apos;b&apos;);</span><br><span class=\"line\">console.log(stack.perk());//输出b</span><br><span class=\"line\">stack.pop();</span><br><span class=\"line\">console.log(stack.perk());//输出k</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><p>例子：数值进制转换<br>算法思想如下：<br>(1)  最高位为 n % b,将此位压入栈。<br>(2)  使用 n/b 代替 n。<br>(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。<br>(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。</p>\n<p>具体代码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mulBase(num,base)&#123;</span><br><span class=\"line\">    var stack = new Stack();</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        stack.push(num % base); </span><br><span class=\"line\">        num = Math.floor(num / base);</span><br><span class=\"line\">    &#125;while(num&gt;0);</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    while(stack.size &gt; 0)&#123;</span><br><span class=\"line\">        result += stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(mulBase(234,2)); //输出11101010</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>堆栈可以用链表和数组两种方式实现，这里分别给出这两种实现方式。<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//数组实现</span><br><span class=\"line\">function Stack()&#123;</span><br><span class=\"line\">   this.items = [];</span><br><span class=\"line\">   this.size = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Stack.prototype = &#123;</span><br><span class=\"line\">   constructor:Stack,</span><br><span class=\"line\">   push:function(data)&#123;</span><br><span class=\"line\">       this.items[this.size++] = data;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   pop:function()&#123;</span><br><span class=\"line\">       return this.items[--this.size];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   clear:function()&#123;</span><br><span class=\"line\">       this.size = 0;</span><br><span class=\"line\">       this.items = [];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   perk:function()&#123;</span><br><span class=\"line\">       return this.items[this.size-1];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//链表实现</span><br><span class=\"line\">    function Stack()&#123;</span><br><span class=\"line\">        this.top = null;</span><br><span class=\"line\">        this.size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack.prototype = &#123;</span><br><span class=\"line\">        constructor:Stack,</span><br><span class=\"line\">        push:function(data)&#123;</span><br><span class=\"line\">            var node = &#123;</span><br><span class=\"line\">                data:data,</span><br><span class=\"line\">                next:null</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            node.next = this.top;</span><br><span class=\"line\">            this.top = node;</span><br><span class=\"line\">            this.size++;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        pop:function()&#123;</span><br><span class=\"line\">            if(this.top === null)&#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var out = this.top;</span><br><span class=\"line\">            this.top = this.top.next;</span><br><span class=\"line\">            if(this.size &gt; 0)&#123;</span><br><span class=\"line\">                this.size--;    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return out.data;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        perk:function()&#123;</span><br><span class=\"line\">            return this.top === null ? null:this.top.data; </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        clear:function()&#123;</span><br><span class=\"line\">            this.top = null;</span><br><span class=\"line\">            this.size = 0;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var stack = new Stack();</span><br><span class=\"line\">stack.push(&apos;k&apos;);</span><br><span class=\"line\">stack.push(&apos;b&apos;);</span><br><span class=\"line\">console.log(stack.perk());//输出b</span><br><span class=\"line\">stack.pop();</span><br><span class=\"line\">console.log(stack.perk());//输出k</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><p>例子：数值进制转换<br>算法思想如下：<br>(1)  最高位为 n % b,将此位压入栈。<br>(2)  使用 n/b 代替 n。<br>(3)  重复步骤 1 和 2,直到 n 等于 0,且没有余数。<br>(4)  持续将栈内元素弹出,直到栈为空,依次将这些元素排列,就得到转换后数字的字符串形式。</p>\n<p>具体代码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mulBase(num,base)&#123;</span><br><span class=\"line\">    var stack = new Stack();</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        stack.push(num % base); </span><br><span class=\"line\">        num = Math.floor(num / base);</span><br><span class=\"line\">    &#125;while(num&gt;0);</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    while(stack.size &gt; 0)&#123;</span><br><span class=\"line\">        result += stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(mulBase(234,2)); //输出11101010</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n"},{"title":"【JavaScript】闭包的概念","date":"2016-03-07T08:56:03.000Z","_content":"背景：\n* 理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》\n* JavaScript中的函数都是对象\n\n简而言之，JavaScript函数内部的所有变量对外部是不可见的\n比如这样的代码会抛出error\n```js\nvar test = function(){\n  var i = 0;\n}\nconsole.log(i); // undefined error\n```\n那么怎么让函数访问外部变量呢？\nJavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。\n\n闭包的好处是**内部函数可以访问定义它们的外部函数的参数和变量**\n****\n闭包示例\n```js\nvar test = function(status) {\n  return {\n    getStatus: function() {\n      return status;\n    }\n  };\n};\n// 测试\n// 调用test时，它返回一个包含getStatus方法的新对象\nvar myQuo = test('404');\nconsole.log(myQuo.getStatus());\n```\n\n另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号\n```js\n// 这是一个错误的例子，点击任意节点输出结果都为9\n// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值\nvar addHandlers = function(nodes){\n  var i;\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].onclick = function(e) {\n      console.log(i);\n    };\n  }\n};\n```\n\n正确的例子·\n```js\nvar addHandlers = function(nodes) {\n  var helper = function(i) {\n    return function() {\n      console.log(i);\n    };\n  };\n  var i; // 避免在循环中创建函数\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].onclick = helper(i);\n  }\n};\n```\n","source":"_posts/【JavaScript】闭包的概念.md","raw":"---\ntitle: 【JavaScript】闭包的概念\ndate: 2016-03-07 16:56:03\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n背景：\n* 理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》\n* JavaScript中的函数都是对象\n\n简而言之，JavaScript函数内部的所有变量对外部是不可见的\n比如这样的代码会抛出error\n```js\nvar test = function(){\n  var i = 0;\n}\nconsole.log(i); // undefined error\n```\n那么怎么让函数访问外部变量呢？\nJavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。\n\n闭包的好处是**内部函数可以访问定义它们的外部函数的参数和变量**\n****\n闭包示例\n```js\nvar test = function(status) {\n  return {\n    getStatus: function() {\n      return status;\n    }\n  };\n};\n// 测试\n// 调用test时，它返回一个包含getStatus方法的新对象\nvar myQuo = test('404');\nconsole.log(myQuo.getStatus());\n```\n\n另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号\n```js\n// 这是一个错误的例子，点击任意节点输出结果都为9\n// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值\nvar addHandlers = function(nodes){\n  var i;\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].onclick = function(e) {\n      console.log(i);\n    };\n  }\n};\n```\n\n正确的例子·\n```js\nvar addHandlers = function(nodes) {\n  var helper = function(i) {\n    return function() {\n      console.log(i);\n    };\n  };\n  var i; // 避免在循环中创建函数\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].onclick = helper(i);\n  }\n};\n```\n","slug":"【JavaScript】闭包的概念","published":1,"updated":"2019-12-29T09:59:32.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn87001shns65365e1wq","content":"<p>背景：</p>\n<ul>\n<li>理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》</li>\n<li>JavaScript中的函数都是对象</li>\n</ul>\n<p>简而言之，JavaScript函数内部的所有变量对外部是不可见的<br>比如这样的代码会抛出error<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// undefined error</span></span><br></pre></td></tr></table></figure></p>\n<p>那么怎么让函数访问外部变量呢？<br>JavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。</p>\n<p>闭包的好处是<strong>内部函数可以访问定义它们的外部函数的参数和变量</strong></p>\n<hr>\n<p>闭包示例<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getStatus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"comment\">// 调用test时，它返回一个包含getStatus方法的新对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myQuo = test(<span class=\"string\">'404'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myQuo.getStatus());</span><br></pre></td></tr></table></figure></p>\n<p>另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个错误的例子，点击任意节点输出结果都为9</span></span><br><span class=\"line\"><span class=\"comment\">// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addHandlers = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nodes</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class=\"line\">    nodes[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>正确的例子·<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addHandlers = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nodes</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> helper = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i; <span class=\"comment\">// 避免在循环中创建函数</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class=\"line\">    nodes[i].onclick = helper(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景：</p>\n<ul>\n<li>理解闭包，必须首先要理解变量作用域，关于JavaScript的变量作用域，参见我之前的一篇文章《【JavaScript】变量作用域》</li>\n<li>JavaScript中的函数都是对象</li>\n</ul>\n<p>简而言之，JavaScript函数内部的所有变量对外部是不可见的<br>比如这样的代码会抛出error<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// undefined error</span></span><br></pre></td></tr></table></figure></p>\n<p>那么怎么让函数访问外部变量呢？<br>JavaScript拥有函数级的作用域，函数内部调用的函数可以访问其外部函数的变量。所以我们可以在一个函数内部再调用一个函数，这样其内部函数就实现了访问外部变量。这就是所谓的闭包。</p>\n<p>闭包的好处是<strong>内部函数可以访问定义它们的外部函数的参数和变量</strong></p>\n<hr>\n<p>闭包示例<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getStatus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"comment\">// 调用test时，它返回一个包含getStatus方法的新对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myQuo = test(<span class=\"string\">'404'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myQuo.getStatus());</span><br></pre></td></tr></table></figure></p>\n<p>另一个例子：构造一个函数，当点击一个节点时，输出当前节点的编号<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个错误的例子，点击任意节点输出结果都为9</span></span><br><span class=\"line\"><span class=\"comment\">// 这个函数绑定了变量i本身，而不是函数在构造时变量i的值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addHandlers = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nodes</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class=\"line\">    nodes[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>正确的例子·<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addHandlers = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nodes</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> helper = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i; <span class=\"comment\">// 避免在循环中创建函数</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class=\"line\">    nodes[i].onclick = helper(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"【JavaScript 实现数据结构】队列","date":"2016-03-21T09:42:51.000Z","_content":"队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。\n\nJavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：\n```\nfunction Queue(){\n    this.items = [];\n}\nQueue.prototype = {\n    enqueue:function(data){\n        this.items.push(data);\n    },\n    dequeue:function(){\n        return this.items.shift();\n    },\n    front:function(){\n        return this.items[0];\n    },\n    rear:function(){\n        return this.items[this.items.length-1];\n    },\n    clear:function(){\n        this.items = [];\n    },\n    length:function(){\n        return this.items.length;\n    },\n    displayAll:function(){\n        var str = '';\n        for(var i = 0;i < this.length();i++){\n            str += this.items[i];\n        }\n        return str;\n    }\n}\n```\n测试：\n```\nvar queue = new Queue();\nqueue.enqueue('aaa');\nqueue.enqueue('bbb');\nconsole.log(queue.length());//输出2\nqueue.dequeue();\nconsole.log(queue.displayAll());//输出bbb\n```\n-----------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","source":"_posts/【JavaScript实现数据结构】队列.md","raw":"---\ntitle: 【JavaScript 实现数据结构】队列\ndate: 2016-03-21 17:42:51\ntags:\n- JavaScript\n- 数据结构\ncategories:\n- 数据结构与算法\n---\n队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。\n\nJavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：\n```\nfunction Queue(){\n    this.items = [];\n}\nQueue.prototype = {\n    enqueue:function(data){\n        this.items.push(data);\n    },\n    dequeue:function(){\n        return this.items.shift();\n    },\n    front:function(){\n        return this.items[0];\n    },\n    rear:function(){\n        return this.items[this.items.length-1];\n    },\n    clear:function(){\n        this.items = [];\n    },\n    length:function(){\n        return this.items.length;\n    },\n    displayAll:function(){\n        var str = '';\n        for(var i = 0;i < this.length();i++){\n            str += this.items[i];\n        }\n        return str;\n    }\n}\n```\n测试：\n```\nvar queue = new Queue();\nqueue.enqueue('aaa');\nqueue.enqueue('bbb');\nconsole.log(queue.length());//输出2\nqueue.dequeue();\nconsole.log(queue.displayAll());//输出bbb\n```\n-----------\n**初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。**","slug":"【JavaScript实现数据结构】队列","published":1,"updated":"2019-12-28T16:35:56.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn89001whns6hz1m1kil","content":"<p>队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。</p>\n<p>JavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Queue()&#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Queue.prototype = &#123;</span><br><span class=\"line\">    enqueue:function(data)&#123;</span><br><span class=\"line\">        this.items.push(data);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dequeue:function()&#123;</span><br><span class=\"line\">        return this.items.shift();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    front:function()&#123;</span><br><span class=\"line\">        return this.items[0];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    rear:function()&#123;</span><br><span class=\"line\">        return this.items[this.items.length-1];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    clear:function()&#123;</span><br><span class=\"line\">        this.items = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    length:function()&#123;</span><br><span class=\"line\">        return this.items.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    displayAll:function()&#123;</span><br><span class=\"line\">        var str = &apos;&apos;;</span><br><span class=\"line\">        for(var i = 0;i &lt; this.length();i++)&#123;</span><br><span class=\"line\">            str += this.items[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var queue = new Queue();</span><br><span class=\"line\">queue.enqueue(&apos;aaa&apos;);</span><br><span class=\"line\">queue.enqueue(&apos;bbb&apos;);</span><br><span class=\"line\">console.log(queue.length());//输出2</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">console.log(queue.displayAll());//输出bbb</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>队列是一种先进先出（FIFO）的数据结构，其实现方式主要分两种：顺序队列和链式队列，本文将给出顺序队列的JavaScript实现。</p>\n<p>JavaScript提供的数组原生方法：push()可以在数组末尾插入元素，shift()可以删除数组的第一个元素，利用这两个方法可以很容易实现队列的“入队”和“出队”。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Queue()&#123;</span><br><span class=\"line\">    this.items = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Queue.prototype = &#123;</span><br><span class=\"line\">    enqueue:function(data)&#123;</span><br><span class=\"line\">        this.items.push(data);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dequeue:function()&#123;</span><br><span class=\"line\">        return this.items.shift();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    front:function()&#123;</span><br><span class=\"line\">        return this.items[0];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    rear:function()&#123;</span><br><span class=\"line\">        return this.items[this.items.length-1];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    clear:function()&#123;</span><br><span class=\"line\">        this.items = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    length:function()&#123;</span><br><span class=\"line\">        return this.items.length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    displayAll:function()&#123;</span><br><span class=\"line\">        var str = &apos;&apos;;</span><br><span class=\"line\">        for(var i = 0;i &lt; this.length();i++)&#123;</span><br><span class=\"line\">            str += this.items[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var queue = new Queue();</span><br><span class=\"line\">queue.enqueue(&apos;aaa&apos;);</span><br><span class=\"line\">queue.enqueue(&apos;bbb&apos;);</span><br><span class=\"line\">console.log(queue.length());//输出2</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">console.log(queue.displayAll());//输出bbb</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>初学者学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</strong></p>\n"},{"title":"【JavaScript 实现算法】快速排序","date":"2016-03-22T13:13:54.000Z","_content":"快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。\n\n快速排序的算法如下:\n(1) 选择一个基准元素,将列表分隔成两个子序列;\n(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;\n(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。\n\n这个算法的JavaScript实现如下：\n```\n//工具函数：交换两个值\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    var pivot = this[start];\n    var pivotIdx = start;\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\n\n```\n测试一下快速排序的性能\n```\n// test\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort();\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:215ms\n```","source":"_posts/【JavaScript实现算法】快速排序.md","raw":"---\ntitle: 【JavaScript 实现算法】快速排序\ndate: 2016-03-22 21:13:54\ntags:\n- JavaScript\n- 算法\ncategories:\n- 数据结构与算法\n---\n快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。\n\n快速排序的算法如下:\n(1) 选择一个基准元素,将列表分隔成两个子序列;\n(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;\n(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。\n\n这个算法的JavaScript实现如下：\n```\n//工具函数：交换两个值\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    var pivot = this[start];\n    var pivotIdx = start;\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\n\n```\n测试一下快速排序的性能\n```\n// test\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort();\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:215ms\n```","slug":"【JavaScript实现算法】快速排序","published":1,"updated":"2019-12-28T16:36:07.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8b0020hns6srxhikf7","content":"<p>快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。</p>\n<p>快速排序的算法如下:<br>(1) 选择一个基准元素,将列表分隔成两个子序列;<br>(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;<br>(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。</p>\n<p>这个算法的JavaScript实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//工具函数：交换两个值</span><br><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivot = this[start];</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下快速排序的性能<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// test</span><br><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort();</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:215ms</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>快速排序是一种分而治之的算法,通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。</p>\n<p>快速排序的算法如下:<br>(1) 选择一个基准元素,将列表分隔成两个子序列;<br>(2) 对列表重新排序,将所有小于基准值的元素放在基准值的前面,所有大于基准值的元素放在基准值的后面;<br>(3) 分别对较小元素的子序列和较大元素的子序列重复步骤 1 和 2。</p>\n<p>这个算法的JavaScript实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//工具函数：交换两个值</span><br><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pivot = this[start];</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下快速排序的性能<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// test</span><br><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort();</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:215ms</span><br></pre></td></tr></table></figure></p>\n"},{"title":"【译】2017 年要去学的 3 个 CSS 新属性","date":"2017-02-05T05:10:28.000Z","_content":"> * 原文地址：[3 New CSS Features to Learn in 2017](https://bitsofco.de/3-new-css-features-to-learn-in-2017/)\n* 原文作者：[ireaderinokun](https://twitter.com/ireaderinokun)\n* 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n* 译者： [熊贤仁](https://github.com/FrankXiong)\n* 校对者： [Professor-Z](https://github.com/Professor-Z) [aleen42](https://github.com/aleen42)\n\n# 2017 年要去学的 3 个 CSS 新属性\n\n## 1. 特性查询（Feature Queries）\n\n不久前，我写过一篇关于特性查询的文章 —— [《一个我十分期待的CSS特性 - the one CSS feature I really want》](https://bitsofco.de/the-one-css-feature/)。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。\n\n特性查询采用 `@supports` 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式\n```\n@supports ( display: flex ) {\n  .foo { display: flex; }\n}\n```\n另外，我们甚至可以使用像 `and` 和 `not` 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法\n```\n@supports ( display: flexbox )\n          and\n          ( not ( display: flex ) ) {\n  .foo { display: flexbox; }\n}\n```\n\n### 兼容性\n\n![](http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg)\n\n## 2. 栅格布局（Grid Layout）\n\n[CSS 栅格布局模块（CSS Grid Layout Module）](https://drafts.csswg.org/css-grid/) 定义了一个用于创建基于栅格布局的系统。它和 [弹性盒子布局模块（Flexbible Box Layout Module）](https://www.w3.org/TR/css-flexbox-1/) 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。\n\n### 显式定位元素\n\n一个栅格由栅格容器（由 `display: grid` 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。\n\n在[《CSS栅格实现圣杯布局》](https://bitsofco.de/holy-grail-layout-css-grid/)这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。\n\n![Holy Grail Layout Demo](https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif)\n\n下列 CSS 代码仅有 31 行\n\n```\n.hg__header { grid-area: header; }\n.hg__footer { grid-area: footer; }\n.hg__main { grid-area: main; }\n.hg__left { grid-area: navigation; }\n.hg__right { grid-area: ads; }\n\n.hg {\n    display: grid;\n    grid-template-areas: \"header header header\"\n                         \"navigation main ads\"\n                         \"footer footer footer\";\n    grid-template-columns: 150px 1fr 150px;\n    grid-template-rows: 100px\n                        1fr\n                        30px;\n    min-height: 100vh;\n}\n\n@media screen and (max-width: 600px) {\n    .hg {\n        grid-template-areas: \"header\"\n                             \"navigation\"\n                             \"main\"\n                             \"ads\"\n                             \"footer\";\n        grid-template-columns: 100%;\n        grid-template-rows: 100px\n                            50px\n                            1fr\n                            50px\n                            30px;\n    }\n}\n```\n\n### 弹性长度\n\nCSS 栅格模块引入了一个新的长度单位：`fr` ，用于表示栅格容器中所剩空间的占比。\n\n这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 `main` 区域占用两个边栏外的余下空间。\n```\n.hg {\n  grid-template-columns: 150px 1fr 150px;\n}\n```\n\n### 槽（Gutters）\n\n我们可以使用 `grid-row-gap`，`grid-column-gap`，和 `grid-gap` 属性来为栅格布局明确地定义槽。这些属性接受一个 [`<length-percentage>` 数据类型](https://bitsofco.de/generic-css-data-types/#percentages) 作为值，以表示内容区大小的相对百分比。\n\n比如设置一个 5% 的槽，我们可以这样写\n```\n.hg {\n  display: grid;\n  grid-column-gap: 5%;\n}\n```\n\n### 兼容性\n\nCSS 栅格模块最早将在今年三月份被浏览器们支持。\n\n![](http://i1.piimg.com/567571/229e6ea502a22d93.jpg)\n\n## 3. 原生变量（Native Variables）\n\n最后，原生 CSS 变量（[层叠变量模块（Cascading Variables Module）的自定义属性](https://drafts.csswg.org/css-variables/)）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。\n\n譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。\n\n```\n:root {\n  --theme-colour: cornflowerblue;\n}\n\nh1 { color: var(--theme-colour); }  \na { color: var(--theme-colour); }  \nstrong { color: var(--theme-colour); }\n```\n\n我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 --theme-colour 属性，我们只需要这样做\n```\nconst rootEl = document.documentElement;  \nrootEl.style.setProperty('--theme-colour','plum');\n```\n\n### 兼容性\n\n ![](http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg)\n\n\n## 关于兼容性？\n\n如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到\n\n[![JavaScript Array Methods -　Mutator](http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png)](https://player.vimeo.com/video/194815985)\n\n2017年有哪些 CSS 特性令你激动不已想要学习？\n","source":"_posts/【译】2017-年要去学的-3-个-CSS-新属性.md","raw":"---\ntitle: 【译】2017 年要去学的 3 个 CSS 新属性\ndate: 2017-02-05 13:10:28\ntags:\n- CSS\n- 翻译\ncategories:\n- 前端\n---\n> * 原文地址：[3 New CSS Features to Learn in 2017](https://bitsofco.de/3-new-css-features-to-learn-in-2017/)\n* 原文作者：[ireaderinokun](https://twitter.com/ireaderinokun)\n* 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)\n* 译者： [熊贤仁](https://github.com/FrankXiong)\n* 校对者： [Professor-Z](https://github.com/Professor-Z) [aleen42](https://github.com/aleen42)\n\n# 2017 年要去学的 3 个 CSS 新属性\n\n## 1. 特性查询（Feature Queries）\n\n不久前，我写过一篇关于特性查询的文章 —— [《一个我十分期待的CSS特性 - the one CSS feature I really want》](https://bitsofco.de/the-one-css-feature/)。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。\n\n特性查询采用 `@supports` 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式\n```\n@supports ( display: flex ) {\n  .foo { display: flex; }\n}\n```\n另外，我们甚至可以使用像 `and` 和 `not` 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法\n```\n@supports ( display: flexbox )\n          and\n          ( not ( display: flex ) ) {\n  .foo { display: flexbox; }\n}\n```\n\n### 兼容性\n\n![](http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg)\n\n## 2. 栅格布局（Grid Layout）\n\n[CSS 栅格布局模块（CSS Grid Layout Module）](https://drafts.csswg.org/css-grid/) 定义了一个用于创建基于栅格布局的系统。它和 [弹性盒子布局模块（Flexbible Box Layout Module）](https://www.w3.org/TR/css-flexbox-1/) 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。\n\n### 显式定位元素\n\n一个栅格由栅格容器（由 `display: grid` 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。\n\n在[《CSS栅格实现圣杯布局》](https://bitsofco.de/holy-grail-layout-css-grid/)这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。\n\n![Holy Grail Layout Demo](https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif)\n\n下列 CSS 代码仅有 31 行\n\n```\n.hg__header { grid-area: header; }\n.hg__footer { grid-area: footer; }\n.hg__main { grid-area: main; }\n.hg__left { grid-area: navigation; }\n.hg__right { grid-area: ads; }\n\n.hg {\n    display: grid;\n    grid-template-areas: \"header header header\"\n                         \"navigation main ads\"\n                         \"footer footer footer\";\n    grid-template-columns: 150px 1fr 150px;\n    grid-template-rows: 100px\n                        1fr\n                        30px;\n    min-height: 100vh;\n}\n\n@media screen and (max-width: 600px) {\n    .hg {\n        grid-template-areas: \"header\"\n                             \"navigation\"\n                             \"main\"\n                             \"ads\"\n                             \"footer\";\n        grid-template-columns: 100%;\n        grid-template-rows: 100px\n                            50px\n                            1fr\n                            50px\n                            30px;\n    }\n}\n```\n\n### 弹性长度\n\nCSS 栅格模块引入了一个新的长度单位：`fr` ，用于表示栅格容器中所剩空间的占比。\n\n这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 `main` 区域占用两个边栏外的余下空间。\n```\n.hg {\n  grid-template-columns: 150px 1fr 150px;\n}\n```\n\n### 槽（Gutters）\n\n我们可以使用 `grid-row-gap`，`grid-column-gap`，和 `grid-gap` 属性来为栅格布局明确地定义槽。这些属性接受一个 [`<length-percentage>` 数据类型](https://bitsofco.de/generic-css-data-types/#percentages) 作为值，以表示内容区大小的相对百分比。\n\n比如设置一个 5% 的槽，我们可以这样写\n```\n.hg {\n  display: grid;\n  grid-column-gap: 5%;\n}\n```\n\n### 兼容性\n\nCSS 栅格模块最早将在今年三月份被浏览器们支持。\n\n![](http://i1.piimg.com/567571/229e6ea502a22d93.jpg)\n\n## 3. 原生变量（Native Variables）\n\n最后，原生 CSS 变量（[层叠变量模块（Cascading Variables Module）的自定义属性](https://drafts.csswg.org/css-variables/)）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。\n\n譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。\n\n```\n:root {\n  --theme-colour: cornflowerblue;\n}\n\nh1 { color: var(--theme-colour); }  \na { color: var(--theme-colour); }  \nstrong { color: var(--theme-colour); }\n```\n\n我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 --theme-colour 属性，我们只需要这样做\n```\nconst rootEl = document.documentElement;  \nrootEl.style.setProperty('--theme-colour','plum');\n```\n\n### 兼容性\n\n ![](http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg)\n\n\n## 关于兼容性？\n\n如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到\n\n[![JavaScript Array Methods -　Mutator](http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png)](https://player.vimeo.com/video/194815985)\n\n2017年有哪些 CSS 特性令你激动不已想要学习？\n","slug":"【译】2017-年要去学的-3-个-CSS-新属性","published":1,"updated":"2019-06-16T14:11:37.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8c0023hns6shboo86g","content":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://bitsofco.de/3-new-css-features-to-learn-in-2017/\" target=\"_blank\" rel=\"noopener\">3 New CSS Features to Learn in 2017</a></li>\n<li>原文作者：<a href=\"https://twitter.com/ireaderinokun\" target=\"_blank\" rel=\"noopener\">ireaderinokun</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>译者： <a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></li>\n<li>校对者： <a href=\"https://github.com/Professor-Z\" target=\"_blank\" rel=\"noopener\">Professor-Z</a> <a href=\"https://github.com/aleen42\" target=\"_blank\" rel=\"noopener\">aleen42</a></li>\n</ul>\n</blockquote>\n<h1 id=\"2017-年要去学的-3-个-CSS-新属性\"><a href=\"#2017-年要去学的-3-个-CSS-新属性\" class=\"headerlink\" title=\"2017 年要去学的 3 个 CSS 新属性\"></a>2017 年要去学的 3 个 CSS 新属性</h1><h2 id=\"1-特性查询（Feature-Queries）\"><a href=\"#1-特性查询（Feature-Queries）\" class=\"headerlink\" title=\"1. 特性查询（Feature Queries）\"></a>1. 特性查询（Feature Queries）</h2><p>不久前，我写过一篇关于特性查询的文章 —— <a href=\"https://bitsofco.de/the-one-css-feature/\" target=\"_blank\" rel=\"noopener\">《一个我十分期待的CSS特性 - the one CSS feature I really want》</a>。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。</p>\n<p>特性查询采用 <code>@supports</code> 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，我们甚至可以使用像 <code>and</code> 和 <code>not</code> 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flexbox )</span><br><span class=\"line\">          and</span><br><span class=\"line\">          ( not ( display: flex ) ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flexbox; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p><img src=\"http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg\" alt=\"\"></p>\n<h2 id=\"2-栅格布局（Grid-Layout）\"><a href=\"#2-栅格布局（Grid-Layout）\" class=\"headerlink\" title=\"2. 栅格布局（Grid Layout）\"></a>2. 栅格布局（Grid Layout）</h2><p><a href=\"https://drafts.csswg.org/css-grid/\" target=\"_blank\" rel=\"noopener\">CSS 栅格布局模块（CSS Grid Layout Module）</a> 定义了一个用于创建基于栅格布局的系统。它和 <a href=\"https://www.w3.org/TR/css-flexbox-1/\" target=\"_blank\" rel=\"noopener\">弹性盒子布局模块（Flexbible Box Layout Module）</a> 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。</p>\n<h3 id=\"显式定位元素\"><a href=\"#显式定位元素\" class=\"headerlink\" title=\"显式定位元素\"></a>显式定位元素</h3><p>一个栅格由栅格容器（由 <code>display: grid</code> 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。</p>\n<p>在<a href=\"https://bitsofco.de/holy-grail-layout-css-grid/\" target=\"_blank\" rel=\"noopener\">《CSS栅格实现圣杯布局》</a>这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。</p>\n<p><img src=\"https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif\" alt=\"Holy Grail Layout Demo\"></p>\n<p>下列 CSS 代码仅有 31 行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg__header &#123; grid-area: header; &#125;</span><br><span class=\"line\">.hg__footer &#123; grid-area: footer; &#125;</span><br><span class=\"line\">.hg__main &#123; grid-area: main; &#125;</span><br><span class=\"line\">.hg__left &#123; grid-area: navigation; &#125;</span><br><span class=\"line\">.hg__right &#123; grid-area: ads; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.hg &#123;</span><br><span class=\"line\">    display: grid;</span><br><span class=\"line\">    grid-template-areas: &quot;header header header&quot;</span><br><span class=\"line\">                         &quot;navigation main ads&quot;</span><br><span class=\"line\">                         &quot;footer footer footer&quot;;</span><br><span class=\"line\">    grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">    grid-template-rows: 100px</span><br><span class=\"line\">                        1fr</span><br><span class=\"line\">                        30px;</span><br><span class=\"line\">    min-height: 100vh;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media screen and (max-width: 600px) &#123;</span><br><span class=\"line\">    .hg &#123;</span><br><span class=\"line\">        grid-template-areas: &quot;header&quot;</span><br><span class=\"line\">                             &quot;navigation&quot;</span><br><span class=\"line\">                             &quot;main&quot;</span><br><span class=\"line\">                             &quot;ads&quot;</span><br><span class=\"line\">                             &quot;footer&quot;;</span><br><span class=\"line\">        grid-template-columns: 100%;</span><br><span class=\"line\">        grid-template-rows: 100px</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            1fr</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            30px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"弹性长度\"><a href=\"#弹性长度\" class=\"headerlink\" title=\"弹性长度\"></a>弹性长度</h3><p>CSS 栅格模块引入了一个新的长度单位：<code>fr</code> ，用于表示栅格容器中所剩空间的占比。</p>\n<p>这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 <code>main</code> 区域占用两个边栏外的余下空间。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"槽（Gutters）\"><a href=\"#槽（Gutters）\" class=\"headerlink\" title=\"槽（Gutters）\"></a>槽（Gutters）</h3><p>我们可以使用 <code>grid-row-gap</code>，<code>grid-column-gap</code>，和 <code>grid-gap</code> 属性来为栅格布局明确地定义槽。这些属性接受一个 <a href=\"https://bitsofco.de/generic-css-data-types/#percentages\" target=\"_blank\" rel=\"noopener\"><code>&lt;length-percentage&gt;</code> 数据类型</a> 作为值，以表示内容区大小的相对百分比。</p>\n<p>比如设置一个 5% 的槽，我们可以这样写<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-column-gap: 5%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-1\"><a href=\"#兼容性-1\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>CSS 栅格模块最早将在今年三月份被浏览器们支持。</p>\n<p><img src=\"http://i1.piimg.com/567571/229e6ea502a22d93.jpg\" alt=\"\"></p>\n<h2 id=\"3-原生变量（Native-Variables）\"><a href=\"#3-原生变量（Native-Variables）\" class=\"headerlink\" title=\"3. 原生变量（Native Variables）\"></a>3. 原生变量（Native Variables）</h2><p>最后，原生 CSS 变量（<a href=\"https://drafts.csswg.org/css-variables/\" target=\"_blank\" rel=\"noopener\">层叠变量模块（Cascading Variables Module）的自定义属性</a>）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。</p>\n<p>譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">  --theme-colour: cornflowerblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1 &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">a &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">strong &#123; color: var(--theme-colour); &#125;</span><br></pre></td></tr></table></figure>\n<p>我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 –theme-colour 属性，我们只需要这样做<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const rootEl = document.documentElement;  </span><br><span class=\"line\">rootEl.style.setProperty(&apos;--theme-colour&apos;,&apos;plum&apos;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-2\"><a href=\"#兼容性-2\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p> <img src=\"http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg\" alt=\"\"></p>\n<h2 id=\"关于兼容性？\"><a href=\"#关于兼容性？\" class=\"headerlink\" title=\"关于兼容性？\"></a>关于兼容性？</h2><p>如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到</p>\n<p><a href=\"https://player.vimeo.com/video/194815985\" target=\"_blank\" rel=\"noopener\"><img src=\"http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png\" alt=\"JavaScript Array Methods -　Mutator\"></a></p>\n<p>2017年有哪些 CSS 特性令你激动不已想要学习？</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://bitsofco.de/3-new-css-features-to-learn-in-2017/\" target=\"_blank\" rel=\"noopener\">3 New CSS Features to Learn in 2017</a></li>\n<li>原文作者：<a href=\"https://twitter.com/ireaderinokun\" target=\"_blank\" rel=\"noopener\">ireaderinokun</a></li>\n<li>译文出自：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"noopener\">掘金翻译计划</a></li>\n<li>译者： <a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></li>\n<li>校对者： <a href=\"https://github.com/Professor-Z\" target=\"_blank\" rel=\"noopener\">Professor-Z</a> <a href=\"https://github.com/aleen42\" target=\"_blank\" rel=\"noopener\">aleen42</a></li>\n</ul>\n</blockquote>\n<h1 id=\"2017-年要去学的-3-个-CSS-新属性\"><a href=\"#2017-年要去学的-3-个-CSS-新属性\" class=\"headerlink\" title=\"2017 年要去学的 3 个 CSS 新属性\"></a>2017 年要去学的 3 个 CSS 新属性</h1><h2 id=\"1-特性查询（Feature-Queries）\"><a href=\"#1-特性查询（Feature-Queries）\" class=\"headerlink\" title=\"1. 特性查询（Feature Queries）\"></a>1. 特性查询（Feature Queries）</h2><p>不久前，我写过一篇关于特性查询的文章 —— <a href=\"https://bitsofco.de/the-one-css-feature/\" target=\"_blank\" rel=\"noopener\">《一个我十分期待的CSS特性 - the one CSS feature I really want》</a>。如今果然出现了。除了 IE浏览器之外，所有主流浏览器（包括 Opera Mini）均已支持特性查询。</p>\n<p>特性查询采用 <code>@supports</code> 规则，它使得我们可以将 CSS 代码包裹一个条件块中。只有当浏览器的用户代理（user agent）支持某个特定的 CSS 属性-值对时，该条件块中的样式代码才会生效。下面举个简单的例子来说：只有支持 display: flex 的浏览器才会应用 Flexbox 样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另外，我们甚至可以使用像 <code>and</code> 和 <code>not</code> 这类操作符来创建更为复杂的特性查询。例如，检测一个浏览器是否只支持老式的 Flexbox 语法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@supports ( display: flexbox )</span><br><span class=\"line\">          and</span><br><span class=\"line\">          ( not ( display: flex ) ) &#123;</span><br><span class=\"line\">  .foo &#123; display: flexbox; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p><img src=\"http://i1.piimg.com/567571/bd5cfc239fccdda6.jpg\" alt=\"\"></p>\n<h2 id=\"2-栅格布局（Grid-Layout）\"><a href=\"#2-栅格布局（Grid-Layout）\" class=\"headerlink\" title=\"2. 栅格布局（Grid Layout）\"></a>2. 栅格布局（Grid Layout）</h2><p><a href=\"https://drafts.csswg.org/css-grid/\" target=\"_blank\" rel=\"noopener\">CSS 栅格布局模块（CSS Grid Layout Module）</a> 定义了一个用于创建基于栅格布局的系统。它和 <a href=\"https://www.w3.org/TR/css-flexbox-1/\" target=\"_blank\" rel=\"noopener\">弹性盒子布局模块（Flexbible Box Layout Module）</a> 有些相似，但由于其专为页面布局而设计，因此拥有许多不同的特性。</p>\n<h3 id=\"显式定位元素\"><a href=\"#显式定位元素\" class=\"headerlink\" title=\"显式定位元素\"></a>显式定位元素</h3><p>一个栅格由栅格容器（由 <code>display: grid</code> 所创建）和栅格项（子元素）组成。在 CSS 中，我们可以简单且显式地组织栅格项的位置及顺序，并独立于 markup 语言中元素的位置。</p>\n<p>在<a href=\"https://bitsofco.de/holy-grail-layout-css-grid/\" target=\"_blank\" rel=\"noopener\">《CSS栅格实现圣杯布局》</a>这篇文章中，我演示了如何使用栅格布局模块来创建万恶的“圣杯布局”。</p>\n<p><img src=\"https://bitsofco.de/content/images/2016/03/Holy_Grail_CSS_Grid.gif\" alt=\"Holy Grail Layout Demo\"></p>\n<p>下列 CSS 代码仅有 31 行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg__header &#123; grid-area: header; &#125;</span><br><span class=\"line\">.hg__footer &#123; grid-area: footer; &#125;</span><br><span class=\"line\">.hg__main &#123; grid-area: main; &#125;</span><br><span class=\"line\">.hg__left &#123; grid-area: navigation; &#125;</span><br><span class=\"line\">.hg__right &#123; grid-area: ads; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.hg &#123;</span><br><span class=\"line\">    display: grid;</span><br><span class=\"line\">    grid-template-areas: &quot;header header header&quot;</span><br><span class=\"line\">                         &quot;navigation main ads&quot;</span><br><span class=\"line\">                         &quot;footer footer footer&quot;;</span><br><span class=\"line\">    grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">    grid-template-rows: 100px</span><br><span class=\"line\">                        1fr</span><br><span class=\"line\">                        30px;</span><br><span class=\"line\">    min-height: 100vh;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media screen and (max-width: 600px) &#123;</span><br><span class=\"line\">    .hg &#123;</span><br><span class=\"line\">        grid-template-areas: &quot;header&quot;</span><br><span class=\"line\">                             &quot;navigation&quot;</span><br><span class=\"line\">                             &quot;main&quot;</span><br><span class=\"line\">                             &quot;ads&quot;</span><br><span class=\"line\">                             &quot;footer&quot;;</span><br><span class=\"line\">        grid-template-columns: 100%;</span><br><span class=\"line\">        grid-template-rows: 100px</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            1fr</span><br><span class=\"line\">                            50px</span><br><span class=\"line\">                            30px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"弹性长度\"><a href=\"#弹性长度\" class=\"headerlink\" title=\"弹性长度\"></a>弹性长度</h3><p>CSS 栅格模块引入了一个新的长度单位：<code>fr</code> ，用于表示栅格容器中所剩空间的占比。</p>\n<p>这样我们可以根据栅格容器中的可用空间来分配栅格项的宽高。比如在圣杯布局中，我们可以通过下面的简单代码使得 <code>main</code> 区域占用两个边栏外的余下空间。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  grid-template-columns: 150px 1fr 150px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"槽（Gutters）\"><a href=\"#槽（Gutters）\" class=\"headerlink\" title=\"槽（Gutters）\"></a>槽（Gutters）</h3><p>我们可以使用 <code>grid-row-gap</code>，<code>grid-column-gap</code>，和 <code>grid-gap</code> 属性来为栅格布局明确地定义槽。这些属性接受一个 <a href=\"https://bitsofco.de/generic-css-data-types/#percentages\" target=\"_blank\" rel=\"noopener\"><code>&lt;length-percentage&gt;</code> 数据类型</a> 作为值，以表示内容区大小的相对百分比。</p>\n<p>比如设置一个 5% 的槽，我们可以这样写<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.hg &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-column-gap: 5%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-1\"><a href=\"#兼容性-1\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>CSS 栅格模块最早将在今年三月份被浏览器们支持。</p>\n<p><img src=\"http://i1.piimg.com/567571/229e6ea502a22d93.jpg\" alt=\"\"></p>\n<h2 id=\"3-原生变量（Native-Variables）\"><a href=\"#3-原生变量（Native-Variables）\" class=\"headerlink\" title=\"3. 原生变量（Native Variables）\"></a>3. 原生变量（Native Variables）</h2><p>最后，原生 CSS 变量（<a href=\"https://drafts.csswg.org/css-variables/\" target=\"_blank\" rel=\"noopener\">层叠变量模块（Cascading Variables Module）的自定义属性</a>）来了。该模块引入了一个用于创建用户自定义变量的方法，变量可被赋值给 CSS 属性。</p>\n<p>譬如，若有多个样式表使用同一个主题颜色，那么我们就可以将其抽象成一个变量，并引用该变量，而非重复书写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">  --theme-colour: cornflowerblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1 &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">a &#123; color: var(--theme-colour); &#125;  </span><br><span class=\"line\">strong &#123; color: var(--theme-colour); &#125;</span><br></pre></td></tr></table></figure>\n<p>我们之前可以用像 SASS 这种 CSS 预处理器来做到这一点，但 CSS 变量的优势是能实际运行于浏览器中。这就意味着，变量的值可以被动态的更新。比如要修改以上所有 –theme-colour 属性，我们只需要这样做<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const rootEl = document.documentElement;  </span><br><span class=\"line\">rootEl.style.setProperty(&apos;--theme-colour&apos;,&apos;plum&apos;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性-2\"><a href=\"#兼容性-2\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p> <img src=\"http://i1.piimg.com/567571/fe40f3b4ec633b1c.jpg\" alt=\"\"></p>\n<h2 id=\"关于兼容性？\"><a href=\"#关于兼容性？\" class=\"headerlink\" title=\"关于兼容性？\"></a>关于兼容性？</h2><p>如你所见，以上所有特性目前都没有被所有浏览器完全支持，那么我们如何在生产环境中舒服地用上他们呢？渐进增强（Progressive Enhancement）！去年的前端开发者大会上，我就曾就如何在 CSS 中进行渐进增强做过一次分享。点击下面可以看到</p>\n<p><a href=\"https://player.vimeo.com/video/194815985\" target=\"_blank\" rel=\"noopener\"><img src=\"http://bitsofco.de/content/images/2017/01/Screen-Shot-2017-01-09-at-20.58.09--2-.png\" alt=\"JavaScript Array Methods -　Mutator\"></a></p>\n<p>2017年有哪些 CSS 特性令你激动不已想要学习？</p>\n"},{"title":"【译】ES2018 新特性：Promise.prototype.finally()","date":"2018-07-09T13:12:05.000Z","_content":"\n\n Jordan Harband 提出了 [`Promise.prototype.finally`](https://github.com/tc39/proposal-promise-finally) 这一章节的提案。\n\n### 如何工作？\n.finally() 这样用：\n```\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\nfinally 的回调总是会被执行。作为比较：\n- then 的回调只有当 promise 为 fulfilled 时才会被执行。\n- catch 的回调只有当 promise 为 rejected，或者 then 的回调抛出一个异常，或者返回一个 rejected Promise 时，才会被执行。\n换句话说，下面的代码段：\n```\npromise\n.finally(() => {\n    «statements»\n});\n```\n等价于：\n```\npromise\n.then(\n    result => {\n        «statements»\n        return result;\n    },\n    error => {\n        «statements»\n        throw error;\n    }\n);\n```\n### 使用案例\n最常见的使用案例类似于同步的 finally 分句：处理完某个资源后做些清理工作。不管是一切正常，还是出现了错误，这样的工作都是有必要的。\n举个例子：\n```\nlet connection;\ndb.open()\n.then(conn => {\n    connection = conn;\n    return connection.select({ name: 'Jane' });\n})\n.then(result => {\n    // Process result\n    // Use `connection` to make more queries\n})\n···\n.catch(error => {\n    // handle errors\n})\n.finally(() => {\n    connection.close();\n});\n```\n\n#### .finally() 类似于同步代码中的 finally {}\n同步代码里，try 语句分为三部分：try 分句，catch 分句和 finally 分句。\n对比 Promise：\n- try 分句相当于调用一个基于 Promise 的函数或者 .then() 方法\n- catch 分句相当于 Promise 的 .catch() 方法\n- finally 分句相当于提案在 Promise 新引入的 .finally() 方法\n\n然而，finally {} 可以 return 和 throw ，而在.finally() 回调里只能 throw, return 不起任何作用。这是因为这个方法不能区分显式返回和正常结束的回调。\n\n### 可用性\n- [npm 包 `promise.prototype.finally`](https://github.com/es-shims/Promise.prototype.finally) 是 .finally() 的一个 polyfill\n- V8 5.8+ (比如. Node.js 8.1.4+)：加上 --harmony-promise-finally 标记后可用。([了解更多](https://chromium.googlesource.com/v8/v8.git/+/18ad0f13afeaabff4e035fddd9edc3d319152160))\n\n### 深入阅读\n* [Promises for asynchronous programming](http://exploringjs.com/es6/ch_promises.html)\n\n\n--------\n原文：http://exploringjs.com/es2018-es2019/ch_promise-prototype-finally.html\n","source":"_posts/【译】ES2018新特性：Promise-prototype-finally.md","raw":"---\ntitle: 【译】ES2018 新特性：Promise.prototype.finally()\ndate: 2018-07-09 21:12:05\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n\n\n Jordan Harband 提出了 [`Promise.prototype.finally`](https://github.com/tc39/proposal-promise-finally) 这一章节的提案。\n\n### 如何工作？\n.finally() 这样用：\n```\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\nfinally 的回调总是会被执行。作为比较：\n- then 的回调只有当 promise 为 fulfilled 时才会被执行。\n- catch 的回调只有当 promise 为 rejected，或者 then 的回调抛出一个异常，或者返回一个 rejected Promise 时，才会被执行。\n换句话说，下面的代码段：\n```\npromise\n.finally(() => {\n    «statements»\n});\n```\n等价于：\n```\npromise\n.then(\n    result => {\n        «statements»\n        return result;\n    },\n    error => {\n        «statements»\n        throw error;\n    }\n);\n```\n### 使用案例\n最常见的使用案例类似于同步的 finally 分句：处理完某个资源后做些清理工作。不管是一切正常，还是出现了错误，这样的工作都是有必要的。\n举个例子：\n```\nlet connection;\ndb.open()\n.then(conn => {\n    connection = conn;\n    return connection.select({ name: 'Jane' });\n})\n.then(result => {\n    // Process result\n    // Use `connection` to make more queries\n})\n···\n.catch(error => {\n    // handle errors\n})\n.finally(() => {\n    connection.close();\n});\n```\n\n#### .finally() 类似于同步代码中的 finally {}\n同步代码里，try 语句分为三部分：try 分句，catch 分句和 finally 分句。\n对比 Promise：\n- try 分句相当于调用一个基于 Promise 的函数或者 .then() 方法\n- catch 分句相当于 Promise 的 .catch() 方法\n- finally 分句相当于提案在 Promise 新引入的 .finally() 方法\n\n然而，finally {} 可以 return 和 throw ，而在.finally() 回调里只能 throw, return 不起任何作用。这是因为这个方法不能区分显式返回和正常结束的回调。\n\n### 可用性\n- [npm 包 `promise.prototype.finally`](https://github.com/es-shims/Promise.prototype.finally) 是 .finally() 的一个 polyfill\n- V8 5.8+ (比如. Node.js 8.1.4+)：加上 --harmony-promise-finally 标记后可用。([了解更多](https://chromium.googlesource.com/v8/v8.git/+/18ad0f13afeaabff4e035fddd9edc3d319152160))\n\n### 深入阅读\n* [Promises for asynchronous programming](http://exploringjs.com/es6/ch_promises.html)\n\n\n--------\n原文：http://exploringjs.com/es2018-es2019/ch_promise-prototype-finally.html\n","slug":"【译】ES2018新特性：Promise-prototype-finally","published":1,"updated":"2019-06-16T14:11:37.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8e0028hns6fk9vusok","content":"<p> Jordan Harband 提出了 <a href=\"https://github.com/tc39/proposal-promise-finally\" target=\"_blank\" rel=\"noopener\"><code>Promise.prototype.finally</code></a> 这一章节的提案。</p>\n<h3 id=\"如何工作？\"><a href=\"#如何工作？\" class=\"headerlink\" title=\"如何工作？\"></a>如何工作？</h3><p>.finally() 这样用：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(result =&gt; &#123;···&#125;)</span><br><span class=\"line\">.catch(error =&gt; &#123;···&#125;)</span><br><span class=\"line\">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>finally 的回调总是会被执行。作为比较：</p>\n<ul>\n<li>then 的回调只有当 promise 为 fulfilled 时才会被执行。</li>\n<li>catch 的回调只有当 promise 为 rejected，或者 then 的回调抛出一个异常，或者返回一个 rejected Promise 时，才会被执行。<br>换句话说，下面的代码段：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.finally(() =&gt; &#123;</span><br><span class=\"line\">    «statements»</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等价于：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(</span><br><span class=\"line\">    result =&gt; &#123;</span><br><span class=\"line\">        «statements»</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error =&gt; &#123;</span><br><span class=\"line\">        «statements»</span><br><span class=\"line\">        throw error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><p>最常见的使用案例类似于同步的 finally 分句：处理完某个资源后做些清理工作。不管是一切正常，还是出现了错误，这样的工作都是有必要的。<br>举个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let connection;</span><br><span class=\"line\">db.open()</span><br><span class=\"line\">.then(conn =&gt; &#123;</span><br><span class=\"line\">    connection = conn;</span><br><span class=\"line\">    return connection.select(&#123; name: &apos;Jane&apos; &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; &#123;</span><br><span class=\"line\">    // Process result</span><br><span class=\"line\">    // Use `connection` to make more queries</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">···</span><br><span class=\"line\">.catch(error =&gt; &#123;</span><br><span class=\"line\">    // handle errors</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.finally(() =&gt; &#123;</span><br><span class=\"line\">    connection.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"finally-类似于同步代码中的-finally\"><a href=\"#finally-类似于同步代码中的-finally\" class=\"headerlink\" title=\".finally() 类似于同步代码中的 finally {}\"></a>.finally() 类似于同步代码中的 finally {}</h4><p>同步代码里，try 语句分为三部分：try 分句，catch 分句和 finally 分句。<br>对比 Promise：</p>\n<ul>\n<li>try 分句相当于调用一个基于 Promise 的函数或者 .then() 方法</li>\n<li>catch 分句相当于 Promise 的 .catch() 方法</li>\n<li>finally 分句相当于提案在 Promise 新引入的 .finally() 方法</li>\n</ul>\n<p>然而，finally {} 可以 return 和 throw ，而在.finally() 回调里只能 throw, return 不起任何作用。这是因为这个方法不能区分显式返回和正常结束的回调。</p>\n<h3 id=\"可用性\"><a href=\"#可用性\" class=\"headerlink\" title=\"可用性\"></a>可用性</h3><ul>\n<li><a href=\"https://github.com/es-shims/Promise.prototype.finally\" target=\"_blank\" rel=\"noopener\">npm 包 <code>promise.prototype.finally</code></a> 是 .finally() 的一个 polyfill</li>\n<li>V8 5.8+ (比如. Node.js 8.1.4+)：加上 –harmony-promise-finally 标记后可用。(<a href=\"https://chromium.googlesource.com/v8/v8.git/+/18ad0f13afeaabff4e035fddd9edc3d319152160\" target=\"_blank\" rel=\"noopener\">了解更多</a>)</li>\n</ul>\n<h3 id=\"深入阅读\"><a href=\"#深入阅读\" class=\"headerlink\" title=\"深入阅读\"></a>深入阅读</h3><ul>\n<li><a href=\"http://exploringjs.com/es6/ch_promises.html\" target=\"_blank\" rel=\"noopener\">Promises for asynchronous programming</a></li>\n</ul>\n<hr>\n<p>原文：<a href=\"http://exploringjs.com/es2018-es2019/ch_promise-prototype-finally.html\" target=\"_blank\" rel=\"noopener\">http://exploringjs.com/es2018-es2019/ch_promise-prototype-finally.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p> Jordan Harband 提出了 <a href=\"https://github.com/tc39/proposal-promise-finally\" target=\"_blank\" rel=\"noopener\"><code>Promise.prototype.finally</code></a> 这一章节的提案。</p>\n<h3 id=\"如何工作？\"><a href=\"#如何工作？\" class=\"headerlink\" title=\"如何工作？\"></a>如何工作？</h3><p>.finally() 这样用：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(result =&gt; &#123;···&#125;)</span><br><span class=\"line\">.catch(error =&gt; &#123;···&#125;)</span><br><span class=\"line\">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>finally 的回调总是会被执行。作为比较：</p>\n<ul>\n<li>then 的回调只有当 promise 为 fulfilled 时才会被执行。</li>\n<li>catch 的回调只有当 promise 为 rejected，或者 then 的回调抛出一个异常，或者返回一个 rejected Promise 时，才会被执行。<br>换句话说，下面的代码段：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.finally(() =&gt; &#123;</span><br><span class=\"line\">    «statements»</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等价于：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(</span><br><span class=\"line\">    result =&gt; &#123;</span><br><span class=\"line\">        «statements»</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error =&gt; &#123;</span><br><span class=\"line\">        «statements»</span><br><span class=\"line\">        throw error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><p>最常见的使用案例类似于同步的 finally 分句：处理完某个资源后做些清理工作。不管是一切正常，还是出现了错误，这样的工作都是有必要的。<br>举个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let connection;</span><br><span class=\"line\">db.open()</span><br><span class=\"line\">.then(conn =&gt; &#123;</span><br><span class=\"line\">    connection = conn;</span><br><span class=\"line\">    return connection.select(&#123; name: &apos;Jane&apos; &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; &#123;</span><br><span class=\"line\">    // Process result</span><br><span class=\"line\">    // Use `connection` to make more queries</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">···</span><br><span class=\"line\">.catch(error =&gt; &#123;</span><br><span class=\"line\">    // handle errors</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.finally(() =&gt; &#123;</span><br><span class=\"line\">    connection.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"finally-类似于同步代码中的-finally\"><a href=\"#finally-类似于同步代码中的-finally\" class=\"headerlink\" title=\".finally() 类似于同步代码中的 finally {}\"></a>.finally() 类似于同步代码中的 finally {}</h4><p>同步代码里，try 语句分为三部分：try 分句，catch 分句和 finally 分句。<br>对比 Promise：</p>\n<ul>\n<li>try 分句相当于调用一个基于 Promise 的函数或者 .then() 方法</li>\n<li>catch 分句相当于 Promise 的 .catch() 方法</li>\n<li>finally 分句相当于提案在 Promise 新引入的 .finally() 方法</li>\n</ul>\n<p>然而，finally {} 可以 return 和 throw ，而在.finally() 回调里只能 throw, return 不起任何作用。这是因为这个方法不能区分显式返回和正常结束的回调。</p>\n<h3 id=\"可用性\"><a href=\"#可用性\" class=\"headerlink\" title=\"可用性\"></a>可用性</h3><ul>\n<li><a href=\"https://github.com/es-shims/Promise.prototype.finally\" target=\"_blank\" rel=\"noopener\">npm 包 <code>promise.prototype.finally</code></a> 是 .finally() 的一个 polyfill</li>\n<li>V8 5.8+ (比如. Node.js 8.1.4+)：加上 –harmony-promise-finally 标记后可用。(<a href=\"https://chromium.googlesource.com/v8/v8.git/+/18ad0f13afeaabff4e035fddd9edc3d319152160\" target=\"_blank\" rel=\"noopener\">了解更多</a>)</li>\n</ul>\n<h3 id=\"深入阅读\"><a href=\"#深入阅读\" class=\"headerlink\" title=\"深入阅读\"></a>深入阅读</h3><ul>\n<li><a href=\"http://exploringjs.com/es6/ch_promises.html\" target=\"_blank\" rel=\"noopener\">Promises for asynchronous programming</a></li>\n</ul>\n<hr>\n<p>原文：<a href=\"http://exploringjs.com/es2018-es2019/ch_promise-prototype-finally.html\" target=\"_blank\" rel=\"noopener\">http://exploringjs.com/es2018-es2019/ch_promise-prototype-finally.html</a></p>\n"},{"title":"【译】为什么 Vue.js 不支持 templateURL?","date":"2016-08-02T17:48:42.000Z","_content":"　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用`templateURL`吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。\n在Angular中，`templateURL`或者`ng-include`允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。\n　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。\n　　其次，由于`templateURL`通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在`$templateCache`中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。\n　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以`<script type=\"x/template\">`的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 [Webpack](http://webpack.github.io/)或者[Browserify](http://browserify.org/)之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始**在单个文件中写Vue组件**时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。\n　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。\n　　**以组件的方式去思考，而不是模板。**\n\n---------\n作者：尤雨溪\n原文地址：http://cn.vuejs.org/2015/10/28/why-no-template-url/\n译者：[熊贤仁](https://blog.skrskrskrskr.com)\n","source":"_posts/【译】为什么Vue-js不支持templateURL.md","raw":"---\ntitle: 【译】为什么 Vue.js 不支持 templateURL?\ndate: 2016-08-03 01:48:42\ntags:\n- JavaScript\n- Vue\n- 翻译\ncategories:\n- 前端\n---\n　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用`templateURL`吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。\n在Angular中，`templateURL`或者`ng-include`允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。\n　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。\n　　其次，由于`templateURL`通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在`$templateCache`中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。\n　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以`<script type=\"x/template\">`的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 [Webpack](http://webpack.github.io/)或者[Browserify](http://browserify.org/)之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始**在单个文件中写Vue组件**时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。\n　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。\n　　**以组件的方式去思考，而不是模板。**\n\n---------\n作者：尤雨溪\n原文地址：http://cn.vuejs.org/2015/10/28/why-no-template-url/\n译者：[熊贤仁](https://blog.skrskrskrskr.com)\n","slug":"【译】为什么Vue-js不支持templateURL","published":1,"updated":"2019-12-29T09:32:36.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8f002bhns6blbvtak1","content":"<p>　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用<code>templateURL</code>吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。<br>在Angular中，<code>templateURL</code>或者<code>ng-include</code>允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。<br>　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。<br>　　其次，由于<code>templateURL</code>通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在<code>$templateCache</code>中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。<br>　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以<code>&lt;script type=&quot;x/template&quot;&gt;</code>的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener\">Webpack</a>或者<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始<strong>在单个文件中写Vue组件</strong>时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。<br>　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。<br>　　<strong>以组件的方式去思考，而不是模板。</strong></p>\n<hr>\n<p>作者：尤雨溪<br>原文地址：<a href=\"http://cn.vuejs.org/2015/10/28/why-no-template-url/\" target=\"_blank\" rel=\"noopener\">http://cn.vuejs.org/2015/10/28/why-no-template-url/</a><br>译者：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　对于Vue新手，尤其是之前用过Angular的人来说，有一个非常普遍的问题：“我可以使用<code>templateURL</code>吗？”我（尤大）已经回答过很多次这个问题，发现最好写点东西来解释一下。<br>在Angular中，<code>templateURL</code>或者<code>ng-include</code>允许开发者在运行时动态地加载远程的模板文件。作为一个内建的特点，这点看起来很方便。但是让我们重新思考一下它解决了什么问题。<br>　　首先，templateURL允许我们在一个分离的HTML文件中写模板。可以让编辑器提供合适的语法高亮，这可能也是许多框架偏爱于这样做的原因吧。但是，分离模板和JavaScript代码真是的最好的方式吗？对于一个Vue组件，template和JavaScript被原生的紧密连在一起。事实上，如果这些东西仅仅在一个文件里会简单得多。上下文的来回跳转事实上会让开发体验变得更加糟糕。从概念上来说，组件是一个Vue应用的基本构建块，而template不是。每一个Vue.js template和一个伴随着的JavaScript上下文紧密连在一起，没有理由去进一步分离他们。<br>　　其次，由于<code>templateURL</code>通过Ajax在运行时加载模板，你不需要为了分离你的文件而增加一个构建的环节。这为开发提供了便利，但是当你想部署项目到生产环境的时候，这种方式带来了严重的开销。在HTTP/2被普遍支持之前，HTTP请求的数量依然是影响你的应用初次加载时性能的关键因素。现在想象你在应用中每一个组件中使用templateURL，浏览器需要在能展示页面之前做大量的HTTP请求，可能你不知道的是，大多数浏览器限制了它对于单个服务器的并行请求的数量。当你超过了这个限制，应用的初次渲染会承受额外的周转时间，因为浏览器要等待请求的加载。当然，现在也有构建工具，能够帮助你在<code>$templateCache</code>中预注册(pre-register)这些模板。但是，这事实上，不可避免的给前端开发增加了一个构建环节。<br>　　所以，没有templateURL，我们如何处理开发体验的问题？把模板作为行内JavaScript字符串来写是很糟糕的，以<code>&lt;script type=&quot;x/template&quot;&gt;</code>的方式来编写模板感觉像是一个hack。好吧，可能是时候去使用一个像 <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener\">Webpack</a>或者<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>之类的模板加载器让程序跑起来。你如果之前没处理过这些问题的话可能会被吓到，但是相信我，做出这种改变是值得的。如果你想要去构建一个大型的可维护的项目时，合适的模块化是必不可少的。更重要的是，当你开始<strong>在单个文件中写Vue组件</strong>时，使用合适的语法高亮，享受着预加载器、热加载(hot-reloading)，ES2015带来的开发上的快感，以及自动补全和scoped css。这些会将开发体验提升10倍。<br>　　最后，Vue也允许懒加载组件。使用webpack的话，这将变得极其简单。尽管这有一个唯一值得担心的问题是，当初始模块太大时，你最好将它进一步分离。<br>　　<strong>以组件的方式去思考，而不是模板。</strong></p>\n<hr>\n<p>作者：尤雨溪<br>原文地址：<a href=\"http://cn.vuejs.org/2015/10/28/why-no-template-url/\" target=\"_blank\" rel=\"noopener\">http://cn.vuejs.org/2015/10/28/why-no-template-url/</a><br>译者：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n"},{"title":"【译】异步：现在与将来（并行篇）","date":"2017-03-31T16:15:40.000Z","_content":"### 并行线程\n人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。\n\n进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。\n\n相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。\n\n并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。\n\n比如：\n```\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n```\n虽然 `later()` 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，`answer = answer * 2` 要先加载 `answer` 的当前值，接着把 `2` 放在某处，然后做乘法计算，然后取出结果，并把结果存回 `answer` 中。\n\n在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为\n线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。\n\n考虑：\n```\nvar a = 20;\n\nfunction foo() {\n\ta = a + 1;\n}\n\nfunction bar() {\n\ta = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n鉴于 JavaScript 的单线程特性，如果 `foo()` 在 `bar()` 之前运行， `a` 计算的结果为 `42`，但如果 `bar()` 在 `foo()`之前运行，`a` 的结果将是 `41`。\n\n如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， `foo()` 和 `bar()` 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。\n\n线程 1 （`X` 和 `Y` 是临时内存地址）\n```\nfoo():\n  a. load value of `a` in `X`\n  b. store `1` in `Y`\n  c. add `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n线程 2 （`X` 和 `Y` 是临时内存地址）\n```\nbar():\n  a. load value of `a` in `X`\n  b. store `2` in `Y`\n  c. multiply `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 `X` 和 `Y` 。\n\n如果上述步骤是这样的， `a` 的最终结果又是什么呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n1b  (store `1` in `Y`   ==> `1`)\n2b  (store `2` in `Y`   ==> `2`)\n1c  (add `X` and `Y`, store result in `X`   ==> `22`)\n1d  (store value of `X` in `a`   ==> `22`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `44`)\n2d  (store value of `X` in `a`   ==> `44`)\n```\n`a` 的结果将是 44。那这样排列呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n2b  (store `2` in `Y`   ==> `2`)\n1b  (store `1` in `Y`   ==> `1`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `20`)\n1c  (add `X` and `Y`, store result in `X`   ==> `21`)\n1d  (store value of `X` in `a`   ==> `21`)\n2d  (store value of `X` in `a`   ==> `21`)\n```\n`a` 的结果将是 21。\n\n所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。\n\nJavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？`foo()` 和 `bar()` 的相对排列顺序导致了不同的结果（41 或 42）。\n\n**注意**： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。\n\n### 完整运行\n由于 JavaScript 的单线程特性，`foo()` 和 `bar()` 内部的代码是原子的，这意味着一旦 `foo()` 开始运行，必须要等到这段代码全部执行完毕， `bar()` 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。\n\n事实上，如果 `foo()` 和 `bar()` 包含更多的代码，完整运行的语义会更清晰，比如：\n```\nvar a = 1;\nvar b = 2;\n\nfunction foo() {\n\ta++;\n\tb = b * a;\n\ta = b + 3;\n}\n\nfunction bar() {\n\tb--;\n\ta = 8 + b;\n\tb = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n因为 `foo()` 不能被 `bar()` 中断，`bar()` 也不能被 `foo()` 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 `foo()` 和 `bar()` 中的语句可以交替运行的话，可能输出结果的数量将大大增加！\n\n块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。\n\n块 1：\n```\nvar a = 1;\nvar b = 2;\n```\n块 2（`foo()`）：\n```\na++;\nb = b * a;\na = b + 3;\n```\n块 3（`bar()`）：\n```\nb--;\na = 8 + b;\nb = a * 2;\n```\n块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：\n\n输出 1：\n```\nvar a = 1;\nvar b = 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\na; // 11\nb; // 22\n```\n输出 2：\n```\nvar a = 1;\nvar b = 2;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\na; // 183\nb; // 180\n```\n同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。\n\n在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。\n\n**注意：** 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！\n\n---------\n本系列下一部分将介绍 “并发”\n","source":"_posts/【译】异步：现在与将来（并行篇）.md","raw":"---\ntitle: '【译】异步：现在与将来（并行篇）'\ndate: 2017-04-01 00:15:40\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n### 并行线程\n人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。\n\n进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。\n\n相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。\n\n并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。\n\n比如：\n```\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n```\n虽然 `later()` 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，`answer = answer * 2` 要先加载 `answer` 的当前值，接着把 `2` 放在某处，然后做乘法计算，然后取出结果，并把结果存回 `answer` 中。\n\n在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为\n线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。\n\n考虑：\n```\nvar a = 20;\n\nfunction foo() {\n\ta = a + 1;\n}\n\nfunction bar() {\n\ta = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n鉴于 JavaScript 的单线程特性，如果 `foo()` 在 `bar()` 之前运行， `a` 计算的结果为 `42`，但如果 `bar()` 在 `foo()`之前运行，`a` 的结果将是 `41`。\n\n如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， `foo()` 和 `bar()` 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。\n\n线程 1 （`X` 和 `Y` 是临时内存地址）\n```\nfoo():\n  a. load value of `a` in `X`\n  b. store `1` in `Y`\n  c. add `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n线程 2 （`X` 和 `Y` 是临时内存地址）\n```\nbar():\n  a. load value of `a` in `X`\n  b. store `2` in `Y`\n  c. multiply `X` and `Y`, store result in `X`\n  d. store value of `X` in `a`\n```\n现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 `X` 和 `Y` 。\n\n如果上述步骤是这样的， `a` 的最终结果又是什么呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n1b  (store `1` in `Y`   ==> `1`)\n2b  (store `2` in `Y`   ==> `2`)\n1c  (add `X` and `Y`, store result in `X`   ==> `22`)\n1d  (store value of `X` in `a`   ==> `22`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `44`)\n2d  (store value of `X` in `a`   ==> `44`)\n```\n`a` 的结果将是 44。那这样排列呢？\n```\n1a  (load value of `a` in `X`   ==> `20`)\n2a  (load value of `a` in `X`   ==> `20`)\n2b  (store `2` in `Y`   ==> `2`)\n1b  (store `1` in `Y`   ==> `1`)\n2c  (multiply `X` and `Y`, store result in `X`   ==> `20`)\n1c  (add `X` and `Y`, store result in `X`   ==> `21`)\n1d  (store value of `X` in `a`   ==> `21`)\n2d  (store value of `X` in `a`   ==> `21`)\n```\n`a` 的结果将是 21。\n\n所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。\n\nJavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？`foo()` 和 `bar()` 的相对排列顺序导致了不同的结果（41 或 42）。\n\n**注意**： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。\n\n### 完整运行\n由于 JavaScript 的单线程特性，`foo()` 和 `bar()` 内部的代码是原子的，这意味着一旦 `foo()` 开始运行，必须要等到这段代码全部执行完毕， `bar()` 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。\n\n事实上，如果 `foo()` 和 `bar()` 包含更多的代码，完整运行的语义会更清晰，比如：\n```\nvar a = 1;\nvar b = 2;\n\nfunction foo() {\n\ta++;\n\tb = b * a;\n\ta = b + 3;\n}\n\nfunction bar() {\n\tb--;\n\ta = 8 + b;\n\tb = a * 2;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n因为 `foo()` 不能被 `bar()` 中断，`bar()` 也不能被 `foo()` 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 `foo()` 和 `bar()` 中的语句可以交替运行的话，可能输出结果的数量将大大增加！\n\n块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。\n\n块 1：\n```\nvar a = 1;\nvar b = 2;\n```\n块 2（`foo()`）：\n```\na++;\nb = b * a;\na = b + 3;\n```\n块 3（`bar()`）：\n```\nb--;\na = 8 + b;\nb = a * 2;\n```\n块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：\n\n输出 1：\n```\nvar a = 1;\nvar b = 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\na; // 11\nb; // 22\n```\n输出 2：\n```\nvar a = 1;\nvar b = 2;\n\n// bar()\nb--;\na = 8 + b;\nb = a * 2;\n\n// foo()\na++;\nb = b * a;\na = b + 3;\n\na; // 183\nb; // 180\n```\n同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。\n\n在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。\n\n**注意：** 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！\n\n---------\n本系列下一部分将介绍 “并发”\n","slug":"【译】异步：现在与将来（并行篇）","published":1,"updated":"2019-06-16T14:11:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8h002ehns64wcocvrf","content":"<h3 id=\"并行线程\"><a href=\"#并行线程\" class=\"headerlink\" title=\"并行线程\"></a>并行线程</h3><p>人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。</p>\n<p>进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。</p>\n<p>相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。</p>\n<p>并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。</p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然 <code>later()</code> 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，<code>answer = answer * 2</code> 要先加载 <code>answer</code> 的当前值，接着把 <code>2</code> 放在某处，然后做乘法计算，然后取出结果，并把结果存回 <code>answer</code> 中。</p>\n<p>在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为<br>线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。</p>\n<p>考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta = a + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\ta = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>鉴于 JavaScript 的单线程特性，如果 <code>foo()</code> 在 <code>bar()</code> 之前运行， <code>a</code> 计算的结果为 <code>42</code>，但如果 <code>bar()</code> 在 <code>foo()</code>之前运行，<code>a</code> 的结果将是 <code>41</code>。</p>\n<p>如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， <code>foo()</code> 和 <code>bar()</code> 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。</p>\n<p>线程 1 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `1` in `Y`</span><br><span class=\"line\">  c. add `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>线程 2 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bar():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `2` in `Y`</span><br><span class=\"line\">  c. multiply `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 <code>X</code> 和 <code>Y</code> 。</p>\n<p>如果上述步骤是这样的， <code>a</code> 的最终结果又是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `22`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `22`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `44`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `44`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 44。那这样排列呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `20`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `21`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `21`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `21`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 21。</p>\n<p>所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。</p>\n<p>JavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？<code>foo()</code> 和 <code>bar()</code> 的相对排列顺序导致了不同的结果（41 或 42）。</p>\n<p><strong>注意</strong>： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。</p>\n<h3 id=\"完整运行\"><a href=\"#完整运行\" class=\"headerlink\" title=\"完整运行\"></a>完整运行</h3><p>由于 JavaScript 的单线程特性，<code>foo()</code> 和 <code>bar()</code> 内部的代码是原子的，这意味着一旦 <code>foo()</code> 开始运行，必须要等到这段代码全部执行完毕， <code>bar()</code> 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。</p>\n<p>事实上，如果 <code>foo()</code> 和 <code>bar()</code> 包含更多的代码，完整运行的语义会更清晰，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta++;</span><br><span class=\"line\">\tb = b * a;</span><br><span class=\"line\">\ta = b + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\tb--;</span><br><span class=\"line\">\ta = 8 + b;</span><br><span class=\"line\">\tb = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>因为 <code>foo()</code> 不能被 <code>bar()</code> 中断，<code>bar()</code> 也不能被 <code>foo()</code> 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 <code>foo()</code> 和 <code>bar()</code> 中的语句可以交替运行的话，可能输出结果的数量将大大增加！</p>\n<p>块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。</p>\n<p>块 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2（<code>foo()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br></pre></td></tr></table></figure></p>\n<p>块 3（<code>bar()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：</p>\n<p>输出 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 11</span><br><span class=\"line\">b; // 22</span><br></pre></td></tr></table></figure></p>\n<p>输出 2：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 183</span><br><span class=\"line\">b; // 180</span><br></pre></td></tr></table></figure></p>\n<p>同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。</p>\n<p>在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。</p>\n<p><strong>注意：</strong> 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！</p>\n<hr>\n<p>本系列下一部分将介绍 “并发”</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"并行线程\"><a href=\"#并行线程\" class=\"headerlink\" title=\"并行线程\"></a>并行线程</h3><p>人们常常把 “异步” 和 “并行” 这两个术语混淆，但它们其实完全不同。记住，异步是关于 “现在” 和 “将来” 之间的间隙，而并行说的是能够同时发生的事情。</p>\n<p>进程和线程是并行计算最常用的工具。进程和线程独立运行，也可能同时运行：在多个独立的处理器上，或者多个独立的计算机上，而多线程可以在同一个进程上共享内存。</p>\n<p>相比之下，事件循环将工作分成多个任务，并串行执行它们，不允许对共享内存做并行访问和改变。通过独立线程中的相互协作的事件循环，并行化和 “串行化” 可以共存。</p>\n<p>并行线程的交错执行和异步事件的交错执行，其颗粒度是完全不同的。</p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然 <code>later()</code> 的全部内容会被作为一个事件循环队列的入口，然而考虑这段代码运行在一个线程上，实际上可能有许多不同的底层操作。比如，<code>answer = answer * 2</code> 要先加载 <code>answer</code> 的当前值，接着把 <code>2</code> 放在某处，然后做乘法计算，然后取出结果，并把结果存回 <code>answer</code> 中。</p>\n<p>在单线程环境下，线程队列中的这些项目是底层操作其实是无所谓的，因为<br>线程不能被中断。但如果你有一个并行系统，其中两个不同的线程在同一个程序中运行，你很可能得到意想不到的结果。</p>\n<p>考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta = a + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\ta = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>鉴于 JavaScript 的单线程特性，如果 <code>foo()</code> 在 <code>bar()</code> 之前运行， <code>a</code> 计算的结果为 <code>42</code>，但如果 <code>bar()</code> 在 <code>foo()</code>之前运行，<code>a</code> 的结果将是 <code>41</code>。</p>\n<p>如果共享相同数据的 JS 事件并行执行，那么问题就更加微妙了。考虑下面两列伪码， <code>foo()</code> 和 <code>bar()</code> 代码运行时所在的线程执行的是下面两列伪码，思考他们正好同一时刻运行会发生什么。</p>\n<p>线程 1 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `1` in `Y`</span><br><span class=\"line\">  c. add `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>线程 2 （<code>X</code> 和 <code>Y</code> 是临时内存地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bar():</span><br><span class=\"line\">  a. load value of `a` in `X`</span><br><span class=\"line\">  b. store `2` in `Y`</span><br><span class=\"line\">  c. multiply `X` and `Y`, store result in `X`</span><br><span class=\"line\">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>\n<p>现在，让我们假设这两个线程真的在并行运行。你可能会发现问题所在，对吗？它们在临时步骤中使用了共享的内存地址 <code>X</code> 和 <code>Y</code> 。</p>\n<p>如果上述步骤是这样的， <code>a</code> 的最终结果又是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `22`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `22`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `44`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `44`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 44。那这样排列呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class=\"line\">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class=\"line\">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class=\"line\">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `20`)</span><br><span class=\"line\">1c  (add `X` and `Y`, store result in `X`   ==&gt; `21`)</span><br><span class=\"line\">1d  (store value of `X` in `a`   ==&gt; `21`)</span><br><span class=\"line\">2d  (store value of `X` in `a`   ==&gt; `21`)</span><br></pre></td></tr></table></figure></p>\n<p><code>a</code> 的结果将是 21。</p>\n<p>所以，多线程编程是相当复杂的，因为如果你不采取特殊步骤去防止此类冲突和交错的发生的话，你会的到非常意外的不确定的结果，这常常让人头痛不已。</p>\n<p>JavaScript 从不跨线程共享数据，这意味着我们不需要担心上述的不确定性。但也不意味着 JS 总是确定的。还记得前面提到的吗？<code>foo()</code> 和 <code>bar()</code> 的相对排列顺序导致了不同的结果（41 或 42）。</p>\n<p><strong>注意</strong>： 可能至今还不明显，但不是所有的不确定性都是有害的。它有时无关紧要，有时是我们刻意而为的。通过本章节的接下来的一些章节，我们将看到更多的这方面的例子。</p>\n<h3 id=\"完整运行\"><a href=\"#完整运行\" class=\"headerlink\" title=\"完整运行\"></a>完整运行</h3><p>由于 JavaScript 的单线程特性，<code>foo()</code> 和 <code>bar()</code> 内部的代码是原子的，这意味着一旦 <code>foo()</code> 开始运行，必须要等到这段代码全部执行完毕， <code>bar()</code> 中的代码才能开始运行，反之亦然。这被称为 “完整运行” 行为。</p>\n<p>事实上，如果 <code>foo()</code> 和 <code>bar()</code> 包含更多的代码，完整运行的语义会更清晰，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\ta++;</span><br><span class=\"line\">\tb = b * a;</span><br><span class=\"line\">\ta = b + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">\tb--;</span><br><span class=\"line\">\ta = 8 + b;</span><br><span class=\"line\">\tb = a * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>因为 <code>foo()</code> 不能被 <code>bar()</code> 中断，<code>bar()</code> 也不能被 <code>foo()</code> 中断，所以这个程序只有两种可能的输出，这取决于哪个先运行——如果存在多线程，而且 <code>foo()</code> 和 <code>bar()</code> 中的语句可以交替运行的话，可能输出结果的数量将大大增加！</p>\n<p>块 1 是同步的（当前执行），但 块 2 和 3 是异步的（将来执行），这意味着他们的执行在时间上是分割的。</p>\n<p>块 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2（<code>foo()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br></pre></td></tr></table></figure></p>\n<p>块 3（<code>bar()</code>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br></pre></td></tr></table></figure></p>\n<p>块 2 和 块 3 的执行顺序不确定，所以这段程序有两个可能的输出，如下所示：</p>\n<p>输出 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 11</span><br><span class=\"line\">b; // 22</span><br></pre></td></tr></table></figure></p>\n<p>输出 2：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">var b = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// bar()</span><br><span class=\"line\">b--;</span><br><span class=\"line\">a = 8 + b;</span><br><span class=\"line\">b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo()</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b = b * a;</span><br><span class=\"line\">a = b + 3;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // 183</span><br><span class=\"line\">b; // 180</span><br></pre></td></tr></table></figure></p>\n<p>同一段代码有两种输出，这意味着仍然存在着不确定性！但这种不确定性是函数（事件）顺序级别的，而不是多线程下的语句顺序级别（或者说，其实是表达式执行顺序级别）。换句话说，这比多线程还是要确定的多。</p>\n<p>在 JavaScript 的特性中，这种函数顺序不确定性就是通常所说的 “竞态条件”，因为 foo() 和 bar() 在相互竞争，来看看谁先运行。具体来说，正因为无法可靠预测 a 和 b 的计算结果，所以它才是 “竞态条件”。</p>\n<p><strong>注意：</strong> 如果 JS 中有个函数，它无论如何也不具备完全执行的特性，我们会有更多种可能的输出，对吧？ES6 就引入了这样一个东西（见第四章 “Generators”），但现在别担心，我们以后会介绍这一部分的！</p>\n<hr>\n<p>本系列下一部分将介绍 “并发”</p>\n"},{"title":"【译】真实的 Virtual DOM","date":"2016-09-08T09:51:03.000Z","_content":"# 为什么我们需要UI框架？\n　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。\n　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。\n　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。\n\n# 什么让React与众不同？\n　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。\n　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。\n\n# DOM很慢？\n　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。\n　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。\n那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。\n\n# Virtual DOM如何工作？\n　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。\n　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：\n**1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。**\n**2. 重新计算比较出新的和之前的Virtual DOM的差异。**\n**3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。**\n\n# Virtual DOM慢吗？\n　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。\n　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。\n　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。\n　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。\n　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。\n\n# 我们来看一些数字\n　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。\n　举个使用原生JS操作DOM的“Hello，world！”的例子：\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello JavaScript!</title>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    document.getElementById(\"example\").innerHTML = \"<h1>Hello, world!</h1>\";\n  </script>\n</body>\n</html>\n```\n　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\" />\n<title>Hello React!</title>\n<script src=\"build/react.js\"></script>\n<script src=\"build/react-dom.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script type=\"text/babel\">\n    ReactDOM.render(\n      <h1>Hello, world!</h1>,    \n      document.getElementById('example')\n    );\n  </script>\n</body>\n</html>\n```\n原生操作DOM总是会更快。我们来看一下证明过程。\n这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）\n\n![原生DOM操作](https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/1.png)\n这是加载和渲染React“Hello，World”页面的timeline（chrome）\n\n![React DOM操作](https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/2.png)\nReact花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello jQuery!</title>\n  <script type=\"text/javascript\" src=\"scripts/vendor/jquery-1.12.3.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    $(document).ready(function(){\n      $(\"#example\").html(\"<h1>Hello, world!</h1>\"); }\n    );\n  </script>\n</body>\n</html>\n```\n\n![jQuery DOM操作](https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/3.png)\n　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。\n\n# 如何使用Virtual DOM\n　\"Hello,World\"例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。\n　**数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处**。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。\n　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。\n　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动--这可以节省大量的资源，显著地提升应用的性能。\n　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是**主要还是取决于你如何更好的优化应用。**\n　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。**这就是React带来的真正好处--性能和生产力**。\n\n--------------\n\n原文作者：[Chris Minnick](https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/)\n翻译：[熊贤仁](https://blog.skrskrskrskr.com)\n","source":"_posts/【译】真实的Virtual-DOM.md","raw":"---\ntitle: 【译】真实的 Virtual DOM\ndate: 2016-09-08 17:51:03\ntags:\n- JavaScript\n- React\n- 翻译\ncategories:\n- 前端\n---\n# 为什么我们需要UI框架？\n　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。\n　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。\n　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。\n\n# 什么让React与众不同？\n　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。\n　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。\n\n# DOM很慢？\n　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。\n　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。\n那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。\n\n# Virtual DOM如何工作？\n　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。\n　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：\n**1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。**\n**2. 重新计算比较出新的和之前的Virtual DOM的差异。**\n**3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。**\n\n# Virtual DOM慢吗？\n　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。\n　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。\n　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。\n　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。\n　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。\n\n# 我们来看一些数字\n　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。\n　举个使用原生JS操作DOM的“Hello，world！”的例子：\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello JavaScript!</title>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    document.getElementById(\"example\").innerHTML = \"<h1>Hello, world!</h1>\";\n  </script>\n</body>\n</html>\n```\n　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\" />\n<title>Hello React!</title>\n<script src=\"build/react.js\"></script>\n<script src=\"build/react-dom.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script type=\"text/babel\">\n    ReactDOM.render(\n      <h1>Hello, world!</h1>,    \n      document.getElementById('example')\n    );\n  </script>\n</body>\n</html>\n```\n原生操作DOM总是会更快。我们来看一下证明过程。\n这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）\n\n![原生DOM操作](https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/1.png)\n这是加载和渲染React“Hello，World”页面的timeline（chrome）\n\n![React DOM操作](https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/2.png)\nReact花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？\n```\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hello jQuery!</title>\n  <script type=\"text/javascript\" src=\"scripts/vendor/jquery-1.12.3.min.js\"></script>\n</head>\n<body>\n  <div id=\"example\"></div>\n  <script>\n    $(document).ready(function(){\n      $(\"#example\").html(\"<h1>Hello, world!</h1>\"); }\n    );\n  </script>\n</body>\n</html>\n```\n\n![jQuery DOM操作](https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/3.png)\n　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。\n\n# 如何使用Virtual DOM\n　\"Hello,World\"例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。\n　**数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处**。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。\n　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。\n　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动--这可以节省大量的资源，显著地提升应用的性能。\n　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是**主要还是取决于你如何更好的优化应用。**\n　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。**这就是React带来的真正好处--性能和生产力**。\n\n--------------\n\n原文作者：[Chris Minnick](https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/)\n翻译：[熊贤仁](https://blog.skrskrskrskr.com)\n","slug":"【译】真实的Virtual-DOM","published":1,"updated":"2019-12-29T11:28:13.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8j002ihns6u29c5vz9","content":"<h1 id=\"为什么我们需要UI框架？\"><a href=\"#为什么我们需要UI框架？\" class=\"headerlink\" title=\"为什么我们需要UI框架？\"></a>为什么我们需要UI框架？</h1><p>　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。<br>　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。<br>　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。</p>\n<h1 id=\"什么让React与众不同？\"><a href=\"#什么让React与众不同？\" class=\"headerlink\" title=\"什么让React与众不同？\"></a>什么让React与众不同？</h1><p>　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。<br>　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。</p>\n<h1 id=\"DOM很慢？\"><a href=\"#DOM很慢？\" class=\"headerlink\" title=\"DOM很慢？\"></a>DOM很慢？</h1><p>　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。<br>　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。<br>那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。</p>\n<h1 id=\"Virtual-DOM如何工作？\"><a href=\"#Virtual-DOM如何工作？\" class=\"headerlink\" title=\"Virtual DOM如何工作？\"></a>Virtual DOM如何工作？</h1><p>　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。<br>　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：<br><strong>1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。</strong><br><strong>2. 重新计算比较出新的和之前的Virtual DOM的差异。</strong><br><strong>3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。</strong></p>\n<h1 id=\"Virtual-DOM慢吗？\"><a href=\"#Virtual-DOM慢吗？\" class=\"headerlink\" title=\"Virtual DOM慢吗？\"></a>Virtual DOM慢吗？</h1><p>　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。<br>　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。<br>　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。<br>　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。<br>　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。</p>\n<h1 id=\"我们来看一些数字\"><a href=\"#我们来看一些数字\" class=\"headerlink\" title=\"我们来看一些数字\"></a>我们来看一些数字</h1><p>　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。<br>　举个使用原生JS操作DOM的“Hello，world！”的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello JavaScript!&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&quot;example&quot;).innerHTML = &quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;Hello React!&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">    ReactDOM.render(</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!&lt;/h1&gt;,    </span><br><span class=\"line\">      document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>原生操作DOM总是会更快。我们来看一下证明过程。<br>这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/1.png\" alt=\"原生DOM操作\"><br>这是加载和渲染React“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/2.png\" alt=\"React DOM操作\"><br>React花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello jQuery!&lt;/title&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot; src=&quot;scripts/vendor/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    $(document).ready(function()&#123;</span><br><span class=\"line\">      $(&quot;#example&quot;).html(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;); &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/3.png\" alt=\"jQuery DOM操作\"><br>　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。</p>\n<h1 id=\"如何使用Virtual-DOM\"><a href=\"#如何使用Virtual-DOM\" class=\"headerlink\" title=\"如何使用Virtual DOM\"></a>如何使用Virtual DOM</h1><p>　“Hello,World”例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。<br>　<strong>数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处</strong>。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。<br>　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。<br>　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动–这可以节省大量的资源，显著地提升应用的性能。<br>　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是<strong>主要还是取决于你如何更好的优化应用。</strong><br>　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。<strong>这就是React带来的真正好处–性能和生产力</strong>。</p>\n<hr>\n<p>原文作者：<a href=\"https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/\" target=\"_blank\" rel=\"noopener\">Chris Minnick</a><br>翻译：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么我们需要UI框架？\"><a href=\"#为什么我们需要UI框架？\" class=\"headerlink\" title=\"为什么我们需要UI框架？\"></a>为什么我们需要UI框架？</h1><p>　响应式编程提出两个最重要的观点是：系统应该是事件驱动并且响应状态的变化。<br>　DOM的UI组件有自己的内部状态，更新浏览器页面并不是在发生变化后简单的重新生成DOM。如果Gmail这样做的话，出现一条新消息或者删掉你写的邮件，就会导致整个浏览器窗口刷新。<br>　正是因为DOM的无状态性，我们才需要类似key/value observation(Ember中使用了它)，或者脏值检查（Angular）。UI框架监听数据模型的变化，并在DOM中更新对应的部分。或者监听DOM的变化，更新对应的数据模型。这就是所谓的双向数据绑定。它通常可以处理非常复杂的UI逻辑。</p>\n<h1 id=\"什么让React与众不同？\"><a href=\"#什么让React与众不同？\" class=\"headerlink\" title=\"什么让React与众不同？\"></a>什么让React与众不同？</h1><p>　令React以及它的Virtual DOM如此与众不同的是：它比其他实现JavaScript响应数据的方法都更简单。你只需写JavaScript去更新React组件，React会帮你更新DOM。数据绑定并没有和应用缠在一起。<br>　React使用单向数据绑定来简化这一过程。每次当你在一个React组件的input文本框中输入时，它并不会直接改变这个组件的状态，而是更新数据模型。这会使得UI被更新，你输入的文本就会出现在文本框里。</p>\n<h1 id=\"DOM很慢？\"><a href=\"#DOM很慢？\" class=\"headerlink\" title=\"DOM很慢？\"></a>DOM很慢？</h1><p>　所有关于Virtual DOM的文章或演讲都在说JavaScript引擎很快，读写浏览器的DOM很慢。这种说法完全不对。DOM是很快的。添加删除DOM节点并不比在JavaScript对象上设置属性慢很多，只是简单的运算罢了。<br>　然而，真正慢的是当DOM改变时浏览器的layout。DOM的每次改变，浏览器都需要重新计算CSS，重排重绘整个页面。这是很耗时的。<br>那些写浏览器的人一直在努力缩短重绘的时间，其中最大的工作是最小化、分批处理DOM改变。</p>\n<h1 id=\"Virtual-DOM如何工作？\"><a href=\"#Virtual-DOM如何工作？\" class=\"headerlink\" title=\"Virtual DOM如何工作？\"></a>Virtual DOM如何工作？</h1><p>　就像真实的DOM，Virtual DOM也是一颗节点树。节点树上元素是对象，attribute和内容是对象的属性。React的render方法从组件上创建一颗节点树，在action触发数据模型发生mutation后响应式的更新节点树。<br>　每次在数据改变之后，就会在UI更新之前创建一个新的Virtual DOM。在React中，更新浏览器的DOM分三个步骤：<br><strong>1. 只要数据发生改变，就会重新生成一个完整的Virtual DOM。</strong><br><strong>2. 重新计算比较出新的和之前的Virtual DOM的差异。</strong><br><strong>3. 更新真实DOM中真正发生改变的部分，就像是给DOM打了个补丁。</strong></p>\n<h1 id=\"Virtual-DOM慢吗？\"><a href=\"#Virtual-DOM慢吗？\" class=\"headerlink\" title=\"Virtual DOM慢吗？\"></a>Virtual DOM慢吗？</h1><p>　我们可以想到每次改变都重新渲染整个Virtual DOM是很浪费的，却没有注意到任意时刻React都在内存中保存了两个Virtual DOM。但是，其实渲染Virtual DOM总是会比渲染真实DOM快，这跟你使用的浏览器无关。<br>　问题是用户并不能看到Virtual DOM。就好比你在其他国家有10000个墨西哥煎玉米卷，你迟早需要把玉米卷运回来，那会很贵并且缓慢。<br>　玉米卷问题的关键在于：一次把所有玉米卷运回来更快，还是计算出你需要的数量和你实际拥有的数量，然后仅仅运输两者最小值更快？当你只想要4个玉米卷的时候，当然只运输4个更划算。<br>　下一个问题是：你如何预定玉米卷？你可以说，“给我运送4个玉米卷”，或者说，“这是我的玉米卷状态清单，你计算出实际结果吧”。第二个方法就是Virtual DOM工作的方式。你写代码来让UI知道你想让他如何展示，Virtual DOM计算出当前UI和它只需要更新的部分的差异。<br>　React像变戏法般的将attribute加到元素上，然后在DOM Diff后决定需要更新的部分，并在文档上单独的修改这些元素。Virtual DOM加入了额外的步骤，但是它创造了一种优雅的方式去对页面做最小的更新。</p>\n<h1 id=\"我们来看一些数字\"><a href=\"#我们来看一些数字\" class=\"headerlink\" title=\"我们来看一些数字\"></a>我们来看一些数字</h1><p>　我不打算做标准的测试。其他人做的各种各样的测试已经证明了React的Virtual DOM更快。Virtual DOM在开发者对浏览器的性能优化之上加了一层脚本。这个额外的一层抽象使React相比其他更新DOM的方法，需要更多的CPU密集计算。<br>　举个使用原生JS操作DOM的“Hello，world！”的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello JavaScript!&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&quot;example&quot;).innerHTML = &quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>　你在React中也会做同样的事。我们需要通过React、React DOM和babel，将看起来像是XML的代码在render()方法中转换成普通的JavaScript对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;Hello React!&lt;/title&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">    ReactDOM.render(</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!&lt;/h1&gt;,    </span><br><span class=\"line\">      document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>原生操作DOM总是会更快。我们来看一下证明过程。<br>这是加载和渲染直接DOM操作的“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/1.png\" alt=\"原生DOM操作\"><br>这是加载和渲染React“Hello，World”页面的timeline（chrome）</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/2.png\" alt=\"React DOM操作\"><br>React花了大量时间在scripting上，React比直接操作DOM慢的多。但是，它和jQuery比怎么样？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">  &lt;title&gt;Hello jQuery!&lt;/title&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot; src=&quot;scripts/vendor/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    $(document).ready(function()&#123;</span><br><span class=\"line\">      $(&quot;#example&quot;).html(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;); &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/virtual-dom/3.png\" alt=\"jQuery DOM操作\"><br>　jQuery的总时间比原生JS慢了50ms，但都比React快3倍。显然，原生JS和jQuery要快得多。一般来说，使用框架都比不使用框架慢。实际操作DOM前在内存中创建一个表示DOM的结构比直接操作DOM要慢。下面，我们讨论一下究竟该如何让Virtual DOM更快。</p>\n<h1 id=\"如何使用Virtual-DOM\"><a href=\"#如何使用Virtual-DOM\" class=\"headerlink\" title=\"如何使用Virtual DOM\"></a>如何使用Virtual DOM</h1><p>　“Hello,World”例子对React不公正，因为他们仅仅包含了一个页面的初始渲染。React长于管理页面的更新。<br>　<strong>数据模型的每一次改变都会触发Virtual DOM的重新生成，这就是React和其他框架的不同之处</strong>。其他框架会检测文档的变化，只更新必要的部分。Virtual DOM通常占用更少的内存，因为它不需要在内存中常驻观察者。<br>　但是，每次改动发生后都比较两个完整的Virtual DOM是低效的。复杂的UI对于CPU的要求也很高。<br>　鉴于这个原因，React开发者要主动决定需要渲染的内容。如果你知道某个行为不会影响对应的组件，你应当告知React不要去分析组件的变动–这可以节省大量的资源，显著地提升应用的性能。<br>　事实上，可能没有办法真正说明使用Virtual DOM比直接操作DOM快，因为要做这种比较需要考虑各种各样的因素。但是<strong>主要还是取决于你如何更好的优化应用。</strong><br>　工具只是工具，关键看你怎么用它。React和Virtual DOM带给我们的是：一种更新页面的简单方法。这种简化能让我们摆脱繁杂的工作，使优化UI变得简单。<strong>这就是React带来的真正好处–性能和生产力</strong>。</p>\n<hr>\n<p>原文作者：<a href=\"https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/\" target=\"_blank\" rel=\"noopener\">Chris Minnick</a><br>翻译：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n"},{"title":"一个优化的快速排序","date":"2016-04-17T07:59:49.000Z","_content":"快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。\n\n一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。\n\nJavaScript实现代码如下：\n```\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\n//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头\nArray.prototype.partionMedianOfThree = function(start,end){\n    var mid = Math.floor(start+(end-start)/2);\n    if(this[start]>this[end]){\n        this.swap(start,end);\n    }\n    if(this[mid]>this[end]){\n        this.swap(mid,end);\n    }\n    if(this[mid]>this[start]){\n        this.swap(mid,start);\n    }\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    this.partionMedianOfThree(start,end);\n    var pivotIdx = start;\n    var pivot = this[pivotIdx];\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n           //比轴值小则交换\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    //递归地对子数组进行排序\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\n\n```\n测试一下算法的性能：\n```\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort1(0,arr.length-1);\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:227ms\n```","source":"_posts/一个优化的快速排序.md","raw":"---\ntitle: 一个优化的快速排序\ndate: 2016-04-17 15:59:49\ntags:\n- JavaScript\n- 算法\ncategories:\n- 数据结构与算法\n---\n快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。\n\n一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。\n\nJavaScript实现代码如下：\n```\nArray.prototype.swap = function (i, j) {\n  var t = this[i];\n  this[i] = this[j];\n  this[j] = t;\n};\n//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头\nArray.prototype.partionMedianOfThree = function(start,end){\n    var mid = Math.floor(start+(end-start)/2);\n    if(this[start]>this[end]){\n        this.swap(start,end);\n    }\n    if(this[mid]>this[end]){\n        this.swap(mid,end);\n    }\n    if(this[mid]>this[start]){\n        this.swap(mid,start);\n    }\n};\nArray.prototype.quickSortHelper = function(start,end){\n    if(start>=end){\n        return;\n    }\n    this.partionMedianOfThree(start,end);\n    var pivotIdx = start;\n    var pivot = this[pivotIdx];\n    var i = start+1;\n    var n = end;\n    while(i<=n){\n        if(this[i] < pivot){\n           //比轴值小则交换\n            this.swap(pivotIdx,i);\n            i++;\n            pivotIdx = i;\n        }else{\n            this.swap(n,i);\n            n--;\n        }\n    }\n    //递归地对子数组进行排序\n    this.quickSortHelper(start,pivotIdx-1);\n    this.quickSortHelper(pivotIdx+1,end);\n}\nArray.prototype.quickSort = function () {\n  this.quickSortHelper(0, this.length-1);\n};\n\n```\n测试一下算法的性能：\n```\nfunction test () {\n    var arr = [];\n    for (var i = 0; i < 1000000; i++) {\n        arr.push(Math.round(Math.random(i) * 10000));\n    }\n    doTest(arr, 1);\n}\nfunction doTest(arr, n) {\n    var tStart = (new Date()).getTime();\n    var re = arr.quickSort1(0,arr.length-1);\n    var tEnd = (new Date()).getTime();\n    console.log('快速排序使用时间是:' + (tEnd - tStart) + 'ms');\n    return re;\n}\ntest();//输出：快速排序使用时间是:227ms\n```","slug":"一个优化的快速排序","published":1,"updated":"2019-06-16T14:11:37.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8l002lhns6ck86lk4y","content":"<p>快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。</p>\n<p>一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。</p>\n<p>JavaScript实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头</span><br><span class=\"line\">Array.prototype.partionMedianOfThree = function(start,end)&#123;</span><br><span class=\"line\">    var mid = Math.floor(start+(end-start)/2);</span><br><span class=\"line\">    if(this[start]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(start,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(mid,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[start])&#123;</span><br><span class=\"line\">        this.swap(mid,start);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.partionMedianOfThree(start,end);</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var pivot = this[pivotIdx];</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">           //比轴值小则交换</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //递归地对子数组进行排序</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下算法的性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort1(0,arr.length-1);</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:227ms</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>快速排序是一个最差时间复杂度为O(n²)的排序算法，这种情况通常出现在选择的轴值(pivot)不能将数组划分为两个长度相等的子数组的时候，比如数组逆序排列的时候，如果选择第一个数作为轴值，划分的子数组的大小分别为0和n-1，此时算法的性能最差。</p>\n<p>一个较好的办法是“三数取中”，查看当前数组的第一个、中间一个和最后一个位置的数组，取其中位数，以此来降低轴值选择得不好的可能性。</p>\n<p>JavaScript实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.swap = function (i, j) &#123;</span><br><span class=\"line\">  var t = this[i];</span><br><span class=\"line\">  this[i] = this[j];</span><br><span class=\"line\">  this[j] = t;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//三数取中，将开头、中间、结尾三个数中间那个数交换到数组开头</span><br><span class=\"line\">Array.prototype.partionMedianOfThree = function(start,end)&#123;</span><br><span class=\"line\">    var mid = Math.floor(start+(end-start)/2);</span><br><span class=\"line\">    if(this[start]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(start,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[end])&#123;</span><br><span class=\"line\">        this.swap(mid,end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(this[mid]&gt;this[start])&#123;</span><br><span class=\"line\">        this.swap(mid,start);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Array.prototype.quickSortHelper = function(start,end)&#123;</span><br><span class=\"line\">    if(start&gt;=end)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.partionMedianOfThree(start,end);</span><br><span class=\"line\">    var pivotIdx = start;</span><br><span class=\"line\">    var pivot = this[pivotIdx];</span><br><span class=\"line\">    var i = start+1;</span><br><span class=\"line\">    var n = end;</span><br><span class=\"line\">    while(i&lt;=n)&#123;</span><br><span class=\"line\">        if(this[i] &lt; pivot)&#123;</span><br><span class=\"line\">           //比轴值小则交换</span><br><span class=\"line\">            this.swap(pivotIdx,i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            pivotIdx = i;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            this.swap(n,i);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //递归地对子数组进行排序</span><br><span class=\"line\">    this.quickSortHelper(start,pivotIdx-1);</span><br><span class=\"line\">    this.quickSortHelper(pivotIdx+1,end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Array.prototype.quickSort = function () &#123;</span><br><span class=\"line\">  this.quickSortHelper(0, this.length-1);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>测试一下算法的性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        arr.push(Math.round(Math.random(i) * 10000));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123;</span><br><span class=\"line\">    var tStart = (new Date()).getTime();</span><br><span class=\"line\">    var re = arr.quickSort1(0,arr.length-1);</span><br><span class=\"line\">    var tEnd = (new Date()).getTime();</span><br><span class=\"line\">    console.log(&apos;快速排序使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;);</span><br><span class=\"line\">    return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();//输出：快速排序使用时间是:227ms</span><br></pre></td></tr></table></figure></p>\n"},{"title":"一个通用的事件监听器","date":"2016-04-29T10:03:38.000Z","_content":"```\ndefine(function(){\n    var Event = {\n        //页面加载完成后注册onload事件\n        readyEvent:function(fn){\n            if(fn == null){\n                fn = document;\n            }\n            var oldonload = window.onload;\n            if(typeof window.onload != 'function'){\n                window.onload = fn;\n            }else{\n                // 如果window.onload上已有事件绑定，则追加到它的后面\n                window.onload = function(){\n                    oldonload();\n                    fn();\n                }\n            }\n        },\n        bindEvent:function(target,type,handler){\n            if(target.addEventListener){\n                target.addEventListener(type,handler,false);\n            }else if(target.attachEvent){\n                target.attachEvent('on'+type,function(event){\n                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向\n                    return handler.call(target,event)\n                })\n            }else{\n                target['on'+type] = handler;\n            }\n        },\n        // 移除事件\n        removeEvent:function(target,type,handler){\n            if(target.removeEventListener){\n                target.removeEventListener(type,handler,false);\n            }else if(target.detachEvent){\n                target.detachEvent('on'+type,handler);\n            }else{\n                target['on'+type] = null;\n            }\n        },\n        // 阻止事件传播\n        stopPropagation:function(event){\n            if(event.stopPropagation){\n                event.stopPropagation();\n            }else{\n                event.cancelBubble = true;\n            }\n        },\n        // 取消事件默认行为\n        preventDefault:function(event){\n            if(event.preventDefault){\n                event.preventDefault();\n            }else{\n                event.returnValue = false;\n            }\n        },\n        // 获取事件目标\n        getTarget:function(event){\n            return event.target || event.srcElement;\n        },\n        // 获取事件对象的引用\n        getEvent:function(event){\n            var event = event || window.event;\n            if(!event){\n                // caller用于在函数内部获取调用getEvent的函数\n                var c = this.getEvent.caller;\n                while(c){\n                    event = c.arguments[0];\n                    if(event && Event == event.constructor){\n                        break;\n                    }\n                    c = c.caller;\n                }\n            }\n            return event;\n        }\n    }\n\n    return Event;\n})\n```\n\n\n\n","source":"_posts/一个通用的事件监听器.md","raw":"---\ntitle: 一个通用的事件监听器\ndate: 2016-04-29 18:03:38\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n```\ndefine(function(){\n    var Event = {\n        //页面加载完成后注册onload事件\n        readyEvent:function(fn){\n            if(fn == null){\n                fn = document;\n            }\n            var oldonload = window.onload;\n            if(typeof window.onload != 'function'){\n                window.onload = fn;\n            }else{\n                // 如果window.onload上已有事件绑定，则追加到它的后面\n                window.onload = function(){\n                    oldonload();\n                    fn();\n                }\n            }\n        },\n        bindEvent:function(target,type,handler){\n            if(target.addEventListener){\n                target.addEventListener(type,handler,false);\n            }else if(target.attachEvent){\n                target.attachEvent('on'+type,function(event){\n                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向\n                    return handler.call(target,event)\n                })\n            }else{\n                target['on'+type] = handler;\n            }\n        },\n        // 移除事件\n        removeEvent:function(target,type,handler){\n            if(target.removeEventListener){\n                target.removeEventListener(type,handler,false);\n            }else if(target.detachEvent){\n                target.detachEvent('on'+type,handler);\n            }else{\n                target['on'+type] = null;\n            }\n        },\n        // 阻止事件传播\n        stopPropagation:function(event){\n            if(event.stopPropagation){\n                event.stopPropagation();\n            }else{\n                event.cancelBubble = true;\n            }\n        },\n        // 取消事件默认行为\n        preventDefault:function(event){\n            if(event.preventDefault){\n                event.preventDefault();\n            }else{\n                event.returnValue = false;\n            }\n        },\n        // 获取事件目标\n        getTarget:function(event){\n            return event.target || event.srcElement;\n        },\n        // 获取事件对象的引用\n        getEvent:function(event){\n            var event = event || window.event;\n            if(!event){\n                // caller用于在函数内部获取调用getEvent的函数\n                var c = this.getEvent.caller;\n                while(c){\n                    event = c.arguments[0];\n                    if(event && Event == event.constructor){\n                        break;\n                    }\n                    c = c.caller;\n                }\n            }\n            return event;\n        }\n    }\n\n    return Event;\n})\n```\n\n\n\n","slug":"一个通用的事件监听器","published":1,"updated":"2019-06-16T14:11:37.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8o002ohns6zpmwdkla","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(function()&#123;</span><br><span class=\"line\">    var Event = &#123;</span><br><span class=\"line\">        //页面加载完成后注册onload事件</span><br><span class=\"line\">        readyEvent:function(fn)&#123;</span><br><span class=\"line\">            if(fn == null)&#123;</span><br><span class=\"line\">                fn = document;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var oldonload = window.onload;</span><br><span class=\"line\">            if(typeof window.onload != &apos;function&apos;)&#123;</span><br><span class=\"line\">                window.onload = fn;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                // 如果window.onload上已有事件绑定，则追加到它的后面</span><br><span class=\"line\">                window.onload = function()&#123;</span><br><span class=\"line\">                    oldonload();</span><br><span class=\"line\">                    fn();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.addEventListener)&#123;</span><br><span class=\"line\">                target.addEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.attachEvent)&#123;</span><br><span class=\"line\">                target.attachEvent(&apos;on&apos;+type,function(event)&#123;</span><br><span class=\"line\">                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向</span><br><span class=\"line\">                    return handler.call(target,event)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = handler;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 移除事件</span><br><span class=\"line\">        removeEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.removeEventListener)&#123;</span><br><span class=\"line\">                target.removeEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.detachEvent)&#123;</span><br><span class=\"line\">                target.detachEvent(&apos;on&apos;+type,handler);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 阻止事件传播</span><br><span class=\"line\">        stopPropagation:function(event)&#123;</span><br><span class=\"line\">            if(event.stopPropagation)&#123;</span><br><span class=\"line\">                event.stopPropagation();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.cancelBubble = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 取消事件默认行为</span><br><span class=\"line\">        preventDefault:function(event)&#123;</span><br><span class=\"line\">            if(event.preventDefault)&#123;</span><br><span class=\"line\">                event.preventDefault();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.returnValue = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件目标</span><br><span class=\"line\">        getTarget:function(event)&#123;</span><br><span class=\"line\">            return event.target || event.srcElement;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件对象的引用</span><br><span class=\"line\">        getEvent:function(event)&#123;</span><br><span class=\"line\">            var event = event || window.event;</span><br><span class=\"line\">            if(!event)&#123;</span><br><span class=\"line\">                // caller用于在函数内部获取调用getEvent的函数</span><br><span class=\"line\">                var c = this.getEvent.caller;</span><br><span class=\"line\">                while(c)&#123;</span><br><span class=\"line\">                    event = c.arguments[0];</span><br><span class=\"line\">                    if(event &amp;&amp; Event == event.constructor)&#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    c = c.caller;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return event;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Event;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(function()&#123;</span><br><span class=\"line\">    var Event = &#123;</span><br><span class=\"line\">        //页面加载完成后注册onload事件</span><br><span class=\"line\">        readyEvent:function(fn)&#123;</span><br><span class=\"line\">            if(fn == null)&#123;</span><br><span class=\"line\">                fn = document;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var oldonload = window.onload;</span><br><span class=\"line\">            if(typeof window.onload != &apos;function&apos;)&#123;</span><br><span class=\"line\">                window.onload = fn;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                // 如果window.onload上已有事件绑定，则追加到它的后面</span><br><span class=\"line\">                window.onload = function()&#123;</span><br><span class=\"line\">                    oldonload();</span><br><span class=\"line\">                    fn();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.addEventListener)&#123;</span><br><span class=\"line\">                target.addEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.attachEvent)&#123;</span><br><span class=\"line\">                target.attachEvent(&apos;on&apos;+type,function(event)&#123;</span><br><span class=\"line\">                    // IE attachEvent注册的事件作为函数调用，其this值是全局对象，需要用call来修改其指向</span><br><span class=\"line\">                    return handler.call(target,event)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = handler;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 移除事件</span><br><span class=\"line\">        removeEvent:function(target,type,handler)&#123;</span><br><span class=\"line\">            if(target.removeEventListener)&#123;</span><br><span class=\"line\">                target.removeEventListener(type,handler,false);</span><br><span class=\"line\">            &#125;else if(target.detachEvent)&#123;</span><br><span class=\"line\">                target.detachEvent(&apos;on&apos;+type,handler);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                target[&apos;on&apos;+type] = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 阻止事件传播</span><br><span class=\"line\">        stopPropagation:function(event)&#123;</span><br><span class=\"line\">            if(event.stopPropagation)&#123;</span><br><span class=\"line\">                event.stopPropagation();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.cancelBubble = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 取消事件默认行为</span><br><span class=\"line\">        preventDefault:function(event)&#123;</span><br><span class=\"line\">            if(event.preventDefault)&#123;</span><br><span class=\"line\">                event.preventDefault();</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                event.returnValue = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件目标</span><br><span class=\"line\">        getTarget:function(event)&#123;</span><br><span class=\"line\">            return event.target || event.srcElement;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 获取事件对象的引用</span><br><span class=\"line\">        getEvent:function(event)&#123;</span><br><span class=\"line\">            var event = event || window.event;</span><br><span class=\"line\">            if(!event)&#123;</span><br><span class=\"line\">                // caller用于在函数内部获取调用getEvent的函数</span><br><span class=\"line\">                var c = this.getEvent.caller;</span><br><span class=\"line\">                while(c)&#123;</span><br><span class=\"line\">                    event = c.arguments[0];</span><br><span class=\"line\">                    if(event &amp;&amp; Event == event.constructor)&#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    c = c.caller;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return event;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Event;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"什么是 TCP 连接的三次握手","date":"2016-03-09T05:46:12.000Z","_content":"第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认\n第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。\nTCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。\n","source":"_posts/什么是TCP连接的三次握手.md","raw":"---\ntitle: 什么是 TCP 连接的三次握手\ndate: 2016-03-09 13:46:12\ntags:\n- HTTP\ncategories:\n- 网络\n---\n第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认\n第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。\nTCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。\n","slug":"什么是TCP连接的三次握手","published":1,"updated":"2019-12-28T16:23:33.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8q002rhns6cs1jedtg","content":"<p>第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认<br>第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>\n<p>注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。<br>TCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第一次握手：客户端发送syn(syn=j)包到服务器；并进入SYN_SEND状态，等待服务器确认<br>第二次握手：服务器收到syn包，确认客户的SYN(ack=j+1),同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>\n<p>注意：三次握手中发送的包不包含数据，三次握手完毕，客户端和服务器才正式开始传送数据。<br>TCP连接一旦建立，在通信双方的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。</p>\n"},{"title":"你不知道的 eval","date":"2018-11-17T17:32:24.000Z","_content":"## 前言\neval() 是 JavaScript 中一个非常有用的函数，它可以一段代码字符串动态执行。然而各种编码规范和最佳实践都强烈抵制 eval，几乎将 eval 打入了死牢，大牛 Douglas Crockford 也在《JavaScript 语言精粹》一书中将 eval 视为 JavaScript 中糟粕。这篇文章将带大家重新认识这个函数，知道为什么不用它，以及为什么不得不用它。\n\n## eval 是什么\n在分析 eval 的利弊前，首先来认识一下它。在不清楚一项技术的情况下，就对它做出武断地评价，是有失公允的。 \n\neval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行。如果传入的参数不是字符串，它会原封不动地将其返回。eval 分为直接调用和间接调用两种，通常间接调用的性能会好于直接调用。\n\n直接调用时，eval 运行于其调用函数的作用域下；\n```\nvar context = 'outside';\n(function(){\n  var context = 'inside';\n  return eval('context');\n})();\n\n// return 'inside'\n```\n而间接调用时，eval 运行于全局作用域。\n```\nvar context = 'outside';\n(function(){\n  var context = 'inside';\n  geval = eval;\n  return geval('context');\n  \n  // 下面两种也属于间接调用\n  // return eval.call(null, 'context');\n  // return (1, eval)('context');\n})();\n\n// return 'outside'\n```\n因此，间接调用时，eval 并不会修改调用函数作用域内的任何东西。JS 解释器有 fast path 和 slow path 两种模式，当直接调用 eval 时，解释器处于 slow path。因为此时作用域是不可控的，需要监听整个作用域，不能应用 v8 的一些编译优化，相应的编译效率也会比 fast path 低。\n\n\n## 为什么不用 eval\n大家抵制 eval 的原因主要是以下几个原因：\n\n1. **降低性能**。具体原因上文已经提到了。网上一些文章甚至说 eval() 会拖慢性能 10 倍。\n2. **安全问题**。因为它的动态执行特性，给被求值的字符串赋予了太大的权力，于是大家担心可能因此导致 XSS 等攻击。\n3. **调试困难**。eval 就像一个黑盒，其执行的代码很难进行断点调试。\n\n鉴于以上各种原因，很多人说 eval 是 evil（魔鬼）。另外，eval 还有一些难兄难弟，比如 new Function, setTimeout, setInterval。它们也具备执行一段代码字符串的能力。\n**究其本质原因，还是因为 JS 赋予这个方法的权限太大了，作为新手很难驾驭它**，如果对 eval 没有很好地理解，很容易写出问题来。这有点像 C 语言中 goto 语句，同样是因为权限太大而被封杀的典范。\n\n## 被误解的 eval\n事实上，eval 一直在被误解，它可能是最强大的一个 JavaScript 函数，但却因为一些人的误用，而被开发者们打入了冷宫。接下来，我来根据上述被质疑最多的几个点，给出一点自己的看法。\n\n1. 关于 eval 会拖慢性能 10 倍这个点，出自 Mozila 工程师的演讲 [“Know Your Engines - How to make your JavaScript Fast”](https://www.slideshare.net/newmovie/know-yourengines-velocity2011/4-lost_in_an_instantfunction_f)。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-97e5c8ab319630c3.png)\n\n这是一个发布于 2011 年的演讲，时至今日，JS 引擎早已做了各种优化。我们来测试现在的 JS 引擎中，eval 的实际性能。依然使用上图作为测试用例，测试环境为 node v8.11.1，设 N 的值为 10000。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-fc057b2bb1edb308.png)\nBenchmark 跑出的数据来看，当 N = 10000 时，用了 eval 的 function 执行性能，相比没有 eval 的情况，慢了 3 倍多。\n将 N 的值设为 1000000，eval 的性能下降到 8 倍。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-a6970c681b262f83.png)\n\n从测试结果可知，eval 的确会拖慢函数执行性能，而且随着函数规模增大，性能也越慢。但是在一般情况下（N < 1000000），性能差异并没有 10 倍那么夸张。\n\n2. 关于 eval 会导致 XSS 攻击这点，问题并不在 eval，而在数据源。如果数据源本身就是不可靠的，即便你不用 eval，也可能出现 XSS。\n\n3. 至于第三点，eval 代码的确调试起来比较麻烦，但也不是完全没有办法。可以在 eval 创建的代码末尾添加一行 \"//@ sourceURL=name\" 就可以给这段代码命名（浏览器会特殊对待这种特殊形式的注释），这样它就会出现在 Sources 面板上，然后就可以设置断点调试了。\n\n\n## 真香警告\n虽然大家嘴上说不要用，但是 eval 用起来却是真香。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-714d2a5fc4462fe0.png)\n笔者做过的项目中，曾经为了让 HTML 模板（应该说是一套页面主题）也具备动态解析内联表达式的能力，用了 data-eval 将 js 代码存储在 dom 节点，然后渲染时用 with 语句（另一个 JS “毒瘤”，现在严格模式下已经禁用 with 了，rip...）将 data 加到作用域链上，再用 eval 解析执行。实现出来的效果类似这样：\n```\n<div data-eval=\"data.count = data.count + 1\">\n    {{data.count}}\n</div>\n```\n渲染出来的结果是 eval 计算后的值。\n\n很多库和框架都用了 eval 实现各种黑魔法。早期的有用 eval 解析 json 的，比如 Douglas Crockford 的 json2.js（真香！）。到后来，各种 MVVM 框架也用 new Function 这个 eval 的好基友，来实现模板内嵌表达式的计算，比如 Vue 和 avalon。要达到的效果和笔者上面介绍的例子大致相同，不同的是这些 MVVM 框架还需要先解析模板，基于正则表达式提取出 new Function 的参数。甚至Chrome的JavaScript控制台，也是用 eval 实现的。\n\n甚至不能用 eval 的时候，也要自己造一个 eval 出来。比如小程序上就不能使用 eval 和 new Function，那么如果想动态注入并执行代码的话，需要绕一个大弯，从编译原理出发，自行实现一个 JS parser。\n\n## 总结\n关于 eval，笔者个人的看法是，**你可以不去用它，但要去了解它**。写这篇文章的目的也不是为了推荐大家使用 eval。就平时的业务开发而言，eval 几乎没有用武之地。但在一些特殊场合，eval 就像一枚核弹，无往不利。\n\n-------\n参考链接：\n\n1. [Global eval. What are the options?](http://perfectionkills.com/global-eval-what-are-the-options/)\n2. [Knockout, Vue 和 AvalonJS 等 MVVM 框架实现中是否用到 eval 或 Function?](https://www.zhihu.com/question/29743491)\n3. [eval() isn’t evil, just misunderstood](https://humanwhocodes.com/blog/2013/06/25/eval-isnt-evil-just-misunderstood/)\n4. [A new V8 is coming, Node.js performance is changing.](https://github.com/davidmarkclements/v8-perf)\n5. [V8: Behind the Scenes (February Edition feat. A tale of TurboFan)](http://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition/)\n\n\n","source":"_posts/你不知道的eval.md","raw":"---\ntitle: 你不知道的 eval\ndate: 2018-11-18 01:32:24\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n## 前言\neval() 是 JavaScript 中一个非常有用的函数，它可以一段代码字符串动态执行。然而各种编码规范和最佳实践都强烈抵制 eval，几乎将 eval 打入了死牢，大牛 Douglas Crockford 也在《JavaScript 语言精粹》一书中将 eval 视为 JavaScript 中糟粕。这篇文章将带大家重新认识这个函数，知道为什么不用它，以及为什么不得不用它。\n\n## eval 是什么\n在分析 eval 的利弊前，首先来认识一下它。在不清楚一项技术的情况下，就对它做出武断地评价，是有失公允的。 \n\neval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行。如果传入的参数不是字符串，它会原封不动地将其返回。eval 分为直接调用和间接调用两种，通常间接调用的性能会好于直接调用。\n\n直接调用时，eval 运行于其调用函数的作用域下；\n```\nvar context = 'outside';\n(function(){\n  var context = 'inside';\n  return eval('context');\n})();\n\n// return 'inside'\n```\n而间接调用时，eval 运行于全局作用域。\n```\nvar context = 'outside';\n(function(){\n  var context = 'inside';\n  geval = eval;\n  return geval('context');\n  \n  // 下面两种也属于间接调用\n  // return eval.call(null, 'context');\n  // return (1, eval)('context');\n})();\n\n// return 'outside'\n```\n因此，间接调用时，eval 并不会修改调用函数作用域内的任何东西。JS 解释器有 fast path 和 slow path 两种模式，当直接调用 eval 时，解释器处于 slow path。因为此时作用域是不可控的，需要监听整个作用域，不能应用 v8 的一些编译优化，相应的编译效率也会比 fast path 低。\n\n\n## 为什么不用 eval\n大家抵制 eval 的原因主要是以下几个原因：\n\n1. **降低性能**。具体原因上文已经提到了。网上一些文章甚至说 eval() 会拖慢性能 10 倍。\n2. **安全问题**。因为它的动态执行特性，给被求值的字符串赋予了太大的权力，于是大家担心可能因此导致 XSS 等攻击。\n3. **调试困难**。eval 就像一个黑盒，其执行的代码很难进行断点调试。\n\n鉴于以上各种原因，很多人说 eval 是 evil（魔鬼）。另外，eval 还有一些难兄难弟，比如 new Function, setTimeout, setInterval。它们也具备执行一段代码字符串的能力。\n**究其本质原因，还是因为 JS 赋予这个方法的权限太大了，作为新手很难驾驭它**，如果对 eval 没有很好地理解，很容易写出问题来。这有点像 C 语言中 goto 语句，同样是因为权限太大而被封杀的典范。\n\n## 被误解的 eval\n事实上，eval 一直在被误解，它可能是最强大的一个 JavaScript 函数，但却因为一些人的误用，而被开发者们打入了冷宫。接下来，我来根据上述被质疑最多的几个点，给出一点自己的看法。\n\n1. 关于 eval 会拖慢性能 10 倍这个点，出自 Mozila 工程师的演讲 [“Know Your Engines - How to make your JavaScript Fast”](https://www.slideshare.net/newmovie/know-yourengines-velocity2011/4-lost_in_an_instantfunction_f)。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-97e5c8ab319630c3.png)\n\n这是一个发布于 2011 年的演讲，时至今日，JS 引擎早已做了各种优化。我们来测试现在的 JS 引擎中，eval 的实际性能。依然使用上图作为测试用例，测试环境为 node v8.11.1，设 N 的值为 10000。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-fc057b2bb1edb308.png)\nBenchmark 跑出的数据来看，当 N = 10000 时，用了 eval 的 function 执行性能，相比没有 eval 的情况，慢了 3 倍多。\n将 N 的值设为 1000000，eval 的性能下降到 8 倍。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-a6970c681b262f83.png)\n\n从测试结果可知，eval 的确会拖慢函数执行性能，而且随着函数规模增大，性能也越慢。但是在一般情况下（N < 1000000），性能差异并没有 10 倍那么夸张。\n\n2. 关于 eval 会导致 XSS 攻击这点，问题并不在 eval，而在数据源。如果数据源本身就是不可靠的，即便你不用 eval，也可能出现 XSS。\n\n3. 至于第三点，eval 代码的确调试起来比较麻烦，但也不是完全没有办法。可以在 eval 创建的代码末尾添加一行 \"//@ sourceURL=name\" 就可以给这段代码命名（浏览器会特殊对待这种特殊形式的注释），这样它就会出现在 Sources 面板上，然后就可以设置断点调试了。\n\n\n## 真香警告\n虽然大家嘴上说不要用，但是 eval 用起来却是真香。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-714d2a5fc4462fe0.png)\n笔者做过的项目中，曾经为了让 HTML 模板（应该说是一套页面主题）也具备动态解析内联表达式的能力，用了 data-eval 将 js 代码存储在 dom 节点，然后渲染时用 with 语句（另一个 JS “毒瘤”，现在严格模式下已经禁用 with 了，rip...）将 data 加到作用域链上，再用 eval 解析执行。实现出来的效果类似这样：\n```\n<div data-eval=\"data.count = data.count + 1\">\n    {{data.count}}\n</div>\n```\n渲染出来的结果是 eval 计算后的值。\n\n很多库和框架都用了 eval 实现各种黑魔法。早期的有用 eval 解析 json 的，比如 Douglas Crockford 的 json2.js（真香！）。到后来，各种 MVVM 框架也用 new Function 这个 eval 的好基友，来实现模板内嵌表达式的计算，比如 Vue 和 avalon。要达到的效果和笔者上面介绍的例子大致相同，不同的是这些 MVVM 框架还需要先解析模板，基于正则表达式提取出 new Function 的参数。甚至Chrome的JavaScript控制台，也是用 eval 实现的。\n\n甚至不能用 eval 的时候，也要自己造一个 eval 出来。比如小程序上就不能使用 eval 和 new Function，那么如果想动态注入并执行代码的话，需要绕一个大弯，从编译原理出发，自行实现一个 JS parser。\n\n## 总结\n关于 eval，笔者个人的看法是，**你可以不去用它，但要去了解它**。写这篇文章的目的也不是为了推荐大家使用 eval。就平时的业务开发而言，eval 几乎没有用武之地。但在一些特殊场合，eval 就像一枚核弹，无往不利。\n\n-------\n参考链接：\n\n1. [Global eval. What are the options?](http://perfectionkills.com/global-eval-what-are-the-options/)\n2. [Knockout, Vue 和 AvalonJS 等 MVVM 框架实现中是否用到 eval 或 Function?](https://www.zhihu.com/question/29743491)\n3. [eval() isn’t evil, just misunderstood](https://humanwhocodes.com/blog/2013/06/25/eval-isnt-evil-just-misunderstood/)\n4. [A new V8 is coming, Node.js performance is changing.](https://github.com/davidmarkclements/v8-perf)\n5. [V8: Behind the Scenes (February Edition feat. A tale of TurboFan)](http://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition/)\n\n\n","slug":"你不知道的eval","published":1,"updated":"2019-12-28T16:07:49.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8s002vhns6jw3lddmv","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>eval() 是 JavaScript 中一个非常有用的函数，它可以一段代码字符串动态执行。然而各种编码规范和最佳实践都强烈抵制 eval，几乎将 eval 打入了死牢，大牛 Douglas Crockford 也在《JavaScript 语言精粹》一书中将 eval 视为 JavaScript 中糟粕。这篇文章将带大家重新认识这个函数，知道为什么不用它，以及为什么不得不用它。</p>\n<h2 id=\"eval-是什么\"><a href=\"#eval-是什么\" class=\"headerlink\" title=\"eval 是什么\"></a>eval 是什么</h2><p>在分析 eval 的利弊前，首先来认识一下它。在不清楚一项技术的情况下，就对它做出武断地评价，是有失公允的。 </p>\n<p>eval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行。如果传入的参数不是字符串，它会原封不动地将其返回。eval 分为直接调用和间接调用两种，通常间接调用的性能会好于直接调用。</p>\n<p>直接调用时，eval 运行于其调用函数的作用域下；<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var context = &apos;outside&apos;;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var context = &apos;inside&apos;;</span><br><span class=\"line\">  return eval(&apos;context&apos;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// return &apos;inside&apos;</span><br></pre></td></tr></table></figure></p>\n<p>而间接调用时，eval 运行于全局作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var context = &apos;outside&apos;;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var context = &apos;inside&apos;;</span><br><span class=\"line\">  geval = eval;</span><br><span class=\"line\">  return geval(&apos;context&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 下面两种也属于间接调用</span><br><span class=\"line\">  // return eval.call(null, &apos;context&apos;);</span><br><span class=\"line\">  // return (1, eval)(&apos;context&apos;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// return &apos;outside&apos;</span><br></pre></td></tr></table></figure></p>\n<p>因此，间接调用时，eval 并不会修改调用函数作用域内的任何东西。JS 解释器有 fast path 和 slow path 两种模式，当直接调用 eval 时，解释器处于 slow path。因为此时作用域是不可控的，需要监听整个作用域，不能应用 v8 的一些编译优化，相应的编译效率也会比 fast path 低。</p>\n<h2 id=\"为什么不用-eval\"><a href=\"#为什么不用-eval\" class=\"headerlink\" title=\"为什么不用 eval\"></a>为什么不用 eval</h2><p>大家抵制 eval 的原因主要是以下几个原因：</p>\n<ol>\n<li><strong>降低性能</strong>。具体原因上文已经提到了。网上一些文章甚至说 eval() 会拖慢性能 10 倍。</li>\n<li><strong>安全问题</strong>。因为它的动态执行特性，给被求值的字符串赋予了太大的权力，于是大家担心可能因此导致 XSS 等攻击。</li>\n<li><strong>调试困难</strong>。eval 就像一个黑盒，其执行的代码很难进行断点调试。</li>\n</ol>\n<p>鉴于以上各种原因，很多人说 eval 是 evil（魔鬼）。另外，eval 还有一些难兄难弟，比如 new Function, setTimeout, setInterval。它们也具备执行一段代码字符串的能力。<br><strong>究其本质原因，还是因为 JS 赋予这个方法的权限太大了，作为新手很难驾驭它</strong>，如果对 eval 没有很好地理解，很容易写出问题来。这有点像 C 语言中 goto 语句，同样是因为权限太大而被封杀的典范。</p>\n<h2 id=\"被误解的-eval\"><a href=\"#被误解的-eval\" class=\"headerlink\" title=\"被误解的 eval\"></a>被误解的 eval</h2><p>事实上，eval 一直在被误解，它可能是最强大的一个 JavaScript 函数，但却因为一些人的误用，而被开发者们打入了冷宫。接下来，我来根据上述被质疑最多的几个点，给出一点自己的看法。</p>\n<ol>\n<li>关于 eval 会拖慢性能 10 倍这个点，出自 Mozila 工程师的演讲 <a href=\"https://www.slideshare.net/newmovie/know-yourengines-velocity2011/4-lost_in_an_instantfunction_f\" target=\"_blank\" rel=\"noopener\">“Know Your Engines - How to make your JavaScript Fast”</a>。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-97e5c8ab319630c3.png\" alt=\"\"></li>\n</ol>\n<p>这是一个发布于 2011 年的演讲，时至今日，JS 引擎早已做了各种优化。我们来测试现在的 JS 引擎中，eval 的实际性能。依然使用上图作为测试用例，测试环境为 node v8.11.1，设 N 的值为 10000。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-fc057b2bb1edb308.png\" alt=\"\"><br>Benchmark 跑出的数据来看，当 N = 10000 时，用了 eval 的 function 执行性能，相比没有 eval 的情况，慢了 3 倍多。<br>将 N 的值设为 1000000，eval 的性能下降到 8 倍。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-a6970c681b262f83.png\" alt=\"\"></p>\n<p>从测试结果可知，eval 的确会拖慢函数执行性能，而且随着函数规模增大，性能也越慢。但是在一般情况下（N &lt; 1000000），性能差异并没有 10 倍那么夸张。</p>\n<ol>\n<li><p>关于 eval 会导致 XSS 攻击这点，问题并不在 eval，而在数据源。如果数据源本身就是不可靠的，即便你不用 eval，也可能出现 XSS。</p>\n</li>\n<li><p>至于第三点，eval 代码的确调试起来比较麻烦，但也不是完全没有办法。可以在 eval 创建的代码末尾添加一行 “//@ sourceURL=name” 就可以给这段代码命名（浏览器会特殊对待这种特殊形式的注释），这样它就会出现在 Sources 面板上，然后就可以设置断点调试了。</p>\n</li>\n</ol>\n<h2 id=\"真香警告\"><a href=\"#真香警告\" class=\"headerlink\" title=\"真香警告\"></a>真香警告</h2><p>虽然大家嘴上说不要用，但是 eval 用起来却是真香。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-714d2a5fc4462fe0.png\" alt=\"\"><br>笔者做过的项目中，曾经为了让 HTML 模板（应该说是一套页面主题）也具备动态解析内联表达式的能力，用了 data-eval 将 js 代码存储在 dom 节点，然后渲染时用 with 语句（另一个 JS “毒瘤”，现在严格模式下已经禁用 with 了，rip…）将 data 加到作用域链上，再用 eval 解析执行。实现出来的效果类似这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div data-eval=&quot;data.count = data.count + 1&quot;&gt;</span><br><span class=\"line\">    &#123;&#123;data.count&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>渲染出来的结果是 eval 计算后的值。</p>\n<p>很多库和框架都用了 eval 实现各种黑魔法。早期的有用 eval 解析 json 的，比如 Douglas Crockford 的 json2.js（真香！）。到后来，各种 MVVM 框架也用 new Function 这个 eval 的好基友，来实现模板内嵌表达式的计算，比如 Vue 和 avalon。要达到的效果和笔者上面介绍的例子大致相同，不同的是这些 MVVM 框架还需要先解析模板，基于正则表达式提取出 new Function 的参数。甚至Chrome的JavaScript控制台，也是用 eval 实现的。</p>\n<p>甚至不能用 eval 的时候，也要自己造一个 eval 出来。比如小程序上就不能使用 eval 和 new Function，那么如果想动态注入并执行代码的话，需要绕一个大弯，从编译原理出发，自行实现一个 JS parser。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于 eval，笔者个人的看法是，<strong>你可以不去用它，但要去了解它</strong>。写这篇文章的目的也不是为了推荐大家使用 eval。就平时的业务开发而言，eval 几乎没有用武之地。但在一些特殊场合，eval 就像一枚核弹，无往不利。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://perfectionkills.com/global-eval-what-are-the-options/\" target=\"_blank\" rel=\"noopener\">Global eval. What are the options?</a></li>\n<li><a href=\"https://www.zhihu.com/question/29743491\" target=\"_blank\" rel=\"noopener\">Knockout, Vue 和 AvalonJS 等 MVVM 框架实现中是否用到 eval 或 Function?</a></li>\n<li><a href=\"https://humanwhocodes.com/blog/2013/06/25/eval-isnt-evil-just-misunderstood/\" target=\"_blank\" rel=\"noopener\">eval() isn’t evil, just misunderstood</a></li>\n<li><a href=\"https://github.com/davidmarkclements/v8-perf\" target=\"_blank\" rel=\"noopener\">A new V8 is coming, Node.js performance is changing.</a></li>\n<li><a href=\"http://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition/\" target=\"_blank\" rel=\"noopener\">V8: Behind the Scenes (February Edition feat. A tale of TurboFan)</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>eval() 是 JavaScript 中一个非常有用的函数，它可以一段代码字符串动态执行。然而各种编码规范和最佳实践都强烈抵制 eval，几乎将 eval 打入了死牢，大牛 Douglas Crockford 也在《JavaScript 语言精粹》一书中将 eval 视为 JavaScript 中糟粕。这篇文章将带大家重新认识这个函数，知道为什么不用它，以及为什么不得不用它。</p>\n<h2 id=\"eval-是什么\"><a href=\"#eval-是什么\" class=\"headerlink\" title=\"eval 是什么\"></a>eval 是什么</h2><p>在分析 eval 的利弊前，首先来认识一下它。在不清楚一项技术的情况下，就对它做出武断地评价，是有失公允的。 </p>\n<p>eval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行。如果传入的参数不是字符串，它会原封不动地将其返回。eval 分为直接调用和间接调用两种，通常间接调用的性能会好于直接调用。</p>\n<p>直接调用时，eval 运行于其调用函数的作用域下；<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var context = &apos;outside&apos;;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var context = &apos;inside&apos;;</span><br><span class=\"line\">  return eval(&apos;context&apos;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// return &apos;inside&apos;</span><br></pre></td></tr></table></figure></p>\n<p>而间接调用时，eval 运行于全局作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var context = &apos;outside&apos;;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var context = &apos;inside&apos;;</span><br><span class=\"line\">  geval = eval;</span><br><span class=\"line\">  return geval(&apos;context&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 下面两种也属于间接调用</span><br><span class=\"line\">  // return eval.call(null, &apos;context&apos;);</span><br><span class=\"line\">  // return (1, eval)(&apos;context&apos;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// return &apos;outside&apos;</span><br></pre></td></tr></table></figure></p>\n<p>因此，间接调用时，eval 并不会修改调用函数作用域内的任何东西。JS 解释器有 fast path 和 slow path 两种模式，当直接调用 eval 时，解释器处于 slow path。因为此时作用域是不可控的，需要监听整个作用域，不能应用 v8 的一些编译优化，相应的编译效率也会比 fast path 低。</p>\n<h2 id=\"为什么不用-eval\"><a href=\"#为什么不用-eval\" class=\"headerlink\" title=\"为什么不用 eval\"></a>为什么不用 eval</h2><p>大家抵制 eval 的原因主要是以下几个原因：</p>\n<ol>\n<li><strong>降低性能</strong>。具体原因上文已经提到了。网上一些文章甚至说 eval() 会拖慢性能 10 倍。</li>\n<li><strong>安全问题</strong>。因为它的动态执行特性，给被求值的字符串赋予了太大的权力，于是大家担心可能因此导致 XSS 等攻击。</li>\n<li><strong>调试困难</strong>。eval 就像一个黑盒，其执行的代码很难进行断点调试。</li>\n</ol>\n<p>鉴于以上各种原因，很多人说 eval 是 evil（魔鬼）。另外，eval 还有一些难兄难弟，比如 new Function, setTimeout, setInterval。它们也具备执行一段代码字符串的能力。<br><strong>究其本质原因，还是因为 JS 赋予这个方法的权限太大了，作为新手很难驾驭它</strong>，如果对 eval 没有很好地理解，很容易写出问题来。这有点像 C 语言中 goto 语句，同样是因为权限太大而被封杀的典范。</p>\n<h2 id=\"被误解的-eval\"><a href=\"#被误解的-eval\" class=\"headerlink\" title=\"被误解的 eval\"></a>被误解的 eval</h2><p>事实上，eval 一直在被误解，它可能是最强大的一个 JavaScript 函数，但却因为一些人的误用，而被开发者们打入了冷宫。接下来，我来根据上述被质疑最多的几个点，给出一点自己的看法。</p>\n<ol>\n<li>关于 eval 会拖慢性能 10 倍这个点，出自 Mozila 工程师的演讲 <a href=\"https://www.slideshare.net/newmovie/know-yourengines-velocity2011/4-lost_in_an_instantfunction_f\" target=\"_blank\" rel=\"noopener\">“Know Your Engines - How to make your JavaScript Fast”</a>。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-97e5c8ab319630c3.png\" alt=\"\"></li>\n</ol>\n<p>这是一个发布于 2011 年的演讲，时至今日，JS 引擎早已做了各种优化。我们来测试现在的 JS 引擎中，eval 的实际性能。依然使用上图作为测试用例，测试环境为 node v8.11.1，设 N 的值为 10000。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-fc057b2bb1edb308.png\" alt=\"\"><br>Benchmark 跑出的数据来看，当 N = 10000 时，用了 eval 的 function 执行性能，相比没有 eval 的情况，慢了 3 倍多。<br>将 N 的值设为 1000000，eval 的性能下降到 8 倍。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-a6970c681b262f83.png\" alt=\"\"></p>\n<p>从测试结果可知，eval 的确会拖慢函数执行性能，而且随着函数规模增大，性能也越慢。但是在一般情况下（N &lt; 1000000），性能差异并没有 10 倍那么夸张。</p>\n<ol>\n<li><p>关于 eval 会导致 XSS 攻击这点，问题并不在 eval，而在数据源。如果数据源本身就是不可靠的，即便你不用 eval，也可能出现 XSS。</p>\n</li>\n<li><p>至于第三点，eval 代码的确调试起来比较麻烦，但也不是完全没有办法。可以在 eval 创建的代码末尾添加一行 “//@ sourceURL=name” 就可以给这段代码命名（浏览器会特殊对待这种特殊形式的注释），这样它就会出现在 Sources 面板上，然后就可以设置断点调试了。</p>\n</li>\n</ol>\n<h2 id=\"真香警告\"><a href=\"#真香警告\" class=\"headerlink\" title=\"真香警告\"></a>真香警告</h2><p>虽然大家嘴上说不要用，但是 eval 用起来却是真香。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84eval/192464-714d2a5fc4462fe0.png\" alt=\"\"><br>笔者做过的项目中，曾经为了让 HTML 模板（应该说是一套页面主题）也具备动态解析内联表达式的能力，用了 data-eval 将 js 代码存储在 dom 节点，然后渲染时用 with 语句（另一个 JS “毒瘤”，现在严格模式下已经禁用 with 了，rip…）将 data 加到作用域链上，再用 eval 解析执行。实现出来的效果类似这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div data-eval=&quot;data.count = data.count + 1&quot;&gt;</span><br><span class=\"line\">    &#123;&#123;data.count&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>渲染出来的结果是 eval 计算后的值。</p>\n<p>很多库和框架都用了 eval 实现各种黑魔法。早期的有用 eval 解析 json 的，比如 Douglas Crockford 的 json2.js（真香！）。到后来，各种 MVVM 框架也用 new Function 这个 eval 的好基友，来实现模板内嵌表达式的计算，比如 Vue 和 avalon。要达到的效果和笔者上面介绍的例子大致相同，不同的是这些 MVVM 框架还需要先解析模板，基于正则表达式提取出 new Function 的参数。甚至Chrome的JavaScript控制台，也是用 eval 实现的。</p>\n<p>甚至不能用 eval 的时候，也要自己造一个 eval 出来。比如小程序上就不能使用 eval 和 new Function，那么如果想动态注入并执行代码的话，需要绕一个大弯，从编译原理出发，自行实现一个 JS parser。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于 eval，笔者个人的看法是，<strong>你可以不去用它，但要去了解它</strong>。写这篇文章的目的也不是为了推荐大家使用 eval。就平时的业务开发而言，eval 几乎没有用武之地。但在一些特殊场合，eval 就像一枚核弹，无往不利。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://perfectionkills.com/global-eval-what-are-the-options/\" target=\"_blank\" rel=\"noopener\">Global eval. What are the options?</a></li>\n<li><a href=\"https://www.zhihu.com/question/29743491\" target=\"_blank\" rel=\"noopener\">Knockout, Vue 和 AvalonJS 等 MVVM 框架实现中是否用到 eval 或 Function?</a></li>\n<li><a href=\"https://humanwhocodes.com/blog/2013/06/25/eval-isnt-evil-just-misunderstood/\" target=\"_blank\" rel=\"noopener\">eval() isn’t evil, just misunderstood</a></li>\n<li><a href=\"https://github.com/davidmarkclements/v8-perf\" target=\"_blank\" rel=\"noopener\">A new V8 is coming, Node.js performance is changing.</a></li>\n<li><a href=\"http://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition/\" target=\"_blank\" rel=\"noopener\">V8: Behind the Scenes (February Edition feat. A tale of TurboFan)</a></li>\n</ol>\n"},{"title":"你该逃课吗","date":"2016-05-29T11:57:44.000Z","_content":"　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。\n<!-- more -->\n　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。\n","source":"_posts/你该逃课吗.md","raw":"---\ntitle: 你该逃课吗\ndate: 2016-05-29 19:57:44\ntags:\n- 随笔\ncategories:\n- 随笔\n---\n　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。\n<!-- more -->\n　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。\n","slug":"你该逃课吗","published":1,"updated":"2019-06-16T14:11:37.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8t002yhns6d6im7ch9","content":"<p>　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。<br><a id=\"more\"></a><br>　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。</p>\n","site":{"data":{}},"excerpt":"<p>　　你逃课的时候，总有人（比如：辅导员）会跟你说：“你交了那么多学费，居然还逃课，真是浪费！”但在经济学里，这种说法是不成立的。因为这些交了的学费是沉没成本：无论你逃或不逃课，学费早就交了。所以逃课的成本和学费没有关系。<br>","more":"<br>　　在经济学看来，逃课和机会成本有关系：你逃了课，那么你就错过了一堂精彩或者无聊的课，而且可能因为点名不到而被扣分。这个错过与扣分就是逃课的代价。所以，如果你逃了课后只是无所事事，那么就不要逃课，因为机会成本太高。但如果逃课是为了干你认为更重要的事，它带来的收益大于逃课的代价，那么就去做吧。因为错过了这些事带来的代价显然比逃课的代价高。</p>"},{"title":"写给自己的鸡汤","date":"2017-03-18T20:50:01.000Z","_content":"时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿\n\n有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿\n\n 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿\n\n 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿\n\n\n\n2017.3.19 凌晨四点\n","source":"_posts/写给自己的鸡汤.md","raw":"---\ntitle: 写给自己的鸡汤\ndate: 2017-03-19 04:50:01\ntags:\n- 随笔\ncategories:\n- 随笔\n---\n时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿\n\n有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿\n\n 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿\n\n 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿\n\n\n\n2017.3.19 凌晨四点\n","slug":"写给自己的鸡汤","published":1,"updated":"2019-06-16T14:11:37.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8u0032hns615i3zznn","content":"<p>时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿</p>\n<p>有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿</p>\n<p> 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿</p>\n<p> 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿</p>\n<p>2017.3.19 凌晨四点</p>\n","site":{"data":{}},"excerpt":"","more":"<p>时常在想一个问题，即便是同一批通过高考拼搏的人，为何就能在短短几年产生如此大的分化，几年前大家可都在教室里背琵琶行、解三角函数的啊。﻿</p>\n<p>有人坚持不懈打电子游戏，有人锲而不舍地刷绩点，也有人辗转于各类竞赛中。其实，这些现象诞生的本质原因都来自于同样的人性：追求快乐。﻿</p>\n<p> 打游戏可以在短时间内就带来快乐，因此许多人花了四年时间延续这种快乐；刷绩点的过程有些乏味，但奖学金、保研、出国这些可被触摸到的理想光是让人想想就激动；竞赛拿名次可以享受到成就感。﻿</p>\n<p> 雷军的一顿午餐只有三分钟，马斯克一周工作100小时。刘强东说让他一连几个月在沙滩、阳光中度过，他会疯掉的。这些人简直是泯灭了人性啊。但其实，别人就是享受工作带来的愉悦感呢。不同的人选择了不同的生活方式，这些选择并无高低贵贱之分，本质上都是在追寻并延续生命中的快乐罢了。只不过聪明的人会采取一些方式将快乐感持久化；伟大的人在保有一己私利之外，还会想着给更多的人甚至全人类谋求福祉吧。﻿﻿</p>\n<p>2017.3.19 凌晨四点</p>\n"},{"title":"常用 Git 操作总结","date":"2019-03-12T14:35:05.000Z","_content":"### 合并远程分支\n1. git fetch origin branch\n2. git checkout [your-branch]\n3. git merge FETCH_HEAD，merge 前可以先git dff [your-branch] [remote-branch]，查看本地分支和远程分支的区别\n\n### 使用 rebase 合并分支\n1. git rebase [origin-branch]\n2. 遇到冲突，解决完冲突后 git add\n3. git rebase --continue\n\nrebase 和 merge 的区别\n![](http://mares.oss-cn-qingdao.aliyuncs.com/image2018-4-11%2019_43_26.png)\n\n\n### 合并历史commit\ngit rebase -i [commit id] commit id是合并的提交的前一个提交节点的commitID，最上的是最早的提交\n修改需要合并的commit，将pick修改成 squash\n退出保存 wq\ngit push origin [branch-name] -f\nrebase 的主要用途一是替代merge，保持分支历史的线性提交；二是方便合并历史提交。\n\n\n\n### 撤销一次merge\n1. git reflog 确定回滚的commit id\n2. git reset --hard [commit id]\n\ngit revert 也可以回退到指定版本，和reset的区别在于，revert会产生一次新的提交,用一次新的提交来消除历史修改。而reset是直接删除历史commit。\n\n### 合并时遇到冲突，想取消merge\ngit merge --abort\n\n### 修改最后一次提交的commit message\ngit commit --amend\n\n### 清空工作区的修改\ngit checkout .\n\n### 恢复误删分支\n1. git log -g 找到之前分支提交的 commit id\n2. git branch recover_branch [commit id]，这时切换到 recover_branch，可以看到原来的文件了。\n\n### 修改历史提交信息\n1. git rebase -i HEAD~10（查看前10次提交信息，也可以直接输入想要修改的commit id）\n2. 将想要的修改的commit前的 pick 修改为 reword，保存并退出。\n3. 在弹出的窗口中，修改commit message，保存。\n\n### 删除历史提交\n1. 用 git rebase -i 928582641a 指定 base 为你需要删除的提交的前一个提交。\n2. 删除指定的commit, 保存退出. 之后可能 git 会提示出现 conflict, 根据提示完成处理。\n\n### 创建空白分支\n1. git checkout --orphan new_branch\n2. git rm -rf .\n\n### 查看本地分支和远程分支的差异\n1. git fetch origin\n2. git diff master origin/master --minimal\n\n### 建立远程追踪分支\ngit branch -u [remote_branch]\n\n### 删除远程分支\n1. git branch -r -d origin/branch-name\n2. git push origin :branch-name\n\n\n","source":"_posts/常用Git操作总结.md","raw":"---\ntitle: 常用 Git 操作总结\ndate: 2019-03-12 22:35:05\ntags:\n- Git\ncategories:\n- 工具\n---\n### 合并远程分支\n1. git fetch origin branch\n2. git checkout [your-branch]\n3. git merge FETCH_HEAD，merge 前可以先git dff [your-branch] [remote-branch]，查看本地分支和远程分支的区别\n\n### 使用 rebase 合并分支\n1. git rebase [origin-branch]\n2. 遇到冲突，解决完冲突后 git add\n3. git rebase --continue\n\nrebase 和 merge 的区别\n![](http://mares.oss-cn-qingdao.aliyuncs.com/image2018-4-11%2019_43_26.png)\n\n\n### 合并历史commit\ngit rebase -i [commit id] commit id是合并的提交的前一个提交节点的commitID，最上的是最早的提交\n修改需要合并的commit，将pick修改成 squash\n退出保存 wq\ngit push origin [branch-name] -f\nrebase 的主要用途一是替代merge，保持分支历史的线性提交；二是方便合并历史提交。\n\n\n\n### 撤销一次merge\n1. git reflog 确定回滚的commit id\n2. git reset --hard [commit id]\n\ngit revert 也可以回退到指定版本，和reset的区别在于，revert会产生一次新的提交,用一次新的提交来消除历史修改。而reset是直接删除历史commit。\n\n### 合并时遇到冲突，想取消merge\ngit merge --abort\n\n### 修改最后一次提交的commit message\ngit commit --amend\n\n### 清空工作区的修改\ngit checkout .\n\n### 恢复误删分支\n1. git log -g 找到之前分支提交的 commit id\n2. git branch recover_branch [commit id]，这时切换到 recover_branch，可以看到原来的文件了。\n\n### 修改历史提交信息\n1. git rebase -i HEAD~10（查看前10次提交信息，也可以直接输入想要修改的commit id）\n2. 将想要的修改的commit前的 pick 修改为 reword，保存并退出。\n3. 在弹出的窗口中，修改commit message，保存。\n\n### 删除历史提交\n1. 用 git rebase -i 928582641a 指定 base 为你需要删除的提交的前一个提交。\n2. 删除指定的commit, 保存退出. 之后可能 git 会提示出现 conflict, 根据提示完成处理。\n\n### 创建空白分支\n1. git checkout --orphan new_branch\n2. git rm -rf .\n\n### 查看本地分支和远程分支的差异\n1. git fetch origin\n2. git diff master origin/master --minimal\n\n### 建立远程追踪分支\ngit branch -u [remote_branch]\n\n### 删除远程分支\n1. git branch -r -d origin/branch-name\n2. git push origin :branch-name\n\n\n","slug":"常用Git操作总结","published":1,"updated":"2019-12-28T16:11:32.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8w0036hns60yf9uwfy","content":"<h3 id=\"合并远程分支\"><a href=\"#合并远程分支\" class=\"headerlink\" title=\"合并远程分支\"></a>合并远程分支</h3><ol>\n<li>git fetch origin branch</li>\n<li>git checkout [your-branch]</li>\n<li>git merge FETCH_HEAD，merge 前可以先git dff [your-branch] [remote-branch]，查看本地分支和远程分支的区别</li>\n</ol>\n<h3 id=\"使用-rebase-合并分支\"><a href=\"#使用-rebase-合并分支\" class=\"headerlink\" title=\"使用 rebase 合并分支\"></a>使用 rebase 合并分支</h3><ol>\n<li>git rebase [origin-branch]</li>\n<li>遇到冲突，解决完冲突后 git add</li>\n<li>git rebase –continue</li>\n</ol>\n<p>rebase 和 merge 的区别<br><img src=\"http://mares.oss-cn-qingdao.aliyuncs.com/image2018-4-11%2019_43_26.png\" alt=\"\"></p>\n<h3 id=\"合并历史commit\"><a href=\"#合并历史commit\" class=\"headerlink\" title=\"合并历史commit\"></a>合并历史commit</h3><p>git rebase -i [commit id] commit id是合并的提交的前一个提交节点的commitID，最上的是最早的提交<br>修改需要合并的commit，将pick修改成 squash<br>退出保存 wq<br>git push origin [branch-name] -f<br>rebase 的主要用途一是替代merge，保持分支历史的线性提交；二是方便合并历史提交。</p>\n<h3 id=\"撤销一次merge\"><a href=\"#撤销一次merge\" class=\"headerlink\" title=\"撤销一次merge\"></a>撤销一次merge</h3><ol>\n<li>git reflog 确定回滚的commit id</li>\n<li>git reset –hard [commit id]</li>\n</ol>\n<p>git revert 也可以回退到指定版本，和reset的区别在于，revert会产生一次新的提交,用一次新的提交来消除历史修改。而reset是直接删除历史commit。</p>\n<h3 id=\"合并时遇到冲突，想取消merge\"><a href=\"#合并时遇到冲突，想取消merge\" class=\"headerlink\" title=\"合并时遇到冲突，想取消merge\"></a>合并时遇到冲突，想取消merge</h3><p>git merge –abort</p>\n<h3 id=\"修改最后一次提交的commit-message\"><a href=\"#修改最后一次提交的commit-message\" class=\"headerlink\" title=\"修改最后一次提交的commit message\"></a>修改最后一次提交的commit message</h3><p>git commit –amend</p>\n<h3 id=\"清空工作区的修改\"><a href=\"#清空工作区的修改\" class=\"headerlink\" title=\"清空工作区的修改\"></a>清空工作区的修改</h3><p>git checkout .</p>\n<h3 id=\"恢复误删分支\"><a href=\"#恢复误删分支\" class=\"headerlink\" title=\"恢复误删分支\"></a>恢复误删分支</h3><ol>\n<li>git log -g 找到之前分支提交的 commit id</li>\n<li>git branch recover_branch [commit id]，这时切换到 recover_branch，可以看到原来的文件了。</li>\n</ol>\n<h3 id=\"修改历史提交信息\"><a href=\"#修改历史提交信息\" class=\"headerlink\" title=\"修改历史提交信息\"></a>修改历史提交信息</h3><ol>\n<li>git rebase -i HEAD~10（查看前10次提交信息，也可以直接输入想要修改的commit id）</li>\n<li>将想要的修改的commit前的 pick 修改为 reword，保存并退出。</li>\n<li>在弹出的窗口中，修改commit message，保存。</li>\n</ol>\n<h3 id=\"删除历史提交\"><a href=\"#删除历史提交\" class=\"headerlink\" title=\"删除历史提交\"></a>删除历史提交</h3><ol>\n<li>用 git rebase -i 928582641a 指定 base 为你需要删除的提交的前一个提交。</li>\n<li>删除指定的commit, 保存退出. 之后可能 git 会提示出现 conflict, 根据提示完成处理。</li>\n</ol>\n<h3 id=\"创建空白分支\"><a href=\"#创建空白分支\" class=\"headerlink\" title=\"创建空白分支\"></a>创建空白分支</h3><ol>\n<li>git checkout –orphan new_branch</li>\n<li>git rm -rf .</li>\n</ol>\n<h3 id=\"查看本地分支和远程分支的差异\"><a href=\"#查看本地分支和远程分支的差异\" class=\"headerlink\" title=\"查看本地分支和远程分支的差异\"></a>查看本地分支和远程分支的差异</h3><ol>\n<li>git fetch origin</li>\n<li>git diff master origin/master –minimal</li>\n</ol>\n<h3 id=\"建立远程追踪分支\"><a href=\"#建立远程追踪分支\" class=\"headerlink\" title=\"建立远程追踪分支\"></a>建立远程追踪分支</h3><p>git branch -u [remote_branch]</p>\n<h3 id=\"删除远程分支\"><a href=\"#删除远程分支\" class=\"headerlink\" title=\"删除远程分支\"></a>删除远程分支</h3><ol>\n<li>git branch -r -d origin/branch-name</li>\n<li>git push origin :branch-name</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"合并远程分支\"><a href=\"#合并远程分支\" class=\"headerlink\" title=\"合并远程分支\"></a>合并远程分支</h3><ol>\n<li>git fetch origin branch</li>\n<li>git checkout [your-branch]</li>\n<li>git merge FETCH_HEAD，merge 前可以先git dff [your-branch] [remote-branch]，查看本地分支和远程分支的区别</li>\n</ol>\n<h3 id=\"使用-rebase-合并分支\"><a href=\"#使用-rebase-合并分支\" class=\"headerlink\" title=\"使用 rebase 合并分支\"></a>使用 rebase 合并分支</h3><ol>\n<li>git rebase [origin-branch]</li>\n<li>遇到冲突，解决完冲突后 git add</li>\n<li>git rebase –continue</li>\n</ol>\n<p>rebase 和 merge 的区别<br><img src=\"http://mares.oss-cn-qingdao.aliyuncs.com/image2018-4-11%2019_43_26.png\" alt=\"\"></p>\n<h3 id=\"合并历史commit\"><a href=\"#合并历史commit\" class=\"headerlink\" title=\"合并历史commit\"></a>合并历史commit</h3><p>git rebase -i [commit id] commit id是合并的提交的前一个提交节点的commitID，最上的是最早的提交<br>修改需要合并的commit，将pick修改成 squash<br>退出保存 wq<br>git push origin [branch-name] -f<br>rebase 的主要用途一是替代merge，保持分支历史的线性提交；二是方便合并历史提交。</p>\n<h3 id=\"撤销一次merge\"><a href=\"#撤销一次merge\" class=\"headerlink\" title=\"撤销一次merge\"></a>撤销一次merge</h3><ol>\n<li>git reflog 确定回滚的commit id</li>\n<li>git reset –hard [commit id]</li>\n</ol>\n<p>git revert 也可以回退到指定版本，和reset的区别在于，revert会产生一次新的提交,用一次新的提交来消除历史修改。而reset是直接删除历史commit。</p>\n<h3 id=\"合并时遇到冲突，想取消merge\"><a href=\"#合并时遇到冲突，想取消merge\" class=\"headerlink\" title=\"合并时遇到冲突，想取消merge\"></a>合并时遇到冲突，想取消merge</h3><p>git merge –abort</p>\n<h3 id=\"修改最后一次提交的commit-message\"><a href=\"#修改最后一次提交的commit-message\" class=\"headerlink\" title=\"修改最后一次提交的commit message\"></a>修改最后一次提交的commit message</h3><p>git commit –amend</p>\n<h3 id=\"清空工作区的修改\"><a href=\"#清空工作区的修改\" class=\"headerlink\" title=\"清空工作区的修改\"></a>清空工作区的修改</h3><p>git checkout .</p>\n<h3 id=\"恢复误删分支\"><a href=\"#恢复误删分支\" class=\"headerlink\" title=\"恢复误删分支\"></a>恢复误删分支</h3><ol>\n<li>git log -g 找到之前分支提交的 commit id</li>\n<li>git branch recover_branch [commit id]，这时切换到 recover_branch，可以看到原来的文件了。</li>\n</ol>\n<h3 id=\"修改历史提交信息\"><a href=\"#修改历史提交信息\" class=\"headerlink\" title=\"修改历史提交信息\"></a>修改历史提交信息</h3><ol>\n<li>git rebase -i HEAD~10（查看前10次提交信息，也可以直接输入想要修改的commit id）</li>\n<li>将想要的修改的commit前的 pick 修改为 reword，保存并退出。</li>\n<li>在弹出的窗口中，修改commit message，保存。</li>\n</ol>\n<h3 id=\"删除历史提交\"><a href=\"#删除历史提交\" class=\"headerlink\" title=\"删除历史提交\"></a>删除历史提交</h3><ol>\n<li>用 git rebase -i 928582641a 指定 base 为你需要删除的提交的前一个提交。</li>\n<li>删除指定的commit, 保存退出. 之后可能 git 会提示出现 conflict, 根据提示完成处理。</li>\n</ol>\n<h3 id=\"创建空白分支\"><a href=\"#创建空白分支\" class=\"headerlink\" title=\"创建空白分支\"></a>创建空白分支</h3><ol>\n<li>git checkout –orphan new_branch</li>\n<li>git rm -rf .</li>\n</ol>\n<h3 id=\"查看本地分支和远程分支的差异\"><a href=\"#查看本地分支和远程分支的差异\" class=\"headerlink\" title=\"查看本地分支和远程分支的差异\"></a>查看本地分支和远程分支的差异</h3><ol>\n<li>git fetch origin</li>\n<li>git diff master origin/master –minimal</li>\n</ol>\n<h3 id=\"建立远程追踪分支\"><a href=\"#建立远程追踪分支\" class=\"headerlink\" title=\"建立远程追踪分支\"></a>建立远程追踪分支</h3><p>git branch -u [remote_branch]</p>\n<h3 id=\"删除远程分支\"><a href=\"#删除远程分支\" class=\"headerlink\" title=\"删除远程分支\"></a>删除远程分支</h3><ol>\n<li>git branch -r -d origin/branch-name</li>\n<li>git push origin :branch-name</li>\n</ol>\n"},{"title":"实现 JavaScript 中的 indexOf 方法","date":"2016-03-21T09:43:49.000Z","_content":"> indexOf()方法是ES5中出现的数组方法，它有两个参数\narray.indexOf(value,start)\n第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。\n示例：['a','b','c'].indexOf('a',1)  //返回-1\n\n下面我们来自己实现这个方法，并保证其向下兼容性。\n```\nvar indexof = function(array,value,start){\n   if(array == null) return -1;\n   var i=0,length = array.length;\n   if(start){\n       if(typeof start == 'number'){\n           // 添加对start为负值时的处理\n           i = (start < 0 ? Math.max(0,length+start):start);\n        }\n   }\n   // 如果浏览器支持ES5 indexOf，则直接使用它\n   if(Array.prototype.indexOf && array.indexOf === Array.prototype.indexOf){\n        return array.indexOf(value,start);\n   }\n   // 遍历数组\n   for(;i < length;i++){\n       if(array[i]===value){\n           return i;\n       }\n   }\n   return -1;\n}\n//测试\nconsole.log(indexof([2,4,1,8,5],1,0));//输出2\n```\n如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。\n","source":"_posts/实现JavaScript中的indexOf方法.md","raw":"---\ntitle: 实现 JavaScript 中的 indexOf 方法\ndate: 2016-03-21 17:43:49\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> indexOf()方法是ES5中出现的数组方法，它有两个参数\narray.indexOf(value,start)\n第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。\n示例：['a','b','c'].indexOf('a',1)  //返回-1\n\n下面我们来自己实现这个方法，并保证其向下兼容性。\n```\nvar indexof = function(array,value,start){\n   if(array == null) return -1;\n   var i=0,length = array.length;\n   if(start){\n       if(typeof start == 'number'){\n           // 添加对start为负值时的处理\n           i = (start < 0 ? Math.max(0,length+start):start);\n        }\n   }\n   // 如果浏览器支持ES5 indexOf，则直接使用它\n   if(Array.prototype.indexOf && array.indexOf === Array.prototype.indexOf){\n        return array.indexOf(value,start);\n   }\n   // 遍历数组\n   for(;i < length;i++){\n       if(array[i]===value){\n           return i;\n       }\n   }\n   return -1;\n}\n//测试\nconsole.log(indexof([2,4,1,8,5],1,0));//输出2\n```\n如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。\n","slug":"实现JavaScript中的indexOf方法","published":1,"updated":"2019-12-28T16:23:29.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8x0039hns6a67p13ok","content":"<blockquote>\n<p>indexOf()方法是ES5中出现的数组方法，它有两个参数<br>array.indexOf(value,start)<br>第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。<br>示例：[‘a’,’b’,’c’].indexOf(‘a’,1)  //返回-1</p>\n</blockquote>\n<p>下面我们来自己实现这个方法，并保证其向下兼容性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var indexof = function(array,value,start)&#123;</span><br><span class=\"line\">   if(array == null) return -1;</span><br><span class=\"line\">   var i=0,length = array.length;</span><br><span class=\"line\">   if(start)&#123;</span><br><span class=\"line\">       if(typeof start == &apos;number&apos;)&#123;</span><br><span class=\"line\">           // 添加对start为负值时的处理</span><br><span class=\"line\">           i = (start &lt; 0 ? Math.max(0,length+start):start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果浏览器支持ES5 indexOf，则直接使用它</span><br><span class=\"line\">   if(Array.prototype.indexOf &amp;&amp; array.indexOf === Array.prototype.indexOf)&#123;</span><br><span class=\"line\">        return array.indexOf(value,start);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 遍历数组</span><br><span class=\"line\">   for(;i &lt; length;i++)&#123;</span><br><span class=\"line\">       if(array[i]===value)&#123;</span><br><span class=\"line\">           return i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//测试</span><br><span class=\"line\">console.log(indexof([2,4,1,8,5],1,0));//输出2</span><br></pre></td></tr></table></figure></p>\n<p>如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>indexOf()方法是ES5中出现的数组方法，它有两个参数<br>array.indexOf(value,start)<br>第一个参数指定要在数组查找的值，第二个可选参数指定开始查找的数组下标。如果省略，则为0。如果数组中存在匹配的值，就返回第一次匹配的数组下标，如果不存在匹配的值，则返回-1。<br>示例：[‘a’,’b’,’c’].indexOf(‘a’,1)  //返回-1</p>\n</blockquote>\n<p>下面我们来自己实现这个方法，并保证其向下兼容性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var indexof = function(array,value,start)&#123;</span><br><span class=\"line\">   if(array == null) return -1;</span><br><span class=\"line\">   var i=0,length = array.length;</span><br><span class=\"line\">   if(start)&#123;</span><br><span class=\"line\">       if(typeof start == &apos;number&apos;)&#123;</span><br><span class=\"line\">           // 添加对start为负值时的处理</span><br><span class=\"line\">           i = (start &lt; 0 ? Math.max(0,length+start):start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果浏览器支持ES5 indexOf，则直接使用它</span><br><span class=\"line\">   if(Array.prototype.indexOf &amp;&amp; array.indexOf === Array.prototype.indexOf)&#123;</span><br><span class=\"line\">        return array.indexOf(value,start);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 遍历数组</span><br><span class=\"line\">   for(;i &lt; length;i++)&#123;</span><br><span class=\"line\">       if(array[i]===value)&#123;</span><br><span class=\"line\">           return i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//测试</span><br><span class=\"line\">console.log(indexof([2,4,1,8,5],1,0));//输出2</span><br></pre></td></tr></table></figure></p>\n<p>如此，我们就扩充了indexOf方法，使其在即便不支持的ES5的浏览器也能运行良好。</p>\n"},{"title":"我的 HTTPS 升级之旅","date":"2017-05-11T13:47:36.000Z","_content":"> 本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0\n\n# 前言\n先贴一个福利，也作为没有启用 HTTPS 的反面教材：\n\n![福利.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/1.png)\n这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。\n\n# 预备条件\n本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。\n\n# 获取证书\nHTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。\n\n我使用了大名鼎鼎的 Let's Encrypt 来生成证书。\n## 1. 安装 certbot\ncertbot 是 Let's Encrypt 提供的一套自动化工具。 \n```\nyum install epel-release\nyum install certbot\n```\n## 2. 生成证书\n这里采用 webroot 作为 Let's Encrypt 的认证方式。\n```\ncertbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com\n```\nwebroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：\n- cert.pem: 服务端证书\n- chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书\n- fullchain.pem: 包括了cert.pem和chain.pem的内容\n- privkey.pem: 证书私钥\n\n## 3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\n为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。\n```\nopenssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\n```\n如果没有安装 openssl，这里要先安装一下。\n```\nyum install openssl\n```\n\n\n# 配置 Nginx\n编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。\n```\nserver {\n    listen 443 ssl;\n    # 启用http2\n    # 需要安装 Nginx Http2 Module\n    # listen 443 http2 ssl;\n    server_name example.com www.example.com;\n    #证书文件\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    #私钥文件\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    # 优先采取服务器算法\n    ssl_prefer_server_ciphers on;\n    # 定义算法\n    ssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\n    ssl_ecdh_curve secp384r1;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_tickets off;\n    ssl_stapling on;\n    ssl_stapling_verify on;\n    resolver 8.8.8.8 8.8.4.4 valid=300s;\n    resolver_timeout 5s;\n   \n    add_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    # 使用DH文件\n    ssl_dhparam /etc/ssl/certs/dhparam.pem;\n\n    location ~ /.well-known {\n        allow all;\n    }\n\n    root /your/project/path;\n    index index.html index.htm;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n```\n解释一下其中几项配置：\n```\nssl_stapling on;\n```\n开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。\n```\nadd_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n```\n启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接\n```\n    add_header X-Frame-Options DENY;\n```\n添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少[点击劫持 (clickjacking)攻击](https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/)。\n```\n    add_header X-Content-Type-Options nosniff;\n```\n添加 X-Content-Type-Options 响应头，防止 [MIME 类型嗅探攻击](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing)\n\n解释完毕。继续，来测试 nginx.conf 是否有语法错误\n```\nnginx -t\n```\n重启 Nginx\n```\nnginx -s reload\n```\n# 重定向 HTTP 到 HTTPS\n修改原来 HTTP 网站的 Nginx 配置。\n```\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    access_log /var/log/example/access.log;\n    error_log /var/log/example/error.log;\n    # 301 永久重定向\n    return 301 https://$host$request_uri;\n    location / {\n        root /your/project/path;\n        index index.html index.htm;\n    }\n}\n```\n这时再访问网站，浏览器地址栏就会出现一把小锁。\n![https.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/2.png)\n\n一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。\n\n最后可以使用 [ssllabs](https://www.ssllabs.com/ssltest/analyze.html) 测试一下网站的安全性，我的网站得了 A+😁\n\n---------\n参考链接：\n1. [Nginx 配置 HTTPS 服务器](https://aotu.io/notes/2016/08/16/nginx-https/)\n2. [How To Secure Nginx with Let's Encrypt on CentOS 7](https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7)","source":"_posts/我的HTTPS升级之旅.md","raw":"---\ntitle: 我的 HTTPS 升级之旅\ndate: 2017-05-11 21:47:36\ntags:\n- HTTP\ncategories:\n- 网络\n---\n> 本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0\n\n# 前言\n先贴一个福利，也作为没有启用 HTTPS 的反面教材：\n\n![福利.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/1.png)\n这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。\n\n# 预备条件\n本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。\n\n# 获取证书\nHTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。\n\n我使用了大名鼎鼎的 Let's Encrypt 来生成证书。\n## 1. 安装 certbot\ncertbot 是 Let's Encrypt 提供的一套自动化工具。 \n```\nyum install epel-release\nyum install certbot\n```\n## 2. 生成证书\n这里采用 webroot 作为 Let's Encrypt 的认证方式。\n```\ncertbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com\n```\nwebroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：\n- cert.pem: 服务端证书\n- chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书\n- fullchain.pem: 包括了cert.pem和chain.pem的内容\n- privkey.pem: 证书私钥\n\n## 3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\n为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。\n```\nopenssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\n```\n如果没有安装 openssl，这里要先安装一下。\n```\nyum install openssl\n```\n\n\n# 配置 Nginx\n编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。\n```\nserver {\n    listen 443 ssl;\n    # 启用http2\n    # 需要安装 Nginx Http2 Module\n    # listen 443 http2 ssl;\n    server_name example.com www.example.com;\n    #证书文件\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    #私钥文件\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    # 优先采取服务器算法\n    ssl_prefer_server_ciphers on;\n    # 定义算法\n    ssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\n    ssl_ecdh_curve secp384r1;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_tickets off;\n    ssl_stapling on;\n    ssl_stapling_verify on;\n    resolver 8.8.8.8 8.8.4.4 valid=300s;\n    resolver_timeout 5s;\n   \n    add_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    # 使用DH文件\n    ssl_dhparam /etc/ssl/certs/dhparam.pem;\n\n    location ~ /.well-known {\n        allow all;\n    }\n\n    root /your/project/path;\n    index index.html index.htm;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n```\n解释一下其中几项配置：\n```\nssl_stapling on;\n```\n开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。\n```\nadd_header Strict-Transport-Security \"max-age=63072000; includeSubdomains\";\n```\n启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接\n```\n    add_header X-Frame-Options DENY;\n```\n添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少[点击劫持 (clickjacking)攻击](https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/)。\n```\n    add_header X-Content-Type-Options nosniff;\n```\n添加 X-Content-Type-Options 响应头，防止 [MIME 类型嗅探攻击](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing)\n\n解释完毕。继续，来测试 nginx.conf 是否有语法错误\n```\nnginx -t\n```\n重启 Nginx\n```\nnginx -s reload\n```\n# 重定向 HTTP 到 HTTPS\n修改原来 HTTP 网站的 Nginx 配置。\n```\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    access_log /var/log/example/access.log;\n    error_log /var/log/example/error.log;\n    # 301 永久重定向\n    return 301 https://$host$request_uri;\n    location / {\n        root /your/project/path;\n        index index.html index.htm;\n    }\n}\n```\n这时再访问网站，浏览器地址栏就会出现一把小锁。\n![https.png](https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/2.png)\n\n一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。\n\n最后可以使用 [ssllabs](https://www.ssllabs.com/ssltest/analyze.html) 测试一下网站的安全性，我的网站得了 A+😁\n\n---------\n参考链接：\n1. [Nginx 配置 HTTPS 服务器](https://aotu.io/notes/2016/08/16/nginx-https/)\n2. [How To Secure Nginx with Let's Encrypt on CentOS 7](https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7)","slug":"我的HTTPS升级之旅","published":1,"updated":"2019-12-29T11:28:13.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn8z003dhns6ejka6sik","content":"<blockquote>\n<p>本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0</p>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>先贴一个福利，也作为没有启用 HTTPS 的反面教材：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/1.png\" alt=\"福利.png\"><br>这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。</p>\n<h1 id=\"预备条件\"><a href=\"#预备条件\" class=\"headerlink\" title=\"预备条件\"></a>预备条件</h1><p>本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。</p>\n<h1 id=\"获取证书\"><a href=\"#获取证书\" class=\"headerlink\" title=\"获取证书\"></a>获取证书</h1><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。</p>\n<p>我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p>\n<h2 id=\"1-安装-certbot\"><a href=\"#1-安装-certbot\" class=\"headerlink\" title=\"1. 安装 certbot\"></a>1. 安装 certbot</h2><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install epel-release</span><br><span class=\"line\">yum install certbot</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h2><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</span><br></pre></td></tr></table></figure></p>\n<p>webroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p>\n<ul>\n<li>cert.pem: 服务端证书</li>\n<li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li>\n<li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li>\n<li>privkey.pem: 证书私钥</li>\n</ul>\n<h2 id=\"3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\"><a href=\"#3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\" class=\"headerlink\" title=\"3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\"></a>3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</h2><p>为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</span><br></pre></td></tr></table></figure></p>\n<p>如果没有安装 openssl，这里要先安装一下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install openssl</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"配置-Nginx\"><a href=\"#配置-Nginx\" class=\"headerlink\" title=\"配置 Nginx\"></a>配置 Nginx</h1><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    # 启用http2</span><br><span class=\"line\">    # 需要安装 Nginx Http2 Module</span><br><span class=\"line\">    # listen 443 http2 ssl;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    #证书文件</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class=\"line\">    #私钥文件</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    # 优先采取服务器算法</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    # 定义算法</span><br><span class=\"line\">    ssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;;</span><br><span class=\"line\">    ssl_ecdh_curve secp384r1;</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_tickets off;</span><br><span class=\"line\">    ssl_stapling on;</span><br><span class=\"line\">    ssl_stapling_verify on;</span><br><span class=\"line\">    resolver 8.8.8.8 8.8.4.4 valid=300s;</span><br><span class=\"line\">    resolver_timeout 5s;</span><br><span class=\"line\">   </span><br><span class=\"line\">    add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br><span class=\"line\">    add_header X-Frame-Options DENY;</span><br><span class=\"line\">    add_header X-Content-Type-Options nosniff;</span><br><span class=\"line\">    # 使用DH文件</span><br><span class=\"line\">    ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ /.well-known &#123;</span><br><span class=\"line\">        allow all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /your/project/path;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        try_files $uri $uri/ =404;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释一下其中几项配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssl_stapling on;</span><br></pre></td></tr></table></figure></p>\n<p>开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Frame-Options DENY;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少<a href=\"https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/\" target=\"_blank\" rel=\"noopener\">点击劫持 (clickjacking)攻击</a>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Content-Type-Options 响应头，防止 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing\" target=\"_blank\" rel=\"noopener\">MIME 类型嗅探攻击</a></p>\n<p>解释完毕。继续，来测试 nginx.conf 是否有语法错误<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure></p>\n<p>重启 Nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"重定向-HTTP-到-HTTPS\"><a href=\"#重定向-HTTP-到-HTTPS\" class=\"headerlink\" title=\"重定向 HTTP 到 HTTPS\"></a>重定向 HTTP 到 HTTPS</h1><p>修改原来 HTTP 网站的 Nginx 配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    access_log /var/log/example/access.log;</span><br><span class=\"line\">    error_log /var/log/example/error.log;</span><br><span class=\"line\">    # 301 永久重定向</span><br><span class=\"line\">    return 301 https://$host$request_uri;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root /your/project/path;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时再访问网站，浏览器地址栏就会出现一把小锁。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/2.png\" alt=\"https.png\"></p>\n<p>一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。</p>\n<p>最后可以使用 <a href=\"https://www.ssllabs.com/ssltest/analyze.html\" target=\"_blank\" rel=\"noopener\">ssllabs</a> 测试一下网站的安全性，我的网站得了 A+😁</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://aotu.io/notes/2016/08/16/nginx-https/\" target=\"_blank\" rel=\"noopener\">Nginx 配置 HTTPS 服务器</a></li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7\" target=\"_blank\" rel=\"noopener\">How To Secure Nginx with Let’s Encrypt on CentOS 7</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文将介绍我是如何将一个 HTTP 网站升级到 HTTPS。系统环境：CentOS 7.0 + Nginx 1.12.0</p>\n</blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>先贴一个福利，也作为没有启用 HTTPS 的反面教材：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/1.png\" alt=\"福利.png\"><br>这是我参与开发过的一个外包网站，没有启用 HTTPS，网站页面被中间人劫持，并插入了一些奇怪的东西。下面是正文。</p>\n<h1 id=\"预备条件\"><a href=\"#预备条件\" class=\"headerlink\" title=\"预备条件\"></a>预备条件</h1><p>本文假定你已经拥有一个正确解析到服务器IP的域名，服务器上已安装 Nginx。Nginx 可以通过源码编译安装，也可以使用系统提供的包管理器安装，比如 RH 系的 yum 或者 Debian 系的 apt-get，具体步骤自行Google。</p>\n<h1 id=\"获取证书\"><a href=\"#获取证书\" class=\"headerlink\" title=\"获取证书\"></a>获取证书</h1><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。</p>\n<p>我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p>\n<h2 id=\"1-安装-certbot\"><a href=\"#1-安装-certbot\" class=\"headerlink\" title=\"1. 安装 certbot\"></a>1. 安装 certbot</h2><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install epel-release</span><br><span class=\"line\">yum install certbot</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-生成证书\"><a href=\"#2-生成证书\" class=\"headerlink\" title=\"2. 生成证书\"></a>2. 生成证书</h2><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</span><br></pre></td></tr></table></figure></p>\n<p>webroot-path就是你的项目路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p>\n<ul>\n<li>cert.pem: 服务端证书</li>\n<li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li>\n<li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li>\n<li>privkey.pem: 证书私钥</li>\n</ul>\n<h2 id=\"3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\"><a href=\"#3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）\" class=\"headerlink\" title=\"3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）\"></a>3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</h2><p>为了进一步提高安全性，你也可以生成一个 Strong Diffie-Hellman Group。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</span><br></pre></td></tr></table></figure></p>\n<p>如果没有安装 openssl，这里要先安装一下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install openssl</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"配置-Nginx\"><a href=\"#配置-Nginx\" class=\"headerlink\" title=\"配置 Nginx\"></a>配置 Nginx</h1><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    # 启用http2</span><br><span class=\"line\">    # 需要安装 Nginx Http2 Module</span><br><span class=\"line\">    # listen 443 http2 ssl;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    #证书文件</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class=\"line\">    #私钥文件</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    # 优先采取服务器算法</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    # 定义算法</span><br><span class=\"line\">    ssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;;</span><br><span class=\"line\">    ssl_ecdh_curve secp384r1;</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_tickets off;</span><br><span class=\"line\">    ssl_stapling on;</span><br><span class=\"line\">    ssl_stapling_verify on;</span><br><span class=\"line\">    resolver 8.8.8.8 8.8.4.4 valid=300s;</span><br><span class=\"line\">    resolver_timeout 5s;</span><br><span class=\"line\">   </span><br><span class=\"line\">    add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br><span class=\"line\">    add_header X-Frame-Options DENY;</span><br><span class=\"line\">    add_header X-Content-Type-Options nosniff;</span><br><span class=\"line\">    # 使用DH文件</span><br><span class=\"line\">    ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ /.well-known &#123;</span><br><span class=\"line\">        allow all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /your/project/path;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        try_files $uri $uri/ =404;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释一下其中几项配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssl_stapling on;</span><br></pre></td></tr></table></figure></p>\n<p>开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Frame-Options DENY;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少<a href=\"https://blogs.msdn.microsoft.com/ie/2009/01/27/ie8-security-part-vii-clickjacking-defenses/\" target=\"_blank\" rel=\"noopener\">点击劫持 (clickjacking)攻击</a>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure></p>\n<p>添加 X-Content-Type-Options 响应头，防止 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing\" target=\"_blank\" rel=\"noopener\">MIME 类型嗅探攻击</a></p>\n<p>解释完毕。继续，来测试 nginx.conf 是否有语法错误<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure></p>\n<p>重启 Nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"重定向-HTTP-到-HTTPS\"><a href=\"#重定向-HTTP-到-HTTPS\" class=\"headerlink\" title=\"重定向 HTTP 到 HTTPS\"></a>重定向 HTTP 到 HTTPS</h1><p>修改原来 HTTP 网站的 Nginx 配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com www.example.com;</span><br><span class=\"line\">    access_log /var/log/example/access.log;</span><br><span class=\"line\">    error_log /var/log/example/error.log;</span><br><span class=\"line\">    # 301 永久重定向</span><br><span class=\"line\">    return 301 https://$host$request_uri;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root /your/project/path;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时再访问网站，浏览器地址栏就会出现一把小锁。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/https-upgrade/2.png\" alt=\"https.png\"></p>\n<p>一旦升级 HTTPS，网站内的所有资源文件和请求的协议也必须为 HTTPS，你需要在前端代码里修改一下。</p>\n<p>最后可以使用 <a href=\"https://www.ssllabs.com/ssltest/analyze.html\" target=\"_blank\" rel=\"noopener\">ssllabs</a> 测试一下网站的安全性，我的网站得了 A+😁</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://aotu.io/notes/2016/08/16/nginx-https/\" target=\"_blank\" rel=\"noopener\">Nginx 配置 HTTPS 服务器</a></li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7\" target=\"_blank\" rel=\"noopener\">How To Secure Nginx with Let’s Encrypt on CentOS 7</a></li>\n</ol>\n"},{"title":"正则表达式学习笔记","date":"2016-03-10T08:11:39.000Z","_content":"JavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建\n如：` var re = /s$/;`这个正则表达式可以匹配以字符s结尾的字符串\n\n### 1.字符类 ###\n把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。\n如：`/[abc]/`与字母a、b、c中的任意一个都匹配。\n常见字符类\n`[abc]`  方括号内任意字符\n`[^abc]`  不在方括号内的任意字符\n`.`  除换行符和其他Unicode行终止符之外的任意字符\n`\\w`  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]  \n`\\W`  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n`\\s`  任何Unicode空白符\n`\\d`  任何ASCII数字\n### 2.重复 ###\n`{n,m}`　匹配前一项至少n次，至多m次\n`{n,}` 　  匹配前一项n次或更多次\n`{n}`　　匹配前一项n次\n`?`　　　匹配前一项0次或1次\n`+`　　 匹配前一项1次或多次\n`*`　　  匹配前一项0次或多次\n\n栗子：\n`/\\d{2,4}/`  匹配2-4个数字\n`/\\w{3}\\d?`  匹配3个字符和一个可选的数字\n### 3.分组 ###\n字符”|“用于分隔供选择的字符，如`/ab|cd|ef/`可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。\n圆括号\"()\"可用于把单独的项组合成子表达式\n\n### 4.修饰符 ###\n修饰符放在\"/\"之外，用语说明匹配模式。JavaScript支持三种修饰符\ni    执行不区分大小写的匹配\ng   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止\nm  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束\n### 5.指定匹配位置 ###\n^   匹配字符串的开头\n$   匹配字符串的结尾\n\\b  匹配单词的边界\n(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配\n`/Java(?!Script)/g `匹配以“Java”开头，但接下来的字符不是“Script”的字符串\n\n### 5.RegExp对象 ###\n- RegExp对象的属性\n  source：只读的字符串，包含正则表达式的源文本\n  lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。\n- RegExp对象的方法\n  exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null\n```\nvar str = 'Hello World';\nvar re = /Wo/g;\nvar result = re.exec(str);\nif(result != null){\n    console.log('Find '+result+' at '+result.index);//输出Find Wo at 6\n    console.log('next search begin at '+re.lastIndex);//输出next search begin at 8\n}\n```\ntest():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false\n### 6.支持正则表达式的String对象的方法 ###\nString对象支持4种使用正则表达式的方法。\n- search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。\n- replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。\n```\n//将Lebron James替换为James Lebron\nvar name = 'Lebron James';\nvar result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,'$2 $1');\nconsole.log(result);\n```\n- match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。\n```\n//匹配出字符串中的数字，将其保存到一个数组中\nvar str = 'rgb(237,13,235)';\nvar result = str.match(/\\d+/g);\nconsole.log(result);//输出[\"237\", \"13\", \"235\"]\n```\n- split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。","source":"_posts/正则表达式的模式匹配.md","raw":"---\ntitle: 正则表达式学习笔记\ndate: 2016-03-10 16:11:39\ntags:\n- JavaScript\ncategories:\n- 前端\n---\nJavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建\n如：` var re = /s$/;`这个正则表达式可以匹配以字符s结尾的字符串\n\n### 1.字符类 ###\n把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。\n如：`/[abc]/`与字母a、b、c中的任意一个都匹配。\n常见字符类\n`[abc]`  方括号内任意字符\n`[^abc]`  不在方括号内的任意字符\n`.`  除换行符和其他Unicode行终止符之外的任意字符\n`\\w`  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]  \n`\\W`  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]\n`\\s`  任何Unicode空白符\n`\\d`  任何ASCII数字\n### 2.重复 ###\n`{n,m}`　匹配前一项至少n次，至多m次\n`{n,}` 　  匹配前一项n次或更多次\n`{n}`　　匹配前一项n次\n`?`　　　匹配前一项0次或1次\n`+`　　 匹配前一项1次或多次\n`*`　　  匹配前一项0次或多次\n\n栗子：\n`/\\d{2,4}/`  匹配2-4个数字\n`/\\w{3}\\d?`  匹配3个字符和一个可选的数字\n### 3.分组 ###\n字符”|“用于分隔供选择的字符，如`/ab|cd|ef/`可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。\n圆括号\"()\"可用于把单独的项组合成子表达式\n\n### 4.修饰符 ###\n修饰符放在\"/\"之外，用语说明匹配模式。JavaScript支持三种修饰符\ni    执行不区分大小写的匹配\ng   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止\nm  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束\n### 5.指定匹配位置 ###\n^   匹配字符串的开头\n$   匹配字符串的结尾\n\\b  匹配单词的边界\n(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配\n(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配\n`/Java(?!Script)/g `匹配以“Java”开头，但接下来的字符不是“Script”的字符串\n\n### 5.RegExp对象 ###\n- RegExp对象的属性\n  source：只读的字符串，包含正则表达式的源文本\n  lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。\n- RegExp对象的方法\n  exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null\n```\nvar str = 'Hello World';\nvar re = /Wo/g;\nvar result = re.exec(str);\nif(result != null){\n    console.log('Find '+result+' at '+result.index);//输出Find Wo at 6\n    console.log('next search begin at '+re.lastIndex);//输出next search begin at 8\n}\n```\ntest():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false\n### 6.支持正则表达式的String对象的方法 ###\nString对象支持4种使用正则表达式的方法。\n- search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。\n- replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。\n```\n//将Lebron James替换为James Lebron\nvar name = 'Lebron James';\nvar result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,'$2 $1');\nconsole.log(result);\n```\n- match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。\n```\n//匹配出字符串中的数字，将其保存到一个数组中\nvar str = 'rgb(237,13,235)';\nvar result = str.match(/\\d+/g);\nconsole.log(result);//输出[\"237\", \"13\", \"235\"]\n```\n- split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。","slug":"正则表达式的模式匹配","published":1,"updated":"2019-12-29T09:43:56.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn91003hhns6c51ntt76","content":"<p>JavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建<br>如：<code>var re = /s$/;</code>这个正则表达式可以匹配以字符s结尾的字符串</p>\n<h3 id=\"1-字符类\"><a href=\"#1-字符类\" class=\"headerlink\" title=\"1.字符类\"></a>1.字符类</h3><p>把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。<br>如：<code>/[abc]/</code>与字母a、b、c中的任意一个都匹配。<br>常见字符类<br><code>[abc]</code>  方括号内任意字符<br><code>[^abc]</code>  不在方括号内的任意字符<br><code>.</code>  除换行符和其他Unicode行终止符之外的任意字符<br><code>\\w</code>  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]<br><code>\\W</code>  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]<br><code>\\s</code>  任何Unicode空白符<br><code>\\d</code>  任何ASCII数字</p>\n<h3 id=\"2-重复\"><a href=\"#2-重复\" class=\"headerlink\" title=\"2.重复\"></a>2.重复</h3><p><code>{n,m}</code>　匹配前一项至少n次，至多m次<br><code>{n,}</code> 　  匹配前一项n次或更多次<br><code>{n}</code>　　匹配前一项n次<br><code>?</code>　　　匹配前一项0次或1次<br><code>+</code>　　 匹配前一项1次或多次<br><code>*</code>　　  匹配前一项0次或多次</p>\n<p>栗子：<br><code>/\\d{2,4}/</code>  匹配2-4个数字<br><code>/\\w{3}\\d?</code>  匹配3个字符和一个可选的数字</p>\n<h3 id=\"3-分组\"><a href=\"#3-分组\" class=\"headerlink\" title=\"3.分组\"></a>3.分组</h3><p>字符”|“用于分隔供选择的字符，如<code>/ab|cd|ef/</code>可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。<br>圆括号”()”可用于把单独的项组合成子表达式</p>\n<h3 id=\"4-修饰符\"><a href=\"#4-修饰符\" class=\"headerlink\" title=\"4.修饰符\"></a>4.修饰符</h3><p>修饰符放在”/“之外，用语说明匹配模式。JavaScript支持三种修饰符<br>i    执行不区分大小写的匹配<br>g   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止<br>m  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束</p>\n<h3 id=\"5-指定匹配位置\"><a href=\"#5-指定匹配位置\" class=\"headerlink\" title=\"5.指定匹配位置\"></a>5.指定匹配位置</h3><p>^   匹配字符串的开头<br>$   匹配字符串的结尾<br>\\b  匹配单词的边界<br>(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配<br>(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配<br><code>/Java(?!Script)/g</code>匹配以“Java”开头，但接下来的字符不是“Script”的字符串</p>\n<h3 id=\"5-RegExp对象\"><a href=\"#5-RegExp对象\" class=\"headerlink\" title=\"5.RegExp对象\"></a>5.RegExp对象</h3><ul>\n<li>RegExp对象的属性<br>source：只读的字符串，包含正则表达式的源文本<br>lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。</li>\n<li>RegExp对象的方法<br>exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str = &apos;Hello World&apos;;</span><br><span class=\"line\">var re = /Wo/g;</span><br><span class=\"line\">var result = re.exec(str);</span><br><span class=\"line\">if(result != null)&#123;</span><br><span class=\"line\">    console.log(&apos;Find &apos;+result+&apos; at &apos;+result.index);//输出Find Wo at 6</span><br><span class=\"line\">    console.log(&apos;next search begin at &apos;+re.lastIndex);//输出next search begin at 8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>test():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false</p>\n<h3 id=\"6-支持正则表达式的String对象的方法\"><a href=\"#6-支持正则表达式的String对象的方法\" class=\"headerlink\" title=\"6.支持正则表达式的String对象的方法\"></a>6.支持正则表达式的String对象的方法</h3><p>String对象支持4种使用正则表达式的方法。</p>\n<ul>\n<li>search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。</li>\n<li><p>replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//将Lebron James替换为James Lebron</span><br><span class=\"line\">var name = &apos;Lebron James&apos;;</span><br><span class=\"line\">var result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,&apos;$2 $1&apos;);</span><br><span class=\"line\">console.log(result);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//匹配出字符串中的数字，将其保存到一个数组中</span><br><span class=\"line\">var str = &apos;rgb(237,13,235)&apos;;</span><br><span class=\"line\">var result = str.match(/\\d+/g);</span><br><span class=\"line\">console.log(result);//输出[&quot;237&quot;, &quot;13&quot;, &quot;235&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript中用RegExp对象表示正则表达式，可以用RegExp()构造函数来创建正则表达式，不过更多时候是用对象直接量来创建<br>如：<code>var re = /s$/;</code>这个正则表达式可以匹配以字符s结尾的字符串</p>\n<h3 id=\"1-字符类\"><a href=\"#1-字符类\" class=\"headerlink\" title=\"1.字符类\"></a>1.字符类</h3><p>把字符放进方括号就变成了字符类，一个字符类可以匹配它所包含的任意字符。<br>如：<code>/[abc]/</code>与字母a、b、c中的任意一个都匹配。<br>常见字符类<br><code>[abc]</code>  方括号内任意字符<br><code>[^abc]</code>  不在方括号内的任意字符<br><code>.</code>  除换行符和其他Unicode行终止符之外的任意字符<br><code>\\w</code>  任何ASCII字符组成的单词，等价于[a-zA-Z0-9]<br><code>\\W</code>  任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]<br><code>\\s</code>  任何Unicode空白符<br><code>\\d</code>  任何ASCII数字</p>\n<h3 id=\"2-重复\"><a href=\"#2-重复\" class=\"headerlink\" title=\"2.重复\"></a>2.重复</h3><p><code>{n,m}</code>　匹配前一项至少n次，至多m次<br><code>{n,}</code> 　  匹配前一项n次或更多次<br><code>{n}</code>　　匹配前一项n次<br><code>?</code>　　　匹配前一项0次或1次<br><code>+</code>　　 匹配前一项1次或多次<br><code>*</code>　　  匹配前一项0次或多次</p>\n<p>栗子：<br><code>/\\d{2,4}/</code>  匹配2-4个数字<br><code>/\\w{3}\\d?</code>  匹配3个字符和一个可选的数字</p>\n<h3 id=\"3-分组\"><a href=\"#3-分组\" class=\"headerlink\" title=\"3.分组\"></a>3.分组</h3><p>字符”|“用于分隔供选择的字符，如<code>/ab|cd|ef/</code>可匹配字符串”ab“,也可匹配”cd“，还可匹配”ef“。<br>圆括号”()”可用于把单独的项组合成子表达式</p>\n<h3 id=\"4-修饰符\"><a href=\"#4-修饰符\" class=\"headerlink\" title=\"4.修饰符\"></a>4.修饰符</h3><p>修饰符放在”/“之外，用语说明匹配模式。JavaScript支持三种修饰符<br>i    执行不区分大小写的匹配<br>g   执行全局匹配，即找到所有的匹配，而不是在找到第一个后就停止<br>m  执行多行匹配。在这种模式下，如果被检索的字符串包含多行，^和$分别匹配每一行的开头和结束</p>\n<h3 id=\"5-指定匹配位置\"><a href=\"#5-指定匹配位置\" class=\"headerlink\" title=\"5.指定匹配位置\"></a>5.指定匹配位置</h3><p>^   匹配字符串的开头<br>$   匹配字符串的结尾<br>\\b  匹配单词的边界<br>(?=p)  零宽正向先行断言，要求接下来的字符都与p匹配<br>(?!p)    零宽负向先行断言，要求接下来的字符都不与p匹配<br><code>/Java(?!Script)/g</code>匹配以“Java”开头，但接下来的字符不是“Script”的字符串</p>\n<h3 id=\"5-RegExp对象\"><a href=\"#5-RegExp对象\" class=\"headerlink\" title=\"5.RegExp对象\"></a>5.RegExp对象</h3><ul>\n<li>RegExp对象的属性<br>source：只读的字符串，包含正则表达式的源文本<br>lastIndex：一个可读写的整数，如果匹配模式带有g修饰符，这个属性用于存储下次匹配的起始位置。</li>\n<li>RegExp对象的方法<br>exec()：检索字符串中指定的值。如果找到匹配的值，返回一个结果数组，并确定其位置。如果没有找到匹配的值，就返回null<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str = &apos;Hello World&apos;;</span><br><span class=\"line\">var re = /Wo/g;</span><br><span class=\"line\">var result = re.exec(str);</span><br><span class=\"line\">if(result != null)&#123;</span><br><span class=\"line\">    console.log(&apos;Find &apos;+result+&apos; at &apos;+result.index);//输出Find Wo at 6</span><br><span class=\"line\">    console.log(&apos;next search begin at &apos;+re.lastIndex);//输出next search begin at 8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>test():参数是一个字符串，如果成功匹配，返回true；如果没有匹配到结果，返回false</p>\n<h3 id=\"6-支持正则表达式的String对象的方法\"><a href=\"#6-支持正则表达式的String对象的方法\" class=\"headerlink\" title=\"6.支持正则表达式的String对象的方法\"></a>6.支持正则表达式的String对象的方法</h3><p>String对象支持4种使用正则表达式的方法。</p>\n<ul>\n<li>search()：参数是一个正则表达式，返回一个与之匹配的子串的起始位置，如果找不到子串，返回-1。</li>\n<li><p>replace()：执行检索和替换。第一个参数是一个正则表达式，第二个参数是一个内容为替换文本的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//将Lebron James替换为James Lebron</span><br><span class=\"line\">var name = &apos;Lebron James&apos;;</span><br><span class=\"line\">var result = name.replace(/(\\w+)\\s*\\s*(\\w+)/g,&apos;$2 $1&apos;);</span><br><span class=\"line\">console.log(result);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>match()：唯一参数是一个正则表达式，返回一个由匹配结果组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//匹配出字符串中的数字，将其保存到一个数组中</span><br><span class=\"line\">var str = &apos;rgb(237,13,235)&apos;;</span><br><span class=\"line\">var result = str.match(/\\d+/g);</span><br><span class=\"line\">console.log(result);//输出[&quot;237&quot;, &quot;13&quot;, &quot;235&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>split()：将调用它的字符串拆分成一个子串组成的数组。第一个参数可以是字符串或者正则表达式，第二个可选参数可以指定返回数组的最大长度。</p>\n</li>\n</ul>\n"},{"title":"深入理解 BFC","date":"2016-03-09T07:56:53.000Z","_content":"# BFC的定义\n先看W3C文档\n> In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the['margin'](https://www.w3.org/TR/CSS2/box.html#propdef-margin) properties. Vertical margins between adjacent block-level boxes in a block formatting context [collapse](https://www.w3.org/TR/CSS2/box.html#collapsing-margins).\n\n>In a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's *line boxes* may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself [*may* become narrower](https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float) due to the floats).\n\nBlock Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。\n\n文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。\n\n通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n# 如何创建BFC\n再来看一下官方文档怎么说的\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n总结一下就是：\n- float属性不为none\n- overflow不为visible(可以是hidden、scroll、auto)\n- position为absolute或fixed\n- display为inline-block、table-cell、table-caption\n\n# BFC的作用\n**1. 清除内部浮动**\n我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。\n**2. 垂直margin合并**\n在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n折叠的结果：\n - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n - 两个外边距一正一负时，折叠结果是两者的相加的和。\n这个同样可以利用BFC解决。关于原理在前文已经讲过了。\n\n**3. 创建自适应两栏布局**\n在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n.box {\n    width:300px;\n    border: 1px solid #000;\n}\n.img {\n    float: left;\n}\n.info {\n    background: #f1f1f1;\n    color: #222;\n}\n```\n```html\n<\\div class=\"box\">\n    <\\img src=\"03.jpg\" alt=\"\" class=\"img\">\n    <\\p class=\"info\">信息信息信息信息信息信息</p>\n</\\div>\n```\n一般情况下，它是这样的\n\n![图1](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/1.png)\n\n但是当文字多了以后...\n\n![图2](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/2.png)\n\n显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上 `overflow:hidden`\n![图3](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/3.png)\n\n两栏布局就完成了。我们改变图片的大小：\n![图4](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/4.png)\n两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。\n\n------\n参考链接：\n1. [Visual formatting model](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)\n2. [CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/?p=4588)","source":"_posts/深入理解BFC.md","raw":"---\ntitle: 深入理解 BFC\ndate: 2016-03-09 15:56:53\ntags: \n- CSS\ncategories: \n- 前端\n---\n# BFC的定义\n先看W3C文档\n> In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the['margin'](https://www.w3.org/TR/CSS2/box.html#propdef-margin) properties. Vertical margins between adjacent block-level boxes in a block formatting context [collapse](https://www.w3.org/TR/CSS2/box.html#collapsing-margins).\n\n>In a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's *line boxes* may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself [*may* become narrower](https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float) due to the floats).\n\nBlock Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。\n\n文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。\n\n通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n# 如何创建BFC\n再来看一下官方文档怎么说的\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n总结一下就是：\n- float属性不为none\n- overflow不为visible(可以是hidden、scroll、auto)\n- position为absolute或fixed\n- display为inline-block、table-cell、table-caption\n\n# BFC的作用\n**1. 清除内部浮动**\n我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。\n**2. 垂直margin合并**\n在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n折叠的结果：\n - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n - 两个外边距一正一负时，折叠结果是两者的相加的和。\n这个同样可以利用BFC解决。关于原理在前文已经讲过了。\n\n**3. 创建自适应两栏布局**\n在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n.box {\n    width:300px;\n    border: 1px solid #000;\n}\n.img {\n    float: left;\n}\n.info {\n    background: #f1f1f1;\n    color: #222;\n}\n```\n```html\n<\\div class=\"box\">\n    <\\img src=\"03.jpg\" alt=\"\" class=\"img\">\n    <\\p class=\"info\">信息信息信息信息信息信息</p>\n</\\div>\n```\n一般情况下，它是这样的\n\n![图1](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/1.png)\n\n但是当文字多了以后...\n\n![图2](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/2.png)\n\n显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上 `overflow:hidden`\n![图3](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/3.png)\n\n两栏布局就完成了。我们改变图片的大小：\n![图4](https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/4.png)\n两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。\n\n------\n参考链接：\n1. [Visual formatting model](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)\n2. [CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/?p=4588)","slug":"深入理解BFC","published":1,"updated":"2019-12-29T11:28:13.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn96003lhns62hju6u8g","content":"<h1 id=\"BFC的定义\"><a href=\"#BFC的定义\" class=\"headerlink\" title=\"BFC的定义\"></a>BFC的定义</h1><p>先看W3C文档</p>\n<blockquote>\n<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the<a href=\"https://www.w3.org/TR/CSS2/box.html#propdef-margin\" target=\"_blank\" rel=\"noopener\">‘margin’</a> properties. Vertical margins between adjacent block-level boxes in a block formatting context <a href=\"https://www.w3.org/TR/CSS2/box.html#collapsing-margins\" target=\"_blank\" rel=\"noopener\">collapse</a>.</p>\n<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s <em>line boxes</em> may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself <a href=\"https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float\" target=\"_blank\" rel=\"noopener\"><em>may</em> become narrower</a> due to the floats).</p>\n</blockquote>\n<p>Block Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。</p>\n<p>文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。</p>\n<p>通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h1 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h1><p>再来看一下官方文档怎么说的</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>总结一下就是：</p>\n<ul>\n<li>float属性不为none</li>\n<li>overflow不为visible(可以是hidden、scroll、auto)</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block、table-cell、table-caption</li>\n</ul>\n<h1 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h1><p><strong>1. 清除内部浮动</strong><br>我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。<br><strong>2. 垂直margin合并</strong><br>在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br>折叠的结果：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。<br>这个同样可以利用BFC解决。关于原理在前文已经讲过了。</li>\n</ul>\n<p><strong>3. 创建自适应两栏布局</strong><br>在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.info</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#f1f1f1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#222</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">\\div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">\\img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"03.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">\\p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"info\"</span>&gt;</span>信息信息信息信息信息信息<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">\\div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一般情况下，它是这样的</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/1.png\" alt=\"图1\"></p>\n<p>但是当文字多了以后…</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/2.png\" alt=\"图2\"></p>\n<p>显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上 <code>overflow:hidden</code><br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/3.png\" alt=\"图3\"></p>\n<p>两栏布局就完成了。我们改变图片的大小：<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/4.png\" alt=\"图4\"><br>两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\" target=\"_blank\" rel=\"noopener\">Visual formatting model</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/?p=4588\" target=\"_blank\" rel=\"noopener\">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BFC的定义\"><a href=\"#BFC的定义\" class=\"headerlink\" title=\"BFC的定义\"></a>BFC的定义</h1><p>先看W3C文档</p>\n<blockquote>\n<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the<a href=\"https://www.w3.org/TR/CSS2/box.html#propdef-margin\" target=\"_blank\" rel=\"noopener\">‘margin’</a> properties. Vertical margins between adjacent block-level boxes in a block formatting context <a href=\"https://www.w3.org/TR/CSS2/box.html#collapsing-margins\" target=\"_blank\" rel=\"noopener\">collapse</a>.</p>\n<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s <em>line boxes</em> may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself <a href=\"https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float\" target=\"_blank\" rel=\"noopener\"><em>may</em> become narrower</a> due to the floats).</p>\n</blockquote>\n<p>Block Formatting Context，中文直译为块级格式上下文。BFC就是一种布局方式，在这种布局方式下，盒子们自所在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定。在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生“塌陷”。</p>\n<p>文档这里也间接指出了垂直相邻盒子margin合并的解决办法：就是给这两个盒子也创建BFC。</p>\n<p>通俗一点，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h1 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h1><p>再来看一下官方文档怎么说的</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>总结一下就是：</p>\n<ul>\n<li>float属性不为none</li>\n<li>overflow不为visible(可以是hidden、scroll、auto)</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block、table-cell、table-caption</li>\n</ul>\n<h1 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h1><p><strong>1. 清除内部浮动</strong><br>我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。<br><strong>2. 垂直margin合并</strong><br>在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br>折叠的结果：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。<br>这个同样可以利用BFC解决。关于原理在前文已经讲过了。</li>\n</ul>\n<p><strong>3. 创建自适应两栏布局</strong><br>在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.info</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#f1f1f1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#222</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">\\div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">\\img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"03.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">\\p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"info\"</span>&gt;</span>信息信息信息信息信息信息<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">\\div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一般情况下，它是这样的</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/1.png\" alt=\"图1\"></p>\n<p>但是当文字多了以后…</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/2.png\" alt=\"图2\"></p>\n<p>显然，这是文字受到了图片浮动的影响。当然，如果你想做文本绕排的效果，浮动是不二之选。不过在这里，这显然不是我们想要的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。给文字加上 <code>overflow:hidden</code><br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/3.png\" alt=\"图3\"></p>\n<p>两栏布局就完成了。我们改变图片的大小：<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/bfc/4.png\" alt=\"图4\"><br>两栏布局的结构依然没有改变，如此就实现了两栏自适应布局。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\" target=\"_blank\" rel=\"noopener\">Visual formatting model</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/?p=4588\" target=\"_blank\" rel=\"noopener\">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></li>\n</ol>\n"},{"title":"深入浅出 Node.js Cluster","date":"2019-03-12T14:16:11.000Z","_content":"\n## 前言\n如果大家用 PM2 管理 Node.js 进程，会发现它支持一种 cluster mode。开启 cluster mode 后，支持给 Node.js 创建多个进程。 如果将 cluster mode 下的 instances 设置为 max 的话，它还会根据服务器的 CPU 核心数，来创建对应数量的 Node 进程。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/nodejs-cluster/1.jpg)\n \nPM2 其实利用的是 Node.js Cluster 模块来实现的，这个模块的出现就是为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的优势而出现的。那么，Cluster 内部又是如何工作的呢？多个进程间是如何通信的？多个进程是如何监听同一个端口的？Node.js 是如何将请求分发到各个进程上的？如果你对上述问题还不清楚，不妨接着往下看。\n\n## 核心原理\nNode.js worker 进程由[`child_process.fork()`](http://nodejs.cn/s/VDCJMa)方法创建，这也意味存在着父进程和多个子进程。代码大致是这样：\n```\nconst cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isMaster) {\n  for (var i = 0, n = os.cpus().length; i < n; i += 1) {\n    cluster.fork();\n  }\n} else {\n   // 启动程序 \n}\n```\n学过操作系统的同学，应该对 fork() 这个系统调用不陌生，调用它的进程为父进程，fork 出来的都是子进程。子进程和父进程具有相同的数据空间、堆栈，但是它们的内存空间不共享。父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。这里涉及三个问题：父子进程通信、负载均衡策略以及多进程的端口监听。\n#### 进程通信\nmaster 进程通过 process.fork() 创建子进程，他们之间通过 IPC (内部进程通信)通道实现通信。操作系统的进程间通信方式主要有以下几种：\n- 共享内存\n不同进程共享同一段内存空间。通常还需要引入信号量机制，来实现同步与互斥。\n- 消息传递\n这种模式下，进程间通过发送、接收消息来实现信息的同步。\n- 信号量\n信号量简单说就是系统赋予进程的一个状态值，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量只有 0 或者 1 两个值的话，又被称作“互斥锁”。这个机制也被广泛用于各种编程模式中。\n- 管道\n管道本身也是一个进程，它用于连接两个进程，将一个进程的输出作为另一个进程的输入。可以用 pipe 系统调用来创建管道。我们经常用的“ | ”命令行就是利用了管道机制。\n\nNode.js 为父子进程的通信提供了事件机制来传递消息。下面的例子实现了父进程将 TCP server 对象句柄传给子进程。\n```\nconst subprocess = require('child_process').fork('subprocess.js');\n\n// 开启 server 对象，并发送该句柄。\nconst server = require('net').createServer();\nserver.on('connection', (socket) => {\n  socket.end('被父进程处理');\n});\nserver.listen(1337, () => {\n  subprocess.send('server', server);\n});\n```\n```\nprocess.on('message', (m, server) => {\n  if (m === 'server') {\n    server.on('connection', (socket) => {\n      socket.end('被子进程处理');\n    });\n  }\n});\n```\n那么问题又来了，如果进程间没有父子关系，换句话说，我们应该如何实现任意进程间的通信呢？大家可以去看看这篇文章：[进程间通信的另类实现](http://taobaofed.org/blog/2016/01/27/nodejs-ipc/)\n\n#### 负载均衡策略 \n前面提到，所有请求是通过 master 进程分配的，要保证服务器负载比较均衡的分配到各个 worker 进程上，这就涉及到负载均衡策略了。Node.js 默认采用的策略是 **round-robin** 时间片轮转法。\n\nround-robin 是一种很常见的负载均衡算法，Nginx 上也采用了它作为负载均衡策略之一。它的原理很简单，每一次把来自用户的请求轮流分配给各个进程，从 1 开始，直到 N(worker 进程个数)，然后重新开始循环。这个算法的问题在于，它是假定各个进程或者说各个服务器的处理性能是一样的，但是如果请求处理间隔较长，就容易导致出现负载不均衡。因此我们通常在 Nginx 上采用另一种算法：**WRR**，加权轮转法。通过给各个服务器分配一定的权重，每次选出权重最大的，给其权重减 1，直到权重全部为 0 后，按照此时生成的序列轮询。\n\n可以通过设置 NODE_CLUSTER_SCHED_POLICY 环境变量，或者通过 cluster.setupMaster(options) 来修改负载均衡策略。读到这里大家可以发现，我们可以 Nginx 做多机器集群上的负载均衡，然后用 Node.js Cluster 来实现单机多进程上的负载均衡。\n\n#### 多进程的端口监听\n最初的 Node.js 上，多个进程监听同一个端口，它们相互竞争新 accept 过来的连接。这样会导致各个进程的负载很不均衡，于是后来使用了上文提到的 round-robin 策略。具体思路是，master 进程创建 socket，绑定地址并进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。简单说就是，master 进程监听端口，然后将连接通过某种分发策略（比如 round-robin），转发给 worker 进程。这样由于只有 master 进程接收客户端连接，就解决了竞争导致的负载不均衡的问题。但是这样设计就要求 master 进程的稳定性足够好了。\n\n## 总结\n本文以 PM2 的 Cluster Mode 作为切入点，向大家介绍了 Node.js Cluster 实现多进程的核心原理。重点讲了进程通信、负载均衡以及多进程端口监听三个方面。通过研究 cluster 模块可以发现，很多底层原理或者是算法，其实都是通用的。比如 round-robin 算法，它在操作系统底层的进程调度中也有使用；比如 master-worker 这种架构，是不是在 Nginx 的多进程架构中也似曾相识；比如信号量、管道这些机制，也可以在各种编程模式中见到它们的身影。当下市面上各种新技术层出不穷，但核心其实是**万变不离其宗**，理解了这些最基础的知识，剩下的也可以触类旁通了。\n\n\n----------\n参考链接：\n1. [当我们谈论 cluster 时我们在谈论什么（下）](http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/)\n2. [Node.js进阶：cluster模块深入剖析](https://juejin.im/entry/5ad3eb536fb9a028d375db4e)\n3. [进程间通信的另类实现](http://taobaofed.org/blog/2016/01/27/nodejs-ipc/)\n","source":"_posts/深入浅出Node-js-Cluster.md","raw":"---\ntitle: 深入浅出 Node.js Cluster\ndate: 2019-03-12 22:16:11\ntags:\n- Node.js\ncategories:\n- 前端\n---\n\n## 前言\n如果大家用 PM2 管理 Node.js 进程，会发现它支持一种 cluster mode。开启 cluster mode 后，支持给 Node.js 创建多个进程。 如果将 cluster mode 下的 instances 设置为 max 的话，它还会根据服务器的 CPU 核心数，来创建对应数量的 Node 进程。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/nodejs-cluster/1.jpg)\n \nPM2 其实利用的是 Node.js Cluster 模块来实现的，这个模块的出现就是为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的优势而出现的。那么，Cluster 内部又是如何工作的呢？多个进程间是如何通信的？多个进程是如何监听同一个端口的？Node.js 是如何将请求分发到各个进程上的？如果你对上述问题还不清楚，不妨接着往下看。\n\n## 核心原理\nNode.js worker 进程由[`child_process.fork()`](http://nodejs.cn/s/VDCJMa)方法创建，这也意味存在着父进程和多个子进程。代码大致是这样：\n```\nconst cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isMaster) {\n  for (var i = 0, n = os.cpus().length; i < n; i += 1) {\n    cluster.fork();\n  }\n} else {\n   // 启动程序 \n}\n```\n学过操作系统的同学，应该对 fork() 这个系统调用不陌生，调用它的进程为父进程，fork 出来的都是子进程。子进程和父进程具有相同的数据空间、堆栈，但是它们的内存空间不共享。父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。这里涉及三个问题：父子进程通信、负载均衡策略以及多进程的端口监听。\n#### 进程通信\nmaster 进程通过 process.fork() 创建子进程，他们之间通过 IPC (内部进程通信)通道实现通信。操作系统的进程间通信方式主要有以下几种：\n- 共享内存\n不同进程共享同一段内存空间。通常还需要引入信号量机制，来实现同步与互斥。\n- 消息传递\n这种模式下，进程间通过发送、接收消息来实现信息的同步。\n- 信号量\n信号量简单说就是系统赋予进程的一个状态值，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量只有 0 或者 1 两个值的话，又被称作“互斥锁”。这个机制也被广泛用于各种编程模式中。\n- 管道\n管道本身也是一个进程，它用于连接两个进程，将一个进程的输出作为另一个进程的输入。可以用 pipe 系统调用来创建管道。我们经常用的“ | ”命令行就是利用了管道机制。\n\nNode.js 为父子进程的通信提供了事件机制来传递消息。下面的例子实现了父进程将 TCP server 对象句柄传给子进程。\n```\nconst subprocess = require('child_process').fork('subprocess.js');\n\n// 开启 server 对象，并发送该句柄。\nconst server = require('net').createServer();\nserver.on('connection', (socket) => {\n  socket.end('被父进程处理');\n});\nserver.listen(1337, () => {\n  subprocess.send('server', server);\n});\n```\n```\nprocess.on('message', (m, server) => {\n  if (m === 'server') {\n    server.on('connection', (socket) => {\n      socket.end('被子进程处理');\n    });\n  }\n});\n```\n那么问题又来了，如果进程间没有父子关系，换句话说，我们应该如何实现任意进程间的通信呢？大家可以去看看这篇文章：[进程间通信的另类实现](http://taobaofed.org/blog/2016/01/27/nodejs-ipc/)\n\n#### 负载均衡策略 \n前面提到，所有请求是通过 master 进程分配的，要保证服务器负载比较均衡的分配到各个 worker 进程上，这就涉及到负载均衡策略了。Node.js 默认采用的策略是 **round-robin** 时间片轮转法。\n\nround-robin 是一种很常见的负载均衡算法，Nginx 上也采用了它作为负载均衡策略之一。它的原理很简单，每一次把来自用户的请求轮流分配给各个进程，从 1 开始，直到 N(worker 进程个数)，然后重新开始循环。这个算法的问题在于，它是假定各个进程或者说各个服务器的处理性能是一样的，但是如果请求处理间隔较长，就容易导致出现负载不均衡。因此我们通常在 Nginx 上采用另一种算法：**WRR**，加权轮转法。通过给各个服务器分配一定的权重，每次选出权重最大的，给其权重减 1，直到权重全部为 0 后，按照此时生成的序列轮询。\n\n可以通过设置 NODE_CLUSTER_SCHED_POLICY 环境变量，或者通过 cluster.setupMaster(options) 来修改负载均衡策略。读到这里大家可以发现，我们可以 Nginx 做多机器集群上的负载均衡，然后用 Node.js Cluster 来实现单机多进程上的负载均衡。\n\n#### 多进程的端口监听\n最初的 Node.js 上，多个进程监听同一个端口，它们相互竞争新 accept 过来的连接。这样会导致各个进程的负载很不均衡，于是后来使用了上文提到的 round-robin 策略。具体思路是，master 进程创建 socket，绑定地址并进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。简单说就是，master 进程监听端口，然后将连接通过某种分发策略（比如 round-robin），转发给 worker 进程。这样由于只有 master 进程接收客户端连接，就解决了竞争导致的负载不均衡的问题。但是这样设计就要求 master 进程的稳定性足够好了。\n\n## 总结\n本文以 PM2 的 Cluster Mode 作为切入点，向大家介绍了 Node.js Cluster 实现多进程的核心原理。重点讲了进程通信、负载均衡以及多进程端口监听三个方面。通过研究 cluster 模块可以发现，很多底层原理或者是算法，其实都是通用的。比如 round-robin 算法，它在操作系统底层的进程调度中也有使用；比如 master-worker 这种架构，是不是在 Nginx 的多进程架构中也似曾相识；比如信号量、管道这些机制，也可以在各种编程模式中见到它们的身影。当下市面上各种新技术层出不穷，但核心其实是**万变不离其宗**，理解了这些最基础的知识，剩下的也可以触类旁通了。\n\n\n----------\n参考链接：\n1. [当我们谈论 cluster 时我们在谈论什么（下）](http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/)\n2. [Node.js进阶：cluster模块深入剖析](https://juejin.im/entry/5ad3eb536fb9a028d375db4e)\n3. [进程间通信的另类实现](http://taobaofed.org/blog/2016/01/27/nodejs-ipc/)\n","slug":"深入浅出Node-js-Cluster","published":1,"updated":"2019-12-29T11:28:13.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9a003ohns627yie8o8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>如果大家用 PM2 管理 Node.js 进程，会发现它支持一种 cluster mode。开启 cluster mode 后，支持给 Node.js 创建多个进程。 如果将 cluster mode 下的 instances 设置为 max 的话，它还会根据服务器的 CPU 核心数，来创建对应数量的 Node 进程。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/nodejs-cluster/1.jpg\" alt=\"\"></p>\n<p>PM2 其实利用的是 Node.js Cluster 模块来实现的，这个模块的出现就是为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的优势而出现的。那么，Cluster 内部又是如何工作的呢？多个进程间是如何通信的？多个进程是如何监听同一个端口的？Node.js 是如何将请求分发到各个进程上的？如果你对上述问题还不清楚，不妨接着往下看。</p>\n<h2 id=\"核心原理\"><a href=\"#核心原理\" class=\"headerlink\" title=\"核心原理\"></a>核心原理</h2><p>Node.js worker 进程由<a href=\"http://nodejs.cn/s/VDCJMa\" target=\"_blank\" rel=\"noopener\"><code>child_process.fork()</code></a>方法创建，这也意味存在着父进程和多个子进程。代码大致是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const cluster = require(&apos;cluster&apos;);</span><br><span class=\"line\">const os = require(&apos;os&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\">  for (var i = 0, n = os.cpus().length; i &lt; n; i += 1) &#123;</span><br><span class=\"line\">    cluster.fork();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">   // 启动程序 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>学过操作系统的同学，应该对 fork() 这个系统调用不陌生，调用它的进程为父进程，fork 出来的都是子进程。子进程和父进程具有相同的数据空间、堆栈，但是它们的内存空间不共享。父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。这里涉及三个问题：父子进程通信、负载均衡策略以及多进程的端口监听。</p>\n<h4 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h4><p>master 进程通过 process.fork() 创建子进程，他们之间通过 IPC (内部进程通信)通道实现通信。操作系统的进程间通信方式主要有以下几种：</p>\n<ul>\n<li>共享内存<br>不同进程共享同一段内存空间。通常还需要引入信号量机制，来实现同步与互斥。</li>\n<li>消息传递<br>这种模式下，进程间通过发送、接收消息来实现信息的同步。</li>\n<li>信号量<br>信号量简单说就是系统赋予进程的一个状态值，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量只有 0 或者 1 两个值的话，又被称作“互斥锁”。这个机制也被广泛用于各种编程模式中。</li>\n<li>管道<br>管道本身也是一个进程，它用于连接两个进程，将一个进程的输出作为另一个进程的输入。可以用 pipe 系统调用来创建管道。我们经常用的“ | ”命令行就是利用了管道机制。</li>\n</ul>\n<p>Node.js 为父子进程的通信提供了事件机制来传递消息。下面的例子实现了父进程将 TCP server 对象句柄传给子进程。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const subprocess = require(&apos;child_process&apos;).fork(&apos;subprocess.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 开启 server 对象，并发送该句柄。</span><br><span class=\"line\">const server = require(&apos;net&apos;).createServer();</span><br><span class=\"line\">server.on(&apos;connection&apos;, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.end(&apos;被父进程处理&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.listen(1337, () =&gt; &#123;</span><br><span class=\"line\">  subprocess.send(&apos;server&apos;, server);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&apos;message&apos;, (m, server) =&gt; &#123;</span><br><span class=\"line\">  if (m === &apos;server&apos;) &#123;</span><br><span class=\"line\">    server.on(&apos;connection&apos;, (socket) =&gt; &#123;</span><br><span class=\"line\">      socket.end(&apos;被子进程处理&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>那么问题又来了，如果进程间没有父子关系，换句话说，我们应该如何实现任意进程间的通信呢？大家可以去看看这篇文章：<a href=\"http://taobaofed.org/blog/2016/01/27/nodejs-ipc/\" target=\"_blank\" rel=\"noopener\">进程间通信的另类实现</a></p>\n<h4 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h4><p>前面提到，所有请求是通过 master 进程分配的，要保证服务器负载比较均衡的分配到各个 worker 进程上，这就涉及到负载均衡策略了。Node.js 默认采用的策略是 <strong>round-robin</strong> 时间片轮转法。</p>\n<p>round-robin 是一种很常见的负载均衡算法，Nginx 上也采用了它作为负载均衡策略之一。它的原理很简单，每一次把来自用户的请求轮流分配给各个进程，从 1 开始，直到 N(worker 进程个数)，然后重新开始循环。这个算法的问题在于，它是假定各个进程或者说各个服务器的处理性能是一样的，但是如果请求处理间隔较长，就容易导致出现负载不均衡。因此我们通常在 Nginx 上采用另一种算法：<strong>WRR</strong>，加权轮转法。通过给各个服务器分配一定的权重，每次选出权重最大的，给其权重减 1，直到权重全部为 0 后，按照此时生成的序列轮询。</p>\n<p>可以通过设置 NODE_CLUSTER_SCHED_POLICY 环境变量，或者通过 cluster.setupMaster(options) 来修改负载均衡策略。读到这里大家可以发现，我们可以 Nginx 做多机器集群上的负载均衡，然后用 Node.js Cluster 来实现单机多进程上的负载均衡。</p>\n<h4 id=\"多进程的端口监听\"><a href=\"#多进程的端口监听\" class=\"headerlink\" title=\"多进程的端口监听\"></a>多进程的端口监听</h4><p>最初的 Node.js 上，多个进程监听同一个端口，它们相互竞争新 accept 过来的连接。这样会导致各个进程的负载很不均衡，于是后来使用了上文提到的 round-robin 策略。具体思路是，master 进程创建 socket，绑定地址并进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。简单说就是，master 进程监听端口，然后将连接通过某种分发策略（比如 round-robin），转发给 worker 进程。这样由于只有 master 进程接收客户端连接，就解决了竞争导致的负载不均衡的问题。但是这样设计就要求 master 进程的稳定性足够好了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文以 PM2 的 Cluster Mode 作为切入点，向大家介绍了 Node.js Cluster 实现多进程的核心原理。重点讲了进程通信、负载均衡以及多进程端口监听三个方面。通过研究 cluster 模块可以发现，很多底层原理或者是算法，其实都是通用的。比如 round-robin 算法，它在操作系统底层的进程调度中也有使用；比如 master-worker 这种架构，是不是在 Nginx 的多进程架构中也似曾相识；比如信号量、管道这些机制，也可以在各种编程模式中见到它们的身影。当下市面上各种新技术层出不穷，但核心其实是<strong>万变不离其宗</strong>，理解了这些最基础的知识，剩下的也可以触类旁通了。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/\" target=\"_blank\" rel=\"noopener\">当我们谈论 cluster 时我们在谈论什么（下）</a></li>\n<li><a href=\"https://juejin.im/entry/5ad3eb536fb9a028d375db4e\" target=\"_blank\" rel=\"noopener\">Node.js进阶：cluster模块深入剖析</a></li>\n<li><a href=\"http://taobaofed.org/blog/2016/01/27/nodejs-ipc/\" target=\"_blank\" rel=\"noopener\">进程间通信的另类实现</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>如果大家用 PM2 管理 Node.js 进程，会发现它支持一种 cluster mode。开启 cluster mode 后，支持给 Node.js 创建多个进程。 如果将 cluster mode 下的 instances 设置为 max 的话，它还会根据服务器的 CPU 核心数，来创建对应数量的 Node 进程。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/nodejs-cluster/1.jpg\" alt=\"\"></p>\n<p>PM2 其实利用的是 Node.js Cluster 模块来实现的，这个模块的出现就是为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的优势而出现的。那么，Cluster 内部又是如何工作的呢？多个进程间是如何通信的？多个进程是如何监听同一个端口的？Node.js 是如何将请求分发到各个进程上的？如果你对上述问题还不清楚，不妨接着往下看。</p>\n<h2 id=\"核心原理\"><a href=\"#核心原理\" class=\"headerlink\" title=\"核心原理\"></a>核心原理</h2><p>Node.js worker 进程由<a href=\"http://nodejs.cn/s/VDCJMa\" target=\"_blank\" rel=\"noopener\"><code>child_process.fork()</code></a>方法创建，这也意味存在着父进程和多个子进程。代码大致是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const cluster = require(&apos;cluster&apos;);</span><br><span class=\"line\">const os = require(&apos;os&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\">  for (var i = 0, n = os.cpus().length; i &lt; n; i += 1) &#123;</span><br><span class=\"line\">    cluster.fork();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">   // 启动程序 </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>学过操作系统的同学，应该对 fork() 这个系统调用不陌生，调用它的进程为父进程，fork 出来的都是子进程。子进程和父进程具有相同的数据空间、堆栈，但是它们的内存空间不共享。父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。这里涉及三个问题：父子进程通信、负载均衡策略以及多进程的端口监听。</p>\n<h4 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h4><p>master 进程通过 process.fork() 创建子进程，他们之间通过 IPC (内部进程通信)通道实现通信。操作系统的进程间通信方式主要有以下几种：</p>\n<ul>\n<li>共享内存<br>不同进程共享同一段内存空间。通常还需要引入信号量机制，来实现同步与互斥。</li>\n<li>消息传递<br>这种模式下，进程间通过发送、接收消息来实现信息的同步。</li>\n<li>信号量<br>信号量简单说就是系统赋予进程的一个状态值，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量只有 0 或者 1 两个值的话，又被称作“互斥锁”。这个机制也被广泛用于各种编程模式中。</li>\n<li>管道<br>管道本身也是一个进程，它用于连接两个进程，将一个进程的输出作为另一个进程的输入。可以用 pipe 系统调用来创建管道。我们经常用的“ | ”命令行就是利用了管道机制。</li>\n</ul>\n<p>Node.js 为父子进程的通信提供了事件机制来传递消息。下面的例子实现了父进程将 TCP server 对象句柄传给子进程。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const subprocess = require(&apos;child_process&apos;).fork(&apos;subprocess.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 开启 server 对象，并发送该句柄。</span><br><span class=\"line\">const server = require(&apos;net&apos;).createServer();</span><br><span class=\"line\">server.on(&apos;connection&apos;, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.end(&apos;被父进程处理&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.listen(1337, () =&gt; &#123;</span><br><span class=\"line\">  subprocess.send(&apos;server&apos;, server);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&apos;message&apos;, (m, server) =&gt; &#123;</span><br><span class=\"line\">  if (m === &apos;server&apos;) &#123;</span><br><span class=\"line\">    server.on(&apos;connection&apos;, (socket) =&gt; &#123;</span><br><span class=\"line\">      socket.end(&apos;被子进程处理&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>那么问题又来了，如果进程间没有父子关系，换句话说，我们应该如何实现任意进程间的通信呢？大家可以去看看这篇文章：<a href=\"http://taobaofed.org/blog/2016/01/27/nodejs-ipc/\" target=\"_blank\" rel=\"noopener\">进程间通信的另类实现</a></p>\n<h4 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h4><p>前面提到，所有请求是通过 master 进程分配的，要保证服务器负载比较均衡的分配到各个 worker 进程上，这就涉及到负载均衡策略了。Node.js 默认采用的策略是 <strong>round-robin</strong> 时间片轮转法。</p>\n<p>round-robin 是一种很常见的负载均衡算法，Nginx 上也采用了它作为负载均衡策略之一。它的原理很简单，每一次把来自用户的请求轮流分配给各个进程，从 1 开始，直到 N(worker 进程个数)，然后重新开始循环。这个算法的问题在于，它是假定各个进程或者说各个服务器的处理性能是一样的，但是如果请求处理间隔较长，就容易导致出现负载不均衡。因此我们通常在 Nginx 上采用另一种算法：<strong>WRR</strong>，加权轮转法。通过给各个服务器分配一定的权重，每次选出权重最大的，给其权重减 1，直到权重全部为 0 后，按照此时生成的序列轮询。</p>\n<p>可以通过设置 NODE_CLUSTER_SCHED_POLICY 环境变量，或者通过 cluster.setupMaster(options) 来修改负载均衡策略。读到这里大家可以发现，我们可以 Nginx 做多机器集群上的负载均衡，然后用 Node.js Cluster 来实现单机多进程上的负载均衡。</p>\n<h4 id=\"多进程的端口监听\"><a href=\"#多进程的端口监听\" class=\"headerlink\" title=\"多进程的端口监听\"></a>多进程的端口监听</h4><p>最初的 Node.js 上，多个进程监听同一个端口，它们相互竞争新 accept 过来的连接。这样会导致各个进程的负载很不均衡，于是后来使用了上文提到的 round-robin 策略。具体思路是，master 进程创建 socket，绑定地址并进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。简单说就是，master 进程监听端口，然后将连接通过某种分发策略（比如 round-robin），转发给 worker 进程。这样由于只有 master 进程接收客户端连接，就解决了竞争导致的负载不均衡的问题。但是这样设计就要求 master 进程的稳定性足够好了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文以 PM2 的 Cluster Mode 作为切入点，向大家介绍了 Node.js Cluster 实现多进程的核心原理。重点讲了进程通信、负载均衡以及多进程端口监听三个方面。通过研究 cluster 模块可以发现，很多底层原理或者是算法，其实都是通用的。比如 round-robin 算法，它在操作系统底层的进程调度中也有使用；比如 master-worker 这种架构，是不是在 Nginx 的多进程架构中也似曾相识；比如信号量、管道这些机制，也可以在各种编程模式中见到它们的身影。当下市面上各种新技术层出不穷，但核心其实是<strong>万变不离其宗</strong>，理解了这些最基础的知识，剩下的也可以触类旁通了。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/\" target=\"_blank\" rel=\"noopener\">当我们谈论 cluster 时我们在谈论什么（下）</a></li>\n<li><a href=\"https://juejin.im/entry/5ad3eb536fb9a028d375db4e\" target=\"_blank\" rel=\"noopener\">Node.js进阶：cluster模块深入剖析</a></li>\n<li><a href=\"http://taobaofed.org/blog/2016/01/27/nodejs-ipc/\" target=\"_blank\" rel=\"noopener\">进程间通信的另类实现</a></li>\n</ol>\n"},{"title":"类数组转换为数组","date":"2016-05-02T13:51:06.000Z","_content":"一、什么是类数组对象\n**1.特征**\n特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数\n特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法\n**2.常见的类数组对象**\n```\ndocument.getElementsByClassName()\ndocument.getElementsByTagName()\ndocument.getElementsByName()\ndocument.querySelectorAll()\ndocument.stylesheets\nparentNode.childNodes\narguments\nvar arrayObj = {\n  0 : 'Benjamin01'\n  1 : 'Benjmain02'\n  length : 2\n};\n```\n**3.转换为数组对象**\nslice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。\n ```\nfunction convertArray(nodeList){\n    var arr = []\n    if(Array.prototype.slice){\n        arr = [].slice.call(nodeList);\n    }else{\n        for(var i=0,len = nodeList.length;i < len;i++){\n            arr.push(nodeList[i]);\n        }\n    }\n    return arr;    \n}\n```\n\n","source":"_posts/类数组转换为数组.md","raw":"---\ntitle: 类数组转换为数组\ndate: 2016-05-02 21:51:06\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n一、什么是类数组对象\n**1.特征**\n特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数\n特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法\n**2.常见的类数组对象**\n```\ndocument.getElementsByClassName()\ndocument.getElementsByTagName()\ndocument.getElementsByName()\ndocument.querySelectorAll()\ndocument.stylesheets\nparentNode.childNodes\narguments\nvar arrayObj = {\n  0 : 'Benjamin01'\n  1 : 'Benjmain02'\n  length : 2\n};\n```\n**3.转换为数组对象**\nslice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。\n ```\nfunction convertArray(nodeList){\n    var arr = []\n    if(Array.prototype.slice){\n        arr = [].slice.call(nodeList);\n    }else{\n        for(var i=0,len = nodeList.length;i < len;i++){\n            arr.push(nodeList[i]);\n        }\n    }\n    return arr;    \n}\n```\n\n","slug":"类数组转换为数组","published":1,"updated":"2019-06-16T14:11:37.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9h003shns6zdizcstc","content":"<p>一、什么是类数组对象<br><strong>1.特征</strong><br>特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数<br>特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法<br><strong>2.常见的类数组对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">document.getElementsByClassName()</span><br><span class=\"line\">document.getElementsByTagName()</span><br><span class=\"line\">document.getElementsByName()</span><br><span class=\"line\">document.querySelectorAll()</span><br><span class=\"line\">document.stylesheets</span><br><span class=\"line\">parentNode.childNodes</span><br><span class=\"line\">arguments</span><br><span class=\"line\">var arrayObj = &#123;</span><br><span class=\"line\">  0 : &apos;Benjamin01&apos;</span><br><span class=\"line\">  1 : &apos;Benjmain02&apos;</span><br><span class=\"line\">  length : 2</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3.转换为数组对象</strong><br>slice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function convertArray(nodeList)&#123;</span><br><span class=\"line\">    var arr = []</span><br><span class=\"line\">    if(Array.prototype.slice)&#123;</span><br><span class=\"line\">        arr = [].slice.call(nodeList);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        for(var i=0,len = nodeList.length;i &lt; len;i++)&#123;</span><br><span class=\"line\">            arr.push(nodeList[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、什么是类数组对象<br><strong>1.特征</strong><br>特征一：具有指向对象元素的数字索引下标以及 length 属性,告诉我们对象的元素个数<br>特征二：不具有诸如 push 、forEach 以及 indexOf 等数组对象具有的方法<br><strong>2.常见的类数组对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">document.getElementsByClassName()</span><br><span class=\"line\">document.getElementsByTagName()</span><br><span class=\"line\">document.getElementsByName()</span><br><span class=\"line\">document.querySelectorAll()</span><br><span class=\"line\">document.stylesheets</span><br><span class=\"line\">parentNode.childNodes</span><br><span class=\"line\">arguments</span><br><span class=\"line\">var arrayObj = &#123;</span><br><span class=\"line\">  0 : &apos;Benjamin01&apos;</span><br><span class=\"line\">  1 : &apos;Benjmain02&apos;</span><br><span class=\"line\">  length : 2</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3.转换为数组对象</strong><br>slice()方法可以将一个类数组(Array-like)对象/集合转换成一个数组. 你只需要用数组原型上的slice方法call这个对象,即Array.prototype.slice.call(Array-like)。IE9以下并不支持slice()方法，因此需要对其做兼容处理。<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function convertArray(nodeList)&#123;</span><br><span class=\"line\">    var arr = []</span><br><span class=\"line\">    if(Array.prototype.slice)&#123;</span><br><span class=\"line\">        arr = [].slice.call(nodeList);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        for(var i=0,len = nodeList.length;i &lt; len;i++)&#123;</span><br><span class=\"line\">            arr.push(nodeList[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"网页渲染中的重绘与重排","date":"2016-03-06T12:18:55.000Z","_content":"重绘\n\n当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。\n\n重排\n\n当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：\n\n- DOM操作（元素添加，删除，修改，或者元素顺序的改变）;\n- 内容变化，包括表单域内的文本改变;\n- CSS属性的计算或改变;\n- 添加或删除样式表;\n- 更改“类”的属性;\n- 浏览器窗口的操作（缩放，滚动）;\n- 伪类激活（：悬停）。\n","source":"_posts/网页渲染中的重绘与重排.md","raw":"---\ntitle: 网页渲染中的重绘与重排\ndate: 2016-03-06 20:18:55\ntags:\n- 浏览器\ncategories:\n- 前端\n---\n重绘\n\n当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。\n\n重排\n\n当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：\n\n- DOM操作（元素添加，删除，修改，或者元素顺序的改变）;\n- 内容变化，包括表单域内的文本改变;\n- CSS属性的计算或改变;\n- 添加或删除样式表;\n- 更改“类”的属性;\n- 浏览器窗口的操作（缩放，滚动）;\n- 伪类激活（：悬停）。\n","slug":"网页渲染中的重绘与重排","published":1,"updated":"2019-06-16T14:11:37.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9i003vhns67gmvm05j","content":"<p>重绘</p>\n<p>当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。</p>\n<p>重排</p>\n<p>当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：</p>\n<ul>\n<li>DOM操作（元素添加，删除，修改，或者元素顺序的改变）;</li>\n<li>内容变化，包括表单域内的文本改变;</li>\n<li>CSS属性的计算或改变;</li>\n<li>添加或删除样式表;</li>\n<li>更改“类”的属性;</li>\n<li>浏览器窗口的操作（缩放，滚动）;</li>\n<li>伪类激活（：悬停）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>重绘</p>\n<p>当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。</p>\n<p>重排</p>\n<p>当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：</p>\n<ul>\n<li>DOM操作（元素添加，删除，修改，或者元素顺序的改变）;</li>\n<li>内容变化，包括表单域内的文本改变;</li>\n<li>CSS属性的计算或改变;</li>\n<li>添加或删除样式表;</li>\n<li>更改“类”的属性;</li>\n<li>浏览器窗口的操作（缩放，滚动）;</li>\n<li>伪类激活（：悬停）。</li>\n</ul>\n"},{"title":"网站性能优化的 14 条规则","date":"2016-03-15T16:10:13.000Z","_content":"**1.减少HTTP请求**\n　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。\n\n**2.使用CDN（内容发布网络）**\n　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。\n\n**3.添加Expires头**\n　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。\n\n**4.启用Gzip**\n　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。\n\n**5.将CSS放在顶部**\n　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。\n\n**6.将脚本放在底部**\n　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。\n\n**7.避免CSS表达式**\n　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。\n\n**8.使用外部JavaScript和CSS**\n　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。\n\n**9.减少DNS查询**\n　　通过使用Keep-Alive和较少的域名可以减少DNS查询\n\n**10.精简JavaScript和CSS**\n　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。\n\n**11.避免重定向**\n　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。\n\n**12.移除重复脚本**\n**13.配置ETag**\n　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。\n\n**14.缓存Ajax**\n　　确保Ajax请求具有长久的Expires头","source":"_posts/网站性能优化的14条规则.md","raw":"---\ntitle: 网站性能优化的 14 条规则\ndate: 2016-03-16 00:10:13\ntags:\n- 性能优化\ncategories: \n- 前端\n---\n**1.减少HTTP请求**\n　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。\n\n**2.使用CDN（内容发布网络）**\n　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。\n\n**3.添加Expires头**\n　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。\n\n**4.启用Gzip**\n　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。\n\n**5.将CSS放在顶部**\n　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。\n\n**6.将脚本放在底部**\n　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。\n\n**7.避免CSS表达式**\n　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。\n\n**8.使用外部JavaScript和CSS**\n　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。\n\n**9.减少DNS查询**\n　　通过使用Keep-Alive和较少的域名可以减少DNS查询\n\n**10.精简JavaScript和CSS**\n　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。\n\n**11.避免重定向**\n　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。\n\n**12.移除重复脚本**\n**13.配置ETag**\n　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。\n\n**14.缓存Ajax**\n　　确保Ajax请求具有长久的Expires头","slug":"网站性能优化的14条规则","published":1,"updated":"2019-12-28T16:23:21.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9l003zhns6a38tns2p","content":"<p><strong>1.减少HTTP请求</strong><br>　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。</p>\n<p><strong>2.使用CDN（内容发布网络）</strong><br>　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。</p>\n<p><strong>3.添加Expires头</strong><br>　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。</p>\n<p><strong>4.启用Gzip</strong><br>　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。</p>\n<p><strong>5.将CSS放在顶部</strong><br>　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。</p>\n<p><strong>6.将脚本放在底部</strong><br>　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。</p>\n<p><strong>7.避免CSS表达式</strong><br>　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。</p>\n<p><strong>8.使用外部JavaScript和CSS</strong><br>　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。</p>\n<p><strong>9.减少DNS查询</strong><br>　　通过使用Keep-Alive和较少的域名可以减少DNS查询</p>\n<p><strong>10.精简JavaScript和CSS</strong><br>　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。</p>\n<p><strong>11.避免重定向</strong><br>　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。</p>\n<p><strong>12.移除重复脚本</strong><br><strong>13.配置ETag</strong><br>　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。</p>\n<p><strong>14.缓存Ajax</strong><br>　　确保Ajax请求具有长久的Expires头</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>1.减少HTTP请求</strong><br>　　减少HTTP请求的方式很多，常见的包括CSS Sprites、合并JS和CSS、图片地图等。遵守这条规则可以改善首次访问网站的响应时间。</p>\n<p><strong>2.使用CDN（内容发布网络）</strong><br>　　只有10%-20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%时间花在了下载页面中的所有组件上。如果web服务器离服务器更近，则一个HTTP请求的响应时间将缩短。CDN是一组分布在多个不同地理位置的web服务器，每个服务器都拥有所有网站的文件副本，用户访问网站时，就可以从离用户最近的服务器发送所需的文件给客户端。Yahoo！Shopping网站使用CDN后响应时间减少了20%。</p>\n<p><strong>3.添加Expires头</strong><br>　　通过使用Expires头，浏览器可以在用户首次访问网站后，将页面的资源缓存下来。可以为Expires指定过期时间，在指定时间后，缓存将失效。</p>\n<p><strong>4.启用Gzip</strong><br>　　客户端可以通过HTTP请求中的Accept-Encoding头来标识对压缩的支持（Accept-Encoding：gzip,deflate），服务器看到请求中有这个头，就会使用客户端列出的一种方法来压缩响应。大多数网站使用gzip压缩了HTML。</p>\n<p><strong>5.将CSS放在顶部</strong><br>　　将CSS放在底部会发生无样式闪烁，浏览器会先加载HTML，然后加载CSS，会出现一段没有任何样式的“白屏时间”。而将CSS放在顶部则能规避这个问题。</p>\n<p><strong>6.将脚本放在底部</strong><br>　　将脚本放在顶部或页面中，浏览器会对script标签内的内容进行解析，从而阻塞样式的渲染。除此之外，HTTP1.1规范建议浏览器从每个主机并行的下载两个组件，在高版本的IE和chrome、Firefox等浏览器则支持并行下载六个组件。但script会阻塞并行下载。因此我们应该将脚本放在底部。</p>\n<p><strong>7.避免CSS表达式</strong><br>　　CSS表达式具备求值计算能力，然而每次页面发生重绘时，CSS表达式会影响页面的加载时间。</p>\n<p><strong>8.使用外部JavaScript和CSS</strong><br>　　使用大量内联的JS和CSS就不能实现样式、结构、行为的分离，这样会在维护上造成很多麻烦，同时也会增大网页的体积。</p>\n<p><strong>9.减少DNS查询</strong><br>　　通过使用Keep-Alive和较少的域名可以减少DNS查询</p>\n<p><strong>10.精简JavaScript和CSS</strong><br>　　进行代码混淆可以压缩JS文件的大小，这个通过gulp等构建工具可以自动化的进行。</p>\n<p><strong>11.避免重定向</strong><br>　　重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种，包括301永久重定向、302临时重定向，304 Not Modified并不是真正的重定向，它是用来响应Get请求，避免下载已经存在于浏览器缓存中的数据。在URL的结尾加上斜线（/）可以避免一部分重定向。</p>\n<p><strong>12.移除重复脚本</strong><br><strong>13.配置ETag</strong><br>　　实体标签（Entity Tag）是web服务器和浏览器用于确认缓存资源的有效性的一种机制，它可以检测浏览器中缓存的资源与原始服务器上的资源是否匹配。ETag是唯一标识资源的一个特定版本的字符串，浏览器要验证一个资源，它会使用If-None-Match头将ETag传回原始服务器。如果ETag是匹配的，就会返回304状态码，从而使用浏览器缓存。</p>\n<p><strong>14.缓存Ajax</strong><br>　　确保Ajax请求具有长久的Expires头</p>\n"},{"title":"自定义复选框","date":"2016-05-18T05:47:27.000Z","_content":">思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。\n<!-- more -->\nHTML结构如下：\n```\n<input type=\"checkbox\" id=\"awesome\">\n<label for=\"awesome\">Awesome!</label>\n```\n首先，生成一个伪元素，先给这个伪元素添加一些样式。\n```\ninput[type=\"checkbox\"] + label::before{\n    content: '\\a0'; /*不换行空格*/\n    display: inline-block;\n    vertical-align: .2em;\n    width: .8em;\n    height: .8em;\n    margin-right: .2em;\n    border-radius: .2em;\n    background: silver;\n    text-indent: .15em;\n    line-height: .65;\n}\n```\n\n![左边是原生复选框，右边是经过我们初步自定义的复选框](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_1.png)\n然后给伪元素添加勾选状态下的样式\n```\ninput[type=\"checkbox\"]:checked + label::before{\n    content: '\\2713';\n    background: yellowgreen;\n}\n```\n\n![为伪元素添加选中状态下的样式](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_2.png)\n这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：\n```\ninput[type=\"checkbox\"]{\n    position: absolute;\n    clip:rect(0,0,0,0);\n}\n```\n这时候，我们自定义的复选框就已经完成了。\n\n![接近完成](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_3.png)\n\n最后，可以给这个复选框再加上聚焦和禁用状态下的样式。\n```\ninput[type=\"checkbox\"]:focus + label::before{\n    box-shadow: 0 0 .1em .1em #58a;\n}\ninput[type=\"checkbox\"]:disabled + label::before{\n    background: gray;\n    box-shadow: none;\n    color: #555;\n}\n```\n![最终效果](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_4.png)\n\n---------------\n参考：[《CSS揭秘》](http://www.ituring.com.cn/book/1695)\n","source":"_posts/自定义复选框.md","raw":"---\ntitle: 自定义复选框\ndate: 2016-05-18 13:47:27\ntags:\n- CSS\ncategories:\n- 前端\n---\n>思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。\n<!-- more -->\nHTML结构如下：\n```\n<input type=\"checkbox\" id=\"awesome\">\n<label for=\"awesome\">Awesome!</label>\n```\n首先，生成一个伪元素，先给这个伪元素添加一些样式。\n```\ninput[type=\"checkbox\"] + label::before{\n    content: '\\a0'; /*不换行空格*/\n    display: inline-block;\n    vertical-align: .2em;\n    width: .8em;\n    height: .8em;\n    margin-right: .2em;\n    border-radius: .2em;\n    background: silver;\n    text-indent: .15em;\n    line-height: .65;\n}\n```\n\n![左边是原生复选框，右边是经过我们初步自定义的复选框](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_1.png)\n然后给伪元素添加勾选状态下的样式\n```\ninput[type=\"checkbox\"]:checked + label::before{\n    content: '\\2713';\n    background: yellowgreen;\n}\n```\n\n![为伪元素添加选中状态下的样式](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_2.png)\n这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：\n```\ninput[type=\"checkbox\"]{\n    position: absolute;\n    clip:rect(0,0,0,0);\n}\n```\n这时候，我们自定义的复选框就已经完成了。\n\n![接近完成](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_3.png)\n\n最后，可以给这个复选框再加上聚焦和禁用状态下的样式。\n```\ninput[type=\"checkbox\"]:focus + label::before{\n    box-shadow: 0 0 .1em .1em #58a;\n}\ninput[type=\"checkbox\"]:disabled + label::before{\n    background: gray;\n    box-shadow: none;\n    color: #555;\n}\n```\n![最终效果](https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_4.png)\n\n---------------\n参考：[《CSS揭秘》](http://www.ituring.com.cn/book/1695)\n","slug":"自定义复选框","published":1,"updated":"2019-12-29T11:28:13.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9m0042hns6yvsey10w","content":"<blockquote>\n<p>思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。<br><a id=\"more\"></a><br>HTML结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>首先，生成一个伪元素，先给这个伪元素添加一些样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;] + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\a0&apos;; /*不换行空格*/</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: .2em;</span><br><span class=\"line\">    width: .8em;</span><br><span class=\"line\">    height: .8em;</span><br><span class=\"line\">    margin-right: .2em;</span><br><span class=\"line\">    border-radius: .2em;</span><br><span class=\"line\">    background: silver;</span><br><span class=\"line\">    text-indent: .15em;</span><br><span class=\"line\">    line-height: .65;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_1.png\" alt=\"左边是原生复选框，右边是经过我们初步自定义的复选框\"><br>然后给伪元素添加勾选状态下的样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:checked + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\2713&apos;;</span><br><span class=\"line\">    background: yellowgreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_2.png\" alt=\"为伪元素添加选中状态下的样式\"><br>这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]&#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    clip:rect(0,0,0,0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候，我们自定义的复选框就已经完成了。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_3.png\" alt=\"接近完成\"></p>\n<p>最后，可以给这个复选框再加上聚焦和禁用状态下的样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:focus + label::before&#123;</span><br><span class=\"line\">    box-shadow: 0 0 .1em .1em #58a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input[type=&quot;checkbox&quot;]:disabled + label::before&#123;</span><br><span class=\"line\">    background: gray;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">    color: #555;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_4.png\" alt=\"最终效果\"></p>\n<hr>\n<p>参考：<a href=\"http://www.ituring.com.cn/book/1695\" target=\"_blank\" rel=\"noopener\">《CSS揭秘》</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>思路：借助于组合选择符和before伪元素，利用content属性改变伪元素的内容，为其添加我们想要的样式。并将原来的复选框隐藏掉。<br>","more":"<br>HTML结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>首先，生成一个伪元素，先给这个伪元素添加一些样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;] + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\a0&apos;; /*不换行空格*/</span><br><span class=\"line\">    display: inline-block;</span><br><span class=\"line\">    vertical-align: .2em;</span><br><span class=\"line\">    width: .8em;</span><br><span class=\"line\">    height: .8em;</span><br><span class=\"line\">    margin-right: .2em;</span><br><span class=\"line\">    border-radius: .2em;</span><br><span class=\"line\">    background: silver;</span><br><span class=\"line\">    text-indent: .15em;</span><br><span class=\"line\">    line-height: .65;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_1.png\" alt=\"左边是原生复选框，右边是经过我们初步自定义的复选框\"><br>然后给伪元素添加勾选状态下的样式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:checked + label::before&#123;</span><br><span class=\"line\">    content: &apos;\\2713&apos;;</span><br><span class=\"line\">    background: yellowgreen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_2.png\" alt=\"为伪元素添加选中状态下的样式\"><br>这时，这个伪元素已经是经过简单美化后的复选框了。然后，我们需要将原来的复选框以一种不损失访问性的方式隐藏起来。因此，不能使用display:none，那样会完全删除这个dom元素。用另一种办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]&#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    clip:rect(0,0,0,0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候，我们自定义的复选框就已经完成了。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_3.png\" alt=\"接近完成\"></p>\n<p>最后，可以给这个复选框再加上聚焦和禁用状态下的样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">input[type=&quot;checkbox&quot;]:focus + label::before&#123;</span><br><span class=\"line\">    box-shadow: 0 0 .1em .1em #58a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">input[type=&quot;checkbox&quot;]:disabled + label::before&#123;</span><br><span class=\"line\">    background: gray;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">    color: #555;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/css-checkbox/checkbox_4.png\" alt=\"最终效果\"></p>\n<hr>\n<p>参考：<a href=\"http://www.ituring.com.cn/book/1695\" target=\"_blank\" rel=\"noopener\">《CSS揭秘》</a></p>"},{"title":"让 Ajax 支持浏览器的前进后退","date":"2016-04-30T17:13:43.000Z","_content":"> 众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。\n\n<!-- more -->\n来看看这几个API\n1. **history.pushState(state, title, url)**\npushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.\n2. **window.onpopstate**\n用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。\n3. **history.replaceState(state,title,url)**\n用新的state和URL替换当前。不会造成页面刷新。\nstate：与要跳转到的URL对应的状态信息。\ntitle：标题\nurl：要跳转到的URL地址，不能跨域。\n\n实现原理如下：\n- 每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。\n- 浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。\n- 页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。\n\n除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。\n\n-------------------\n欢迎关注我博客:http://voidman.xyz\n","source":"_posts/让Ajax支持浏览器的前进后退.md","raw":"---\ntitle: 让 Ajax 支持浏览器的前进后退\ndate: 2016-05-01 01:13:43\ntags:\n- JavaScript\ncategories:\n- 前端\n---\n> 众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。\n\n<!-- more -->\n来看看这几个API\n1. **history.pushState(state, title, url)**\npushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.\n2. **window.onpopstate**\n用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。\n3. **history.replaceState(state,title,url)**\n用新的state和URL替换当前。不会造成页面刷新。\nstate：与要跳转到的URL对应的状态信息。\ntitle：标题\nurl：要跳转到的URL地址，不能跨域。\n\n实现原理如下：\n- 每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。\n- 浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。\n- 页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。\n\n除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。\n\n-------------------\n欢迎关注我博客:http://voidman.xyz\n","slug":"让Ajax支持浏览器的前进后退","published":1,"updated":"2019-12-28T16:23:44.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9p0046hns6xsdlste3","content":"<blockquote>\n<p>众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>来看看这几个API</p>\n<ol>\n<li><strong>history.pushState(state, title, url)</strong><br>pushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.</li>\n<li><strong>window.onpopstate</strong><br>用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。</li>\n<li><strong>history.replaceState(state,title,url)</strong><br>用新的state和URL替换当前。不会造成页面刷新。<br>state：与要跳转到的URL对应的状态信息。<br>title：标题<br>url：要跳转到的URL地址，不能跨域。</li>\n</ol>\n<p>实现原理如下：</p>\n<ul>\n<li>每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。</li>\n<li>浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。</li>\n<li>页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。</li>\n</ul>\n<p>除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。</p>\n<hr>\n<p>欢迎关注我博客:<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">http://voidman.xyz</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>众所周知，Ajax可以实现网页的局部刷新，但与此同时，Ajax会破坏浏览器历史的前进后退。为了让Ajax也能支持浏览器的前进后退，HTML5的history API中定义了一系列方法，其中pushState就是来解决这个问题的。</p>\n</blockquote>","more":"<p>来看看这几个API</p>\n<ol>\n<li><strong>history.pushState(state, title, url)</strong><br>pushState 是人工插入历史记录和修改地址栏,此时地址栏虽然修改,但并不触发网页跳转,换句话说就是给你看的而已,第一个参数是一个对象,你可以放入需要的参数,第二个标题名称,第三个就是url.这是地址栏里显示的东西.</li>\n<li><strong>window.onpopstate</strong><br>用户点击浏览器历史前进后退按钮，并且页面无刷的时候（由于使用pushState修改了history）会触发popstate事件，事件发生时浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。</li>\n<li><strong>history.replaceState(state,title,url)</strong><br>用新的state和URL替换当前。不会造成页面刷新。<br>state：与要跳转到的URL对应的状态信息。<br>title：标题<br>url：要跳转到的URL地址，不能跨域。</li>\n</ol>\n<p>实现原理如下：</p>\n<ul>\n<li>每次发起Ajax请求时，将Ajax地址的查询内容(?后面的)附在HTML页面地址后面，使用history.pushState塞到浏览器历史中。</li>\n<li>浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。</li>\n<li>页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作。</li>\n</ul>\n<p>除此之外，单页应用处理路由还可以监听onhashchange事件，只要hash值一改变就会触发该事件。Angular的路由机制就同时利用了这两种方案。</p>\n<hr>\n<p>欢迎关注我博客:<a href=\"http://voidman.xyz\" target=\"_blank\" rel=\"noopener\">http://voidman.xyz</a></p>"},{"title":"部署 Node 项目到 CentOS 服务器","date":"2016-04-05T06:15:56.000Z","_content":"最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。\n\n通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的\"MEAN\"。不废话了，下面是正文。\n\n-----------\n\n# 服务器配置\n- 阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）\n- 操作系统：CentOS 7.0 64位\n\n首先SSH连接服务器管理终端：\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/1.png)\n\n# 安装Node\nNode.JS的安装方法很多，这里贴上一种方法以供参考。\nhttp://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\n\n# 安装MongoDB\n在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。\n1.输入以下命令：curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\nmongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题...)\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/2.png)\n2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz\n文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb\n3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/3.png)\n4.添加环境变量\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/4.png)\n5.重新加载环境变量,验证结果。\n用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/5.png)\n# 上传项目文件到服务器\nMac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。\n# 启动MongoDB\n进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库\n```mongod --dbpath \"/developer/mongodb/imooc\"```\n# 连接MongoDB\n在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。\n\n-----------\n下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问\n附一张这个网站的截图\n\n![电影详情页](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/6.png)\n\n另：网站的Github地址 https://github.com/FrankXiong/imooc\n","source":"_posts/部署Node项目到CentOS服务器.md","raw":"---\ntitle: 部署 Node 项目到 CentOS 服务器\ndate: 2016-04-05 14:15:56\ntags:\n- 运维\ncategories:\n- Node.js\n---\n最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。\n\n通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的\"MEAN\"。不废话了，下面是正文。\n\n-----------\n\n# 服务器配置\n- 阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）\n- 操作系统：CentOS 7.0 64位\n\n首先SSH连接服务器管理终端：\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/1.png)\n\n# 安装Node\nNode.JS的安装方法很多，这里贴上一种方法以供参考。\nhttp://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\n\n# 安装MongoDB\n在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。\n1.输入以下命令：curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\nmongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题...)\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/2.png)\n2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz\n文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb\n3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/3.png)\n4.添加环境变量\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/4.png)\n5.重新加载环境变量,验证结果。\n用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/5.png)\n# 上传项目文件到服务器\nMac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。\n# 启动MongoDB\n进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库\n```mongod --dbpath \"/developer/mongodb/imooc\"```\n# 连接MongoDB\n在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。\n\n-----------\n下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问\n附一张这个网站的截图\n\n![电影详情页](https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/6.png)\n\n另：网站的Github地址 https://github.com/FrankXiong/imooc\n","slug":"部署Node项目到CentOS服务器","published":1,"updated":"2019-12-29T11:28:13.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygn9s0049hns6qd5h6eyn","content":"<p>最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。</p>\n<p>通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的”MEAN”。不废话了，下面是正文。</p>\n<hr>\n<h1 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h1><ul>\n<li>阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）</li>\n<li>操作系统：CentOS 7.0 64位</li>\n</ul>\n<p>首先SSH连接服务器管理终端：<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/1.png\" alt=\"\"></p>\n<h1 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h1><p>Node.JS的安装方法很多，这里贴上一种方法以供参考。<br><a href=\"http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\" target=\"_blank\" rel=\"noopener\">http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html</a></p>\n<h1 id=\"安装MongoDB\"><a href=\"#安装MongoDB\" class=\"headerlink\" title=\"安装MongoDB\"></a>安装MongoDB</h1><p>在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。<br>1.输入以下命令：curl -O <a href=\"https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\" target=\"_blank\" rel=\"noopener\">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz</a><br>mongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题…)</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/2.png\" alt=\"\"><br>2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz<br>文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb<br>3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/3.png\" alt=\"\"><br>4.添加环境变量</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/4.png\" alt=\"\"><br>5.重新加载环境变量,验证结果。<br>用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/5.png\" alt=\"\"></p>\n<h1 id=\"上传项目文件到服务器\"><a href=\"#上传项目文件到服务器\" class=\"headerlink\" title=\"上传项目文件到服务器\"></a>上传项目文件到服务器</h1><p>Mac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。</p>\n<h1 id=\"启动MongoDB\"><a href=\"#启动MongoDB\" class=\"headerlink\" title=\"启动MongoDB\"></a>启动MongoDB</h1><p>进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库<br><code>mongod --dbpath &quot;/developer/mongodb/imooc&quot;</code></p>\n<h1 id=\"连接MongoDB\"><a href=\"#连接MongoDB\" class=\"headerlink\" title=\"连接MongoDB\"></a>连接MongoDB</h1><p>在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。</p>\n<hr>\n<p>下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问<br>附一张这个网站的截图</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/6.png\" alt=\"电影详情页\"></p>\n<p>另：网站的Github地址 <a href=\"https://github.com/FrankXiong/imooc\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankXiong/imooc</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近开始折腾Node，跟着慕课网的教程写了个电影网站，于是想把网站部署到服务器上，本文记录了我整个环境搭建的流程。</p>\n<p>通常Node和mongoDB一起搭配使用，再加上Node的一个热门的开发框架Express，以及angular.js，共同构成了整个web开发的技术架构（这次的开发中没有用到angular）。取其首字母，也就是所谓的”MEAN”。不废话了，下面是正文。</p>\n<hr>\n<h1 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h1><ul>\n<li>阿里云ECS 单核1G内存（这里要安利一下阿里云的学生优惠活动，一个月只要￥10，学生党的福利~）</li>\n<li>操作系统：CentOS 7.0 64位</li>\n</ul>\n<p>首先SSH连接服务器管理终端：<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/1.png\" alt=\"\"></p>\n<h1 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h1><p>Node.JS的安装方法很多，这里贴上一种方法以供参考。<br><a href=\"http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html\" target=\"_blank\" rel=\"noopener\">http://yijiebuyi.com/blog/4fcce2f8b1aed8389f34c27f22864a04.html</a></p>\n<h1 id=\"安装MongoDB\"><a href=\"#安装MongoDB\" class=\"headerlink\" title=\"安装MongoDB\"></a>安装MongoDB</h1><p>在MongoDB官网上看了下，没找到在centOS直接用apt-get安装mongo的方法，那就手动来下载安装吧。<br>1.输入以下命令：curl -O <a href=\"https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz\" target=\"_blank\" rel=\"noopener\">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.4.tgz</a><br>mongoDB就开始下载了，也可以用wget来下载。(下载过程比较缓慢，不知道是我的网速还是curl的问题…)</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/2.png\" alt=\"\"><br>2.下载结束后解压文件：tar xf mongodb-linux-x86_64-rhel70-3.2.4.tgz<br>文件名太长了，重命名一下：mv mongodb-linux-x86_64-rhel70-3.2.4  mongodb<br>3.进入mongodb文件夹，新建logs文件夹，并在其下创建一个mongodb.log文件用于保存日志。创建data文件夹，在data文件夹下再新建db文件夹，用于存储mongoDB的数据。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/3.png\" alt=\"\"><br>4.添加环境变量</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/4.png\" alt=\"\"><br>5.重新加载环境变量,验证结果。<br>用mongod -verison或者-v看到下面的结果，就证明mongoDB安装成功了</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/5.png\" alt=\"\"></p>\n<h1 id=\"上传项目文件到服务器\"><a href=\"#上传项目文件到服务器\" class=\"headerlink\" title=\"上传项目文件到服务器\"></a>上传项目文件到服务器</h1><p>Mac上可以用scp上传，windows上用FTP。FTP上传工具很多，随意选一种即可。</p>\n<h1 id=\"启动MongoDB\"><a href=\"#启动MongoDB\" class=\"headerlink\" title=\"启动MongoDB\"></a>启动MongoDB</h1><p>进入mongo目录的bin文件夹，输入如下命令，dbpath后指定的是Node项目的路径，这样就可以直接通过该项目启动数据库<br><code>mongod --dbpath &quot;/developer/mongodb/imooc&quot;</code></p>\n<h1 id=\"连接MongoDB\"><a href=\"#连接MongoDB\" class=\"headerlink\" title=\"连接MongoDB\"></a>连接MongoDB</h1><p>在Node项目根目录下输入mongo命令就可以建立与数据库的连接。另外，如果你前面没有指定在启动mongoDB的时候指定项目路径的话，你就还需要使用use命令建立两者的关联。当时我忘了这一点，于是注册后的帐号等数据都没有被保存到数据库中。</p>\n<hr>\n<p>下面就能看到网站欢快地跑起来了~~~因为没做域名解析，暂时只能通过IP地址来访问<br>附一张这个网站的截图</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/node-deploy/6.png\" alt=\"电影详情页\"></p>\n<p>另：网站的Github地址 <a href=\"https://github.com/FrankXiong/imooc\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankXiong/imooc</a></p>\n"},{"title":"阿里前端实习电话面试（二）","date":"2016-03-16T14:22:52.000Z","_content":"今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。\n\n这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……\n\n1.自我介绍，描述你的项目\n\n2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)\n\n3.什么是重载与多态？如何用JS实现多态？(OOP)\n\n4.常见的数据结构？栈和队列的区别？(数据结构)\n\n5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)\n\n6.C语言中分配的几个空间(直接说了不知道……坑啊)\n\n7.JS中apply和call的用法(JS基础)\n\n8.什么是URL编码？(encodeUriComponent)\n\n9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)\n\n10.说出几个HTTP请求头(说了一堆，哈哈哈)\n\n11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)\n\n12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)\n\n13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)\n\n14.描述一下五层网络模型(easy~)\n\n15.了解HashMap吗？描述其原理(勉强答了上来)\n\n16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)\n\n17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)\n\n18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)\n\n\n\n感觉遗漏了很多问题，大致如此吧，共勉。","source":"_posts/阿里前端实习电话面试（二）.md","raw":"---\ntitle: 阿里前端实习电话面试（二）\ndate: 2016-03-16 22:22:52\ntags: \n- 面试\ncategories:\n- 面试\n---\n今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。\n\n这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……\n\n1.自我介绍，描述你的项目\n\n2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)\n\n3.什么是重载与多态？如何用JS实现多态？(OOP)\n\n4.常见的数据结构？栈和队列的区别？(数据结构)\n\n5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)\n\n6.C语言中分配的几个空间(直接说了不知道……坑啊)\n\n7.JS中apply和call的用法(JS基础)\n\n8.什么是URL编码？(encodeUriComponent)\n\n9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)\n\n10.说出几个HTTP请求头(说了一堆，哈哈哈)\n\n11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)\n\n12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)\n\n13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)\n\n14.描述一下五层网络模型(easy~)\n\n15.了解HashMap吗？描述其原理(勉强答了上来)\n\n16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)\n\n17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)\n\n18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)\n\n\n\n感觉遗漏了很多问题，大致如此吧，共勉。","slug":"阿里前端实习电话面试（二）","published":1,"updated":"2019-06-16T14:11:37.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygna4004dhns6dtmexnif","content":"<p>今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。</p>\n<p>这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……</p>\n<p>1.自我介绍，描述你的项目</p>\n<p>2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)</p>\n<p>3.什么是重载与多态？如何用JS实现多态？(OOP)</p>\n<p>4.常见的数据结构？栈和队列的区别？(数据结构)</p>\n<p>5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)</p>\n<p>6.C语言中分配的几个空间(直接说了不知道……坑啊)</p>\n<p>7.JS中apply和call的用法(JS基础)</p>\n<p>8.什么是URL编码？(encodeUriComponent)</p>\n<p>9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)</p>\n<p>10.说出几个HTTP请求头(说了一堆，哈哈哈)</p>\n<p>11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)</p>\n<p>12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)</p>\n<p>13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)</p>\n<p>14.描述一下五层网络模型(easy~)</p>\n<p>15.了解HashMap吗？描述其原理(勉强答了上来)</p>\n<p>16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)</p>\n<p>17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)</p>\n<p>18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)</p>\n<p>感觉遗漏了很多问题，大致如此吧，共勉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天经历了阿里的两轮电话面试，分别来自阿里旅行和无线部门。加上之前无线部门的一面，事实上这已经是阿里的第三次电面了。。。我猜是他们的招聘系统出了问题，填简历时选的杭州，结果今天收到了来自北京的电面。。。</p>\n<p>这两次面试显然考察的比第一次面试全面多了，从C语言、数据结构、算法，到网络、OOP、以及JS基础……两次都面了半个多小时……</p>\n<p>1.自我介绍，描述你的项目</p>\n<p>2.项目中用到了哪些技术，如何进行依赖管理，描述项目的结构(显然是在问前端工程化)</p>\n<p>3.什么是重载与多态？如何用JS实现多态？(OOP)</p>\n<p>4.常见的数据结构？栈和队列的区别？(数据结构)</p>\n<p>5.如何找出数组中重复最多的三个数?描述其复杂度(答的不好，放了我这个算法渣吧……)</p>\n<p>6.C语言中分配的几个空间(直接说了不知道……坑啊)</p>\n<p>7.JS中apply和call的用法(JS基础)</p>\n<p>8.什么是URL编码？(encodeUriComponent)</p>\n<p>9.Get和Post的区别？什么时候使用Post？(幂等与非幂等，数据长度，安全性)</p>\n<p>10.说出几个HTTP请求头(说了一堆，哈哈哈)</p>\n<p>11.HTTP和HTTPS的区别？HTTPS解决了哪些问题？(easy~)</p>\n<p>12.websocket实现了服务器和浏览器的实时通信，它还有哪些替代方案？(轮询Ajax和long pool)</p>\n<p>13.网页中你有使用栅格系统吗？你如何进行的布局？(没用，自己写的栅格，提到了Flexbox)</p>\n<p>14.描述一下五层网络模型(easy~)</p>\n<p>15.了解HashMap吗？描述其原理(勉强答了上来)</p>\n<p>16.对于账号密码等提交，如何保证其安全性(我答了加盐hash,似乎不是他想听到的答案)</p>\n<p>17.学过密码学吗？(没有)大学专业课里面哪个科目学的最好？(都学的差不多……)</p>\n<p>18.你还有什么问题要问我的吗？(这个问题每次面试结束的时候都会问到……)</p>\n<p>感觉遗漏了很多问题，大致如此吧，共勉。</p>\n"},{"title":"随笔#1","date":"2016-03-06T12:10:10.000Z","_content":"现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。\n\n2016.3.6 傍晚\n","source":"_posts/随笔-1.md","raw":"---\ntitle: '随笔#1'\ndate: 2016-03-06 20:10:10\ntags: \n- 随笔\ncategories:\n- 随笔\n---\n现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。\n\n2016.3.6 傍晚\n","slug":"随笔-1","published":1,"updated":"2019-06-16T14:11:37.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygna6004hhns6n78nusq1","content":"<p>现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。</p>\n<p>2016.3.6 傍晚</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现代社会的发展路径不再是一种爬金字塔、熬时间、凭关系、看运气式的呆板线性路径，只要你的创新成果能对他人、社会乃至整个世界形成有意义的影响，你就可以迅速脱颖而出，而这一切与你的年龄、资历、背景无关。这最终从根本上更能激发创新者的出现和创新成果的诞生。</p>\n<p>2016.3.6 傍晚</p>\n"},{"title":"JavaScript 数组去重","date":"2016-03-21T09:42:35.000Z","_content":"话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于[JavaScript数组相关的知识](http://www.w3cplus.com/blog/tags/538.html),趁此机会整理了一些有关于JavaScript数组去重的方法。\n\n下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。\n### 双重循环去重 ###\n-----------\n这个方法使用了两个for循环做遍历。整个思路是：\n- 构建一个空数组用来存放去重后的数组\n- 外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比\n- 如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中\n\n代码如下:\n```\nArray.prototype.unique1 = function () { \n　// 构建一个新数组，存放结果 var newArray = [this[0]]; \n　// for循环，每次从原数组中取出一个元素 \n　// 用取出的元素循环与结果数组对比 \n　for (var i = 1; i < this.length; i++) { \n　　var repeat = false; \n　　for (var j=0; j < newArray.length; j++) { \n　　// 原数组取出的元素与结果数组元素相同 \n　　　if(this[i] == newArray[j]) { \n　　　　repeat = true; break; \n　　　} \n　　} \n　　if(!repeat) { \n　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　\n　　　newArray.push(this[i]);\n　　} \n　} \n　return newArray;\n}\n```\n假设我们有一个这样的数组：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique1(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5]\n```\n据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：\n```\nfunction test () { \n　var arr = []; \n　for (var i = 0; i < 1000000; i++) { 　　\n　　arr.push(Math.round(Math.random(i) * 10000)); \n　} \n　doTest(arr, 1);\n}\nfunction doTest(arr, n) { \n　var tStart = (new Date()).getTime(); \n　var re = arr.unique1(); \n　var tEnd = (new Date()).getTime(); \n　console.log('双重循环去重方法使用时间是:' + (tEnd - tStart) + 'ms'); \n　return re;\n}\ntest();\n```\n在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。\n\n上面的方法可以使用forEach()方法和indexOf()方法模拟实现：\n```\nfunction unique1() { \n　var newArray = []; \n　this.forEach(function (index) { \n　　if (newArray.indexOf(index) == -1) { \n　　　newArray.push(index); \n　　} \n　}); \n　return newArray;\n}\n```\n通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。\n### 排序遍历去重 ###\n-----------\n先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。\n```\nArray.prototype.unique2 = function () { \n　// 原数组先排序 \n　this.sort(); \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　for (var i = 1; i < this.length; i++) { \n　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 \n　　// 因为排序了，所以重复元素会在相邻位置 \n　　if(this[i] !== newArray[newArray.length - 1]) { \n　　　// 如果不同，将元素放到结果数组中 \n　　　newArray.push(this[i]); \n　　} \n　} \n　return newArray;\n}\n```\n\n例如：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique2(); // [\"1\", 1, 2, \"2\", 3, 32, 34, 4, 5, 56, \"a\", \"b\", \"c\"]\n```\n\n这种方法有两个特色：\n去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如'1'和1\n\n使用同样的方法，测试所费时间：1232ms。\n### 对象键值对法 ###\n---------\n这种去重方法实现思路是：\n创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比\n如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object\n对象中该属性名的值设置为1\n\n代码如下:\n```\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n运行前面的示例：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique3(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，不同的键可能会被误认为一样；例如： a[1]、a[\"1\"]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。\n\n除了上面几种方法，还有其他几种方法如下：\n```\n// 方法四\nArray.prototype.unique4 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 遍历是否有重复的值 \n　　for (j = i + 1; j < this.length; j++) { \n　　　// 如果有相同元素，自增i变量，跳出i的循环 \n　　　if(this[i] === this[j]) { \n　　　　j = ++i; \n　　　}　 \n　　} \n　　// 如果没有相同元素，将元素推入到结果数组中 　\n　　newArray.push(this[i]); \n　} \n　return newArray;\n}\n```\nChrome测试结果\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique4(); // [\"a\", 1, 3, 4, 56, 32, 34, 2, \"b\", \"c\", 5, \"1\", \"2\"]\n```\n同样的，1和'1'无法区分。\n```\n// 方法五\nArray.prototype.unique5 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 如果当前数组的第i值保存到临时数组，那么跳过 \n　　var index = this[i]; \n　　// 如果数组项不在结果数组中，将这个值推入结果数组中 \n　　if (newArray.indexOf(index) === -1) { \n　　　newArray.push(index); \n　　} \n　} \n　return newArray;\n}\n```\nChrome测试结果:\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，类似于1和'1'无法区分。所费时间：14361ms。\n```\n// 方法六\nArray.prototype.unique6 = function () { \n　return this.reduce(function (newArray, index) { 　　\n　　if(newArray.indexOf(index) < 0) { \n　　　newArray.push(index); \n　　} \n　　return newArray; \n　},[]);\n}\n```\n测试结果如下：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：16490ms。\n```\n// 方法七\nArray.prototype.unique7 = function(){ \n　var newArray; \n　newArray = this.filter(function (ele,i,arr) { \n　　return arr.indexOf(ele) === i; }); \n　　return newArray;\n}\n```\n测试结果：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：13201ms。\n方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：\n```\n//方法三\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n但在ES6去重还有更简单，更优化的方案，比如：\n```\n// ES6\nfunction unique (arr) { \n　const seen = new Map() \n　return arr.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n// or\nfunction unique (arr) { \n　return Array.from(new Set(arr))\n}\n```\n----------\n转载自：http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\n","source":"_posts/JavaScript数组去重.md","raw":"---\ntitle: JavaScript 数组去重\ndate: 2016-03-21 17:42:35\ntags:\n- JavaScript\n- 算法\ncategories:\n- 数据结构与算法\n---\n话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于[JavaScript数组相关的知识](http://www.w3cplus.com/blog/tags/538.html),趁此机会整理了一些有关于JavaScript数组去重的方法。\n\n下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。\n### 双重循环去重 ###\n-----------\n这个方法使用了两个for循环做遍历。整个思路是：\n- 构建一个空数组用来存放去重后的数组\n- 外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比\n- 如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中\n\n代码如下:\n```\nArray.prototype.unique1 = function () { \n　// 构建一个新数组，存放结果 var newArray = [this[0]]; \n　// for循环，每次从原数组中取出一个元素 \n　// 用取出的元素循环与结果数组对比 \n　for (var i = 1; i < this.length; i++) { \n　　var repeat = false; \n　　for (var j=0; j < newArray.length; j++) { \n　　// 原数组取出的元素与结果数组元素相同 \n　　　if(this[i] == newArray[j]) { \n　　　　repeat = true; break; \n　　　} \n　　} \n　　if(!repeat) { \n　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　\n　　　newArray.push(this[i]);\n　　} \n　} \n　return newArray;\n}\n```\n假设我们有一个这样的数组：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique1(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5]\n```\n据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：\n```\nfunction test () { \n　var arr = []; \n　for (var i = 0; i < 1000000; i++) { 　　\n　　arr.push(Math.round(Math.random(i) * 10000)); \n　} \n　doTest(arr, 1);\n}\nfunction doTest(arr, n) { \n　var tStart = (new Date()).getTime(); \n　var re = arr.unique1(); \n　var tEnd = (new Date()).getTime(); \n　console.log('双重循环去重方法使用时间是:' + (tEnd - tStart) + 'ms'); \n　return re;\n}\ntest();\n```\n在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。\n\n上面的方法可以使用forEach()方法和indexOf()方法模拟实现：\n```\nfunction unique1() { \n　var newArray = []; \n　this.forEach(function (index) { \n　　if (newArray.indexOf(index) == -1) { \n　　　newArray.push(index); \n　　} \n　}); \n　return newArray;\n}\n```\n通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。\n### 排序遍历去重 ###\n-----------\n先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。\n```\nArray.prototype.unique2 = function () { \n　// 原数组先排序 \n　this.sort(); \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　for (var i = 1; i < this.length; i++) { \n　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 \n　　// 因为排序了，所以重复元素会在相邻位置 \n　　if(this[i] !== newArray[newArray.length - 1]) { \n　　　// 如果不同，将元素放到结果数组中 \n　　　newArray.push(this[i]); \n　　} \n　} \n　return newArray;\n}\n```\n\n例如：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique2(); // [\"1\", 1, 2, \"2\", 3, 32, 34, 4, 5, 56, \"a\", \"b\", \"c\"]\n```\n\n这种方法有两个特色：\n去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如'1'和1\n\n使用同样的方法，测试所费时间：1232ms。\n### 对象键值对法 ###\n---------\n这种去重方法实现思路是：\n创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比\n如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object\n对象中该属性名的值设置为1\n\n代码如下:\n```\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n运行前面的示例：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique3(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，不同的键可能会被误认为一样；例如： a[1]、a[\"1\"]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。\n\n除了上面几种方法，还有其他几种方法如下：\n```\n// 方法四\nArray.prototype.unique4 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 遍历是否有重复的值 \n　　for (j = i + 1; j < this.length; j++) { \n　　　// 如果有相同元素，自增i变量，跳出i的循环 \n　　　if(this[i] === this[j]) { \n　　　　j = ++i; \n　　　}　 \n　　} \n　　// 如果没有相同元素，将元素推入到结果数组中 　\n　　newArray.push(this[i]); \n　} \n　return newArray;\n}\n```\nChrome测试结果\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique4(); // [\"a\", 1, 3, 4, 56, 32, 34, 2, \"b\", \"c\", 5, \"1\", \"2\"]\n```\n同样的，1和'1'无法区分。\n```\n// 方法五\nArray.prototype.unique5 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 遍历整个数组 \n　for (var i = 0; i < this.length; i++) { \n　　// 如果当前数组的第i值保存到临时数组，那么跳过 \n　　var index = this[i]; \n　　// 如果数组项不在结果数组中，将这个值推入结果数组中 \n　　if (newArray.indexOf(index) === -1) { \n　　　newArray.push(index); \n　　} \n　} \n　return newArray;\n}\n```\nChrome测试结果:\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];\narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n同样的，类似于1和'1'无法区分。所费时间：14361ms。\n```\n// 方法六\nArray.prototype.unique6 = function () { \n　return this.reduce(function (newArray, index) { 　　\n　　if(newArray.indexOf(index) < 0) { \n　　　newArray.push(index); \n　　} \n　　return newArray; \n　},[]);\n}\n```\n测试结果如下：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：16490ms。\n```\n// 方法七\nArray.prototype.unique7 = function(){ \n　var newArray; \n　newArray = this.filter(function (ele,i,arr) { \n　　return arr.indexOf(ele) === i; }); \n　　return newArray;\n}\n```\n测试结果：\n```\nvar arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2']; \narr.unique6(); // [1, 2, 3, 4, \"a\", \"b\", 56, 32, 34, \"c\", 5, \"1\", \"2\"]\n```\n所费时间：13201ms。\n方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：\n```\n//方法三\nArray.prototype.unique3 = function () { \n　// 构建一个新数组存放结果 \n　var newArray = []; \n　// 创建一个空对象 \n　var object = {}; \n　// for循环时，每次取出一个元素与对象进行对比 \n　// 如果这个元素不重复，则将它存放到结果数中 \n　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, \n　// 存入到第2步建立的对象中 \n　for (var i = 0; i < this.length; i++){ \n　　// 检测在object对象中是否包含遍历到的元素的值 \n　　if(!object[typeof(this[i]) + this[i]]) { \n　　// 如果不包含，将存入对象的元素的值推入到结果数组中\n　　　newArray.push(this[i]); \n　　　// 如果不包含，存入object对象中该属性名的值设置为1 \n　　　object[typeof(this[i]) + this[i]] = 1; \n　　} \n　} \n　return newArray;\n}\n```\n但在ES6去重还有更简单，更优化的方案，比如：\n```\n// ES6\nfunction unique (arr) { \n　const seen = new Map() \n　return arr.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n// or\nfunction unique (arr) { \n　return Array.from(new Set(arr))\n}\n```\n----------\n转载自：http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\n","slug":"JavaScript数组去重","published":1,"updated":"2019-12-29T09:42:13.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnba005shns61i3zs2zx","content":"<p>话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于<a href=\"http://www.w3cplus.com/blog/tags/538.html\" target=\"_blank\" rel=\"noopener\">JavaScript数组相关的知识</a>,趁此机会整理了一些有关于JavaScript数组去重的方法。</p>\n<p>下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。</p>\n<h3 id=\"双重循环去重\"><a href=\"#双重循环去重\" class=\"headerlink\" title=\"双重循环去重\"></a>双重循环去重</h3><hr>\n<p>这个方法使用了两个for循环做遍历。整个思路是：</p>\n<ul>\n<li>构建一个空数组用来存放去重后的数组</li>\n<li>外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比</li>\n<li>如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中</li>\n</ul>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique1 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组，存放结果 var newArray = [this[0]]; </span><br><span class=\"line\">　// for循环，每次从原数组中取出一个元素 </span><br><span class=\"line\">　// 用取出的元素循环与结果数组对比 </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　var repeat = false; </span><br><span class=\"line\">　　for (var j=0; j &lt; newArray.length; j++) &#123; </span><br><span class=\"line\">　　// 原数组取出的元素与结果数组元素相同 </span><br><span class=\"line\">　　　if(this[i] == newArray[j]) &#123; </span><br><span class=\"line\">　　　　repeat = true; break; </span><br><span class=\"line\">　　　&#125; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　if(!repeat) &#123; </span><br><span class=\"line\">　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　</span><br><span class=\"line\">　　　newArray.push(this[i]);</span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设我们有一个这样的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique1(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5]</span><br></pre></td></tr></table></figure></p>\n<p>据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123; </span><br><span class=\"line\">　var arr = []; </span><br><span class=\"line\">　for (var i = 0; i &lt; 1000000; i++) &#123; 　　</span><br><span class=\"line\">　　arr.push(Math.round(Math.random(i) * 10000)); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123; </span><br><span class=\"line\">　var tStart = (new Date()).getTime(); </span><br><span class=\"line\">　var re = arr.unique1(); </span><br><span class=\"line\">　var tEnd = (new Date()).getTime(); </span><br><span class=\"line\">　console.log(&apos;双重循环去重方法使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;); </span><br><span class=\"line\">　return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure></p>\n<p>在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。</p>\n<p>上面的方法可以使用forEach()方法和indexOf()方法模拟实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function unique1() &#123; </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　this.forEach(function (index) &#123; </span><br><span class=\"line\">　　if (newArray.indexOf(index) == -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125;); </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。</p>\n<h3 id=\"排序遍历去重\"><a href=\"#排序遍历去重\" class=\"headerlink\" title=\"排序遍历去重\"></a>排序遍历去重</h3><hr>\n<p>先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique2 = function () &#123; </span><br><span class=\"line\">　// 原数组先排序 </span><br><span class=\"line\">　this.sort(); </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 </span><br><span class=\"line\">　　// 因为排序了，所以重复元素会在相邻位置 </span><br><span class=\"line\">　　if(this[i] !== newArray[newArray.length - 1]) &#123; </span><br><span class=\"line\">　　　// 如果不同，将元素放到结果数组中 </span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique2(); // [&quot;1&quot;, 1, 2, &quot;2&quot;, 3, 32, 34, 4, 5, 56, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>这种方法有两个特色：<br>去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如’1’和1</p>\n<p>使用同样的方法，测试所费时间：1232ms。</p>\n<h3 id=\"对象键值对法\"><a href=\"#对象键值对法\" class=\"headerlink\" title=\"对象键值对法\"></a>对象键值对法</h3><hr>\n<p>这种去重方法实现思路是：<br>创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比<br>如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object<br>对象中该属性名的值设置为1</p>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行前面的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique3(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，不同的键可能会被误认为一样；例如： a[1]、a[“1”]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。</p>\n<p>除了上面几种方法，还有其他几种方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法四</span><br><span class=\"line\">Array.prototype.unique4 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 遍历是否有重复的值 </span><br><span class=\"line\">　　for (j = i + 1; j &lt; this.length; j++) &#123; </span><br><span class=\"line\">　　　// 如果有相同元素，自增i变量，跳出i的循环 </span><br><span class=\"line\">　　　if(this[i] === this[j]) &#123; </span><br><span class=\"line\">　　　　j = ++i; </span><br><span class=\"line\">　　　&#125;　 </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　// 如果没有相同元素，将元素推入到结果数组中 　</span><br><span class=\"line\">　　newArray.push(this[i]); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique4(); // [&quot;a&quot;, 1, 3, 4, 56, 32, 34, 2, &quot;b&quot;, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，1和’1’无法区分。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法五</span><br><span class=\"line\">Array.prototype.unique5 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 如果当前数组的第i值保存到临时数组，那么跳过 </span><br><span class=\"line\">　　var index = this[i]; </span><br><span class=\"line\">　　// 如果数组项不在结果数组中，将这个值推入结果数组中 </span><br><span class=\"line\">　　if (newArray.indexOf(index) === -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，类似于1和’1’无法区分。所费时间：14361ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法六</span><br><span class=\"line\">Array.prototype.unique6 = function () &#123; </span><br><span class=\"line\">　return this.reduce(function (newArray, index) &#123; 　　</span><br><span class=\"line\">　　if(newArray.indexOf(index) &lt; 0) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　return newArray; </span><br><span class=\"line\">　&#125;,[]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：16490ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法七</span><br><span class=\"line\">Array.prototype.unique7 = function()&#123; </span><br><span class=\"line\">　var newArray; </span><br><span class=\"line\">　newArray = this.filter(function (ele,i,arr) &#123; </span><br><span class=\"line\">　　return arr.indexOf(ele) === i; &#125;); </span><br><span class=\"line\">　　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：13201ms。<br>方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//方法三</span><br><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但在ES6去重还有更简单，更优化的方案，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ES6</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　const seen = new Map() </span><br><span class=\"line\">　return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// or</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　return Array.from(new Set(arr))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>转载自：<a href=\"http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\" target=\"_blank\" rel=\"noopener\">http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>话说面试常会碰到面试官会问JavaScript实现数组去重的问题，最近刚好在学习有关于<a href=\"http://www.w3cplus.com/blog/tags/538.html\" target=\"_blank\" rel=\"noopener\">JavaScript数组相关的知识</a>,趁此机会整理了一些有关于JavaScript数组去重的方法。</p>\n<p>下面这些数组去重的方法是自己收集和整理的，如有不对希望指正文中不对之处。</p>\n<h3 id=\"双重循环去重\"><a href=\"#双重循环去重\" class=\"headerlink\" title=\"双重循环去重\"></a>双重循环去重</h3><hr>\n<p>这个方法使用了两个for循环做遍历。整个思路是：</p>\n<ul>\n<li>构建一个空数组用来存放去重后的数组</li>\n<li>外面的for循环对原数组做遍历，每次从数组中取出一个元素与结果数组做对比</li>\n<li>如果原数组取出的元素与结果数组元素相同，则跳出循环;反之则将其存放到结果数组中</li>\n</ul>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique1 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组，存放结果 var newArray = [this[0]]; </span><br><span class=\"line\">　// for循环，每次从原数组中取出一个元素 </span><br><span class=\"line\">　// 用取出的元素循环与结果数组对比 </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　var repeat = false; </span><br><span class=\"line\">　　for (var j=0; j &lt; newArray.length; j++) &#123; </span><br><span class=\"line\">　　// 原数组取出的元素与结果数组元素相同 </span><br><span class=\"line\">　　　if(this[i] == newArray[j]) &#123; </span><br><span class=\"line\">　　　　repeat = true; break; </span><br><span class=\"line\">　　　&#125; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　if(!repeat) &#123; </span><br><span class=\"line\">　　// 如果结果数组中没有该元素，则存放到结果数组中 　　　　</span><br><span class=\"line\">　　　newArray.push(this[i]);</span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设我们有一个这样的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique1(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5]</span><br></pre></td></tr></table></figure></p>\n<p>据说这种方法比较耗时，费性能。简单做个测试(测试方法写得比较拙逼)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function test () &#123; </span><br><span class=\"line\">　var arr = []; </span><br><span class=\"line\">　for (var i = 0; i &lt; 1000000; i++) &#123; 　　</span><br><span class=\"line\">　　arr.push(Math.round(Math.random(i) * 10000)); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　doTest(arr, 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doTest(arr, n) &#123; </span><br><span class=\"line\">　var tStart = (new Date()).getTime(); </span><br><span class=\"line\">　var re = arr.unique1(); </span><br><span class=\"line\">　var tEnd = (new Date()).getTime(); </span><br><span class=\"line\">　console.log(&apos;双重循环去重方法使用时间是:&apos; + (tEnd - tStart) + &apos;ms&apos;); </span><br><span class=\"line\">　return re;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure></p>\n<p>在Chrome控制器运行上面的代码，测试双重循环去重所费时间：11031ms。</p>\n<p>上面的方法可以使用forEach()方法和indexOf()方法模拟实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function unique1() &#123; </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　this.forEach(function (index) &#123; </span><br><span class=\"line\">　　if (newArray.indexOf(index) == -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125;); </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过unique1.apply(arr)或unique1.call(arr)调用。不过这种方法效率要快得多，同样的上面测试代码，所费时间5423ms，几乎快了一半。</p>\n<h3 id=\"排序遍历去重\"><a href=\"#排序遍历去重\" class=\"headerlink\" title=\"排序遍历去重\"></a>排序遍历去重</h3><hr>\n<p>先使用sort()方法对原数组做一个排序，排完序之后对数组做遍历，并且检查数组中的第i个元素与结果数组中最后一个元素是否相同。如果不同，则将元素放到结果数组中。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique2 = function () &#123; </span><br><span class=\"line\">　// 原数组先排序 </span><br><span class=\"line\">　this.sort(); </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　for (var i = 1; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 检查原数中的第i个元素与结果中的最后一个元素是否相同 </span><br><span class=\"line\">　　// 因为排序了，所以重复元素会在相邻位置 </span><br><span class=\"line\">　　if(this[i] !== newArray[newArray.length - 1]) &#123; </span><br><span class=\"line\">　　　// 如果不同，将元素放到结果数组中 </span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique2(); // [&quot;1&quot;, 1, 2, &quot;2&quot;, 3, 32, 34, 4, 5, 56, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>这种方法有两个特色：<br>去重后的数组会做排序，主要是因为原数在去重前做了排序去重后的数组，与数字相同的数字字符无法区分，比如’1’和1</p>\n<p>使用同样的方法，测试所费时间：1232ms。</p>\n<h3 id=\"对象键值对法\"><a href=\"#对象键值对法\" class=\"headerlink\" title=\"对象键值对法\"></a>对象键值对法</h3><hr>\n<p>这种去重方法实现思路是：<br>创建一个JavaScript对象以及新数组使用for循环遍历原数组，每次取出一个元素与JavaScript对象的键做对比<br>如果不包含，将存入对象的元素的值推入到结果数组中,并且将存入object<br>对象中该属性名的值设置为1</p>\n<p>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行前面的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique3(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，不同的键可能会被误认为一样；例如： a[1]、a[“1”]。这种方法所费时间：621ms。 这种方法所费时间是最短，但就是占用内存大一些。</p>\n<p>除了上面几种方法，还有其他几种方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法四</span><br><span class=\"line\">Array.prototype.unique4 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 遍历是否有重复的值 </span><br><span class=\"line\">　　for (j = i + 1; j &lt; this.length; j++) &#123; </span><br><span class=\"line\">　　　// 如果有相同元素，自增i变量，跳出i的循环 </span><br><span class=\"line\">　　　if(this[i] === this[j]) &#123; </span><br><span class=\"line\">　　　　j = ++i; </span><br><span class=\"line\">　　　&#125;　 </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　// 如果没有相同元素，将元素推入到结果数组中 　</span><br><span class=\"line\">　　newArray.push(this[i]); </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique4(); // [&quot;a&quot;, 1, 3, 4, 56, 32, 34, 2, &quot;b&quot;, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，1和’1’无法区分。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法五</span><br><span class=\"line\">Array.prototype.unique5 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 遍历整个数组 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++) &#123; </span><br><span class=\"line\">　　// 如果当前数组的第i值保存到临时数组，那么跳过 </span><br><span class=\"line\">　　var index = this[i]; </span><br><span class=\"line\">　　// 如果数组项不在结果数组中，将这个值推入结果数组中 </span><br><span class=\"line\">　　if (newArray.indexOf(index) === -1) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Chrome测试结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;];</span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>同样的，类似于1和’1’无法区分。所费时间：14361ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法六</span><br><span class=\"line\">Array.prototype.unique6 = function () &#123; </span><br><span class=\"line\">　return this.reduce(function (newArray, index) &#123; 　　</span><br><span class=\"line\">　　if(newArray.indexOf(index) &lt; 0) &#123; </span><br><span class=\"line\">　　　newArray.push(index); </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　　return newArray; </span><br><span class=\"line\">　&#125;,[]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：16490ms。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 方法七</span><br><span class=\"line\">Array.prototype.unique7 = function()&#123; </span><br><span class=\"line\">　var newArray; </span><br><span class=\"line\">　newArray = this.filter(function (ele,i,arr) &#123; </span><br><span class=\"line\">　　return arr.indexOf(ele) === i; &#125;); </span><br><span class=\"line\">　　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1,2,3,4,&apos;a&apos;,&apos;b&apos;,1,3,4,56,32,34,2,&apos;b&apos;,&apos;c&apos;,5,&apos;1&apos;,&apos;2&apos;]; </span><br><span class=\"line\">arr.unique6(); // [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, 56, 32, 34, &quot;c&quot;, 5, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>所费时间：13201ms。<br>方法虽然很多种，但相比下来，下面这种方法是较为优秀的方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//方法三</span><br><span class=\"line\">Array.prototype.unique3 = function () &#123; </span><br><span class=\"line\">　// 构建一个新数组存放结果 </span><br><span class=\"line\">　var newArray = []; </span><br><span class=\"line\">　// 创建一个空对象 </span><br><span class=\"line\">　var object = &#123;&#125;; </span><br><span class=\"line\">　// for循环时，每次取出一个元素与对象进行对比 </span><br><span class=\"line\">　// 如果这个元素不重复，则将它存放到结果数中 </span><br><span class=\"line\">　// 同时把这个元素的内容作为对象的一个属性，并赋值为1, </span><br><span class=\"line\">　// 存入到第2步建立的对象中 </span><br><span class=\"line\">　for (var i = 0; i &lt; this.length; i++)&#123; </span><br><span class=\"line\">　　// 检测在object对象中是否包含遍历到的元素的值 </span><br><span class=\"line\">　　if(!object[typeof(this[i]) + this[i]]) &#123; </span><br><span class=\"line\">　　// 如果不包含，将存入对象的元素的值推入到结果数组中</span><br><span class=\"line\">　　　newArray.push(this[i]); </span><br><span class=\"line\">　　　// 如果不包含，存入object对象中该属性名的值设置为1 </span><br><span class=\"line\">　　　object[typeof(this[i]) + this[i]] = 1; </span><br><span class=\"line\">　　&#125; </span><br><span class=\"line\">　&#125; </span><br><span class=\"line\">　return newArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但在ES6去重还有更简单，更优化的方案，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ES6</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　const seen = new Map() </span><br><span class=\"line\">　return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// or</span><br><span class=\"line\">function unique (arr) &#123; </span><br><span class=\"line\">　return Array.from(new Set(arr))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>转载自：<a href=\"http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html\" target=\"_blank\" rel=\"noopener\">http://www.w3cplus.com/javascript/remove-duplicates-from-javascript-array.html</a></p>\n"},{"title":"聊一聊 Node.js 错误处理","date":"2019-12-26T09:39:59.000Z","_content":"\n# 错误分类\n软件程序中，**我们可以将错误大致分为外部错误和内部错误两大类**。\n\n外部错误是正确编写的程序在运行时产生的错误。它并不是程序本身的 Bug，更多是一些外部原因导致的问题，比如请求超时、服务器返回500、内存不足等。\n\n而内部错误是程序里的 bug。比如传参类型错误、读取 undefined 的一个属性等。这类问题跟你选择的开发语言、开发者的编程经验、系统复杂度等因素息息相关，虽然无法避免，但可以通过修改代码来修复它。\n\n对应到 Node.js 程序上，一般遇到以下四类错误：\n1. 标准的 JavaScript 错误。例如 SyntaxError、RangeError、ReferenceError、TypeError等。\n2. 由底层操作系触发的系统错误，例如试图打开不存在的文件。\n3. 用户自定义错误。\n4. 断言错误。这类错误通常来自 assert 模块。\n\n注：本文中不区分错误和异常，都将其统称为错误。\n\n# 错误处理\n当错误发生后，我们需要第一时间去处理它。针对不同类型的错误，有不同的措施。处理错误的总体原则：\n1. 及时止损，防止系统级崩溃。\n2. 详细记录现场，方便分析原因。\n\n## 外部错误\n\n程序运行过程中，可能会遇到各种外部因素导致的问题，这些问题需要具体问题具体分析。我们没办法保证外部服务提供方的稳定性，但是遇到此类问题时，可以做一些事情，来保证我们的程序不至于直接崩溃。\n\n举个例子，秒杀场景的业务经常会承受非常大的 QPS，在一波瞬间大流量的冲击，后端服务扛不住的话会报 5XX 错误。在后端服务挂掉后，我们可能会去读 redis 等缓存中的数据，用旧数据来兜底。而当 Node.js 应用也挂掉了，还可以在 Nginx 层进行 CDN 降级，给用户输出一个兜底的静态页。\n\n还有些来自后端服务的错误，只需要进行简单的重试就能解决。如果要重试的话，要确定重试的次数，以及重试的间隔。\n\n有人建议在发生错误后直接崩溃掉，防止错误扩散。个人认为其实是不合理的，会降低服务的可用性。我们可以在出现一些严重的错误后，先记录下错误，然后重启进程。在 Node.js 中，未捕获的 JavaScript 异常一直冒泡回到事件循环时，会触发 process.uncaughtException 事件。我们可以在事件回调中做错误上报，然后重启 Node.js 进程。这时，还需要借助 Cluster 来启动多个 Node 进程，保证单进程崩溃重启不会影响整体服务的可用性。实际的生产环境中，使用 PM2 来管理 Node.js 进程是一个更好的选项。\n\n我们永远也无法阻止外部错误，它跟你的业务场景、用户终端等各种不可控的因素相关。但是我们如果做好监控、告警、日志、缓存等工作，可以方便程序员迅速定位/解决问题，从而将损失降至最低。\n\n## 内部错误\n### 同步场景\n对于 JavaScript 错误，我们可以使用 throw 抛出，并用 try catch 来捕获住。\n```js\ntry {\n  throw new Error('some error')\n} catch(e) {\n  console.error(e)\n}\n```\n\n而且对于 throw 抛出的异常必须要 try catch 包裹，否则 Node.js 进程会直接退出。这种写法可以获取到完整的错误调用堆栈。比如：\n\n```js\nfs.js:115\n    throw err;\n    ^\n\nError: ENOENT: no such file or directory, scandir '/Users/frank/code/work/wxapp/src/componentsa'\n    at Object.readdirSync (fs.js:783:3)\n    at getDirFilePaths (/Users/frank/code/m/demo/readdir.js:8:22)\n    at Object.<anonymous> (/Users/frank/code/m/demo/readdir.js:27:15)\n    at Module._compile (internal/modules/cjs/loader.js:688:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:699:10)\n    at Module.load (internal/modules/cjs/loader.js:598:32)\n    at tryModuleLoad (internal/modules/cjs/loader.js:537:12)\n    at Function.Module._load (internal/modules/cjs/loader.js:529:3)\n    at Function.Module.runMain (internal/modules/cjs/loader.js:741:12)\n    at startup (internal/bootstrap/node.js:285:19)\n```\n\n众所周知，JS 函数调用会形成一系列的栈帧，为了尽可能的恢复错误发生现场，最好在错误上报时带上堆栈信息。Node.js 中，`Error.captureStackTrace()` 方法是 v8 引擎暴露出来的，处理错误堆栈信息的 API。\n\n> Error.captureStackTrace(targetObject[, constructorOpt])\n在 targetObject 中添加一个 .stack 属性。对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息(即：调用栈历史)。\n\n值得注意的是，它的第二个参数可以用来控制栈帧的终点。在一些底层库中，这个参数可以用来向开发者隐藏内部实现细节。\n\n实际的生产环境中，我们可以使用 `nested-error-stacks` 这类 npm 包来采集堆栈信息，原理其实也是基于 Error.captureStackTrace()。\n\n这里有个问题是：**try catch 代码块是同步的，对于异步 API 发生的错误，它不能捕获到**。\n\n比如下列代码：\n```js\ntry {\n  setTimeout(() => {\n    throw new Error('some error')\n  }, 1000)\n} catch(e) {\n  console.log('some error...')\n}\n```\n错误并不能被捕获住。这个跟 Node.js 的事件循环机制有关，因为异步任务是通过事件队列来实现的，每次从事件队列中取出一个函数来执行时，实际上这个函数是在调用栈的最顶层执行的，如果它抛出了一个异常，也是无法沿着调用栈回溯到这个异步任务的创建者的。\n\n下面介绍下在异步流程中，我们应该怎么处理错误。\n\n### 异步场景\nNode.js 中常见异步场景包括三类：\n- Node.js style callback\n- Promise\n- EventEmitter\n\n大部分异步 API 都遵循错误回调优先的约定，将 Error 作为 callback 的第一个参数来传递，这种风格比较类似函数式编程中的 [Continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style)。\n```js\nfs.readFile(path, 'r', (err, data) => {\n  if (err) {\n    throw err\n  } else {\n    try {\n      // handle data\n    } catch(e) {\n\n    }\n  }\n})\n```\n这种写法很容易造成回调地狱。另一方面，对于回调函数中的同步逻辑，我们还需要用 try catch 去单独处理，这导致错误逻辑的处理被分散了两处。Promise 被正式 ES6 标准化后，我们可以用 Promise 的链式调用来处理错误。\n```js\nnew Promise((resolve, reject) => {\n    reject(new Error('some error'));\n  })\n  .then(() => {\n    ...\n  })\n  .then(() => {\n    ...\n  })\n  .catch(err => {\n    \n  });\n```\n这样，Promise 链上的错误都会在 catch 方法上捕获住。对于没有 catch 的 Promise 异常，会一直冒泡到顶层，在 `process.unhandledRejection` 事件上被捕获住。\n\n还有一类是 EventEmitter 对象上的错误。它们会被分发到 error 事件上进行处理，比如 Stream 等。我们需要去为每一个流去监听 error 事件，否则会冒泡到process.uncaughtException 事件上去。\n\n异步场景中，还有个问题就是，会丢失异步回调前的错误堆栈。原因还是上文提到的 Node.js 事件循环机制。\n```js\nconst foo = function () {\n  throw new Error('some error')\n}\nconst bar = function () {\n  setTimeout(foo)\n}\nbar()\n```\n输出结果：\n```js\nError: some error\n    at Timeout.foo [as _onTimeout] (/Users/frank/code/m/demo/readdir.js:47:9)\n    at ontimeout (timers.js:436:11)\n    at tryOnTimeout (timers.js:300:5)\n    at listOnTimeout (timers.js:263:5)\n    at Timer.processTimers (timers.js:223:10)\n```\n可以看到丢失了 bar 的调用栈。然而在 Node.js 中，异步调用场景还挺多的，有什么办法可以将多个异步调用给串起来，获取到完整的调用链信息呢？答案是有的。Node.js v8+ 上提供了 async_hooks 模块，用来完善异步场景的监控。\n\n### async_hooks\nasync_hooks 提供了一些 API 用于跟踪 Node.js 中的异步资源的生命周期。有几个概念：\n- 每个异步函数的作用域，我们称之为 async scope。\n- 每一个 async scope 中都有一个 asyncId, 用来标记当前作用域。相同 async scope 的 asyncId 也相同。每个异步资源在创建时 asyncId 全量递增的。\n- 每一个 async scope 中都有一个 triggerAsyncId 表示当前函数是由哪个 async scope 触发生成的。\n- 通过 asyncId 和 triggerAsyncId，我们可以获取到异步资源的调用链。\n- async_hooks.createHooks 函数可以用来给每个异步资源添加 init/before/after/destory 等生命周期钩子函数。\n\n```js\nconsole.log('global.asyncId:', async_hooks.executionAsyncId());  // global.asyncId: 1\nconsole.log('global.triggerAsyncId:', async_hooks.triggerAsyncId()); // global.triggerAsyncId: 0\nfs.open('./app.js', 'r', (err, fd) => {\n    console.log('fs.open.asyncId:', async_hooks.executionAsyncId()); // fs.open.asyncId: 7\n    console.log('fs.open.triggerAsyncId:', async_hooks.triggerAsyncId()); // fs.open.triggerAsyncId: 1\n});\n```\n回调函数中的 triggerAsyncId 为 1，它等于 global scope 上的 asyncId。这样就可以拿到多个异步调用的调用链。\n\n国内的赵坤大神写过一个 koa 日志中间件 [koa-await-breakpoint](https://github.com/nswbmw/koa-await-breakpoint)，用于实现在每个 await 执行的语句前后进行自动打点工作。\n```js\n// On top of the main file\nconst koaAwaitBreakpoint = require('koa-await-breakpoint')({\n  name: 'api',\n  files: ['./routes/*.js']\n})\nconst Koa = require('koa')\nconst app = new Koa()\n// Generally, above other middlewares\napp.use(koaAwaitBreakpoint)\n...\napp.listen(3000)\n```\n每个请求到来时，生成一个 requestId 挂载到 ctx 上，通过 requestId 将日志串起来。核心原理是 hack 了模块的 require 方法（重载 Module.prototype._compile），用 esprima 将模块代码转成 AST，找到其中的 awaitExpression 节点，对其用日志函数包裹后重新插入到 AST，最后用 escodegen 将 AST 生成代码。其中还用到了 async_hooks，在日志函数中，基于 async_hooks 的 init 钩子中将异步调用关系存储到一个 Map 中，最终实现函数调用链的自动日志打点。\n\n不过，使用 async_hooks 在目前有较严重的[性能损耗](https://github.com/bmeurer/async-hooks-performance-impact)。建议生产环境慎用。\n![](https://raw.githubusercontent.com/bmeurer/async-hooks-performance-impact/master/results-hapi-koa-node-9.4.0.png)\n\n# 总结\n错误可分为外部错误和内部错误两类。对外部错误的处理主要考验系统架构的设计，只有系统设计的足够健壮，才能够抵御各种外部挑战，并损失降到最低。对于内部错误，本文分别讨论了同步和异步两种场景，介绍了 `Error.captureStackTrace()`、`async_hooks` 等 API 在收集错误堆栈、异步调用链上的用途，并结合 koa-await-breakpoint 源码，解释了 Node.js 自动化打点的核心原理。\n\n------\n参考链接：\n1. [深入理解 JavaScript Errors 和 Stack Traces](https://zhuanlan.zhihu.com/p/25338849)\n2. [关于 Error.captureStackTrace](http://blog.shaochuancs.com/about-error-capturestacktrace/)\n3. [Error Handling in Node.js](https://www.joyent.com/node-js/production/design/errors)\n4. [Node.js 错误处理实践](https://jysperm.me/2016/10/nodejs-error-handling/)\n5. [学习使用 Node.js 中 async-hooks 模块](https://zhuanlan.zhihu.com/p/53036228)\n6. https://github.com/bmeurer/async-hooks-performance-impact\n7. http://nodejs.cn/api/errors.html#errors_errors","source":"_posts/Node-js错误处理最佳实践.md","raw":"---\ntitle: 聊一聊 Node.js 错误处理\ndate: 2019-12-26 17:39:59\ntags:\n- Node.js\ncategories:\n- 前端\n---\n\n# 错误分类\n软件程序中，**我们可以将错误大致分为外部错误和内部错误两大类**。\n\n外部错误是正确编写的程序在运行时产生的错误。它并不是程序本身的 Bug，更多是一些外部原因导致的问题，比如请求超时、服务器返回500、内存不足等。\n\n而内部错误是程序里的 bug。比如传参类型错误、读取 undefined 的一个属性等。这类问题跟你选择的开发语言、开发者的编程经验、系统复杂度等因素息息相关，虽然无法避免，但可以通过修改代码来修复它。\n\n对应到 Node.js 程序上，一般遇到以下四类错误：\n1. 标准的 JavaScript 错误。例如 SyntaxError、RangeError、ReferenceError、TypeError等。\n2. 由底层操作系触发的系统错误，例如试图打开不存在的文件。\n3. 用户自定义错误。\n4. 断言错误。这类错误通常来自 assert 模块。\n\n注：本文中不区分错误和异常，都将其统称为错误。\n\n# 错误处理\n当错误发生后，我们需要第一时间去处理它。针对不同类型的错误，有不同的措施。处理错误的总体原则：\n1. 及时止损，防止系统级崩溃。\n2. 详细记录现场，方便分析原因。\n\n## 外部错误\n\n程序运行过程中，可能会遇到各种外部因素导致的问题，这些问题需要具体问题具体分析。我们没办法保证外部服务提供方的稳定性，但是遇到此类问题时，可以做一些事情，来保证我们的程序不至于直接崩溃。\n\n举个例子，秒杀场景的业务经常会承受非常大的 QPS，在一波瞬间大流量的冲击，后端服务扛不住的话会报 5XX 错误。在后端服务挂掉后，我们可能会去读 redis 等缓存中的数据，用旧数据来兜底。而当 Node.js 应用也挂掉了，还可以在 Nginx 层进行 CDN 降级，给用户输出一个兜底的静态页。\n\n还有些来自后端服务的错误，只需要进行简单的重试就能解决。如果要重试的话，要确定重试的次数，以及重试的间隔。\n\n有人建议在发生错误后直接崩溃掉，防止错误扩散。个人认为其实是不合理的，会降低服务的可用性。我们可以在出现一些严重的错误后，先记录下错误，然后重启进程。在 Node.js 中，未捕获的 JavaScript 异常一直冒泡回到事件循环时，会触发 process.uncaughtException 事件。我们可以在事件回调中做错误上报，然后重启 Node.js 进程。这时，还需要借助 Cluster 来启动多个 Node 进程，保证单进程崩溃重启不会影响整体服务的可用性。实际的生产环境中，使用 PM2 来管理 Node.js 进程是一个更好的选项。\n\n我们永远也无法阻止外部错误，它跟你的业务场景、用户终端等各种不可控的因素相关。但是我们如果做好监控、告警、日志、缓存等工作，可以方便程序员迅速定位/解决问题，从而将损失降至最低。\n\n## 内部错误\n### 同步场景\n对于 JavaScript 错误，我们可以使用 throw 抛出，并用 try catch 来捕获住。\n```js\ntry {\n  throw new Error('some error')\n} catch(e) {\n  console.error(e)\n}\n```\n\n而且对于 throw 抛出的异常必须要 try catch 包裹，否则 Node.js 进程会直接退出。这种写法可以获取到完整的错误调用堆栈。比如：\n\n```js\nfs.js:115\n    throw err;\n    ^\n\nError: ENOENT: no such file or directory, scandir '/Users/frank/code/work/wxapp/src/componentsa'\n    at Object.readdirSync (fs.js:783:3)\n    at getDirFilePaths (/Users/frank/code/m/demo/readdir.js:8:22)\n    at Object.<anonymous> (/Users/frank/code/m/demo/readdir.js:27:15)\n    at Module._compile (internal/modules/cjs/loader.js:688:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:699:10)\n    at Module.load (internal/modules/cjs/loader.js:598:32)\n    at tryModuleLoad (internal/modules/cjs/loader.js:537:12)\n    at Function.Module._load (internal/modules/cjs/loader.js:529:3)\n    at Function.Module.runMain (internal/modules/cjs/loader.js:741:12)\n    at startup (internal/bootstrap/node.js:285:19)\n```\n\n众所周知，JS 函数调用会形成一系列的栈帧，为了尽可能的恢复错误发生现场，最好在错误上报时带上堆栈信息。Node.js 中，`Error.captureStackTrace()` 方法是 v8 引擎暴露出来的，处理错误堆栈信息的 API。\n\n> Error.captureStackTrace(targetObject[, constructorOpt])\n在 targetObject 中添加一个 .stack 属性。对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息(即：调用栈历史)。\n\n值得注意的是，它的第二个参数可以用来控制栈帧的终点。在一些底层库中，这个参数可以用来向开发者隐藏内部实现细节。\n\n实际的生产环境中，我们可以使用 `nested-error-stacks` 这类 npm 包来采集堆栈信息，原理其实也是基于 Error.captureStackTrace()。\n\n这里有个问题是：**try catch 代码块是同步的，对于异步 API 发生的错误，它不能捕获到**。\n\n比如下列代码：\n```js\ntry {\n  setTimeout(() => {\n    throw new Error('some error')\n  }, 1000)\n} catch(e) {\n  console.log('some error...')\n}\n```\n错误并不能被捕获住。这个跟 Node.js 的事件循环机制有关，因为异步任务是通过事件队列来实现的，每次从事件队列中取出一个函数来执行时，实际上这个函数是在调用栈的最顶层执行的，如果它抛出了一个异常，也是无法沿着调用栈回溯到这个异步任务的创建者的。\n\n下面介绍下在异步流程中，我们应该怎么处理错误。\n\n### 异步场景\nNode.js 中常见异步场景包括三类：\n- Node.js style callback\n- Promise\n- EventEmitter\n\n大部分异步 API 都遵循错误回调优先的约定，将 Error 作为 callback 的第一个参数来传递，这种风格比较类似函数式编程中的 [Continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style)。\n```js\nfs.readFile(path, 'r', (err, data) => {\n  if (err) {\n    throw err\n  } else {\n    try {\n      // handle data\n    } catch(e) {\n\n    }\n  }\n})\n```\n这种写法很容易造成回调地狱。另一方面，对于回调函数中的同步逻辑，我们还需要用 try catch 去单独处理，这导致错误逻辑的处理被分散了两处。Promise 被正式 ES6 标准化后，我们可以用 Promise 的链式调用来处理错误。\n```js\nnew Promise((resolve, reject) => {\n    reject(new Error('some error'));\n  })\n  .then(() => {\n    ...\n  })\n  .then(() => {\n    ...\n  })\n  .catch(err => {\n    \n  });\n```\n这样，Promise 链上的错误都会在 catch 方法上捕获住。对于没有 catch 的 Promise 异常，会一直冒泡到顶层，在 `process.unhandledRejection` 事件上被捕获住。\n\n还有一类是 EventEmitter 对象上的错误。它们会被分发到 error 事件上进行处理，比如 Stream 等。我们需要去为每一个流去监听 error 事件，否则会冒泡到process.uncaughtException 事件上去。\n\n异步场景中，还有个问题就是，会丢失异步回调前的错误堆栈。原因还是上文提到的 Node.js 事件循环机制。\n```js\nconst foo = function () {\n  throw new Error('some error')\n}\nconst bar = function () {\n  setTimeout(foo)\n}\nbar()\n```\n输出结果：\n```js\nError: some error\n    at Timeout.foo [as _onTimeout] (/Users/frank/code/m/demo/readdir.js:47:9)\n    at ontimeout (timers.js:436:11)\n    at tryOnTimeout (timers.js:300:5)\n    at listOnTimeout (timers.js:263:5)\n    at Timer.processTimers (timers.js:223:10)\n```\n可以看到丢失了 bar 的调用栈。然而在 Node.js 中，异步调用场景还挺多的，有什么办法可以将多个异步调用给串起来，获取到完整的调用链信息呢？答案是有的。Node.js v8+ 上提供了 async_hooks 模块，用来完善异步场景的监控。\n\n### async_hooks\nasync_hooks 提供了一些 API 用于跟踪 Node.js 中的异步资源的生命周期。有几个概念：\n- 每个异步函数的作用域，我们称之为 async scope。\n- 每一个 async scope 中都有一个 asyncId, 用来标记当前作用域。相同 async scope 的 asyncId 也相同。每个异步资源在创建时 asyncId 全量递增的。\n- 每一个 async scope 中都有一个 triggerAsyncId 表示当前函数是由哪个 async scope 触发生成的。\n- 通过 asyncId 和 triggerAsyncId，我们可以获取到异步资源的调用链。\n- async_hooks.createHooks 函数可以用来给每个异步资源添加 init/before/after/destory 等生命周期钩子函数。\n\n```js\nconsole.log('global.asyncId:', async_hooks.executionAsyncId());  // global.asyncId: 1\nconsole.log('global.triggerAsyncId:', async_hooks.triggerAsyncId()); // global.triggerAsyncId: 0\nfs.open('./app.js', 'r', (err, fd) => {\n    console.log('fs.open.asyncId:', async_hooks.executionAsyncId()); // fs.open.asyncId: 7\n    console.log('fs.open.triggerAsyncId:', async_hooks.triggerAsyncId()); // fs.open.triggerAsyncId: 1\n});\n```\n回调函数中的 triggerAsyncId 为 1，它等于 global scope 上的 asyncId。这样就可以拿到多个异步调用的调用链。\n\n国内的赵坤大神写过一个 koa 日志中间件 [koa-await-breakpoint](https://github.com/nswbmw/koa-await-breakpoint)，用于实现在每个 await 执行的语句前后进行自动打点工作。\n```js\n// On top of the main file\nconst koaAwaitBreakpoint = require('koa-await-breakpoint')({\n  name: 'api',\n  files: ['./routes/*.js']\n})\nconst Koa = require('koa')\nconst app = new Koa()\n// Generally, above other middlewares\napp.use(koaAwaitBreakpoint)\n...\napp.listen(3000)\n```\n每个请求到来时，生成一个 requestId 挂载到 ctx 上，通过 requestId 将日志串起来。核心原理是 hack 了模块的 require 方法（重载 Module.prototype._compile），用 esprima 将模块代码转成 AST，找到其中的 awaitExpression 节点，对其用日志函数包裹后重新插入到 AST，最后用 escodegen 将 AST 生成代码。其中还用到了 async_hooks，在日志函数中，基于 async_hooks 的 init 钩子中将异步调用关系存储到一个 Map 中，最终实现函数调用链的自动日志打点。\n\n不过，使用 async_hooks 在目前有较严重的[性能损耗](https://github.com/bmeurer/async-hooks-performance-impact)。建议生产环境慎用。\n![](https://raw.githubusercontent.com/bmeurer/async-hooks-performance-impact/master/results-hapi-koa-node-9.4.0.png)\n\n# 总结\n错误可分为外部错误和内部错误两类。对外部错误的处理主要考验系统架构的设计，只有系统设计的足够健壮，才能够抵御各种外部挑战，并损失降到最低。对于内部错误，本文分别讨论了同步和异步两种场景，介绍了 `Error.captureStackTrace()`、`async_hooks` 等 API 在收集错误堆栈、异步调用链上的用途，并结合 koa-await-breakpoint 源码，解释了 Node.js 自动化打点的核心原理。\n\n------\n参考链接：\n1. [深入理解 JavaScript Errors 和 Stack Traces](https://zhuanlan.zhihu.com/p/25338849)\n2. [关于 Error.captureStackTrace](http://blog.shaochuancs.com/about-error-capturestacktrace/)\n3. [Error Handling in Node.js](https://www.joyent.com/node-js/production/design/errors)\n4. [Node.js 错误处理实践](https://jysperm.me/2016/10/nodejs-error-handling/)\n5. [学习使用 Node.js 中 async-hooks 模块](https://zhuanlan.zhihu.com/p/53036228)\n6. https://github.com/bmeurer/async-hooks-performance-impact\n7. http://nodejs.cn/api/errors.html#errors_errors","slug":"Node-js错误处理最佳实践","published":1,"updated":"2019-12-28T15:39:58.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbc005thns6b099buza","content":"<h1 id=\"错误分类\"><a href=\"#错误分类\" class=\"headerlink\" title=\"错误分类\"></a>错误分类</h1><p>软件程序中，<strong>我们可以将错误大致分为外部错误和内部错误两大类</strong>。</p>\n<p>外部错误是正确编写的程序在运行时产生的错误。它并不是程序本身的 Bug，更多是一些外部原因导致的问题，比如请求超时、服务器返回500、内存不足等。</p>\n<p>而内部错误是程序里的 bug。比如传参类型错误、读取 undefined 的一个属性等。这类问题跟你选择的开发语言、开发者的编程经验、系统复杂度等因素息息相关，虽然无法避免，但可以通过修改代码来修复它。</p>\n<p>对应到 Node.js 程序上，一般遇到以下四类错误：</p>\n<ol>\n<li>标准的 JavaScript 错误。例如 SyntaxError、RangeError、ReferenceError、TypeError等。</li>\n<li>由底层操作系触发的系统错误，例如试图打开不存在的文件。</li>\n<li>用户自定义错误。</li>\n<li>断言错误。这类错误通常来自 assert 模块。</li>\n</ol>\n<p>注：本文中不区分错误和异常，都将其统称为错误。</p>\n<h1 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h1><p>当错误发生后，我们需要第一时间去处理它。针对不同类型的错误，有不同的措施。处理错误的总体原则：</p>\n<ol>\n<li>及时止损，防止系统级崩溃。</li>\n<li>详细记录现场，方便分析原因。</li>\n</ol>\n<h2 id=\"外部错误\"><a href=\"#外部错误\" class=\"headerlink\" title=\"外部错误\"></a>外部错误</h2><p>程序运行过程中，可能会遇到各种外部因素导致的问题，这些问题需要具体问题具体分析。我们没办法保证外部服务提供方的稳定性，但是遇到此类问题时，可以做一些事情，来保证我们的程序不至于直接崩溃。</p>\n<p>举个例子，秒杀场景的业务经常会承受非常大的 QPS，在一波瞬间大流量的冲击，后端服务扛不住的话会报 5XX 错误。在后端服务挂掉后，我们可能会去读 redis 等缓存中的数据，用旧数据来兜底。而当 Node.js 应用也挂掉了，还可以在 Nginx 层进行 CDN 降级，给用户输出一个兜底的静态页。</p>\n<p>还有些来自后端服务的错误，只需要进行简单的重试就能解决。如果要重试的话，要确定重试的次数，以及重试的间隔。</p>\n<p>有人建议在发生错误后直接崩溃掉，防止错误扩散。个人认为其实是不合理的，会降低服务的可用性。我们可以在出现一些严重的错误后，先记录下错误，然后重启进程。在 Node.js 中，未捕获的 JavaScript 异常一直冒泡回到事件循环时，会触发 process.uncaughtException 事件。我们可以在事件回调中做错误上报，然后重启 Node.js 进程。这时，还需要借助 Cluster 来启动多个 Node 进程，保证单进程崩溃重启不会影响整体服务的可用性。实际的生产环境中，使用 PM2 来管理 Node.js 进程是一个更好的选项。</p>\n<p>我们永远也无法阻止外部错误，它跟你的业务场景、用户终端等各种不可控的因素相关。但是我们如果做好监控、告警、日志、缓存等工作，可以方便程序员迅速定位/解决问题，从而将损失降至最低。</p>\n<h2 id=\"内部错误\"><a href=\"#内部错误\" class=\"headerlink\" title=\"内部错误\"></a>内部错误</h2><h3 id=\"同步场景\"><a href=\"#同步场景\" class=\"headerlink\" title=\"同步场景\"></a>同步场景</h3><p>对于 JavaScript 错误，我们可以使用 throw 抛出，并用 try catch 来捕获住。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而且对于 throw 抛出的异常必须要 try catch 包裹，否则 Node.js 进程会直接退出。这种写法可以获取到完整的错误调用堆栈。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.js:<span class=\"number\">115</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    ^</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Error</span>: ENOENT: no such file or directory, scandir <span class=\"string\">'/Users/frank/code/work/wxapp/src/componentsa'</span></span><br><span class=\"line\">    at <span class=\"built_in\">Object</span>.readdirSync (fs.js:<span class=\"number\">783</span>:<span class=\"number\">3</span>)</span><br><span class=\"line\">    at getDirFilePaths (<span class=\"regexp\">/Users/</span>frank/code/m/demo/readdir.js:<span class=\"number\">8</span>:<span class=\"number\">22</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Object</span>.&lt;anonymous&gt; (<span class=\"regexp\">/Users/</span>frank/code/m/demo/readdir.js:<span class=\"number\">27</span>:<span class=\"number\">15</span>)</span><br><span class=\"line\">    at Module._compile (internal/modules/cjs/loader.js:<span class=\"number\">688</span>:<span class=\"number\">30</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Object</span>.Module._extensions..js (internal/modules/cjs/loader.js:<span class=\"number\">699</span>:<span class=\"number\">10</span>)</span><br><span class=\"line\">    at Module.load (internal/modules/cjs/loader.js:<span class=\"number\">598</span>:<span class=\"number\">32</span>)</span><br><span class=\"line\">    at tryModuleLoad (internal/modules/cjs/loader.js:<span class=\"number\">537</span>:<span class=\"number\">12</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Function</span>.Module._load (internal/modules/cjs/loader.js:<span class=\"number\">529</span>:<span class=\"number\">3</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Function</span>.Module.runMain (internal/modules/cjs/loader.js:<span class=\"number\">741</span>:<span class=\"number\">12</span>)</span><br><span class=\"line\">    at startup (internal/bootstrap/node.js:<span class=\"number\">285</span>:<span class=\"number\">19</span>)</span><br></pre></td></tr></table></figure>\n<p>众所周知，JS 函数调用会形成一系列的栈帧，为了尽可能的恢复错误发生现场，最好在错误上报时带上堆栈信息。Node.js 中，<code>Error.captureStackTrace()</code> 方法是 v8 引擎暴露出来的，处理错误堆栈信息的 API。</p>\n<blockquote>\n<p>Error.captureStackTrace(targetObject[, constructorOpt])<br>在 targetObject 中添加一个 .stack 属性。对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息(即：调用栈历史)。</p>\n</blockquote>\n<p>值得注意的是，它的第二个参数可以用来控制栈帧的终点。在一些底层库中，这个参数可以用来向开发者隐藏内部实现细节。</p>\n<p>实际的生产环境中，我们可以使用 <code>nested-error-stacks</code> 这类 npm 包来采集堆栈信息，原理其实也是基于 Error.captureStackTrace()。</p>\n<p>这里有个问题是：<strong>try catch 代码块是同步的，对于异步 API 发生的错误，它不能捕获到</strong>。</p>\n<p>比如下列代码：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'some error...'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>错误并不能被捕获住。这个跟 Node.js 的事件循环机制有关，因为异步任务是通过事件队列来实现的，每次从事件队列中取出一个函数来执行时，实际上这个函数是在调用栈的最顶层执行的，如果它抛出了一个异常，也是无法沿着调用栈回溯到这个异步任务的创建者的。</p>\n<p>下面介绍下在异步流程中，我们应该怎么处理错误。</p>\n<h3 id=\"异步场景\"><a href=\"#异步场景\" class=\"headerlink\" title=\"异步场景\"></a>异步场景</h3><p>Node.js 中常见异步场景包括三类：</p>\n<ul>\n<li>Node.js style callback</li>\n<li>Promise</li>\n<li>EventEmitter</li>\n</ul>\n<p>大部分异步 API 都遵循错误回调优先的约定，将 Error 作为 callback 的第一个参数来传递，这种风格比较类似函数式编程中的 <a href=\"https://en.wikipedia.org/wiki/Continuation-passing_style\" target=\"_blank\" rel=\"noopener\">Continuation-passing style</a>。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.readFile(path, <span class=\"string\">'r'</span>, (err, data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// handle data</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这种写法很容易造成回调地狱。另一方面，对于回调函数中的同步逻辑，我们还需要用 try catch 去单独处理，这导致错误逻辑的处理被分散了两处。Promise 被正式 ES6 标准化后，我们可以用 Promise 的链式调用来处理错误。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>));</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，Promise 链上的错误都会在 catch 方法上捕获住。对于没有 catch 的 Promise 异常，会一直冒泡到顶层，在 <code>process.unhandledRejection</code> 事件上被捕获住。</p>\n<p>还有一类是 EventEmitter 对象上的错误。它们会被分发到 error 事件上进行处理，比如 Stream 等。我们需要去为每一个流去监听 error 事件，否则会冒泡到process.uncaughtException 事件上去。</p>\n<p>异步场景中，还有个问题就是，会丢失异步回调前的错误堆栈。原因还是上文提到的 Node.js 事件循环机制。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(foo)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Error</span>: some error</span><br><span class=\"line\">    at Timeout.foo [<span class=\"keyword\">as</span> _onTimeout] (<span class=\"regexp\">/Users/</span>frank/code/m/demo/readdir.js:<span class=\"number\">47</span>:<span class=\"number\">9</span>)</span><br><span class=\"line\">    at ontimeout (timers.js:<span class=\"number\">436</span>:<span class=\"number\">11</span>)</span><br><span class=\"line\">    at tryOnTimeout (timers.js:<span class=\"number\">300</span>:<span class=\"number\">5</span>)</span><br><span class=\"line\">    at listOnTimeout (timers.js:<span class=\"number\">263</span>:<span class=\"number\">5</span>)</span><br><span class=\"line\">    at Timer.processTimers (timers.js:<span class=\"number\">223</span>:<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到丢失了 bar 的调用栈。然而在 Node.js 中，异步调用场景还挺多的，有什么办法可以将多个异步调用给串起来，获取到完整的调用链信息呢？答案是有的。Node.js v8+ 上提供了 async_hooks 模块，用来完善异步场景的监控。</p>\n<h3 id=\"async-hooks\"><a href=\"#async-hooks\" class=\"headerlink\" title=\"async_hooks\"></a>async_hooks</h3><p>async_hooks 提供了一些 API 用于跟踪 Node.js 中的异步资源的生命周期。有几个概念：</p>\n<ul>\n<li>每个异步函数的作用域，我们称之为 async scope。</li>\n<li>每一个 async scope 中都有一个 asyncId, 用来标记当前作用域。相同 async scope 的 asyncId 也相同。每个异步资源在创建时 asyncId 全量递增的。</li>\n<li>每一个 async scope 中都有一个 triggerAsyncId 表示当前函数是由哪个 async scope 触发生成的。</li>\n<li>通过 asyncId 和 triggerAsyncId，我们可以获取到异步资源的调用链。</li>\n<li>async_hooks.createHooks 函数可以用来给每个异步资源添加 init/before/after/destory 等生命周期钩子函数。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'global.asyncId:'</span>, async_hooks.executionAsyncId());  <span class=\"comment\">// global.asyncId: 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'global.triggerAsyncId:'</span>, async_hooks.triggerAsyncId()); <span class=\"comment\">// global.triggerAsyncId: 0</span></span><br><span class=\"line\">fs.open(<span class=\"string\">'./app.js'</span>, <span class=\"string\">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fs.open.asyncId:'</span>, async_hooks.executionAsyncId()); <span class=\"comment\">// fs.open.asyncId: 7</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fs.open.triggerAsyncId:'</span>, async_hooks.triggerAsyncId()); <span class=\"comment\">// fs.open.triggerAsyncId: 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>回调函数中的 triggerAsyncId 为 1，它等于 global scope 上的 asyncId。这样就可以拿到多个异步调用的调用链。</p>\n<p>国内的赵坤大神写过一个 koa 日志中间件 <a href=\"https://github.com/nswbmw/koa-await-breakpoint\" target=\"_blank\" rel=\"noopener\">koa-await-breakpoint</a>，用于实现在每个 await 执行的语句前后进行自动打点工作。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// On top of the main file</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> koaAwaitBreakpoint = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-await-breakpoint'</span>)(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'api'</span>,</span><br><span class=\"line\">  files: [<span class=\"string\">'./routes/*.js'</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"comment\">// Generally, above other middlewares</span></span><br><span class=\"line\">app.use(koaAwaitBreakpoint)</span><br><span class=\"line\">...</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure></p>\n<p>每个请求到来时，生成一个 requestId 挂载到 ctx 上，通过 requestId 将日志串起来。核心原理是 hack 了模块的 require 方法（重载 Module.prototype._compile），用 esprima 将模块代码转成 AST，找到其中的 awaitExpression 节点，对其用日志函数包裹后重新插入到 AST，最后用 escodegen 将 AST 生成代码。其中还用到了 async_hooks，在日志函数中，基于 async_hooks 的 init 钩子中将异步调用关系存储到一个 Map 中，最终实现函数调用链的自动日志打点。</p>\n<p>不过，使用 async_hooks 在目前有较严重的<a href=\"https://github.com/bmeurer/async-hooks-performance-impact\" target=\"_blank\" rel=\"noopener\">性能损耗</a>。建议生产环境慎用。<br><img src=\"https://raw.githubusercontent.com/bmeurer/async-hooks-performance-impact/master/results-hapi-koa-node-9.4.0.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>错误可分为外部错误和内部错误两类。对外部错误的处理主要考验系统架构的设计，只有系统设计的足够健壮，才能够抵御各种外部挑战，并损失降到最低。对于内部错误，本文分别讨论了同步和异步两种场景，介绍了 <code>Error.captureStackTrace()</code>、<code>async_hooks</code> 等 API 在收集错误堆栈、异步调用链上的用途，并结合 koa-await-breakpoint 源码，解释了 Node.js 自动化打点的核心原理。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25338849\" target=\"_blank\" rel=\"noopener\">深入理解 JavaScript Errors 和 Stack Traces</a></li>\n<li><a href=\"http://blog.shaochuancs.com/about-error-capturestacktrace/\" target=\"_blank\" rel=\"noopener\">关于 Error.captureStackTrace</a></li>\n<li><a href=\"https://www.joyent.com/node-js/production/design/errors\" target=\"_blank\" rel=\"noopener\">Error Handling in Node.js</a></li>\n<li><a href=\"https://jysperm.me/2016/10/nodejs-error-handling/\" target=\"_blank\" rel=\"noopener\">Node.js 错误处理实践</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/53036228\" target=\"_blank\" rel=\"noopener\">学习使用 Node.js 中 async-hooks 模块</a></li>\n<li><a href=\"https://github.com/bmeurer/async-hooks-performance-impact\" target=\"_blank\" rel=\"noopener\">https://github.com/bmeurer/async-hooks-performance-impact</a></li>\n<li><a href=\"http://nodejs.cn/api/errors.html#errors_errors\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/errors.html#errors_errors</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"错误分类\"><a href=\"#错误分类\" class=\"headerlink\" title=\"错误分类\"></a>错误分类</h1><p>软件程序中，<strong>我们可以将错误大致分为外部错误和内部错误两大类</strong>。</p>\n<p>外部错误是正确编写的程序在运行时产生的错误。它并不是程序本身的 Bug，更多是一些外部原因导致的问题，比如请求超时、服务器返回500、内存不足等。</p>\n<p>而内部错误是程序里的 bug。比如传参类型错误、读取 undefined 的一个属性等。这类问题跟你选择的开发语言、开发者的编程经验、系统复杂度等因素息息相关，虽然无法避免，但可以通过修改代码来修复它。</p>\n<p>对应到 Node.js 程序上，一般遇到以下四类错误：</p>\n<ol>\n<li>标准的 JavaScript 错误。例如 SyntaxError、RangeError、ReferenceError、TypeError等。</li>\n<li>由底层操作系触发的系统错误，例如试图打开不存在的文件。</li>\n<li>用户自定义错误。</li>\n<li>断言错误。这类错误通常来自 assert 模块。</li>\n</ol>\n<p>注：本文中不区分错误和异常，都将其统称为错误。</p>\n<h1 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h1><p>当错误发生后，我们需要第一时间去处理它。针对不同类型的错误，有不同的措施。处理错误的总体原则：</p>\n<ol>\n<li>及时止损，防止系统级崩溃。</li>\n<li>详细记录现场，方便分析原因。</li>\n</ol>\n<h2 id=\"外部错误\"><a href=\"#外部错误\" class=\"headerlink\" title=\"外部错误\"></a>外部错误</h2><p>程序运行过程中，可能会遇到各种外部因素导致的问题，这些问题需要具体问题具体分析。我们没办法保证外部服务提供方的稳定性，但是遇到此类问题时，可以做一些事情，来保证我们的程序不至于直接崩溃。</p>\n<p>举个例子，秒杀场景的业务经常会承受非常大的 QPS，在一波瞬间大流量的冲击，后端服务扛不住的话会报 5XX 错误。在后端服务挂掉后，我们可能会去读 redis 等缓存中的数据，用旧数据来兜底。而当 Node.js 应用也挂掉了，还可以在 Nginx 层进行 CDN 降级，给用户输出一个兜底的静态页。</p>\n<p>还有些来自后端服务的错误，只需要进行简单的重试就能解决。如果要重试的话，要确定重试的次数，以及重试的间隔。</p>\n<p>有人建议在发生错误后直接崩溃掉，防止错误扩散。个人认为其实是不合理的，会降低服务的可用性。我们可以在出现一些严重的错误后，先记录下错误，然后重启进程。在 Node.js 中，未捕获的 JavaScript 异常一直冒泡回到事件循环时，会触发 process.uncaughtException 事件。我们可以在事件回调中做错误上报，然后重启 Node.js 进程。这时，还需要借助 Cluster 来启动多个 Node 进程，保证单进程崩溃重启不会影响整体服务的可用性。实际的生产环境中，使用 PM2 来管理 Node.js 进程是一个更好的选项。</p>\n<p>我们永远也无法阻止外部错误，它跟你的业务场景、用户终端等各种不可控的因素相关。但是我们如果做好监控、告警、日志、缓存等工作，可以方便程序员迅速定位/解决问题，从而将损失降至最低。</p>\n<h2 id=\"内部错误\"><a href=\"#内部错误\" class=\"headerlink\" title=\"内部错误\"></a>内部错误</h2><h3 id=\"同步场景\"><a href=\"#同步场景\" class=\"headerlink\" title=\"同步场景\"></a>同步场景</h3><p>对于 JavaScript 错误，我们可以使用 throw 抛出，并用 try catch 来捕获住。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而且对于 throw 抛出的异常必须要 try catch 包裹，否则 Node.js 进程会直接退出。这种写法可以获取到完整的错误调用堆栈。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.js:<span class=\"number\">115</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    ^</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Error</span>: ENOENT: no such file or directory, scandir <span class=\"string\">'/Users/frank/code/work/wxapp/src/componentsa'</span></span><br><span class=\"line\">    at <span class=\"built_in\">Object</span>.readdirSync (fs.js:<span class=\"number\">783</span>:<span class=\"number\">3</span>)</span><br><span class=\"line\">    at getDirFilePaths (<span class=\"regexp\">/Users/</span>frank/code/m/demo/readdir.js:<span class=\"number\">8</span>:<span class=\"number\">22</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Object</span>.&lt;anonymous&gt; (<span class=\"regexp\">/Users/</span>frank/code/m/demo/readdir.js:<span class=\"number\">27</span>:<span class=\"number\">15</span>)</span><br><span class=\"line\">    at Module._compile (internal/modules/cjs/loader.js:<span class=\"number\">688</span>:<span class=\"number\">30</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Object</span>.Module._extensions..js (internal/modules/cjs/loader.js:<span class=\"number\">699</span>:<span class=\"number\">10</span>)</span><br><span class=\"line\">    at Module.load (internal/modules/cjs/loader.js:<span class=\"number\">598</span>:<span class=\"number\">32</span>)</span><br><span class=\"line\">    at tryModuleLoad (internal/modules/cjs/loader.js:<span class=\"number\">537</span>:<span class=\"number\">12</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Function</span>.Module._load (internal/modules/cjs/loader.js:<span class=\"number\">529</span>:<span class=\"number\">3</span>)</span><br><span class=\"line\">    at <span class=\"built_in\">Function</span>.Module.runMain (internal/modules/cjs/loader.js:<span class=\"number\">741</span>:<span class=\"number\">12</span>)</span><br><span class=\"line\">    at startup (internal/bootstrap/node.js:<span class=\"number\">285</span>:<span class=\"number\">19</span>)</span><br></pre></td></tr></table></figure>\n<p>众所周知，JS 函数调用会形成一系列的栈帧，为了尽可能的恢复错误发生现场，最好在错误上报时带上堆栈信息。Node.js 中，<code>Error.captureStackTrace()</code> 方法是 v8 引擎暴露出来的，处理错误堆栈信息的 API。</p>\n<blockquote>\n<p>Error.captureStackTrace(targetObject[, constructorOpt])<br>在 targetObject 中添加一个 .stack 属性。对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息(即：调用栈历史)。</p>\n</blockquote>\n<p>值得注意的是，它的第二个参数可以用来控制栈帧的终点。在一些底层库中，这个参数可以用来向开发者隐藏内部实现细节。</p>\n<p>实际的生产环境中，我们可以使用 <code>nested-error-stacks</code> 这类 npm 包来采集堆栈信息，原理其实也是基于 Error.captureStackTrace()。</p>\n<p>这里有个问题是：<strong>try catch 代码块是同步的，对于异步 API 发生的错误，它不能捕获到</strong>。</p>\n<p>比如下列代码：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'some error...'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>错误并不能被捕获住。这个跟 Node.js 的事件循环机制有关，因为异步任务是通过事件队列来实现的，每次从事件队列中取出一个函数来执行时，实际上这个函数是在调用栈的最顶层执行的，如果它抛出了一个异常，也是无法沿着调用栈回溯到这个异步任务的创建者的。</p>\n<p>下面介绍下在异步流程中，我们应该怎么处理错误。</p>\n<h3 id=\"异步场景\"><a href=\"#异步场景\" class=\"headerlink\" title=\"异步场景\"></a>异步场景</h3><p>Node.js 中常见异步场景包括三类：</p>\n<ul>\n<li>Node.js style callback</li>\n<li>Promise</li>\n<li>EventEmitter</li>\n</ul>\n<p>大部分异步 API 都遵循错误回调优先的约定，将 Error 作为 callback 的第一个参数来传递，这种风格比较类似函数式编程中的 <a href=\"https://en.wikipedia.org/wiki/Continuation-passing_style\" target=\"_blank\" rel=\"noopener\">Continuation-passing style</a>。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.readFile(path, <span class=\"string\">'r'</span>, (err, data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// handle data</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这种写法很容易造成回调地狱。另一方面，对于回调函数中的同步逻辑，我们还需要用 try catch 去单独处理，这导致错误逻辑的处理被分散了两处。Promise 被正式 ES6 标准化后，我们可以用 Promise 的链式调用来处理错误。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>));</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，Promise 链上的错误都会在 catch 方法上捕获住。对于没有 catch 的 Promise 异常，会一直冒泡到顶层，在 <code>process.unhandledRejection</code> 事件上被捕获住。</p>\n<p>还有一类是 EventEmitter 对象上的错误。它们会被分发到 error 事件上进行处理，比如 Stream 等。我们需要去为每一个流去监听 error 事件，否则会冒泡到process.uncaughtException 事件上去。</p>\n<p>异步场景中，还有个问题就是，会丢失异步回调前的错误堆栈。原因还是上文提到的 Node.js 事件循环机制。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some error'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(foo)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Error</span>: some error</span><br><span class=\"line\">    at Timeout.foo [<span class=\"keyword\">as</span> _onTimeout] (<span class=\"regexp\">/Users/</span>frank/code/m/demo/readdir.js:<span class=\"number\">47</span>:<span class=\"number\">9</span>)</span><br><span class=\"line\">    at ontimeout (timers.js:<span class=\"number\">436</span>:<span class=\"number\">11</span>)</span><br><span class=\"line\">    at tryOnTimeout (timers.js:<span class=\"number\">300</span>:<span class=\"number\">5</span>)</span><br><span class=\"line\">    at listOnTimeout (timers.js:<span class=\"number\">263</span>:<span class=\"number\">5</span>)</span><br><span class=\"line\">    at Timer.processTimers (timers.js:<span class=\"number\">223</span>:<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到丢失了 bar 的调用栈。然而在 Node.js 中，异步调用场景还挺多的，有什么办法可以将多个异步调用给串起来，获取到完整的调用链信息呢？答案是有的。Node.js v8+ 上提供了 async_hooks 模块，用来完善异步场景的监控。</p>\n<h3 id=\"async-hooks\"><a href=\"#async-hooks\" class=\"headerlink\" title=\"async_hooks\"></a>async_hooks</h3><p>async_hooks 提供了一些 API 用于跟踪 Node.js 中的异步资源的生命周期。有几个概念：</p>\n<ul>\n<li>每个异步函数的作用域，我们称之为 async scope。</li>\n<li>每一个 async scope 中都有一个 asyncId, 用来标记当前作用域。相同 async scope 的 asyncId 也相同。每个异步资源在创建时 asyncId 全量递增的。</li>\n<li>每一个 async scope 中都有一个 triggerAsyncId 表示当前函数是由哪个 async scope 触发生成的。</li>\n<li>通过 asyncId 和 triggerAsyncId，我们可以获取到异步资源的调用链。</li>\n<li>async_hooks.createHooks 函数可以用来给每个异步资源添加 init/before/after/destory 等生命周期钩子函数。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'global.asyncId:'</span>, async_hooks.executionAsyncId());  <span class=\"comment\">// global.asyncId: 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'global.triggerAsyncId:'</span>, async_hooks.triggerAsyncId()); <span class=\"comment\">// global.triggerAsyncId: 0</span></span><br><span class=\"line\">fs.open(<span class=\"string\">'./app.js'</span>, <span class=\"string\">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fs.open.asyncId:'</span>, async_hooks.executionAsyncId()); <span class=\"comment\">// fs.open.asyncId: 7</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fs.open.triggerAsyncId:'</span>, async_hooks.triggerAsyncId()); <span class=\"comment\">// fs.open.triggerAsyncId: 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>回调函数中的 triggerAsyncId 为 1，它等于 global scope 上的 asyncId。这样就可以拿到多个异步调用的调用链。</p>\n<p>国内的赵坤大神写过一个 koa 日志中间件 <a href=\"https://github.com/nswbmw/koa-await-breakpoint\" target=\"_blank\" rel=\"noopener\">koa-await-breakpoint</a>，用于实现在每个 await 执行的语句前后进行自动打点工作。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// On top of the main file</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> koaAwaitBreakpoint = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-await-breakpoint'</span>)(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'api'</span>,</span><br><span class=\"line\">  files: [<span class=\"string\">'./routes/*.js'</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"comment\">// Generally, above other middlewares</span></span><br><span class=\"line\">app.use(koaAwaitBreakpoint)</span><br><span class=\"line\">...</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure></p>\n<p>每个请求到来时，生成一个 requestId 挂载到 ctx 上，通过 requestId 将日志串起来。核心原理是 hack 了模块的 require 方法（重载 Module.prototype._compile），用 esprima 将模块代码转成 AST，找到其中的 awaitExpression 节点，对其用日志函数包裹后重新插入到 AST，最后用 escodegen 将 AST 生成代码。其中还用到了 async_hooks，在日志函数中，基于 async_hooks 的 init 钩子中将异步调用关系存储到一个 Map 中，最终实现函数调用链的自动日志打点。</p>\n<p>不过，使用 async_hooks 在目前有较严重的<a href=\"https://github.com/bmeurer/async-hooks-performance-impact\" target=\"_blank\" rel=\"noopener\">性能损耗</a>。建议生产环境慎用。<br><img src=\"https://raw.githubusercontent.com/bmeurer/async-hooks-performance-impact/master/results-hapi-koa-node-9.4.0.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>错误可分为外部错误和内部错误两类。对外部错误的处理主要考验系统架构的设计，只有系统设计的足够健壮，才能够抵御各种外部挑战，并损失降到最低。对于内部错误，本文分别讨论了同步和异步两种场景，介绍了 <code>Error.captureStackTrace()</code>、<code>async_hooks</code> 等 API 在收集错误堆栈、异步调用链上的用途，并结合 koa-await-breakpoint 源码，解释了 Node.js 自动化打点的核心原理。</p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25338849\" target=\"_blank\" rel=\"noopener\">深入理解 JavaScript Errors 和 Stack Traces</a></li>\n<li><a href=\"http://blog.shaochuancs.com/about-error-capturestacktrace/\" target=\"_blank\" rel=\"noopener\">关于 Error.captureStackTrace</a></li>\n<li><a href=\"https://www.joyent.com/node-js/production/design/errors\" target=\"_blank\" rel=\"noopener\">Error Handling in Node.js</a></li>\n<li><a href=\"https://jysperm.me/2016/10/nodejs-error-handling/\" target=\"_blank\" rel=\"noopener\">Node.js 错误处理实践</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/53036228\" target=\"_blank\" rel=\"noopener\">学习使用 Node.js 中 async-hooks 模块</a></li>\n<li><a href=\"https://github.com/bmeurer/async-hooks-performance-impact\" target=\"_blank\" rel=\"noopener\">https://github.com/bmeurer/async-hooks-performance-impact</a></li>\n<li><a href=\"http://nodejs.cn/api/errors.html#errors_errors\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/errors.html#errors_errors</a></li>\n</ol>\n"},{"title":"WebP 技术原理及应用","date":"2017-08-04T08:24:00.000Z","_content":"\n# 背景\n浏览器环境下，使用最多的图片格式有 JPEG、PNG、GIF。其中，JPEG 适合色彩复杂的图片，PNG 适合色彩单一或者需要透明的图片，GIF 通常用于动图。现有的图片格式体积较大。\n![图1.1- 微店模板编辑页瀑布图](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/1.png)\n\n从瀑布图可见，图片的加载在整个页面加载时间中占据了很大的比重，个别 JPEG 图片甚至达 200 多 KB，这在移动端环境下非常影响用户体验。\n\n# 介绍\nWebP 是一个现代的图片格式，用于在 web 上提供更好的有损和无损压缩图片。它能够在肉眼观看几乎一样的情况下，对图片体积进行大幅压缩。在将一张 1.3MB 的 JPG 有损压缩为 WebP 后，大小仅为483KB。你能分辨出下面两张图片有什么差别吗？\n![图2.1](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/2.png) ![图2.2](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/3.png)\n我们来测试一下 JPG 和 PNG 转成 WebP 后，实际体积大概减少多少。 \n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/4.png)\n根据测试结果可见，对 PNG 进行 WebP 无损压缩后，体积减少了 31%，这与 Google 宣称的 26% 大体吻合。WebP 有损压缩的减少比例则更大，将图片质量降低到原来的 75% 后，减少体积达 90% 左右。值得注意的是，将 JPG 进行 WebP 无损压缩后，图片大小反而增加了 66%。在实际应用中，推荐使用 WebP 有损压缩。\n\n另外，WebP 支持 alpha 透明和 24bit 颜色数，不存在 PNG8 色彩不够丰富和毛边问题。WebP 也支持真彩动图。因此 WebP 可以替代当前大多数图片格式，包括 JPG、PNG、GIF 等。\n\n# 原理\n下面来分析一下 WebP 有损压缩的编码过程：\n**1. 分块（MacroBlocking）**\n  将图片划分成多个宏块（macro blocks），典型的宏块由一个 16×16 的亮度像素(luma pixel)块和两个 8×8 的色度像素(chroma pixel)块组成。分块越小，预测越准，需要记录的信息也越多。一般来说，细节越丰富的地方，分块越细，即使用 4×4 分块预测。细节相对不丰富的地方使用 16×16 分块。（这一过程相当于 JPEG 编码中的色彩空间转换）\n![图3.1-分块](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/5.png)\n\n**2. 帧内预测**\nWebP 有损压缩使用了帧内预测编码，这一技术也被用于 VP8 视频编码中的关键帧压缩。VP8 有四种常见的帧内预测模型。\n- H_PRED(horizontal prediction)\n像素块中每一行使用其左边一列（col L）的数据填充（如图3.2 Horizontal）\n- V_PRED (vertical prediction)\n像素块中每一列使用其上边一行（row A）的数据填充（如图3.2 Vertical）\n- DC_PRED (DC prediction)\n像素块中每个单元使用 row A 和 col L 的所有像素的平均值填充（如图3.2 Average）\n- TM_PRED (TrueMotion prediction)\n一种我还没搞清楚的预测模式，比较接近真实数据\n  \n下图展示了 4×4 分块的所有帧内预测模型\n![图 3.2 - VP8 帧内预测模型](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/6.png)\n\n使用哪种分块预测模式是动态决定的。编码器会将所有可能的预测模式都计算出来，然后选出错误程度最小的模式。\n\n**3. DCT（离散余弦变换）**\n将预测部分的原图像数据减去预测出来的数据，得到差值矩阵，最后对差值进行 [DCT](https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2)。此步骤会生成一个频率系数矩阵，左上的系数幅度最大，右下最小。幅度值越小，频率越高。大部分图片信息都在左上区域。这一步的作用就是找出图片的高频和低频区域。\n\n**4. 量化**\n人眼对高频部分不敏感，这一步会将高频部分舍去。对上一步的频率系数表和量化表进行计算，将频率系数表和量化表按位相除，并四舍五入位整数。最终生成一个量化矩阵。\n\n**5. 算法编码**\nWebP 使用 [Arithmetic entropy encoding](http://en.wikipedia.org/wiki/Arithmetic_coding)，该算法相比JPEG上使用的 Huffman encoding，在压缩表现上更出色。\n\n![图 3.3 - WebP 无损压缩过程](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/7.png)\n\n\n总结一下，WebP 对图片进行分块，然后对待填充的宏块使用了帧间预测技术，根据其附近已编码宏块的数据，预测出当前块数据。相比 JEPG 对图像原值进行编码，WebP 编码的是预测值和原值的差值，这是 WebP 体积更小的主要原因。最后，WebP 使用了更优秀的算数编码。\n\n# 应用\n![图 4.1 - WebP 兼容性](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/8.png)\nWebP 完全兼容 Android 4.4 及其以上版本，而在另一大移动平台 iOS 上，则是完全不兼容 WebP。因此，我们需要在前端进行平台检测，对于支持 WebP 的平台输出 WebP，在不支持的平台上采用降级方案。\n\n**方案一：**\nJavaScript 判断浏览器是否支持 WebP。\n```js\nfunction check_webp_feature(feature, callback) {\n  var kTestImages = {\n    lossy: 'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA',\n    lossless: 'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',\n    alpha:\n      'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==',\n    animation:\n      'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA'\n  };\n  var img = new Image();\n  img.onload = function() {\n    var result = img.width > 0 && img.height > 0;\n    callback(feature, result);\n  };\n  img.onerror = function() {\n    callback(feature, false);\n  };\n  img.src = 'data:image/webp;base64,' + kTestImages[feature];\n}\n```\n\n如果平台支持 WebP，则在请求头 Accept 中带上 image/webp，这样服务器就会知道浏览器是否支持 WebP。\n\n**方案二：**\nGoogle 开发的 PageSpeed 模块，可以自动将图像转出 WebP 或者其他格式。以 Nginx 为例。\n首先在 http 模块中开启 pagespeed 属性。\n```\npagespeed on;\npagespeed FileCachePath \"/var/cache/ngx_pagespeed/“;\n```\n然后在你的主机配置添加如下一行代码，就能启用这个特性。\n```\npagespeed EnableFilters convert_png_to_jpeg,convert_jpeg_to_webp;\n```\n我们可以看下经过转换后的代码：\n页面原始代码：\n\n![图 4.2 - 原始代码](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/9.png)\n\nChrome 打开后源码如下：\n\n![图 4.3 - Chrome 下的代码](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/10.png)\n\nSafari 打开如下：\n\n![图 4.4 - Safari 下的代码](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/11.png)\n\n# 总结\n显然，WebP 是个好东西，它在肉眼效果几乎一样的情况下，大幅减少了图片体积。本文对 WebP 这种图片格式进行了性能测试分析，并解释了 WebP 有损压缩的实现原理，最后给出了两种应用方案。\n\n---------------------\n参考文献：\n1. https://isux.tencent.com/introduction-of-webp.html\n2. https://developers.google.com/speed/webp/docs/compression#adaptive_block_quantization\n3. https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670\n4. https://modpagespeed.com/doc/configuration\n5. https://juejin.im/entry/5791843bc4c9710054f55751\n6. https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html\n","source":"_posts/WebP技术原理及应用.md","raw":"---\ntitle: WebP 技术原理及应用\ndate: 2017-08-04 16:24:00\ntags:\n- WebP\ncategories:\n- 前端\n---\n\n# 背景\n浏览器环境下，使用最多的图片格式有 JPEG、PNG、GIF。其中，JPEG 适合色彩复杂的图片，PNG 适合色彩单一或者需要透明的图片，GIF 通常用于动图。现有的图片格式体积较大。\n![图1.1- 微店模板编辑页瀑布图](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/1.png)\n\n从瀑布图可见，图片的加载在整个页面加载时间中占据了很大的比重，个别 JPEG 图片甚至达 200 多 KB，这在移动端环境下非常影响用户体验。\n\n# 介绍\nWebP 是一个现代的图片格式，用于在 web 上提供更好的有损和无损压缩图片。它能够在肉眼观看几乎一样的情况下，对图片体积进行大幅压缩。在将一张 1.3MB 的 JPG 有损压缩为 WebP 后，大小仅为483KB。你能分辨出下面两张图片有什么差别吗？\n![图2.1](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/2.png) ![图2.2](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/3.png)\n我们来测试一下 JPG 和 PNG 转成 WebP 后，实际体积大概减少多少。 \n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/4.png)\n根据测试结果可见，对 PNG 进行 WebP 无损压缩后，体积减少了 31%，这与 Google 宣称的 26% 大体吻合。WebP 有损压缩的减少比例则更大，将图片质量降低到原来的 75% 后，减少体积达 90% 左右。值得注意的是，将 JPG 进行 WebP 无损压缩后，图片大小反而增加了 66%。在实际应用中，推荐使用 WebP 有损压缩。\n\n另外，WebP 支持 alpha 透明和 24bit 颜色数，不存在 PNG8 色彩不够丰富和毛边问题。WebP 也支持真彩动图。因此 WebP 可以替代当前大多数图片格式，包括 JPG、PNG、GIF 等。\n\n# 原理\n下面来分析一下 WebP 有损压缩的编码过程：\n**1. 分块（MacroBlocking）**\n  将图片划分成多个宏块（macro blocks），典型的宏块由一个 16×16 的亮度像素(luma pixel)块和两个 8×8 的色度像素(chroma pixel)块组成。分块越小，预测越准，需要记录的信息也越多。一般来说，细节越丰富的地方，分块越细，即使用 4×4 分块预测。细节相对不丰富的地方使用 16×16 分块。（这一过程相当于 JPEG 编码中的色彩空间转换）\n![图3.1-分块](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/5.png)\n\n**2. 帧内预测**\nWebP 有损压缩使用了帧内预测编码，这一技术也被用于 VP8 视频编码中的关键帧压缩。VP8 有四种常见的帧内预测模型。\n- H_PRED(horizontal prediction)\n像素块中每一行使用其左边一列（col L）的数据填充（如图3.2 Horizontal）\n- V_PRED (vertical prediction)\n像素块中每一列使用其上边一行（row A）的数据填充（如图3.2 Vertical）\n- DC_PRED (DC prediction)\n像素块中每个单元使用 row A 和 col L 的所有像素的平均值填充（如图3.2 Average）\n- TM_PRED (TrueMotion prediction)\n一种我还没搞清楚的预测模式，比较接近真实数据\n  \n下图展示了 4×4 分块的所有帧内预测模型\n![图 3.2 - VP8 帧内预测模型](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/6.png)\n\n使用哪种分块预测模式是动态决定的。编码器会将所有可能的预测模式都计算出来，然后选出错误程度最小的模式。\n\n**3. DCT（离散余弦变换）**\n将预测部分的原图像数据减去预测出来的数据，得到差值矩阵，最后对差值进行 [DCT](https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2)。此步骤会生成一个频率系数矩阵，左上的系数幅度最大，右下最小。幅度值越小，频率越高。大部分图片信息都在左上区域。这一步的作用就是找出图片的高频和低频区域。\n\n**4. 量化**\n人眼对高频部分不敏感，这一步会将高频部分舍去。对上一步的频率系数表和量化表进行计算，将频率系数表和量化表按位相除，并四舍五入位整数。最终生成一个量化矩阵。\n\n**5. 算法编码**\nWebP 使用 [Arithmetic entropy encoding](http://en.wikipedia.org/wiki/Arithmetic_coding)，该算法相比JPEG上使用的 Huffman encoding，在压缩表现上更出色。\n\n![图 3.3 - WebP 无损压缩过程](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/7.png)\n\n\n总结一下，WebP 对图片进行分块，然后对待填充的宏块使用了帧间预测技术，根据其附近已编码宏块的数据，预测出当前块数据。相比 JEPG 对图像原值进行编码，WebP 编码的是预测值和原值的差值，这是 WebP 体积更小的主要原因。最后，WebP 使用了更优秀的算数编码。\n\n# 应用\n![图 4.1 - WebP 兼容性](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/8.png)\nWebP 完全兼容 Android 4.4 及其以上版本，而在另一大移动平台 iOS 上，则是完全不兼容 WebP。因此，我们需要在前端进行平台检测，对于支持 WebP 的平台输出 WebP，在不支持的平台上采用降级方案。\n\n**方案一：**\nJavaScript 判断浏览器是否支持 WebP。\n```js\nfunction check_webp_feature(feature, callback) {\n  var kTestImages = {\n    lossy: 'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA',\n    lossless: 'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',\n    alpha:\n      'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==',\n    animation:\n      'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA'\n  };\n  var img = new Image();\n  img.onload = function() {\n    var result = img.width > 0 && img.height > 0;\n    callback(feature, result);\n  };\n  img.onerror = function() {\n    callback(feature, false);\n  };\n  img.src = 'data:image/webp;base64,' + kTestImages[feature];\n}\n```\n\n如果平台支持 WebP，则在请求头 Accept 中带上 image/webp，这样服务器就会知道浏览器是否支持 WebP。\n\n**方案二：**\nGoogle 开发的 PageSpeed 模块，可以自动将图像转出 WebP 或者其他格式。以 Nginx 为例。\n首先在 http 模块中开启 pagespeed 属性。\n```\npagespeed on;\npagespeed FileCachePath \"/var/cache/ngx_pagespeed/“;\n```\n然后在你的主机配置添加如下一行代码，就能启用这个特性。\n```\npagespeed EnableFilters convert_png_to_jpeg,convert_jpeg_to_webp;\n```\n我们可以看下经过转换后的代码：\n页面原始代码：\n\n![图 4.2 - 原始代码](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/9.png)\n\nChrome 打开后源码如下：\n\n![图 4.3 - Chrome 下的代码](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/10.png)\n\nSafari 打开如下：\n\n![图 4.4 - Safari 下的代码](https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/11.png)\n\n# 总结\n显然，WebP 是个好东西，它在肉眼效果几乎一样的情况下，大幅减少了图片体积。本文对 WebP 这种图片格式进行了性能测试分析，并解释了 WebP 有损压缩的实现原理，最后给出了两种应用方案。\n\n---------------------\n参考文献：\n1. https://isux.tencent.com/introduction-of-webp.html\n2. https://developers.google.com/speed/webp/docs/compression#adaptive_block_quantization\n3. https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670\n4. https://modpagespeed.com/doc/configuration\n5. https://juejin.im/entry/5791843bc4c9710054f55751\n6. https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html\n","slug":"WebP技术原理及应用","published":1,"updated":"2019-12-29T11:52:52.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbf005vhns60h1xniv6","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>浏览器环境下，使用最多的图片格式有 JPEG、PNG、GIF。其中，JPEG 适合色彩复杂的图片，PNG 适合色彩单一或者需要透明的图片，GIF 通常用于动图。现有的图片格式体积较大。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/1.png\" alt=\"图1.1- 微店模板编辑页瀑布图\"></p>\n<p>从瀑布图可见，图片的加载在整个页面加载时间中占据了很大的比重，个别 JPEG 图片甚至达 200 多 KB，这在移动端环境下非常影响用户体验。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>WebP 是一个现代的图片格式，用于在 web 上提供更好的有损和无损压缩图片。它能够在肉眼观看几乎一样的情况下，对图片体积进行大幅压缩。在将一张 1.3MB 的 JPG 有损压缩为 WebP 后，大小仅为483KB。你能分辨出下面两张图片有什么差别吗？<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/2.png\" alt=\"图2.1\"> <img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/3.png\" alt=\"图2.2\"><br>我们来测试一下 JPG 和 PNG 转成 WebP 后，实际体积大概减少多少。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/4.png\" alt=\"\"><br>根据测试结果可见，对 PNG 进行 WebP 无损压缩后，体积减少了 31%，这与 Google 宣称的 26% 大体吻合。WebP 有损压缩的减少比例则更大，将图片质量降低到原来的 75% 后，减少体积达 90% 左右。值得注意的是，将 JPG 进行 WebP 无损压缩后，图片大小反而增加了 66%。在实际应用中，推荐使用 WebP 有损压缩。</p>\n<p>另外，WebP 支持 alpha 透明和 24bit 颜色数，不存在 PNG8 色彩不够丰富和毛边问题。WebP 也支持真彩动图。因此 WebP 可以替代当前大多数图片格式，包括 JPG、PNG、GIF 等。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>下面来分析一下 WebP 有损压缩的编码过程：<br><strong>1. 分块（MacroBlocking）</strong><br>  将图片划分成多个宏块（macro blocks），典型的宏块由一个 16×16 的亮度像素(luma pixel)块和两个 8×8 的色度像素(chroma pixel)块组成。分块越小，预测越准，需要记录的信息也越多。一般来说，细节越丰富的地方，分块越细，即使用 4×4 分块预测。细节相对不丰富的地方使用 16×16 分块。（这一过程相当于 JPEG 编码中的色彩空间转换）<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/5.png\" alt=\"图3.1-分块\"></p>\n<p><strong>2. 帧内预测</strong><br>WebP 有损压缩使用了帧内预测编码，这一技术也被用于 VP8 视频编码中的关键帧压缩。VP8 有四种常见的帧内预测模型。</p>\n<ul>\n<li>H_PRED(horizontal prediction)<br>像素块中每一行使用其左边一列（col L）的数据填充（如图3.2 Horizontal）</li>\n<li>V_PRED (vertical prediction)<br>像素块中每一列使用其上边一行（row A）的数据填充（如图3.2 Vertical）</li>\n<li>DC_PRED (DC prediction)<br>像素块中每个单元使用 row A 和 col L 的所有像素的平均值填充（如图3.2 Average）</li>\n<li>TM_PRED (TrueMotion prediction)<br>一种我还没搞清楚的预测模式，比较接近真实数据</li>\n</ul>\n<p>下图展示了 4×4 分块的所有帧内预测模型<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/6.png\" alt=\"图 3.2 - VP8 帧内预测模型\"></p>\n<p>使用哪种分块预测模式是动态决定的。编码器会将所有可能的预测模式都计算出来，然后选出错误程度最小的模式。</p>\n<p><strong>3. DCT（离散余弦变换）</strong><br>将预测部分的原图像数据减去预测出来的数据，得到差值矩阵，最后对差值进行 <a href=\"https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">DCT</a>。此步骤会生成一个频率系数矩阵，左上的系数幅度最大，右下最小。幅度值越小，频率越高。大部分图片信息都在左上区域。这一步的作用就是找出图片的高频和低频区域。</p>\n<p><strong>4. 量化</strong><br>人眼对高频部分不敏感，这一步会将高频部分舍去。对上一步的频率系数表和量化表进行计算，将频率系数表和量化表按位相除，并四舍五入位整数。最终生成一个量化矩阵。</p>\n<p><strong>5. 算法编码</strong><br>WebP 使用 <a href=\"http://en.wikipedia.org/wiki/Arithmetic_coding\" target=\"_blank\" rel=\"noopener\">Arithmetic entropy encoding</a>，该算法相比JPEG上使用的 Huffman encoding，在压缩表现上更出色。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/7.png\" alt=\"图 3.3 - WebP 无损压缩过程\"></p>\n<p>总结一下，WebP 对图片进行分块，然后对待填充的宏块使用了帧间预测技术，根据其附近已编码宏块的数据，预测出当前块数据。相比 JEPG 对图像原值进行编码，WebP 编码的是预测值和原值的差值，这是 WebP 体积更小的主要原因。最后，WebP 使用了更优秀的算数编码。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/8.png\" alt=\"图 4.1 - WebP 兼容性\"><br>WebP 完全兼容 Android 4.4 及其以上版本，而在另一大移动平台 iOS 上，则是完全不兼容 WebP。因此，我们需要在前端进行平台检测，对于支持 WebP 的平台输出 WebP，在不支持的平台上采用降级方案。</p>\n<p><strong>方案一：</strong><br>JavaScript 判断浏览器是否支持 WebP。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check_webp_feature</span>(<span class=\"params\">feature, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> kTestImages = &#123;</span><br><span class=\"line\">    lossy: <span class=\"string\">'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'</span>,</span><br><span class=\"line\">    lossless: <span class=\"string\">'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=='</span>,</span><br><span class=\"line\">    alpha:</span><br><span class=\"line\">      <span class=\"string\">'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=='</span>,</span><br><span class=\"line\">    animation:</span><br><span class=\"line\">      <span class=\"string\">'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">  img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = img.width &gt; <span class=\"number\">0</span> &amp;&amp; img.height &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    callback(feature, result);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  img.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(feature, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  img.src = <span class=\"string\">'data:image/webp;base64,'</span> + kTestImages[feature];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果平台支持 WebP，则在请求头 Accept 中带上 image/webp，这样服务器就会知道浏览器是否支持 WebP。</p>\n<p><strong>方案二：</strong><br>Google 开发的 PageSpeed 模块，可以自动将图像转出 WebP 或者其他格式。以 Nginx 为例。<br>首先在 http 模块中开启 pagespeed 属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pagespeed on;</span><br><span class=\"line\">pagespeed FileCachePath &quot;/var/cache/ngx_pagespeed/“;</span><br></pre></td></tr></table></figure></p>\n<p>然后在你的主机配置添加如下一行代码，就能启用这个特性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pagespeed EnableFilters convert_png_to_jpeg,convert_jpeg_to_webp;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看下经过转换后的代码：<br>页面原始代码：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/9.png\" alt=\"图 4.2 - 原始代码\"></p>\n<p>Chrome 打开后源码如下：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/10.png\" alt=\"图 4.3 - Chrome 下的代码\"></p>\n<p>Safari 打开如下：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/11.png\" alt=\"图 4.4 - Safari 下的代码\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>显然，WebP 是个好东西，它在肉眼效果几乎一样的情况下，大幅减少了图片体积。本文对 WebP 这种图片格式进行了性能测试分析，并解释了 WebP 有损压缩的实现原理，最后给出了两种应用方案。</p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://isux.tencent.com/introduction-of-webp.html\" target=\"_blank\" rel=\"noopener\">https://isux.tencent.com/introduction-of-webp.html</a></li>\n<li><a href=\"https://developers.google.com/speed/webp/docs/compression#adaptive_block_quantization\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/speed/webp/docs/compression#adaptive_block_quantization</a></li>\n<li><a href=\"https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670\" target=\"_blank\" rel=\"noopener\">https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670</a></li>\n<li><a href=\"https://modpagespeed.com/doc/configuration\" target=\"_blank\" rel=\"noopener\">https://modpagespeed.com/doc/configuration</a></li>\n<li><a href=\"https://juejin.im/entry/5791843bc4c9710054f55751\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5791843bc4c9710054f55751</a></li>\n<li><a href=\"https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html\" target=\"_blank\" rel=\"noopener\">https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>浏览器环境下，使用最多的图片格式有 JPEG、PNG、GIF。其中，JPEG 适合色彩复杂的图片，PNG 适合色彩单一或者需要透明的图片，GIF 通常用于动图。现有的图片格式体积较大。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/1.png\" alt=\"图1.1- 微店模板编辑页瀑布图\"></p>\n<p>从瀑布图可见，图片的加载在整个页面加载时间中占据了很大的比重，个别 JPEG 图片甚至达 200 多 KB，这在移动端环境下非常影响用户体验。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>WebP 是一个现代的图片格式，用于在 web 上提供更好的有损和无损压缩图片。它能够在肉眼观看几乎一样的情况下，对图片体积进行大幅压缩。在将一张 1.3MB 的 JPG 有损压缩为 WebP 后，大小仅为483KB。你能分辨出下面两张图片有什么差别吗？<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/2.png\" alt=\"图2.1\"> <img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/3.png\" alt=\"图2.2\"><br>我们来测试一下 JPG 和 PNG 转成 WebP 后，实际体积大概减少多少。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/4.png\" alt=\"\"><br>根据测试结果可见，对 PNG 进行 WebP 无损压缩后，体积减少了 31%，这与 Google 宣称的 26% 大体吻合。WebP 有损压缩的减少比例则更大，将图片质量降低到原来的 75% 后，减少体积达 90% 左右。值得注意的是，将 JPG 进行 WebP 无损压缩后，图片大小反而增加了 66%。在实际应用中，推荐使用 WebP 有损压缩。</p>\n<p>另外，WebP 支持 alpha 透明和 24bit 颜色数，不存在 PNG8 色彩不够丰富和毛边问题。WebP 也支持真彩动图。因此 WebP 可以替代当前大多数图片格式，包括 JPG、PNG、GIF 等。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>下面来分析一下 WebP 有损压缩的编码过程：<br><strong>1. 分块（MacroBlocking）</strong><br>  将图片划分成多个宏块（macro blocks），典型的宏块由一个 16×16 的亮度像素(luma pixel)块和两个 8×8 的色度像素(chroma pixel)块组成。分块越小，预测越准，需要记录的信息也越多。一般来说，细节越丰富的地方，分块越细，即使用 4×4 分块预测。细节相对不丰富的地方使用 16×16 分块。（这一过程相当于 JPEG 编码中的色彩空间转换）<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/5.png\" alt=\"图3.1-分块\"></p>\n<p><strong>2. 帧内预测</strong><br>WebP 有损压缩使用了帧内预测编码，这一技术也被用于 VP8 视频编码中的关键帧压缩。VP8 有四种常见的帧内预测模型。</p>\n<ul>\n<li>H_PRED(horizontal prediction)<br>像素块中每一行使用其左边一列（col L）的数据填充（如图3.2 Horizontal）</li>\n<li>V_PRED (vertical prediction)<br>像素块中每一列使用其上边一行（row A）的数据填充（如图3.2 Vertical）</li>\n<li>DC_PRED (DC prediction)<br>像素块中每个单元使用 row A 和 col L 的所有像素的平均值填充（如图3.2 Average）</li>\n<li>TM_PRED (TrueMotion prediction)<br>一种我还没搞清楚的预测模式，比较接近真实数据</li>\n</ul>\n<p>下图展示了 4×4 分块的所有帧内预测模型<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/6.png\" alt=\"图 3.2 - VP8 帧内预测模型\"></p>\n<p>使用哪种分块预测模式是动态决定的。编码器会将所有可能的预测模式都计算出来，然后选出错误程度最小的模式。</p>\n<p><strong>3. DCT（离散余弦变换）</strong><br>将预测部分的原图像数据减去预测出来的数据，得到差值矩阵，最后对差值进行 <a href=\"https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">DCT</a>。此步骤会生成一个频率系数矩阵，左上的系数幅度最大，右下最小。幅度值越小，频率越高。大部分图片信息都在左上区域。这一步的作用就是找出图片的高频和低频区域。</p>\n<p><strong>4. 量化</strong><br>人眼对高频部分不敏感，这一步会将高频部分舍去。对上一步的频率系数表和量化表进行计算，将频率系数表和量化表按位相除，并四舍五入位整数。最终生成一个量化矩阵。</p>\n<p><strong>5. 算法编码</strong><br>WebP 使用 <a href=\"http://en.wikipedia.org/wiki/Arithmetic_coding\" target=\"_blank\" rel=\"noopener\">Arithmetic entropy encoding</a>，该算法相比JPEG上使用的 Huffman encoding，在压缩表现上更出色。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/7.png\" alt=\"图 3.3 - WebP 无损压缩过程\"></p>\n<p>总结一下，WebP 对图片进行分块，然后对待填充的宏块使用了帧间预测技术，根据其附近已编码宏块的数据，预测出当前块数据。相比 JEPG 对图像原值进行编码，WebP 编码的是预测值和原值的差值，这是 WebP 体积更小的主要原因。最后，WebP 使用了更优秀的算数编码。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/8.png\" alt=\"图 4.1 - WebP 兼容性\"><br>WebP 完全兼容 Android 4.4 及其以上版本，而在另一大移动平台 iOS 上，则是完全不兼容 WebP。因此，我们需要在前端进行平台检测，对于支持 WebP 的平台输出 WebP，在不支持的平台上采用降级方案。</p>\n<p><strong>方案一：</strong><br>JavaScript 判断浏览器是否支持 WebP。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check_webp_feature</span>(<span class=\"params\">feature, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> kTestImages = &#123;</span><br><span class=\"line\">    lossy: <span class=\"string\">'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'</span>,</span><br><span class=\"line\">    lossless: <span class=\"string\">'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=='</span>,</span><br><span class=\"line\">    alpha:</span><br><span class=\"line\">      <span class=\"string\">'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=='</span>,</span><br><span class=\"line\">    animation:</span><br><span class=\"line\">      <span class=\"string\">'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">  img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = img.width &gt; <span class=\"number\">0</span> &amp;&amp; img.height &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    callback(feature, result);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  img.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(feature, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  img.src = <span class=\"string\">'data:image/webp;base64,'</span> + kTestImages[feature];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果平台支持 WebP，则在请求头 Accept 中带上 image/webp，这样服务器就会知道浏览器是否支持 WebP。</p>\n<p><strong>方案二：</strong><br>Google 开发的 PageSpeed 模块，可以自动将图像转出 WebP 或者其他格式。以 Nginx 为例。<br>首先在 http 模块中开启 pagespeed 属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pagespeed on;</span><br><span class=\"line\">pagespeed FileCachePath &quot;/var/cache/ngx_pagespeed/“;</span><br></pre></td></tr></table></figure></p>\n<p>然后在你的主机配置添加如下一行代码，就能启用这个特性。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pagespeed EnableFilters convert_png_to_jpeg,convert_jpeg_to_webp;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看下经过转换后的代码：<br>页面原始代码：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/9.png\" alt=\"图 4.2 - 原始代码\"></p>\n<p>Chrome 打开后源码如下：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/10.png\" alt=\"图 4.3 - Chrome 下的代码\"></p>\n<p>Safari 打开如下：</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/WebP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/11.png\" alt=\"图 4.4 - Safari 下的代码\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>显然，WebP 是个好东西，它在肉眼效果几乎一样的情况下，大幅减少了图片体积。本文对 WebP 这种图片格式进行了性能测试分析，并解释了 WebP 有损压缩的实现原理，最后给出了两种应用方案。</p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://isux.tencent.com/introduction-of-webp.html\" target=\"_blank\" rel=\"noopener\">https://isux.tencent.com/introduction-of-webp.html</a></li>\n<li><a href=\"https://developers.google.com/speed/webp/docs/compression#adaptive_block_quantization\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/speed/webp/docs/compression#adaptive_block_quantization</a></li>\n<li><a href=\"https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670\" target=\"_blank\" rel=\"noopener\">https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670</a></li>\n<li><a href=\"https://modpagespeed.com/doc/configuration\" target=\"_blank\" rel=\"noopener\">https://modpagespeed.com/doc/configuration</a></li>\n<li><a href=\"https://juejin.im/entry/5791843bc4c9710054f55751\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5791843bc4c9710054f55751</a></li>\n<li><a href=\"https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html\" target=\"_blank\" rel=\"noopener\">https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html</a></li>\n</ol>\n"},{"title":"【译】ES2018 新特性：Rest/Spread 特性","date":"2018-07-09T13:10:24.000Z","_content":"\nSebastian Markbåge 提出的 Rest/Spread Properties 提案包括两部分：\n\n* 用于对象解构的 rest 操作符(...)。目前，这个操作符只能在数组解构和参数定义中使用\n* 对象字面量中的 spread 操作符(...)。目前，这个操作符只能用于数组字面量和在函数方法中调用。\n\n## 对象解构中的 rest 操作符(...)\n\n在对象解构模式下，rest 操作符会将解构源的除了已经在对象字面量中指明的属性之外的，所有可枚举自有属性拷贝到它的运算对象中。\n\n```\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst {foo, ...rest} = obj;\n    // Same as:\n    // const foo = 1;\n    // const rest = {bar: 2, baz: 3};\n```\n\n如果你正在使用对象解构来处理命名参数，rest 操作符让你可以收集所有剩余参数：\n\n```\nfunction func({param1, param2, ...rest}) { // rest operator\n    console.log('All parameters: ',{param1, param2, ...rest}); // spread operator\n    return param1 + param2;\n}\n```\n\n#### 语法限制\n\n在每个对象字面量的顶层，可以使用 rest 操作符最多一次，并且必须只能在末尾出现：\n\n```\nconst {...rest, foo} = obj; // SyntaxError\nconst {foo, ...rest1, ...rest2} = obj; // SyntaxError\n```\n\n如果是嵌套结构，你可以多次使用 rest 操作符：\n\n```\nconst obj = {\n    foo: {\n        a: 1,\n        b: 2,\n        c: 3,\n    },\n    bar: 4,\n    baz: 5,\n};\n\nconst {foo: {a, ...rest1}, ...rest2} = obj;\n\n// Same as:\n// const a = 1;\n// const rest1 = {b: 2, c: 3};\n// const rest2 = {bar: 4, baz: 5};\n\n```\n\n## 对象字面量中的 spread 操作符\n\n对象字面量内部，spread 操作符将自身运算对象的所有可枚举的自有属性，插入到通过字面量创建的对象中：\n\n```\n> const obj = {foo: 1, bar: 2, baz: 3};\n> {...obj, qux: 4}\n{ foo: 1, bar: 2, baz: 3, qux: 4 }\n```\n\n要注意的是顺序问题，即使属性 key 并不冲突，因为对象会记录插入顺序：\n\n```\n> {qux: 4, ...obj}\n{ qux: 4, foo: 1, bar: 2, baz: 3 }\n```\n\n如果 key 出现了冲突，后面的会覆盖前面的属性：\n\n```\n> const obj = {foo: 1, bar: 2, baz: 3};\n> {...obj, foo: true}\n{ foo: true, bar: 2, baz: 3 }\n> {foo: true, ...obj}\n{ foo: 1, bar: 2, baz: 3 }\n```\n\n## 对象 spread 操作符的使用场景\n\n这一节，我们会看看 spread 操作符的使用场景。我也会用 Object.assign() 实现一遍，它和 spread 操作符很相似（之后我们会更详细地比较它们）。\n\n#### 拷贝对象\n\n拷贝对象 obj 的可枚举自有属性：\n\n```\nconst clone1 = {...obj};\nconst clone2 = Object.assign({}, obj);\n```\n\nclone 对象们的原型都是 Object.prototype，它是所有通过对象字面量创建的对象的默认原型：\n\n```\n> Object.getPrototypeOf(clone1) === Object.prototype\ntrue\n> Object.getPrototypeOf(clone2) === Object.prototype\ntrue\n> Object.getPrototypeOf({}) === Object.prototype\ntrue\n```\n\n拷贝一个对象 obj，包括它的原型：\n\n```\nconst clone1 = {__proto__: Object.getPrototypeOf(obj), ...obj};\nconst clone2 = Object.assign(\n    Object.create(Object.getPrototypeOf(obj)), obj);\n```\n\n注意，一般来说，对象字面量内部的 __proto__ 只是浏览器内置的特性，并非 JavaScript 引擎所有。\n\n#### 对象的真拷贝\n\n有时候，你需要老老实实地拷贝对象的所有自有属性(properties)和特性(writable, enumerable, …)，包括 getters 和 setters。这时候 Object.assign() 和 spread 操作符就回天乏术了。你需要使用属性描述符([property descriptors](http://speakingjs.com/es5/ch17.html#property_attributes))：\n```\nconst clone1 = Object.defineProperties({},\n    Object.getOwnPropertyDescriptors(obj));\n```\n如果还希望保留 obj 的原型，可以用 [`Object.create()`](http://speakingjs.com/es5/ch17.html#Object.create)：\n```\nconst clone2 = Object.create(\n    Object.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj));\n```\n“探索 ES2016 and ES2017” 里介绍了 [`Object.getOwnPropertyDescriptors()`](http://exploringjs.com/es2016-es2017/ch_object-getownpropertydescriptors.html)\n#### 陷阱：总是浅拷贝\n我们之前见过的所有拷贝对象的方式，都是浅拷贝：如果原始属性值是一个对象，拷贝的对象将指向同一个对象，它不会（递归的、深度的）拷贝自身：\n```\nconst original = { prop: {} };\nconst clone = Object.assign({}, original);\n\nconsole.log(original.prop === clone.prop); // true\noriginal.prop.foo = 'abc';\nconsole.log(clone.prop.foo); // abc\n```\n#### 其他使用场景\n合并 obj1 和 obj2 两个对象：\n```\nconst merged = {...obj1, ...obj2};\nconst merged = Object.assign({}, obj1, obj2);\n```\n给用户数据填充默认值\n```\nconst DEFAULTS = {foo: 'a', bar: 'b'};\nconst userData = {foo: 1};\n\nconst data = {...DEFAULTS, ...userData};\nconst data = Object.assign({}, DEFAULTS, userData);\n    // {foo: 1, bar: 'b'}\n```\n安全地更新属性 foo:\n```\nconst obj = {foo: 'a', bar: 'b'};\nconst obj2 = {...obj, foo: 1};\nconst obj2 = Object.assign({}, obj, {foo: 1});\n    // {foo: 1, bar: 'b'}\n```\n指定属性 foo  和 bar 的默认值：\n```\nconst userData = {foo: 1};\nconst data = {foo: 'a', bar: 'b', ...userData};\nconst data = Object.assign({}, {foo:'a', bar:'b'}, userData);\n    // {foo: 1, bar: 'b'}\n```\n## 展开对象 VS Object.assign()\nspread 操作符和 Object.assign() 很相似。主要的区别在于前者定义了新属性，而后者还进行了赋值。稍后将解释这究竟意味着什么。\n#### Object.assign() 的两种使用方式\nObject.assign() 有两种使用方式：\n第一种，带有破坏性的（修改已有对象）：\n```\nObject.assign(target, source1, source2);\n```\n这里的 target 对象被修改了；source1 和 source2 被拷贝进去了。\n第二种，非破坏性的（已有对象不会被修改）：\n```\nconst result = Object.assign({}, source1, source2);\n```\n新对象是通过将 source1 和 source2 拷贝进一个空对象而生成的。最终，这个新对象被返回并赋值给 result。\nspread 操作符类似于 Object.assign() 的第二种方式。接下来，我们来看看两者的相似和不同之处。\n#### 都是通过 \"get\" 操作符读值\n在写对象之前，两者都使用了 ”get“ 操作符去读取源对象的属性值。这一过程会将 getter 被转换成正常的数据属性。\n来看个例子：\n```\nconst original = {\n    get foo() {\n        return 123;\n    }\n};\n```\noriginal 有一个 foo getter(它的属性描述符有 get 和 set 属性)\n```\n> Object.getOwnPropertyDescriptor(original, 'foo')\n{ get: [Function: foo],\n  set: undefined,\n  enumerable: true,\n  configurable: true }\n```\n但是在它拷贝的结果 clone1 和 clone2 里，foo 是一个正常的数据属性（属性描述符有value 和 writable 属性）：\n```\n> const clone1 = {...original};\n> Object.getOwnPropertyDescriptor(clone1, 'foo')\n{ value: 123,\n  writable: true,\n  enumerable: true,\n  configurable: true }\n\n> const clone2 = Object.assign({}, original);\n> Object.getOwnPropertyDescriptor(clone2, 'foo')\n{ value: 123,\n  writable: true,\n  enumerable: true,\n  configurable: true }\n ```\n#### spread 定义属性，Object.assign() 设置属性\nspread 操作符在目标对象上定义了新的属性，而Object.assign() 使用了一个 \"set\" 操作符来创建属性。这会导致两个结果：\n###### 目标对象带有 setter\n首先，Object.assign() 触发 setter，而 spread 不会：\n```\nObject.defineProperty(Object.prototype, 'foo', {\n    set(value) {\n        console.log('SET', value);\n    },\n});\nconst obj = {foo: 123};\n```\n以上代码段设置了一个 foo setter，它会被所有普通对象继承。\n如果我们通过 Object.assign() 拷贝 obj，继承的 setter  会被触发：\n```\n> Object.assign({}, obj)\nSET 123\n{}\n```\n而 spread 就不会：\n```\n> { ...obj }\n{ foo: 123 }\n```\nObject.assign() 在拷贝时还会触发自有 setter，这里并没有发生重写。\n###### 目标对象带有只读属性\n第二，你可以通过继承只读属性，来阻止 Object.assign() 创建自有属性，但 spread 上这是做不到的：\n```\nObject.defineProperty(Object.prototype, 'bar', {\n    writable: false,\n    value: 'abc',\n});\n```\n以上代码设置了只读属性 bar，它会被所有普通对象继承。\n这样，你就再也不能使用赋值语句去创建自有属性 bar（严格模式下会抛一个异常，宽松模式会静默失败）：\n```\n> const tmp = {};\n> tmp.bar = 123;\nTypeError: Cannot assign to read only property 'bar'\n```\n下列代码，我们使用对象字面量成功地创建了属性 bar。因为对象字面量没有设置属性，它只是定义了它们：\n```\nconst obj = {bar: 123};\n```\n然而，Object.assign() 使用赋值语句创建属性，这就是不能拷贝 obj 的原因：\n```\n> Object.assign({}, obj)\nTypeError: Cannot assign to read only property 'bar'\n```\n通过 spread 操作符拷贝没有问题：\n```\n> { ...obj }\n{ bar: 123 }\n```\n#### spread 和 Object.assign() 都只拷贝自有可枚举属性\n它们都会忽略所有继承的属性和不可枚举的自有属性。\n对象 obj 从 proto 继承了一个可枚举属性，并且有两个自有属性：\n```\nconst proto = {\n    inheritedEnumerable: 1,\n};\nconst obj = Object.create(proto, {\n    ownEnumerable: {\n        value: 2,\n        enumerable: true,\n    },\n    ownNonEnumerable: {\n        value: 3,\n        enumerable: false,\n    },\n});\n```\n如果拷贝 obj，结果将只有属性 ownEnumerable。属性 inheritedEnumerable 和 ownNonEnumerable 没有被拷贝：\n```\n> {...obj}\n{ ownEnumerable: 2 }\n> Object.assign({}, obj)\n{ ownEnumerable: 2 }\n```\n\n\n\n-----------\n原文：http://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html\n","source":"_posts/【译】ES2018新特性：Rest-Spread-特性.md","raw":"---\ntitle: 【译】ES2018 新特性：Rest/Spread 特性\ndate: 2018-07-09 21:10:24\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n\nSebastian Markbåge 提出的 Rest/Spread Properties 提案包括两部分：\n\n* 用于对象解构的 rest 操作符(...)。目前，这个操作符只能在数组解构和参数定义中使用\n* 对象字面量中的 spread 操作符(...)。目前，这个操作符只能用于数组字面量和在函数方法中调用。\n\n## 对象解构中的 rest 操作符(...)\n\n在对象解构模式下，rest 操作符会将解构源的除了已经在对象字面量中指明的属性之外的，所有可枚举自有属性拷贝到它的运算对象中。\n\n```\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst {foo, ...rest} = obj;\n    // Same as:\n    // const foo = 1;\n    // const rest = {bar: 2, baz: 3};\n```\n\n如果你正在使用对象解构来处理命名参数，rest 操作符让你可以收集所有剩余参数：\n\n```\nfunction func({param1, param2, ...rest}) { // rest operator\n    console.log('All parameters: ',{param1, param2, ...rest}); // spread operator\n    return param1 + param2;\n}\n```\n\n#### 语法限制\n\n在每个对象字面量的顶层，可以使用 rest 操作符最多一次，并且必须只能在末尾出现：\n\n```\nconst {...rest, foo} = obj; // SyntaxError\nconst {foo, ...rest1, ...rest2} = obj; // SyntaxError\n```\n\n如果是嵌套结构，你可以多次使用 rest 操作符：\n\n```\nconst obj = {\n    foo: {\n        a: 1,\n        b: 2,\n        c: 3,\n    },\n    bar: 4,\n    baz: 5,\n};\n\nconst {foo: {a, ...rest1}, ...rest2} = obj;\n\n// Same as:\n// const a = 1;\n// const rest1 = {b: 2, c: 3};\n// const rest2 = {bar: 4, baz: 5};\n\n```\n\n## 对象字面量中的 spread 操作符\n\n对象字面量内部，spread 操作符将自身运算对象的所有可枚举的自有属性，插入到通过字面量创建的对象中：\n\n```\n> const obj = {foo: 1, bar: 2, baz: 3};\n> {...obj, qux: 4}\n{ foo: 1, bar: 2, baz: 3, qux: 4 }\n```\n\n要注意的是顺序问题，即使属性 key 并不冲突，因为对象会记录插入顺序：\n\n```\n> {qux: 4, ...obj}\n{ qux: 4, foo: 1, bar: 2, baz: 3 }\n```\n\n如果 key 出现了冲突，后面的会覆盖前面的属性：\n\n```\n> const obj = {foo: 1, bar: 2, baz: 3};\n> {...obj, foo: true}\n{ foo: true, bar: 2, baz: 3 }\n> {foo: true, ...obj}\n{ foo: 1, bar: 2, baz: 3 }\n```\n\n## 对象 spread 操作符的使用场景\n\n这一节，我们会看看 spread 操作符的使用场景。我也会用 Object.assign() 实现一遍，它和 spread 操作符很相似（之后我们会更详细地比较它们）。\n\n#### 拷贝对象\n\n拷贝对象 obj 的可枚举自有属性：\n\n```\nconst clone1 = {...obj};\nconst clone2 = Object.assign({}, obj);\n```\n\nclone 对象们的原型都是 Object.prototype，它是所有通过对象字面量创建的对象的默认原型：\n\n```\n> Object.getPrototypeOf(clone1) === Object.prototype\ntrue\n> Object.getPrototypeOf(clone2) === Object.prototype\ntrue\n> Object.getPrototypeOf({}) === Object.prototype\ntrue\n```\n\n拷贝一个对象 obj，包括它的原型：\n\n```\nconst clone1 = {__proto__: Object.getPrototypeOf(obj), ...obj};\nconst clone2 = Object.assign(\n    Object.create(Object.getPrototypeOf(obj)), obj);\n```\n\n注意，一般来说，对象字面量内部的 __proto__ 只是浏览器内置的特性，并非 JavaScript 引擎所有。\n\n#### 对象的真拷贝\n\n有时候，你需要老老实实地拷贝对象的所有自有属性(properties)和特性(writable, enumerable, …)，包括 getters 和 setters。这时候 Object.assign() 和 spread 操作符就回天乏术了。你需要使用属性描述符([property descriptors](http://speakingjs.com/es5/ch17.html#property_attributes))：\n```\nconst clone1 = Object.defineProperties({},\n    Object.getOwnPropertyDescriptors(obj));\n```\n如果还希望保留 obj 的原型，可以用 [`Object.create()`](http://speakingjs.com/es5/ch17.html#Object.create)：\n```\nconst clone2 = Object.create(\n    Object.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj));\n```\n“探索 ES2016 and ES2017” 里介绍了 [`Object.getOwnPropertyDescriptors()`](http://exploringjs.com/es2016-es2017/ch_object-getownpropertydescriptors.html)\n#### 陷阱：总是浅拷贝\n我们之前见过的所有拷贝对象的方式，都是浅拷贝：如果原始属性值是一个对象，拷贝的对象将指向同一个对象，它不会（递归的、深度的）拷贝自身：\n```\nconst original = { prop: {} };\nconst clone = Object.assign({}, original);\n\nconsole.log(original.prop === clone.prop); // true\noriginal.prop.foo = 'abc';\nconsole.log(clone.prop.foo); // abc\n```\n#### 其他使用场景\n合并 obj1 和 obj2 两个对象：\n```\nconst merged = {...obj1, ...obj2};\nconst merged = Object.assign({}, obj1, obj2);\n```\n给用户数据填充默认值\n```\nconst DEFAULTS = {foo: 'a', bar: 'b'};\nconst userData = {foo: 1};\n\nconst data = {...DEFAULTS, ...userData};\nconst data = Object.assign({}, DEFAULTS, userData);\n    // {foo: 1, bar: 'b'}\n```\n安全地更新属性 foo:\n```\nconst obj = {foo: 'a', bar: 'b'};\nconst obj2 = {...obj, foo: 1};\nconst obj2 = Object.assign({}, obj, {foo: 1});\n    // {foo: 1, bar: 'b'}\n```\n指定属性 foo  和 bar 的默认值：\n```\nconst userData = {foo: 1};\nconst data = {foo: 'a', bar: 'b', ...userData};\nconst data = Object.assign({}, {foo:'a', bar:'b'}, userData);\n    // {foo: 1, bar: 'b'}\n```\n## 展开对象 VS Object.assign()\nspread 操作符和 Object.assign() 很相似。主要的区别在于前者定义了新属性，而后者还进行了赋值。稍后将解释这究竟意味着什么。\n#### Object.assign() 的两种使用方式\nObject.assign() 有两种使用方式：\n第一种，带有破坏性的（修改已有对象）：\n```\nObject.assign(target, source1, source2);\n```\n这里的 target 对象被修改了；source1 和 source2 被拷贝进去了。\n第二种，非破坏性的（已有对象不会被修改）：\n```\nconst result = Object.assign({}, source1, source2);\n```\n新对象是通过将 source1 和 source2 拷贝进一个空对象而生成的。最终，这个新对象被返回并赋值给 result。\nspread 操作符类似于 Object.assign() 的第二种方式。接下来，我们来看看两者的相似和不同之处。\n#### 都是通过 \"get\" 操作符读值\n在写对象之前，两者都使用了 ”get“ 操作符去读取源对象的属性值。这一过程会将 getter 被转换成正常的数据属性。\n来看个例子：\n```\nconst original = {\n    get foo() {\n        return 123;\n    }\n};\n```\noriginal 有一个 foo getter(它的属性描述符有 get 和 set 属性)\n```\n> Object.getOwnPropertyDescriptor(original, 'foo')\n{ get: [Function: foo],\n  set: undefined,\n  enumerable: true,\n  configurable: true }\n```\n但是在它拷贝的结果 clone1 和 clone2 里，foo 是一个正常的数据属性（属性描述符有value 和 writable 属性）：\n```\n> const clone1 = {...original};\n> Object.getOwnPropertyDescriptor(clone1, 'foo')\n{ value: 123,\n  writable: true,\n  enumerable: true,\n  configurable: true }\n\n> const clone2 = Object.assign({}, original);\n> Object.getOwnPropertyDescriptor(clone2, 'foo')\n{ value: 123,\n  writable: true,\n  enumerable: true,\n  configurable: true }\n ```\n#### spread 定义属性，Object.assign() 设置属性\nspread 操作符在目标对象上定义了新的属性，而Object.assign() 使用了一个 \"set\" 操作符来创建属性。这会导致两个结果：\n###### 目标对象带有 setter\n首先，Object.assign() 触发 setter，而 spread 不会：\n```\nObject.defineProperty(Object.prototype, 'foo', {\n    set(value) {\n        console.log('SET', value);\n    },\n});\nconst obj = {foo: 123};\n```\n以上代码段设置了一个 foo setter，它会被所有普通对象继承。\n如果我们通过 Object.assign() 拷贝 obj，继承的 setter  会被触发：\n```\n> Object.assign({}, obj)\nSET 123\n{}\n```\n而 spread 就不会：\n```\n> { ...obj }\n{ foo: 123 }\n```\nObject.assign() 在拷贝时还会触发自有 setter，这里并没有发生重写。\n###### 目标对象带有只读属性\n第二，你可以通过继承只读属性，来阻止 Object.assign() 创建自有属性，但 spread 上这是做不到的：\n```\nObject.defineProperty(Object.prototype, 'bar', {\n    writable: false,\n    value: 'abc',\n});\n```\n以上代码设置了只读属性 bar，它会被所有普通对象继承。\n这样，你就再也不能使用赋值语句去创建自有属性 bar（严格模式下会抛一个异常，宽松模式会静默失败）：\n```\n> const tmp = {};\n> tmp.bar = 123;\nTypeError: Cannot assign to read only property 'bar'\n```\n下列代码，我们使用对象字面量成功地创建了属性 bar。因为对象字面量没有设置属性，它只是定义了它们：\n```\nconst obj = {bar: 123};\n```\n然而，Object.assign() 使用赋值语句创建属性，这就是不能拷贝 obj 的原因：\n```\n> Object.assign({}, obj)\nTypeError: Cannot assign to read only property 'bar'\n```\n通过 spread 操作符拷贝没有问题：\n```\n> { ...obj }\n{ bar: 123 }\n```\n#### spread 和 Object.assign() 都只拷贝自有可枚举属性\n它们都会忽略所有继承的属性和不可枚举的自有属性。\n对象 obj 从 proto 继承了一个可枚举属性，并且有两个自有属性：\n```\nconst proto = {\n    inheritedEnumerable: 1,\n};\nconst obj = Object.create(proto, {\n    ownEnumerable: {\n        value: 2,\n        enumerable: true,\n    },\n    ownNonEnumerable: {\n        value: 3,\n        enumerable: false,\n    },\n});\n```\n如果拷贝 obj，结果将只有属性 ownEnumerable。属性 inheritedEnumerable 和 ownNonEnumerable 没有被拷贝：\n```\n> {...obj}\n{ ownEnumerable: 2 }\n> Object.assign({}, obj)\n{ ownEnumerable: 2 }\n```\n\n\n\n-----------\n原文：http://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html\n","slug":"【译】ES2018新特性：Rest-Spread-特性","published":1,"updated":"2019-06-16T14:11:37.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbg005xhns6552vd1o7","content":"<p>Sebastian Markbåge 提出的 Rest/Spread Properties 提案包括两部分：</p>\n<ul>\n<li>用于对象解构的 rest 操作符(…)。目前，这个操作符只能在数组解构和参数定义中使用</li>\n<li>对象字面量中的 spread 操作符(…)。目前，这个操作符只能用于数组字面量和在函数方法中调用。</li>\n</ul>\n<h2 id=\"对象解构中的-rest-操作符-…\"><a href=\"#对象解构中的-rest-操作符-…\" class=\"headerlink\" title=\"对象解构中的 rest 操作符(…)\"></a>对象解构中的 rest 操作符(…)</h2><p>在对象解构模式下，rest 操作符会将解构源的除了已经在对象字面量中指明的属性之外的，所有可枚举自有属性拷贝到它的运算对象中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;foo: 1, bar: 2, baz: 3&#125;;</span><br><span class=\"line\">const &#123;foo, ...rest&#125; = obj;</span><br><span class=\"line\">    // Same as:</span><br><span class=\"line\">    // const foo = 1;</span><br><span class=\"line\">    // const rest = &#123;bar: 2, baz: 3&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果你正在使用对象解构来处理命名参数，rest 操作符让你可以收集所有剩余参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function func(&#123;param1, param2, ...rest&#125;) &#123; // rest operator</span><br><span class=\"line\">    console.log(&apos;All parameters: &apos;,&#123;param1, param2, ...rest&#125;); // spread operator</span><br><span class=\"line\">    return param1 + param2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"语法限制\"><a href=\"#语法限制\" class=\"headerlink\" title=\"语法限制\"></a>语法限制</h4><p>在每个对象字面量的顶层，可以使用 rest 操作符最多一次，并且必须只能在末尾出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;...rest, foo&#125; = obj; // SyntaxError</span><br><span class=\"line\">const &#123;foo, ...rest1, ...rest2&#125; = obj; // SyntaxError</span><br></pre></td></tr></table></figure>\n<p>如果是嵌套结构，你可以多次使用 rest 操作符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    foo: &#123;</span><br><span class=\"line\">        a: 1,</span><br><span class=\"line\">        b: 2,</span><br><span class=\"line\">        c: 3,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bar: 4,</span><br><span class=\"line\">    baz: 5,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123;foo: &#123;a, ...rest1&#125;, ...rest2&#125; = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// Same as:</span><br><span class=\"line\">// const a = 1;</span><br><span class=\"line\">// const rest1 = &#123;b: 2, c: 3&#125;;</span><br><span class=\"line\">// const rest2 = &#123;bar: 4, baz: 5&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象字面量中的-spread-操作符\"><a href=\"#对象字面量中的-spread-操作符\" class=\"headerlink\" title=\"对象字面量中的 spread 操作符\"></a>对象字面量中的 spread 操作符</h2><p>对象字面量内部，spread 操作符将自身运算对象的所有可枚举的自有属性，插入到通过字面量创建的对象中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const obj = &#123;foo: 1, bar: 2, baz: 3&#125;;</span><br><span class=\"line\">&gt; &#123;...obj, qux: 4&#125;</span><br><span class=\"line\">&#123; foo: 1, bar: 2, baz: 3, qux: 4 &#125;</span><br></pre></td></tr></table></figure>\n<p>要注意的是顺序问题，即使属性 key 并不冲突，因为对象会记录插入顺序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123;qux: 4, ...obj&#125;</span><br><span class=\"line\">&#123; qux: 4, foo: 1, bar: 2, baz: 3 &#125;</span><br></pre></td></tr></table></figure>\n<p>如果 key 出现了冲突，后面的会覆盖前面的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const obj = &#123;foo: 1, bar: 2, baz: 3&#125;;</span><br><span class=\"line\">&gt; &#123;...obj, foo: true&#125;</span><br><span class=\"line\">&#123; foo: true, bar: 2, baz: 3 &#125;</span><br><span class=\"line\">&gt; &#123;foo: true, ...obj&#125;</span><br><span class=\"line\">&#123; foo: 1, bar: 2, baz: 3 &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象-spread-操作符的使用场景\"><a href=\"#对象-spread-操作符的使用场景\" class=\"headerlink\" title=\"对象 spread 操作符的使用场景\"></a>对象 spread 操作符的使用场景</h2><p>这一节，我们会看看 spread 操作符的使用场景。我也会用 Object.assign() 实现一遍，它和 spread 操作符很相似（之后我们会更详细地比较它们）。</p>\n<h4 id=\"拷贝对象\"><a href=\"#拷贝对象\" class=\"headerlink\" title=\"拷贝对象\"></a>拷贝对象</h4><p>拷贝对象 obj 的可枚举自有属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone1 = &#123;...obj&#125;;</span><br><span class=\"line\">const clone2 = Object.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure>\n<p>clone 对象们的原型都是 Object.prototype，它是所有通过对象字面量创建的对象的默认原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.getPrototypeOf(clone1) === Object.prototype</span><br><span class=\"line\">true</span><br><span class=\"line\">&gt; Object.getPrototypeOf(clone2) === Object.prototype</span><br><span class=\"line\">true</span><br><span class=\"line\">&gt; Object.getPrototypeOf(&#123;&#125;) === Object.prototype</span><br><span class=\"line\">true</span><br></pre></td></tr></table></figure>\n<p>拷贝一个对象 obj，包括它的原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone1 = &#123;__proto__: Object.getPrototypeOf(obj), ...obj&#125;;</span><br><span class=\"line\">const clone2 = Object.assign(</span><br><span class=\"line\">    Object.create(Object.getPrototypeOf(obj)), obj);</span><br></pre></td></tr></table></figure>\n<p>注意，一般来说，对象字面量内部的 <strong>proto</strong> 只是浏览器内置的特性，并非 JavaScript 引擎所有。</p>\n<h4 id=\"对象的真拷贝\"><a href=\"#对象的真拷贝\" class=\"headerlink\" title=\"对象的真拷贝\"></a>对象的真拷贝</h4><p>有时候，你需要老老实实地拷贝对象的所有自有属性(properties)和特性(writable, enumerable, …)，包括 getters 和 setters。这时候 Object.assign() 和 spread 操作符就回天乏术了。你需要使用属性描述符(<a href=\"http://speakingjs.com/es5/ch17.html#property_attributes\" target=\"_blank\" rel=\"noopener\">property descriptors</a>)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone1 = Object.defineProperties(&#123;&#125;,</span><br><span class=\"line\">    Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure></p>\n<p>如果还希望保留 obj 的原型，可以用 <a href=\"http://speakingjs.com/es5/ch17.html#Object.create\" target=\"_blank\" rel=\"noopener\"><code>Object.create()</code></a>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone2 = Object.create(</span><br><span class=\"line\">    Object.getPrototypeOf(obj),</span><br><span class=\"line\">    Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure></p>\n<p>“探索 ES2016 and ES2017” 里介绍了 <a href=\"http://exploringjs.com/es2016-es2017/ch_object-getownpropertydescriptors.html\" target=\"_blank\" rel=\"noopener\"><code>Object.getOwnPropertyDescriptors()</code></a></p>\n<h4 id=\"陷阱：总是浅拷贝\"><a href=\"#陷阱：总是浅拷贝\" class=\"headerlink\" title=\"陷阱：总是浅拷贝\"></a>陷阱：总是浅拷贝</h4><p>我们之前见过的所有拷贝对象的方式，都是浅拷贝：如果原始属性值是一个对象，拷贝的对象将指向同一个对象，它不会（递归的、深度的）拷贝自身：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const original = &#123; prop: &#123;&#125; &#125;;</span><br><span class=\"line\">const clone = Object.assign(&#123;&#125;, original);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(original.prop === clone.prop); // true</span><br><span class=\"line\">original.prop.foo = &apos;abc&apos;;</span><br><span class=\"line\">console.log(clone.prop.foo); // abc</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他使用场景\"><a href=\"#其他使用场景\" class=\"headerlink\" title=\"其他使用场景\"></a>其他使用场景</h4><p>合并 obj1 和 obj2 两个对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const merged = &#123;...obj1, ...obj2&#125;;</span><br><span class=\"line\">const merged = Object.assign(&#123;&#125;, obj1, obj2);</span><br></pre></td></tr></table></figure></p>\n<p>给用户数据填充默认值<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DEFAULTS = &#123;foo: &apos;a&apos;, bar: &apos;b&apos;&#125;;</span><br><span class=\"line\">const userData = &#123;foo: 1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const data = &#123;...DEFAULTS, ...userData&#125;;</span><br><span class=\"line\">const data = Object.assign(&#123;&#125;, DEFAULTS, userData);</span><br><span class=\"line\">    // &#123;foo: 1, bar: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>安全地更新属性 foo:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;foo: &apos;a&apos;, bar: &apos;b&apos;&#125;;</span><br><span class=\"line\">const obj2 = &#123;...obj, foo: 1&#125;;</span><br><span class=\"line\">const obj2 = Object.assign(&#123;&#125;, obj, &#123;foo: 1&#125;);</span><br><span class=\"line\">    // &#123;foo: 1, bar: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>指定属性 foo  和 bar 的默认值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const userData = &#123;foo: 1&#125;;</span><br><span class=\"line\">const data = &#123;foo: &apos;a&apos;, bar: &apos;b&apos;, ...userData&#125;;</span><br><span class=\"line\">const data = Object.assign(&#123;&#125;, &#123;foo:&apos;a&apos;, bar:&apos;b&apos;&#125;, userData);</span><br><span class=\"line\">    // &#123;foo: 1, bar: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"展开对象-VS-Object-assign\"><a href=\"#展开对象-VS-Object-assign\" class=\"headerlink\" title=\"展开对象 VS Object.assign()\"></a>展开对象 VS Object.assign()</h2><p>spread 操作符和 Object.assign() 很相似。主要的区别在于前者定义了新属性，而后者还进行了赋值。稍后将解释这究竟意味着什么。</p>\n<h4 id=\"Object-assign-的两种使用方式\"><a href=\"#Object-assign-的两种使用方式\" class=\"headerlink\" title=\"Object.assign() 的两种使用方式\"></a>Object.assign() 的两种使用方式</h4><p>Object.assign() 有两种使用方式：<br>第一种，带有破坏性的（修改已有对象）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.assign(target, source1, source2);</span><br></pre></td></tr></table></figure></p>\n<p>这里的 target 对象被修改了；source1 和 source2 被拷贝进去了。<br>第二种，非破坏性的（已有对象不会被修改）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const result = Object.assign(&#123;&#125;, source1, source2);</span><br></pre></td></tr></table></figure></p>\n<p>新对象是通过将 source1 和 source2 拷贝进一个空对象而生成的。最终，这个新对象被返回并赋值给 result。<br>spread 操作符类似于 Object.assign() 的第二种方式。接下来，我们来看看两者的相似和不同之处。</p>\n<h4 id=\"都是通过-“get”-操作符读值\"><a href=\"#都是通过-“get”-操作符读值\" class=\"headerlink\" title=\"都是通过 “get” 操作符读值\"></a>都是通过 “get” 操作符读值</h4><p>在写对象之前，两者都使用了 ”get“ 操作符去读取源对象的属性值。这一过程会将 getter 被转换成正常的数据属性。<br>来看个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const original = &#123;</span><br><span class=\"line\">    get foo() &#123;</span><br><span class=\"line\">        return 123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>original 有一个 foo getter(它的属性描述符有 get 和 set 属性)<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.getOwnPropertyDescriptor(original, &apos;foo&apos;)</span><br><span class=\"line\">&#123; get: [Function: foo],</span><br><span class=\"line\">  set: undefined,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true &#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是在它拷贝的结果 clone1 和 clone2 里，foo 是一个正常的数据属性（属性描述符有value 和 writable 属性）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const clone1 = &#123;...original&#125;;</span><br><span class=\"line\">&gt; Object.getOwnPropertyDescriptor(clone1, &apos;foo&apos;)</span><br><span class=\"line\">&#123; value: 123,</span><br><span class=\"line\">  writable: true,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; const clone2 = Object.assign(&#123;&#125;, original);</span><br><span class=\"line\">&gt; Object.getOwnPropertyDescriptor(clone2, &apos;foo&apos;)</span><br><span class=\"line\">&#123; value: 123,</span><br><span class=\"line\">  writable: true,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"spread-定义属性，Object-assign-设置属性\"><a href=\"#spread-定义属性，Object-assign-设置属性\" class=\"headerlink\" title=\"spread 定义属性，Object.assign() 设置属性\"></a>spread 定义属性，Object.assign() 设置属性</h4><p>spread 操作符在目标对象上定义了新的属性，而Object.assign() 使用了一个 “set” 操作符来创建属性。这会导致两个结果：</p>\n<h6 id=\"目标对象带有-setter\"><a href=\"#目标对象带有-setter\" class=\"headerlink\" title=\"目标对象带有 setter\"></a>目标对象带有 setter</h6><p>首先，Object.assign() 触发 setter，而 spread 不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Object.prototype, &apos;foo&apos;, &#123;</span><br><span class=\"line\">    set(value) &#123;</span><br><span class=\"line\">        console.log(&apos;SET&apos;, value);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const obj = &#123;foo: 123&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码段设置了一个 foo setter，它会被所有普通对象继承。<br>如果我们通过 Object.assign() 拷贝 obj，继承的 setter  会被触发：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.assign(&#123;&#125;, obj)</span><br><span class=\"line\">SET 123</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而 spread 就不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123; ...obj &#125;</span><br><span class=\"line\">&#123; foo: 123 &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Object.assign() 在拷贝时还会触发自有 setter，这里并没有发生重写。</p>\n<h6 id=\"目标对象带有只读属性\"><a href=\"#目标对象带有只读属性\" class=\"headerlink\" title=\"目标对象带有只读属性\"></a>目标对象带有只读属性</h6><p>第二，你可以通过继承只读属性，来阻止 Object.assign() 创建自有属性，但 spread 上这是做不到的：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Object.prototype, &apos;bar&apos;, &#123;</span><br><span class=\"line\">    writable: false,</span><br><span class=\"line\">    value: &apos;abc&apos;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>以上代码设置了只读属性 bar，它会被所有普通对象继承。<br>这样，你就再也不能使用赋值语句去创建自有属性 bar（严格模式下会抛一个异常，宽松模式会静默失败）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const tmp = &#123;&#125;;</span><br><span class=\"line\">&gt; tmp.bar = 123;</span><br><span class=\"line\">TypeError: Cannot assign to read only property &apos;bar&apos;</span><br></pre></td></tr></table></figure></p>\n<p>下列代码，我们使用对象字面量成功地创建了属性 bar。因为对象字面量没有设置属性，它只是定义了它们：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;bar: 123&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>然而，Object.assign() 使用赋值语句创建属性，这就是不能拷贝 obj 的原因：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.assign(&#123;&#125;, obj)</span><br><span class=\"line\">TypeError: Cannot assign to read only property &apos;bar&apos;</span><br></pre></td></tr></table></figure></p>\n<p>通过 spread 操作符拷贝没有问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123; ...obj &#125;</span><br><span class=\"line\">&#123; bar: 123 &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"spread-和-Object-assign-都只拷贝自有可枚举属性\"><a href=\"#spread-和-Object-assign-都只拷贝自有可枚举属性\" class=\"headerlink\" title=\"spread 和 Object.assign() 都只拷贝自有可枚举属性\"></a>spread 和 Object.assign() 都只拷贝自有可枚举属性</h4><p>它们都会忽略所有继承的属性和不可枚举的自有属性。<br>对象 obj 从 proto 继承了一个可枚举属性，并且有两个自有属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const proto = &#123;</span><br><span class=\"line\">    inheritedEnumerable: 1,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const obj = Object.create(proto, &#123;</span><br><span class=\"line\">    ownEnumerable: &#123;</span><br><span class=\"line\">        value: 2,</span><br><span class=\"line\">        enumerable: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ownNonEnumerable: &#123;</span><br><span class=\"line\">        value: 3,</span><br><span class=\"line\">        enumerable: false,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果拷贝 obj，结果将只有属性 ownEnumerable。属性 inheritedEnumerable 和 ownNonEnumerable 没有被拷贝：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123;...obj&#125;</span><br><span class=\"line\">&#123; ownEnumerable: 2 &#125;</span><br><span class=\"line\">&gt; Object.assign(&#123;&#125;, obj)</span><br><span class=\"line\">&#123; ownEnumerable: 2 &#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>原文：<a href=\"http://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html\" target=\"_blank\" rel=\"noopener\">http://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Sebastian Markbåge 提出的 Rest/Spread Properties 提案包括两部分：</p>\n<ul>\n<li>用于对象解构的 rest 操作符(…)。目前，这个操作符只能在数组解构和参数定义中使用</li>\n<li>对象字面量中的 spread 操作符(…)。目前，这个操作符只能用于数组字面量和在函数方法中调用。</li>\n</ul>\n<h2 id=\"对象解构中的-rest-操作符-…\"><a href=\"#对象解构中的-rest-操作符-…\" class=\"headerlink\" title=\"对象解构中的 rest 操作符(…)\"></a>对象解构中的 rest 操作符(…)</h2><p>在对象解构模式下，rest 操作符会将解构源的除了已经在对象字面量中指明的属性之外的，所有可枚举自有属性拷贝到它的运算对象中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;foo: 1, bar: 2, baz: 3&#125;;</span><br><span class=\"line\">const &#123;foo, ...rest&#125; = obj;</span><br><span class=\"line\">    // Same as:</span><br><span class=\"line\">    // const foo = 1;</span><br><span class=\"line\">    // const rest = &#123;bar: 2, baz: 3&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果你正在使用对象解构来处理命名参数，rest 操作符让你可以收集所有剩余参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function func(&#123;param1, param2, ...rest&#125;) &#123; // rest operator</span><br><span class=\"line\">    console.log(&apos;All parameters: &apos;,&#123;param1, param2, ...rest&#125;); // spread operator</span><br><span class=\"line\">    return param1 + param2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"语法限制\"><a href=\"#语法限制\" class=\"headerlink\" title=\"语法限制\"></a>语法限制</h4><p>在每个对象字面量的顶层，可以使用 rest 操作符最多一次，并且必须只能在末尾出现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;...rest, foo&#125; = obj; // SyntaxError</span><br><span class=\"line\">const &#123;foo, ...rest1, ...rest2&#125; = obj; // SyntaxError</span><br></pre></td></tr></table></figure>\n<p>如果是嵌套结构，你可以多次使用 rest 操作符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    foo: &#123;</span><br><span class=\"line\">        a: 1,</span><br><span class=\"line\">        b: 2,</span><br><span class=\"line\">        c: 3,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bar: 4,</span><br><span class=\"line\">    baz: 5,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123;foo: &#123;a, ...rest1&#125;, ...rest2&#125; = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// Same as:</span><br><span class=\"line\">// const a = 1;</span><br><span class=\"line\">// const rest1 = &#123;b: 2, c: 3&#125;;</span><br><span class=\"line\">// const rest2 = &#123;bar: 4, baz: 5&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象字面量中的-spread-操作符\"><a href=\"#对象字面量中的-spread-操作符\" class=\"headerlink\" title=\"对象字面量中的 spread 操作符\"></a>对象字面量中的 spread 操作符</h2><p>对象字面量内部，spread 操作符将自身运算对象的所有可枚举的自有属性，插入到通过字面量创建的对象中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const obj = &#123;foo: 1, bar: 2, baz: 3&#125;;</span><br><span class=\"line\">&gt; &#123;...obj, qux: 4&#125;</span><br><span class=\"line\">&#123; foo: 1, bar: 2, baz: 3, qux: 4 &#125;</span><br></pre></td></tr></table></figure>\n<p>要注意的是顺序问题，即使属性 key 并不冲突，因为对象会记录插入顺序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123;qux: 4, ...obj&#125;</span><br><span class=\"line\">&#123; qux: 4, foo: 1, bar: 2, baz: 3 &#125;</span><br></pre></td></tr></table></figure>\n<p>如果 key 出现了冲突，后面的会覆盖前面的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const obj = &#123;foo: 1, bar: 2, baz: 3&#125;;</span><br><span class=\"line\">&gt; &#123;...obj, foo: true&#125;</span><br><span class=\"line\">&#123; foo: true, bar: 2, baz: 3 &#125;</span><br><span class=\"line\">&gt; &#123;foo: true, ...obj&#125;</span><br><span class=\"line\">&#123; foo: 1, bar: 2, baz: 3 &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象-spread-操作符的使用场景\"><a href=\"#对象-spread-操作符的使用场景\" class=\"headerlink\" title=\"对象 spread 操作符的使用场景\"></a>对象 spread 操作符的使用场景</h2><p>这一节，我们会看看 spread 操作符的使用场景。我也会用 Object.assign() 实现一遍，它和 spread 操作符很相似（之后我们会更详细地比较它们）。</p>\n<h4 id=\"拷贝对象\"><a href=\"#拷贝对象\" class=\"headerlink\" title=\"拷贝对象\"></a>拷贝对象</h4><p>拷贝对象 obj 的可枚举自有属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone1 = &#123;...obj&#125;;</span><br><span class=\"line\">const clone2 = Object.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure>\n<p>clone 对象们的原型都是 Object.prototype，它是所有通过对象字面量创建的对象的默认原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.getPrototypeOf(clone1) === Object.prototype</span><br><span class=\"line\">true</span><br><span class=\"line\">&gt; Object.getPrototypeOf(clone2) === Object.prototype</span><br><span class=\"line\">true</span><br><span class=\"line\">&gt; Object.getPrototypeOf(&#123;&#125;) === Object.prototype</span><br><span class=\"line\">true</span><br></pre></td></tr></table></figure>\n<p>拷贝一个对象 obj，包括它的原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone1 = &#123;__proto__: Object.getPrototypeOf(obj), ...obj&#125;;</span><br><span class=\"line\">const clone2 = Object.assign(</span><br><span class=\"line\">    Object.create(Object.getPrototypeOf(obj)), obj);</span><br></pre></td></tr></table></figure>\n<p>注意，一般来说，对象字面量内部的 <strong>proto</strong> 只是浏览器内置的特性，并非 JavaScript 引擎所有。</p>\n<h4 id=\"对象的真拷贝\"><a href=\"#对象的真拷贝\" class=\"headerlink\" title=\"对象的真拷贝\"></a>对象的真拷贝</h4><p>有时候，你需要老老实实地拷贝对象的所有自有属性(properties)和特性(writable, enumerable, …)，包括 getters 和 setters。这时候 Object.assign() 和 spread 操作符就回天乏术了。你需要使用属性描述符(<a href=\"http://speakingjs.com/es5/ch17.html#property_attributes\" target=\"_blank\" rel=\"noopener\">property descriptors</a>)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone1 = Object.defineProperties(&#123;&#125;,</span><br><span class=\"line\">    Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure></p>\n<p>如果还希望保留 obj 的原型，可以用 <a href=\"http://speakingjs.com/es5/ch17.html#Object.create\" target=\"_blank\" rel=\"noopener\"><code>Object.create()</code></a>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const clone2 = Object.create(</span><br><span class=\"line\">    Object.getPrototypeOf(obj),</span><br><span class=\"line\">    Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure></p>\n<p>“探索 ES2016 and ES2017” 里介绍了 <a href=\"http://exploringjs.com/es2016-es2017/ch_object-getownpropertydescriptors.html\" target=\"_blank\" rel=\"noopener\"><code>Object.getOwnPropertyDescriptors()</code></a></p>\n<h4 id=\"陷阱：总是浅拷贝\"><a href=\"#陷阱：总是浅拷贝\" class=\"headerlink\" title=\"陷阱：总是浅拷贝\"></a>陷阱：总是浅拷贝</h4><p>我们之前见过的所有拷贝对象的方式，都是浅拷贝：如果原始属性值是一个对象，拷贝的对象将指向同一个对象，它不会（递归的、深度的）拷贝自身：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const original = &#123; prop: &#123;&#125; &#125;;</span><br><span class=\"line\">const clone = Object.assign(&#123;&#125;, original);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(original.prop === clone.prop); // true</span><br><span class=\"line\">original.prop.foo = &apos;abc&apos;;</span><br><span class=\"line\">console.log(clone.prop.foo); // abc</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他使用场景\"><a href=\"#其他使用场景\" class=\"headerlink\" title=\"其他使用场景\"></a>其他使用场景</h4><p>合并 obj1 和 obj2 两个对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const merged = &#123;...obj1, ...obj2&#125;;</span><br><span class=\"line\">const merged = Object.assign(&#123;&#125;, obj1, obj2);</span><br></pre></td></tr></table></figure></p>\n<p>给用户数据填充默认值<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const DEFAULTS = &#123;foo: &apos;a&apos;, bar: &apos;b&apos;&#125;;</span><br><span class=\"line\">const userData = &#123;foo: 1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const data = &#123;...DEFAULTS, ...userData&#125;;</span><br><span class=\"line\">const data = Object.assign(&#123;&#125;, DEFAULTS, userData);</span><br><span class=\"line\">    // &#123;foo: 1, bar: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>安全地更新属性 foo:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;foo: &apos;a&apos;, bar: &apos;b&apos;&#125;;</span><br><span class=\"line\">const obj2 = &#123;...obj, foo: 1&#125;;</span><br><span class=\"line\">const obj2 = Object.assign(&#123;&#125;, obj, &#123;foo: 1&#125;);</span><br><span class=\"line\">    // &#123;foo: 1, bar: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>指定属性 foo  和 bar 的默认值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const userData = &#123;foo: 1&#125;;</span><br><span class=\"line\">const data = &#123;foo: &apos;a&apos;, bar: &apos;b&apos;, ...userData&#125;;</span><br><span class=\"line\">const data = Object.assign(&#123;&#125;, &#123;foo:&apos;a&apos;, bar:&apos;b&apos;&#125;, userData);</span><br><span class=\"line\">    // &#123;foo: 1, bar: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"展开对象-VS-Object-assign\"><a href=\"#展开对象-VS-Object-assign\" class=\"headerlink\" title=\"展开对象 VS Object.assign()\"></a>展开对象 VS Object.assign()</h2><p>spread 操作符和 Object.assign() 很相似。主要的区别在于前者定义了新属性，而后者还进行了赋值。稍后将解释这究竟意味着什么。</p>\n<h4 id=\"Object-assign-的两种使用方式\"><a href=\"#Object-assign-的两种使用方式\" class=\"headerlink\" title=\"Object.assign() 的两种使用方式\"></a>Object.assign() 的两种使用方式</h4><p>Object.assign() 有两种使用方式：<br>第一种，带有破坏性的（修改已有对象）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.assign(target, source1, source2);</span><br></pre></td></tr></table></figure></p>\n<p>这里的 target 对象被修改了；source1 和 source2 被拷贝进去了。<br>第二种，非破坏性的（已有对象不会被修改）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const result = Object.assign(&#123;&#125;, source1, source2);</span><br></pre></td></tr></table></figure></p>\n<p>新对象是通过将 source1 和 source2 拷贝进一个空对象而生成的。最终，这个新对象被返回并赋值给 result。<br>spread 操作符类似于 Object.assign() 的第二种方式。接下来，我们来看看两者的相似和不同之处。</p>\n<h4 id=\"都是通过-“get”-操作符读值\"><a href=\"#都是通过-“get”-操作符读值\" class=\"headerlink\" title=\"都是通过 “get” 操作符读值\"></a>都是通过 “get” 操作符读值</h4><p>在写对象之前，两者都使用了 ”get“ 操作符去读取源对象的属性值。这一过程会将 getter 被转换成正常的数据属性。<br>来看个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const original = &#123;</span><br><span class=\"line\">    get foo() &#123;</span><br><span class=\"line\">        return 123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>original 有一个 foo getter(它的属性描述符有 get 和 set 属性)<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.getOwnPropertyDescriptor(original, &apos;foo&apos;)</span><br><span class=\"line\">&#123; get: [Function: foo],</span><br><span class=\"line\">  set: undefined,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true &#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是在它拷贝的结果 clone1 和 clone2 里，foo 是一个正常的数据属性（属性描述符有value 和 writable 属性）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const clone1 = &#123;...original&#125;;</span><br><span class=\"line\">&gt; Object.getOwnPropertyDescriptor(clone1, &apos;foo&apos;)</span><br><span class=\"line\">&#123; value: 123,</span><br><span class=\"line\">  writable: true,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; const clone2 = Object.assign(&#123;&#125;, original);</span><br><span class=\"line\">&gt; Object.getOwnPropertyDescriptor(clone2, &apos;foo&apos;)</span><br><span class=\"line\">&#123; value: 123,</span><br><span class=\"line\">  writable: true,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">  configurable: true &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"spread-定义属性，Object-assign-设置属性\"><a href=\"#spread-定义属性，Object-assign-设置属性\" class=\"headerlink\" title=\"spread 定义属性，Object.assign() 设置属性\"></a>spread 定义属性，Object.assign() 设置属性</h4><p>spread 操作符在目标对象上定义了新的属性，而Object.assign() 使用了一个 “set” 操作符来创建属性。这会导致两个结果：</p>\n<h6 id=\"目标对象带有-setter\"><a href=\"#目标对象带有-setter\" class=\"headerlink\" title=\"目标对象带有 setter\"></a>目标对象带有 setter</h6><p>首先，Object.assign() 触发 setter，而 spread 不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Object.prototype, &apos;foo&apos;, &#123;</span><br><span class=\"line\">    set(value) &#123;</span><br><span class=\"line\">        console.log(&apos;SET&apos;, value);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const obj = &#123;foo: 123&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码段设置了一个 foo setter，它会被所有普通对象继承。<br>如果我们通过 Object.assign() 拷贝 obj，继承的 setter  会被触发：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.assign(&#123;&#125;, obj)</span><br><span class=\"line\">SET 123</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而 spread 就不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123; ...obj &#125;</span><br><span class=\"line\">&#123; foo: 123 &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Object.assign() 在拷贝时还会触发自有 setter，这里并没有发生重写。</p>\n<h6 id=\"目标对象带有只读属性\"><a href=\"#目标对象带有只读属性\" class=\"headerlink\" title=\"目标对象带有只读属性\"></a>目标对象带有只读属性</h6><p>第二，你可以通过继承只读属性，来阻止 Object.assign() 创建自有属性，但 spread 上这是做不到的：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(Object.prototype, &apos;bar&apos;, &#123;</span><br><span class=\"line\">    writable: false,</span><br><span class=\"line\">    value: &apos;abc&apos;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>以上代码设置了只读属性 bar，它会被所有普通对象继承。<br>这样，你就再也不能使用赋值语句去创建自有属性 bar（严格模式下会抛一个异常，宽松模式会静默失败）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; const tmp = &#123;&#125;;</span><br><span class=\"line\">&gt; tmp.bar = 123;</span><br><span class=\"line\">TypeError: Cannot assign to read only property &apos;bar&apos;</span><br></pre></td></tr></table></figure></p>\n<p>下列代码，我们使用对象字面量成功地创建了属性 bar。因为对象字面量没有设置属性，它只是定义了它们：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;bar: 123&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>然而，Object.assign() 使用赋值语句创建属性，这就是不能拷贝 obj 的原因：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; Object.assign(&#123;&#125;, obj)</span><br><span class=\"line\">TypeError: Cannot assign to read only property &apos;bar&apos;</span><br></pre></td></tr></table></figure></p>\n<p>通过 spread 操作符拷贝没有问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123; ...obj &#125;</span><br><span class=\"line\">&#123; bar: 123 &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"spread-和-Object-assign-都只拷贝自有可枚举属性\"><a href=\"#spread-和-Object-assign-都只拷贝自有可枚举属性\" class=\"headerlink\" title=\"spread 和 Object.assign() 都只拷贝自有可枚举属性\"></a>spread 和 Object.assign() 都只拷贝自有可枚举属性</h4><p>它们都会忽略所有继承的属性和不可枚举的自有属性。<br>对象 obj 从 proto 继承了一个可枚举属性，并且有两个自有属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const proto = &#123;</span><br><span class=\"line\">    inheritedEnumerable: 1,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const obj = Object.create(proto, &#123;</span><br><span class=\"line\">    ownEnumerable: &#123;</span><br><span class=\"line\">        value: 2,</span><br><span class=\"line\">        enumerable: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ownNonEnumerable: &#123;</span><br><span class=\"line\">        value: 3,</span><br><span class=\"line\">        enumerable: false,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果拷贝 obj，结果将只有属性 ownEnumerable。属性 inheritedEnumerable 和 ownNonEnumerable 没有被拷贝：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; &#123;...obj&#125;</span><br><span class=\"line\">&#123; ownEnumerable: 2 &#125;</span><br><span class=\"line\">&gt; Object.assign(&#123;&#125;, obj)</span><br><span class=\"line\">&#123; ownEnumerable: 2 &#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>原文：<a href=\"http://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html\" target=\"_blank\" rel=\"noopener\">http://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html</a></p>\n"},{"title":"【译】HLS 架构简介","date":"2017-03-11T18:03:01.000Z","_content":"\n> - 原文：[HTTP Streaming Architecture](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html)\n- 译者：[熊贤仁](https://blog.skrskrskrskr.com)\n\n### 前言\n作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   \n\n### 概览\n在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。\n\nHLS 由三部分组成：服务器、分发组件（distribution component）和客户端。\n\n服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。\n\n分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。\n\n客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。\n\n在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。\n\n举个简单例子用于说明HTTP 流的配置\n\n![图1-1 基本配置](https://mares.oss-cn-qingdao.aliyuncs.com/blog/hls/1.png)\n\n输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。\n\n只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。\n\n分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。\n\n### 服务器\n服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。\n\n**媒体编码器（Media Encoder）**\n\n媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。\n\n编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。[Audio Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2) 和 [Video Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6) 列出了支持的压缩格式。\n> 重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 **EXT-X-DISCONTINUITY** 标签\n\n**流分段器（Stream Segmenter）**\n\n流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。\n\n流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。\n\n媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。\n\n**文件分段器（File Segmenter）**\n\n如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。\n\n### 媒体段文件（Media Segment Files）\n媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。\n\n### 索引文件（播放列表）\n 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。\n> 注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。\n\n关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。\n```\n#EXT-X-VERSION:3\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:1\n\n# Old-style integer duration; avoid for newer clients.\n#EXTINF:10,\nhttp://media.example.com/segment0.ts\n\n# New-style floating-point duration; use for modern clients.\n#EXTINF:10.0,\nhttp://media.example.com/segment1.ts\n#EXTINF:9.5,\nhttp://media.example.com/segment2.ts\n#EXT-X-ENDLIST\n```\n当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。\n> 当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见[Media File Segmenter](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7)\n\n索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  [HTTP Live Streaming specification](http://tools.ietf.org/html/draft-pantos-http-live-streaming) 部分。\n\n索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。\n\n### 分发组件（Distribution Components）\n分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。\n\n更详细介绍见 [Deploying HTTP Live Streaming](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3)。\n\n### 客户端\n客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。\n\n客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。\n\n这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。\n","source":"_posts/【译】HLS架构简介.md","raw":"---\ntitle: 【译】HLS 架构简介\ndate: 2017-03-12 02:03:01\ntags:\n- 直播\n- 翻译\ncategories:\n- 后端\n---\n\n> - 原文：[HTTP Streaming Architecture](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html)\n- 译者：[熊贤仁](https://blog.skrskrskrskr.com)\n\n### 前言\n作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   \n\n### 概览\n在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。\n\nHLS 由三部分组成：服务器、分发组件（distribution component）和客户端。\n\n服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。\n\n分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。\n\n客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。\n\n在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。\n\n举个简单例子用于说明HTTP 流的配置\n\n![图1-1 基本配置](https://mares.oss-cn-qingdao.aliyuncs.com/blog/hls/1.png)\n\n输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。\n\n只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。\n\n分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。\n\n### 服务器\n服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。\n\n**媒体编码器（Media Encoder）**\n\n媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。\n\n编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。[Audio Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2) 和 [Video Technologies](https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6) 列出了支持的压缩格式。\n> 重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 **EXT-X-DISCONTINUITY** 标签\n\n**流分段器（Stream Segmenter）**\n\n流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。\n\n流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。\n\n媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。\n\n**文件分段器（File Segmenter）**\n\n如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。\n\n### 媒体段文件（Media Segment Files）\n媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。\n\n### 索引文件（播放列表）\n 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。\n> 注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。\n\n关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。\n```\n#EXT-X-VERSION:3\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:1\n\n# Old-style integer duration; avoid for newer clients.\n#EXTINF:10,\nhttp://media.example.com/segment0.ts\n\n# New-style floating-point duration; use for modern clients.\n#EXTINF:10.0,\nhttp://media.example.com/segment1.ts\n#EXTINF:9.5,\nhttp://media.example.com/segment2.ts\n#EXT-X-ENDLIST\n```\n当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。\n> 当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见[Media File Segmenter](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7)\n\n索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  [HTTP Live Streaming specification](http://tools.ietf.org/html/draft-pantos-http-live-streaming) 部分。\n\n索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。\n\n### 分发组件（Distribution Components）\n分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。\n\n更详细介绍见 [Deploying HTTP Live Streaming](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3)。\n\n### 客户端\n客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。\n\n客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。\n\n这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。\n","slug":"【译】HLS架构简介","published":1,"updated":"2019-12-29T11:28:13.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbi0061hns6m1xsd27k","content":"<blockquote>\n<ul>\n<li>原文：<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html\" target=\"_blank\" rel=\"noopener\">HTTP Streaming Architecture</a></li>\n<li>译者：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></li>\n</ul>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   </p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。</p>\n<p>HLS 由三部分组成：服务器、分发组件（distribution component）和客户端。</p>\n<p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p>\n<p>分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。</p>\n<p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。</p>\n<p>在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。</p>\n<p>举个简单例子用于说明HTTP 流的配置</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/hls/1.png\" alt=\"图1-1 基本配置\"></p>\n<p>输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。</p>\n<p>只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。</p>\n<p>分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。</p>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。</p>\n<p><strong>媒体编码器（Media Encoder）</strong></p>\n<p>媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。</p>\n<p>编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。<a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2\" target=\"_blank\" rel=\"noopener\">Audio Technologies</a> 和 <a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6\" target=\"_blank\" rel=\"noopener\">Video Technologies</a> 列出了支持的压缩格式。</p>\n<blockquote>\n<p>重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 <strong>EXT-X-DISCONTINUITY</strong> 标签</p>\n</blockquote>\n<p><strong>流分段器（Stream Segmenter）</strong></p>\n<p>流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。</p>\n<p>流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。</p>\n<p>媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。</p>\n<p><strong>文件分段器（File Segmenter）</strong></p>\n<p>如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。</p>\n<h3 id=\"媒体段文件（Media-Segment-Files）\"><a href=\"#媒体段文件（Media-Segment-Files）\" class=\"headerlink\" title=\"媒体段文件（Media Segment Files）\"></a>媒体段文件（Media Segment Files）</h3><p>媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。</p>\n<h3 id=\"索引文件（播放列表）\"><a href=\"#索引文件（播放列表）\" class=\"headerlink\" title=\"索引文件（播放列表）\"></a>索引文件（播放列表）</h3><p> 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。</p>\n<blockquote>\n<p>注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。</p>\n</blockquote>\n<p>关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#EXT-X-VERSION:3</span><br><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-TARGETDURATION:10</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:1</span><br><span class=\"line\"></span><br><span class=\"line\"># Old-style integer duration; avoid for newer clients.</span><br><span class=\"line\">#EXTINF:10,</span><br><span class=\"line\">http://media.example.com/segment0.ts</span><br><span class=\"line\"></span><br><span class=\"line\"># New-style floating-point duration; use for modern clients.</span><br><span class=\"line\">#EXTINF:10.0,</span><br><span class=\"line\">http://media.example.com/segment1.ts</span><br><span class=\"line\">#EXTINF:9.5,</span><br><span class=\"line\">http://media.example.com/segment2.ts</span><br><span class=\"line\">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure></p>\n<p>当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。</p>\n<blockquote>\n<p>当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7\" target=\"_blank\" rel=\"noopener\">Media File Segmenter</a></p>\n</blockquote>\n<p>索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  <a href=\"http://tools.ietf.org/html/draft-pantos-http-live-streaming\" target=\"_blank\" rel=\"noopener\">HTTP Live Streaming specification</a> 部分。</p>\n<p>索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。</p>\n<h3 id=\"分发组件（Distribution-Components）\"><a href=\"#分发组件（Distribution-Components）\" class=\"headerlink\" title=\"分发组件（Distribution Components）\"></a>分发组件（Distribution Components）</h3><p>分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。</p>\n<p>更详细介绍见 <a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3\" target=\"_blank\" rel=\"noopener\">Deploying HTTP Live Streaming</a>。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。</p>\n<p>客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。</p>\n<p>这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>原文：<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html\" target=\"_blank\" rel=\"noopener\">HTTP Streaming Architecture</a></li>\n<li>译者：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></li>\n</ul>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>作为 Apple 提出的一种基于 HTTP 的协议，HLS（HTTP Live Streaming）用于解决实时音视频流的传输。尤其是在移动端，由于 iOS 不支持 flash，使得 HLS 成了移动端实时视频流传输的首选。HLS 经常用在直播领域，一些国内的直播云通常用 HLS 拉流（将视频流从服务器拉到客户端）。 HLS 值得诟病之处就是其延迟严重，延迟通常在 10-30s 之间。通过本文你可以了解到 HLS 延迟问题的原因，同时对直播系统的架构有个大概的认知。   </p>\n<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>在进行编码和鉴权后，HLS 支持从一台普通的 web 服务器上发送实时或预先录制的音视频，接收端可以是 iOS 3.0+ 的任何设备（包括 iPad 和 Apple TV ），或者其他安装有 Safari 4.0+ 的设备。</p>\n<p>HLS 由三部分组成：服务器、分发组件（distribution component）和客户端。</p>\n<p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p>\n<p>分发组件（distribution component）组成了标准的 web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。如果分发规模较大，可能需要使用边缘网络（edge networks）和 CDN。</p>\n<p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。客户端环境必须为 iOS 3.0 以上或 Safari 4.0 以上的设备。</p>\n<p>在一种典型的配置中，硬件编码器接收音视频输入，将其编码为 H.264 视频和 AAC 音频，然后输出为 MPEG-2 传输流（Transport Stream）。MPEG-2 传输流被软件流分段器（software stream segmenter）分割为一系列短小的媒体文件。这些文件被放进 web 服务器。分段器同时也创造和维护了一个包含媒体文件列表的索引文件。索引文件的URL被发布到 web 服务器上。客户端软件读取索引，然后按序请求列表中的媒体文件，并将其展示出来，片段之间无任务暂停或间隔。</p>\n<p>举个简单例子用于说明HTTP 流的配置</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/hls/1.png\" alt=\"图1-1 基本配置\"></p>\n<p>输入可以是实时的或者录制好的资源。输入文件通常被编码为 MPEG-4 （H.264 视频和 AAC 音频），并通过现有的硬件设备打包进一个 MPEG-2 传输流。MPEG-2 传输流被分段，保存为一系列的媒体文件。这一过程通常使用软件工具来完成，比如 Apple stream segmenter。</p>\n<p>只含音频的流可以是一系列 MPEG 基本音频（MPEG elementary audio）文件，比如 MP3 或者 AC-3。文件格式为 AAC，它们带着 ADTS 头部。</p>\n<p>分段器（segmenter）同时生成了一个索引文件。索引文件里包含了一个媒体文件列表和元数据（metadata）。这个索引文件是一个 .M3U8 播放列表。索引文件的 URL 可被客户端访问，并按序请求这些文件。</p>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>服务器需要进行媒体编码，编码器可以是自带的硬件。还需要将编码后的媒体进行分段，并保存为文件，可以使用 Apple 提供的媒体流分段器或者第三方集成解决方案来完成这一过程。</p>\n<p><strong>媒体编码器（Media Encoder）</strong></p>\n<p>媒体编码器接收来自音视频设备上的实时信号，进行媒体编码，并将其封装成适于传输的格式。应该将媒体编码为客户端设备支持的格式，比如 H.264 视频和 HE-AAC 音频。当下支持 MPEG-2 传输流作为音视频传输格式。对于纯音频，支持 MPEG 基础流（MPEG elementary stream）进行传输。</p>\n<p>编码器在本地网络上将编码后的媒体以 MPEG-2 传输流的形式传递给媒体分段器。别把MPEG-2 传输流和 MPEG-2 压缩视频格式弄混了，传输流是一个可以和许多其他不同压缩格式一起使用的打包格式。<a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2\" target=\"_blank\" rel=\"noopener\">Audio Technologies</a> 和 <a href=\"https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6\" target=\"_blank\" rel=\"noopener\">Video Technologies</a> 列出了支持的压缩格式。</p>\n<blockquote>\n<p>重要提醒：视频编码器不能在编码流的过程中改变流的参数——比如视频大小或者解码类型。如果实在要改变流的参数，应该在片段的边界处改变，并且必须在后续的片段中设置 <strong>EXT-X-DISCONTINUITY</strong> 标签</p>\n</blockquote>\n<p><strong>流分段器（Stream Segmenter）</strong></p>\n<p>流分段器从本地网络读取传输流，将其划分为一系列长度相同的小的媒体文件。即使每个片段在一个独立的文件中，视频文件都可以通过一个连续流被无缝地重建。</p>\n<p>流分段器也将创造一个索引文件，每个索引都映射到一个独立的媒体文件。分段器每次产生一个新的媒体文件，索引文件都会被更新。索引用于追踪媒体文件的可用性和具体位置。分段器可能也需要加密媒体片段，生成一个 key 文件。</p>\n<p>媒体片段被保存为 .ts 文件（MPEG-2 传输流文件）。索引文件被保存为 .M3U8 播放列表。</p>\n<p><strong>文件分段器（File Segmenter）</strong></p>\n<p>如果媒体文件早已按照支持的解码格式进行了编码，你可以使用文件分段器将媒体文件封装进 MPEG-2 传输流，然后将它们分割为长度相同的片段。文件分段器支持使用现有的音视频文件库，通过 HLS 来发送点播视频。文件分段器承担了和流分段器相同的任务，但是它的输入是文件，而不是流。</p>\n<h3 id=\"媒体段文件（Media-Segment-Files）\"><a href=\"#媒体段文件（Media-Segment-Files）\" class=\"headerlink\" title=\"媒体段文件（Media Segment Files）\"></a>媒体段文件（Media Segment Files）</h3><p>媒体段文件通常由流分段器（stream segmenter）产生，输入来自于编码器，由一系列 .ts 文件组成。.ts 文件包含了一个 MPEG-2 传输流片段，传输流里带有 H.264 视频和 AAC，MP3，或者 AC-3 音频。对于一个纯音频广播，分段器可以生成 MPEG 基础音频流 （MPEG elementary audio stream）。音频流包括了任一种带有 ADTS 头部的 AAC，MP3，或者 AC-3 音频。</p>\n<h3 id=\"索引文件（播放列表）\"><a href=\"#索引文件（播放列表）\" class=\"headerlink\" title=\"索引文件（播放列表）\"></a>索引文件（播放列表）</h3><p> 索引文件通常由流分段器或者文件分段器产生，并保存为 .M3U8 播放列表。.M3U8 扩展自 .m3u，是一种用于 MP3 播放列表的格式。</p>\n<blockquote>\n<p>注意：因为索引文件格式一种 .m3u 播放列表格式的扩展 ，而且系统也支持 .mp3 音频，所以客户端软件可能也和用于流媒体的经典的 MP3 播放列表兼容。</p>\n</blockquote>\n<p>关于索引文件，举个简单的例子。如果整个流由三个未加密的 10s 长度的媒体文件组成，分段器可能生成一个 .M3U8 格式的播放列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#EXT-X-VERSION:3</span><br><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-TARGETDURATION:10</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:1</span><br><span class=\"line\"></span><br><span class=\"line\"># Old-style integer duration; avoid for newer clients.</span><br><span class=\"line\">#EXTINF:10,</span><br><span class=\"line\">http://media.example.com/segment0.ts</span><br><span class=\"line\"></span><br><span class=\"line\"># New-style floating-point duration; use for modern clients.</span><br><span class=\"line\">#EXTINF:10.0,</span><br><span class=\"line\">http://media.example.com/segment1.ts</span><br><span class=\"line\">#EXTINF:9.5,</span><br><span class=\"line\">http://media.example.com/segment2.ts</span><br><span class=\"line\">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure></p>\n<p>当发送播放列表给支持 HLS 3.0+ 协议的客户端的时候，为了提高精确度，你应该指定所有持续时间为浮点值。（低版本只支持整形值）你必须在使用浮点长度的时候指定协议的版本；如果该版本已经被删除，播放列表必须遵照 HLS 1.0 协议。</p>\n<blockquote>\n<p>当源文件使用 MPEG-4 视频、AAC 或者 MP3 音频时，你可以使用 Apple 提供的文件分段器生成各种示例播放列表。详细说明见<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7\" target=\"_blank\" rel=\"noopener\">Media File Segmenter</a></p>\n</blockquote>\n<p>索引文件可能也包含了一些用于加密 key 文件的 URL，在不同的带宽下会替换成相应的索引文件。关于索引文件格式的更详细说明，见 IETF Internet-Draft 中  <a href=\"http://tools.ietf.org/html/draft-pantos-http-live-streaming\" target=\"_blank\" rel=\"noopener\">HTTP Live Streaming specification</a> 部分。</p>\n<p>索引文件通常由那个生成媒体段文件的分段器产生。或者，如果遵守规范，独立生成 .M3U8 文件和媒体段文件也是可能的。对于纯音频而言，你可以使用文本编辑器生成一个 .M3U8 文件，在文件里列出一系列存在的 .MP3 文件。</p>\n<h3 id=\"分发组件（Distribution-Components）\"><a href=\"#分发组件（Distribution-Components）\" class=\"headerlink\" title=\"分发组件（Distribution Components）\"></a>分发组件（Distribution Components）</h3><p>分发系统是一个 web 服务器或者 web 缓存系统，系统将媒体文件和索引文件传递给基于 HTTP 的客户端。所有自定义的服务器模块都不必传递内容，而且一般只需要在 web 服务器上做很少的配置。</p>\n<p>更详细介绍见 <a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3\" target=\"_blank\" rel=\"noopener\">Deploying HTTP Live Streaming</a>。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>客户端软件先获取索引文件，基于 URL 来定位流。索引文件依次指定可用媒体文件、解码 key 和其他可用的替代流的位置。对于选中的流，客户端按序下载每一个可用媒体文件。每个文件包含了流的连续片段。一旦下载完成，客户端就开始给用户展示重新组装的媒体流。</p>\n<p>客户端负责拉取所有解码 key，鉴权或者展示一个允许鉴权的界面，并按需解码媒体文件。</p>\n<p>这一过程将在索引文件执行到 #EXT-X-ENDLIST 标签后结束。如果没有  #EXT-X-ENDLIST 标签，系统将一直进行广播。在持续广播过程中，客户端会周期性地加载索引文件的新版本。客户端在更新后的索引中寻找新的媒体文件和解密 key，然后把这些 URL 添加到下载队列中。</p>\n"},{"title":"【译】异步：现在与将来（基础篇）","date":"2017-03-31T16:10:03.000Z","_content":"> 原文：https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\n译者：[熊贤仁](https://github.com/FrankXiong)\n\n使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。\n\n这不仅是 ` for ` 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。\n\n几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。\n\n事实上，程序中现在和将来的关系是异步编程的核心。\n\n毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。\n\n但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。\n\n刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种\n JavaScript 异步编程的技巧。\n\n但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。\n\n### 分块的程序 ###\n\n你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 `function`。\n\n大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。\n\n考虑这个例子：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\nvar data = ajax( \"http://some.url.1\" );\n\nconsole.log( data );\n// Oops! `data` generally won't have the Ajax results\n```\n你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 `ajax(..)` 函数现在还没有任何可以赋给 `data` 变量的返回值。如果 `ajax(..)` 可以在返回响应之前一直阻塞，那么 `data = .. ` 赋值将正常运行。\n\n但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。\n\n从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", function myCallbackFunction(data){\n\n\tconsole.log( data ); // Yay, I gots me some `data`!\n\n} );\n```\n**警告：** 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。\n\n你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。\n\n举个例子，考虑下列代码：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n\nvar answer = now();\n\nsetTimeout( later, 1000 ); // Meaning of life: 42\n```\n这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：\n现在：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() { .. }\n\nvar answer = now();\n\nsetTimeout( later, 1000 );\n```\n将来：\n```\nanswer = answer * 2;\nconsole.log( \"Meaning of life:\", answer );\n```\n现在这一块在程序运行后立刻执行。但是 `setTimeout(...)` 还设置了一个在将来执行的事件（定时），所以 `later()` 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。\n\n任何时候将一部分代码包裹进 `function` ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。\n\n### 异步控制台 ###\n关于 `console.*` 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。\n\n因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。\n\n特别是，在某些条件下，一些浏览器的 `console.log(...)` 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 `console` I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。\n\n一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：\n```\nvar a = {\n\tindex: 1\n};\n\n// later\nconsole.log( a ); // ??\n\n// even later\na.index++;\n```\n我们通常会认为 `a` 对象在 `console.log(...)` 语句执行的时候生成了快照，打印出像 `{ like: 1}` 这样的内容，然后当 `a.index++` 执行， 对其进行了修改，这句会严格的在输出  `a` 之后才执行。\n\n多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，`a.index++` 已经执行过了，因此会输出 `{ index: 2}`。\n\n究竟何时 `console` I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 `console.log(...)` 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。\n\n**注意：** 如果你遇到这种特殊情况，不要依赖 `console` 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 `JSON.stringify(...)`。\n\n### 事件循环 ###\n我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。\n\n什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。\n\n“需要”。谁需要？这就是重点所在！\n\nJS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。\n\n但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。\n\n换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。\n\n举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。\n\n浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。\n\n那么什么是事件循环？\n\n我们首先通过一些伪代码来说明：\n```\n// `eventLoop` is an array that acts as a queue (first-in, first-out)\nvar eventLoop = [ ];\nvar event;\n\n// keep going \"forever\"\nwhile (true) {\n\t// perform a \"tick\"\n\tif (eventLoop.length > 0) {\n\t\t// get the next event in the queue\n\t\tevent = eventLoop.shift();\n\n\t\t// now, execute the next event\n\t\ttry {\n\t\t\tevent();\n\t\t}\n\t\tcatch (err) {\n\t\t\treportError(err);\n\t\t}\n\t}\n}\n```\n当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。\n\n正如你所看到的，`while` 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。\n\n需要注意的是，`setTimeout(..)` 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。\n\n如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 `setTimeout(..)` 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。\n\n换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。\n\n**注意：** 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 `setTimeout(..0)` 的讨论 ）。\n\n------\n本系列下一部分将介绍并行线程。\n","source":"_posts/【译】异步：现在与将来（基础篇）.md","raw":"---\ntitle: 【译】异步：现在与将来（基础篇）\ndate: 2017-04-01 00:10:03\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n> 原文：https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\n译者：[熊贤仁](https://github.com/FrankXiong)\n\n使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。\n\n这不仅是 ` for ` 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。\n\n几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。\n\n事实上，程序中现在和将来的关系是异步编程的核心。\n\n毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。\n\n但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。\n\n刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种\n JavaScript 异步编程的技巧。\n\n但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。\n\n### 分块的程序 ###\n\n你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 `function`。\n\n大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。\n\n考虑这个例子：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\nvar data = ajax( \"http://some.url.1\" );\n\nconsole.log( data );\n// Oops! `data` generally won't have the Ajax results\n```\n你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 `ajax(..)` 函数现在还没有任何可以赋给 `data` 变量的返回值。如果 `ajax(..)` 可以在返回响应之前一直阻塞，那么 `data = .. ` 赋值将正常运行。\n\n但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。\n\n从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：\n```\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", function myCallbackFunction(data){\n\n\tconsole.log( data ); // Yay, I gots me some `data`!\n\n} );\n```\n**警告：** 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。\n\n你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。\n\n举个例子，考虑下列代码：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() {\n\tanswer = answer * 2;\n\tconsole.log( \"Meaning of life:\", answer );\n}\n\nvar answer = now();\n\nsetTimeout( later, 1000 ); // Meaning of life: 42\n```\n这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：\n现在：\n```\nfunction now() {\n\treturn 21;\n}\n\nfunction later() { .. }\n\nvar answer = now();\n\nsetTimeout( later, 1000 );\n```\n将来：\n```\nanswer = answer * 2;\nconsole.log( \"Meaning of life:\", answer );\n```\n现在这一块在程序运行后立刻执行。但是 `setTimeout(...)` 还设置了一个在将来执行的事件（定时），所以 `later()` 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。\n\n任何时候将一部分代码包裹进 `function` ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。\n\n### 异步控制台 ###\n关于 `console.*` 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。\n\n因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。\n\n特别是，在某些条件下，一些浏览器的 `console.log(...)` 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 `console` I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。\n\n一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：\n```\nvar a = {\n\tindex: 1\n};\n\n// later\nconsole.log( a ); // ??\n\n// even later\na.index++;\n```\n我们通常会认为 `a` 对象在 `console.log(...)` 语句执行的时候生成了快照，打印出像 `{ like: 1}` 这样的内容，然后当 `a.index++` 执行， 对其进行了修改，这句会严格的在输出  `a` 之后才执行。\n\n多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，`a.index++` 已经执行过了，因此会输出 `{ index: 2}`。\n\n究竟何时 `console` I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 `console.log(...)` 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。\n\n**注意：** 如果你遇到这种特殊情况，不要依赖 `console` 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 `JSON.stringify(...)`。\n\n### 事件循环 ###\n我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。\n\n什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。\n\n“需要”。谁需要？这就是重点所在！\n\nJS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。\n\n但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。\n\n换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。\n\n举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。\n\n浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。\n\n那么什么是事件循环？\n\n我们首先通过一些伪代码来说明：\n```\n// `eventLoop` is an array that acts as a queue (first-in, first-out)\nvar eventLoop = [ ];\nvar event;\n\n// keep going \"forever\"\nwhile (true) {\n\t// perform a \"tick\"\n\tif (eventLoop.length > 0) {\n\t\t// get the next event in the queue\n\t\tevent = eventLoop.shift();\n\n\t\t// now, execute the next event\n\t\ttry {\n\t\t\tevent();\n\t\t}\n\t\tcatch (err) {\n\t\t\treportError(err);\n\t\t}\n\t}\n}\n```\n当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。\n\n正如你所看到的，`while` 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。\n\n需要注意的是，`setTimeout(..)` 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。\n\n如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 `setTimeout(..)` 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。\n\n换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。\n\n**注意：** 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 `setTimeout(..0)` 的讨论 ）。\n\n------\n本系列下一部分将介绍并行线程。\n","slug":"【译】异步：现在与将来（基础篇）","published":1,"updated":"2019-06-16T14:11:37.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbj0064hns6rfne07l4","content":"<blockquote>\n<p>原文：<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md</a><br>译者：<a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n</blockquote>\n<p>使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。</p>\n<p>这不仅是 <code>for</code> 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。</p>\n<p>几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。</p>\n<p>事实上，程序中现在和将来的关系是异步编程的核心。</p>\n<p>毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。</p>\n<p>但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。</p>\n<p>刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种<br> JavaScript 异步编程的技巧。</p>\n<p>但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。</p>\n<h3 id=\"分块的程序\"><a href=\"#分块的程序\" class=\"headerlink\" title=\"分块的程序\"></a>分块的程序</h3><p>你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 <code>function</code>。</p>\n<p>大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。</p>\n<p>考虑这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">var data = ajax( &quot;http://some.url.1&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( data );</span><br><span class=\"line\">// Oops! `data` generally won&apos;t have the Ajax results</span><br></pre></td></tr></table></figure></p>\n<p>你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 <code>ajax(..)</code> 函数现在还没有任何可以赋给 <code>data</code> 变量的返回值。如果 <code>ajax(..)</code> 可以在返回响应之前一直阻塞，那么 <code>data = ..</code> 赋值将正常运行。</p>\n<p>但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。</p>\n<p>从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, function myCallbackFunction(data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log( data ); // Yay, I gots me some `data`!</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure></p>\n<p><strong>警告：</strong> 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。</p>\n<p>你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。</p>\n<p>举个例子，考虑下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 ); // Meaning of life: 42</span><br></pre></td></tr></table></figure></p>\n<p>这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：<br>现在：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123; .. &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 );</span><br></pre></td></tr></table></figure></p>\n<p>将来：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">answer = answer * 2;</span><br><span class=\"line\">console.log( &quot;Meaning of life:&quot;, answer );</span><br></pre></td></tr></table></figure></p>\n<p>现在这一块在程序运行后立刻执行。但是 <code>setTimeout(...)</code> 还设置了一个在将来执行的事件（定时），所以 <code>later()</code> 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。</p>\n<p>任何时候将一部分代码包裹进 <code>function</code> ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。</p>\n<h3 id=\"异步控制台\"><a href=\"#异步控制台\" class=\"headerlink\" title=\"异步控制台\"></a>异步控制台</h3><p>关于 <code>console.*</code> 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。</p>\n<p>因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。</p>\n<p>特别是，在某些条件下，一些浏览器的 <code>console.log(...)</code> 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 <code>console</code> I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。</p>\n<p>一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">\tindex: 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// later</span><br><span class=\"line\">console.log( a ); // ??</span><br><span class=\"line\"></span><br><span class=\"line\">// even later</span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></figure></p>\n<p>我们通常会认为 <code>a</code> 对象在 <code>console.log(...)</code> 语句执行的时候生成了快照，打印出像 <code>{ like: 1}</code> 这样的内容，然后当 <code>a.index++</code> 执行， 对其进行了修改，这句会严格的在输出  <code>a</code> 之后才执行。</p>\n<p>多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，<code>a.index++</code> 已经执行过了，因此会输出 <code>{ index: 2}</code>。</p>\n<p>究竟何时 <code>console</code> I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 <code>console.log(...)</code> 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。</p>\n<p><strong>注意：</strong> 如果你遇到这种特殊情况，不要依赖 <code>console</code> 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 <code>JSON.stringify(...)</code>。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。</p>\n<p>什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。</p>\n<p>“需要”。谁需要？这就是重点所在！</p>\n<p>JS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。</p>\n<p>但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。</p>\n<p>换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。</p>\n<p>举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。</p>\n<p>浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。</p>\n<p>那么什么是事件循环？</p>\n<p>我们首先通过一些伪代码来说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// `eventLoop` is an array that acts as a queue (first-in, first-out)</span><br><span class=\"line\">var eventLoop = [ ];</span><br><span class=\"line\">var event;</span><br><span class=\"line\"></span><br><span class=\"line\">// keep going &quot;forever&quot;</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">\t// perform a &quot;tick&quot;</span><br><span class=\"line\">\tif (eventLoop.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// get the next event in the queue</span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// now, execute the next event</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。</p>\n<p>正如你所看到的，<code>while</code> 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。</p>\n<p>需要注意的是，<code>setTimeout(..)</code> 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。</p>\n<p>如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 <code>setTimeout(..)</code> 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。</p>\n<p>换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。</p>\n<p><strong>注意：</strong> 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 <code>setTimeout(..0)</code> 的讨论 ）。</p>\n<hr>\n<p>本系列下一部分将介绍并行线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md</a><br>译者：<a href=\"https://github.com/FrankXiong\" target=\"_blank\" rel=\"noopener\">熊贤仁</a></p>\n</blockquote>\n<p>使用像 JavaScript 这样的语言编程时，很重要的并且还常被人误解的部分是，如何表达和控制程序在一段时间内分散的行为。</p>\n<p>这不仅是 <code>for</code> 循环的开始到结束，这一过程当然也要花费一些时间（几微妙到几毫秒），而是当你的程序的一部分现在开始运行，而另一部分将来才运行—— “现在” 和 “将来” 之间存在一个程序并未有效执行的间隙。</p>\n<p>几乎所有重要的程序当初在被编写的时候，都不得不以某种方式管理这个间隙。这段间隙可能是存在于等待用户输入，请求数据库或文件系统的数据，通过网络发送数据并等待响应，或者是定时运行一个重复任务（比如动画）之中。在诸如此类的场景中，你的程序必须及时管理这段跨间隙时间的状态。正如伦敦地铁门和站台上贴的很有名的一句话：“小心间隙”。</p>\n<p>事实上，程序中现在和将来的关系是异步编程的核心。</p>\n<p>毫无疑问，自 JS 诞生以来就伴随着异步编程。但是大多数 JS 开发者从未真正思考过程序如何出现异步的，以及为何要出现异步，或者去探索更多的解决之道。普通的回调函数一直以来成为一种足够好的方法。时至今日还有许多人坚持认为回调函数已经够用了。</p>\n<p>但是，为了迎合运行在浏览器和服务器，以及每一种可能的设备上日益拓展的需求，JS 的规模和复杂度日渐增长。管理异步变得越来越困难成了开发者的痛点，我们迫切需要更给力和更合理的方案。</p>\n<p>刚才说的这些可能有些抽象，随着本书的展开，我保证你将对这些概念有更完整具体的理解。我们将在接下来的章节探索各种<br> JavaScript 异步编程的技巧。</p>\n<p>但是在这之前，我们要更深入地理解异步的概念，以及 JS 中异步的运转机制。</p>\n<h3 id=\"分块的程序\"><a href=\"#分块的程序\" class=\"headerlink\" title=\"分块的程序\"></a>分块的程序</h3><p>你可能把 JS 程序写进一个 .js 文件，但是程序多半分成了一些块，其中只有一块现在执行，剩下的在将来执行。最常见的块单位是 <code>function</code>。</p>\n<p>大多数 JS 新手看起来会遇到的问题是，将来执行的部分并没有在现在执行部分结束后立即执行。换句话说，当前不能完成的任务将会异步完成，因此阻塞行为并不会如你直觉所想般发生。</p>\n<p>考虑这个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">var data = ajax( &quot;http://some.url.1&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( data );</span><br><span class=\"line\">// Oops! `data` generally won&apos;t have the Ajax results</span><br></pre></td></tr></table></figure></p>\n<p>你可能注意到标准的 Ajax 请求没有同步的完成，这意味着 <code>ajax(..)</code> 函数现在还没有任何可以赋给 <code>data</code> 变量的返回值。如果 <code>ajax(..)</code> 可以在返回响应之前一直阻塞，那么 <code>data = ..</code> 赋值将正常运行。</p>\n<p>但是我们并不是这么使用 Ajax 的。“现在” 发起一个异步的 Ajax 请求，“将来” 才得到返回的结果。</p>\n<p>从“现在” 一直等待到“将来”，最简单的方式（但绝不是唯一，甚至也不是最好的）是使用一个函数，通常被称为回调函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, function myCallbackFunction(data)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log( data ); // Yay, I gots me some `data`!</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure></p>\n<p><strong>警告：</strong> 你可能也听说过可以使 Ajax 请求同步化。然而即使技术上可行，你也绝不应该在任何情况下这样做，因为这会锁住浏览器的 UI（按钮，菜单，滚动等等），会阻塞所有的用户交互。这个想法很糟糕，应该永远避免。</p>\n<p>你可能想提出抗议，千万别，你希望避免回调函数带来的混乱，然而这并不足以成为使用阻塞式同步 Ajax 的理由。</p>\n<p>举个例子，考虑下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123;</span><br><span class=\"line\">\tanswer = answer * 2;</span><br><span class=\"line\">\tconsole.log( &quot;Meaning of life:&quot;, answer );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 ); // Meaning of life: 42</span><br></pre></td></tr></table></figure></p>\n<p>这段程序分为两块：现在执行的部分和将来执行的部分。这两块的内容显而易见，但我们还是明确地指出来：<br>现在：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function now() &#123;</span><br><span class=\"line\">\treturn 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function later() &#123; .. &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var answer = now();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( later, 1000 );</span><br></pre></td></tr></table></figure></p>\n<p>将来：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">answer = answer * 2;</span><br><span class=\"line\">console.log( &quot;Meaning of life:&quot;, answer );</span><br></pre></td></tr></table></figure></p>\n<p>现在这一块在程序运行后立刻执行。但是 <code>setTimeout(...)</code> 还设置了一个在将来执行的事件（定时），所以 <code>later()</code> 函数的内容会在之后的某个时间（从现在之后 1000 毫秒）。</p>\n<p>任何时候将一部分代码包裹进 <code>function</code> ，并指定它在响应某个事件（定时器，鼠标点击，Ajax响应等待）时执行，你就在创建一个 “将来” 执行的代码块，这样就在程序中引入了异步。</p>\n<h3 id=\"异步控制台\"><a href=\"#异步控制台\" class=\"headerlink\" title=\"异步控制台\"></a>异步控制台</h3><p>关于 <code>console.*</code> 方法的工作原理，现在还没有规范或者需求集——因为它们不属于正式的 JavaScript，而是通过宿主环境（见本书的类型和语法章节）被加入到 JS 中来。</p>\n<p>因此，不同的浏览器和 JS 环境各行其是，有时导致出现令人困惑的行为。</p>\n<p>特别是，在某些条件下，一些浏览器的 <code>console.log(...)</code> 并没有按照给定的内容立即输出。主要原因可能是因为 I/O 在很多程序（不只是 JS ）中是一个很慢并且阻塞的部分。所以，浏览器在后台异步处理 <code>console</code> I/O ，性能可能会更好， 这时甚至你可能都察觉不到发生了 I/O。</p>\n<p>一个不算很常见，但可能出现的场景是， 这一过程是可观察的（不是从代码本身，而是从外部）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">\tindex: 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// later</span><br><span class=\"line\">console.log( a ); // ??</span><br><span class=\"line\"></span><br><span class=\"line\">// even later</span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></figure></p>\n<p>我们通常会认为 <code>a</code> 对象在 <code>console.log(...)</code> 语句执行的时候生成了快照，打印出像 <code>{ like: 1}</code> 这样的内容，然后当 <code>a.index++</code> 执行， 对其进行了修改，这句会严格的在输出  <code>a</code> 之后才执行。</p>\n<p>多数时候，前面的代码很可能在开发者控制台中生成了一个与你期望一致的对象表示。但是，当浏览器将控制台 I/O 推迟到后台进行，同样这段代码可能在浏览器控制台输出对象的时候，<code>a.index++</code> 已经执行过了，因此会输出 <code>{ index: 2}</code>。</p>\n<p>究竟何时 <code>console</code> I/O 会被推迟，或者是否可观察，这些都是不确定的。只是在调试时遇到在 <code>console.log(...)</code> 语句后，对象被修改了，你要意识到这可能是 I/O 中的异步化造成的。</p>\n<p><strong>注意：</strong> 如果你遇到这种特殊情况，不要依赖 <code>console</code> 输出，最好是在 JS debugger 中使用断点。另一个不错的选择是把对象序列化为一个字符串，以强制执行一次 “快照”，比如使用 <code>JSON.stringify(...)</code>。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>我们来澄清一件事（可能很震惊）：尽管 JS 支持异步代码（比如我们刚才见过的 timeout ）是显而易见的，然而直到最近（ES6）,JavaScript 还没有内建任何直接的异步概念。</p>\n<p>什么！？这看起来很疯狂，对吧？事实上，这是真的。JS 引擎本身当需要的时候，在给定任意时刻都只在执行程序中的单个块。</p>\n<p>“需要”。谁需要？这就是重点所在！</p>\n<p>JS 引擎并不运行于隔离的环境中。它在宿主环境下运行，对于多数开发者而言，这个宿主环境就是 Web 浏览器。在过去几年中（但肯定不完全是），JS 已经超出了浏览器的范围，进入到其他环境中，比如通过 Node.js 打入了服务器领域。事实上，现在 JavaScript 已经嵌入到各种设备中，从机器人到灯泡。</p>\n<p>但是所有这些环境都有一个共同 “点”（无论如何，这都不是一个精妙的异步笑话），它们都有一个机制来处理程序中多个块的执行，并与此同时调用 JS 引擎，这被称之为 “事件循环”。</p>\n<p>换句话说，JS 引擎对时间并不敏感，但是有一个按需执行任意 JS 代码的环境。“事件”调度（JS 代码执行）总是在其所在的环境进行。</p>\n<p>举个例子，当 JS 程序发起一个 Ajax 请求，从服务器上拉取一些数据，你把 “响应” 代码写在一个函数（通常被称为 “回调函数”）中，然后 JS 引擎告知宿主环境， “嘿，我现在要将代码执行挂起，但是一旦你完成了网络请求并拿到数据，请调用这个函数”。</p>\n<p>浏览器将为网络请求建立监听，当一些数据过来后，它会将回调函数插入到事件循环中，以实现回调函数的调度执行。</p>\n<p>那么什么是事件循环？</p>\n<p>我们首先通过一些伪代码来说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// `eventLoop` is an array that acts as a queue (first-in, first-out)</span><br><span class=\"line\">var eventLoop = [ ];</span><br><span class=\"line\">var event;</span><br><span class=\"line\"></span><br><span class=\"line\">// keep going &quot;forever&quot;</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">\t// perform a &quot;tick&quot;</span><br><span class=\"line\">\tif (eventLoop.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// get the next event in the queue</span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// now, execute the next event</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，这是为了说明概念而写的非常简化的伪代码。但这也足以帮助我们更好的理解事件循环了。</p>\n<p>正如你所看到的，<code>while</code> 循环不断运行，循环的每次迭代被称为一次 “tick”。对于每个 tick，如果一个事件在队列中等待，它会被取出来并执行。这些事件就是回调函数。</p>\n<p>需要注意的是，<code>setTimeout(..)</code> 并没有把回调函数放进事件循环队列中。它做的是建立一个定时器；当定时器过期后，执行环境将回调函数放进事件循环，一些将来的 tick 会将其取出来并执行。</p>\n<p>如果这时事件循环中已经有20个事件了呢？回调函数将会等待。它会排在其他事件之后——通常不能插队。这解释了为什么 <code>setTimeout(..)</code> 定时器的时间精度不高。只能保证（大体来说）回调函数不会在你指定的时间间隔之前执行，但可以在那个时间点或者之后才执行，这取决于事件队列的状态。</p>\n<p>换句话说，你的程序通常被分为许多小块，在事件循环队列中一个接一个的执行。其他和你的程序不直接相关的事件也可以被插入到队列中。</p>\n<p><strong>注意：</strong> 我们提到的 “直到最近” 是说ES6 从本质上改变了从何处管理事件循环队列。这主要是一个正式的技术细则，ES6 现在指明了事件循环的工作原理，这意味着从技术上来说，事件循环属于 JS 引擎的范畴，而不仅仅是宿主环境。这项改变的一个主要原因是 ES6 Promise 的引入，我们将在第三章讨论它，因为这项技术要去在事件循环队列的任务调度上做直接、细粒度的控制（见 “协作” 部分对 <code>setTimeout(..0)</code> 的讨论 ）。</p>\n<hr>\n<p>本系列下一部分将介绍并行线程。</p>\n"},{"title":"【译】异步：现在与将来（并发篇）","date":"2017-04-05T08:45:33.000Z","_content":"> 原文： https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\n译者：[熊贤仁](https://blog.skrskrskrskr.com)\n\n让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。\n\n**注意：** 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。\n\n当用户向下滚动页面后，第一个 “进程” 会响应 `onscroll` 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。\n\n显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 `onscroll` 事件被触发。因此你将得到快速触发并交错执行的`onscroll` 事件和 Ajax 响应事件。\n\n并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。\n\n**注意：** 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。\n\n对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：\n\n“进程” 1（`onscroll` 事件）:\n```\nonscroll, request 1\nonscroll, request 2\nonscroll, request 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nonscroll, request 7\n```\n“进程” 2（Ajax 响应事件）：\n```\nresponse 1\nresponse 2\nresponse 3\nresponse 4\nresponse 5\nresponse 6\nresponse 7\n```\n`onscroll` 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：\n```\nonscroll, request 1\nonscroll, request 2          response 1\nonscroll, request 3          response 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6          response 4\nonscroll, request 7\nresponse 6\nresponse 5\nresponse 7\n```\n但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，`onscroll` 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。\n\n我们设想所有这些事件在事件循环队列中交替执行。\n事件循环队列：\n```\nonscroll, request 1 <--- Process 1 starts\nonscroll, request 2\nresponse 1 <--- Process 2 starts\nonscroll, request 3\nresponse 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nresponse 4\nonscroll, request 7 <--- Process 1 finishes\nresponse 6\nresponse 5\nresponse 7 <--- Process 2 finishes\n```\n\n“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。\n\n顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？\n\n基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。\n\n### 非交互\n\n当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。**如果它们没有交互，程序的不确定性将相当低。**\n\n比如：\n```\nvar res = {};\n\nfunction foo(results) {\n\tres.foo = results;\n}\n\nfunction bar(results) {\n\tres.bar = results;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n\n`foo()` 和 `bar()` 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。\n\n这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。\n\n### 交互\n\n更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。\n\n这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序**有时会被破坏**：\n```\nvar res = [];\n\nfunction response(data) {\n\tres.push( data );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n并发 “进程” 是两个用于处理 Ajax 响应而调用的 `response()` 方法。它们任意一个都可以先执行。\n\n我们假设期待的行为是，`res[0]` 存放调用 `\"http://some.url.1\"` 的结果，`res[1]`存放调用 `\"http://some.url.2\"` 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。\n\n**注意：**  你要对这些情况保持极度警惕。比如，开发者如果观察到响应\n `\"http://some.url.2\"` **总是** 比 `\"http://some.url.1\"` 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。\n\n为了处理这种竞态条件，你可以调整交互顺序：\n```\nvar res = [];\n\nfunction response(data) {\n\tif (data.url == \"http://some.url.1\") {\n\t\tres[0] = data;\n\t}\n\telse if (data.url == \"http://some.url.2\") {\n\t\tres[1] = data;\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n无论先返回哪个 Ajax 响应，我们都要通过检查 `data.url` （当然，假设其中一个返回自服务器）来确定响应数据应该放在 `res` 数组的哪个位置。 `res[0]` 总是保存 `\"http://some.url.1\"` 返回的结果，`res[1]` 总是保存 `\"http://some.url.2\"` 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。\n\n如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 `<div>` 的内容，另一个更新 `<div>` 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。\n\n若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log(a + b);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n在这个例子中，不管是  `foo()` 还是 `bar()` 先执行，总是会造成 `baz()` 过早执行（`a` 和 `b` 都还是 `unfined`），但 `baz()` 的第二次调用会正常工作，因为 `a` 和 `b` 都已被初始化了。\n\n有多种方法可以处理此类情况。这里有一个简单的办法：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a + b );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n包裹着 `baz()` 调用的 `if (a && b)` 条件语句通常被称为一个 “门”，因为不确定 `a` 和`b` 的到达顺序，我们要在开门之前（调用 `baz()`）等待这两者的到达。\n\n另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。\n\n考虑这段有问题的代码：\n```\nvar a;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(x) {\n\ta = x / 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n无论哪个（`foo()` 或者 `bar()`）先执行，不仅 `a` 的赋值会被另一个覆盖，而且还会重复调用 `baz()` （很可能并不希望这样）。\n\n所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：\n```\nvar a;\n\nfunction foo(x) {\n\tif (a == undefined) {\n\t\ta = x * 2;\n\t\tbaz();\n\t}\n}\n\nfunction bar(x) {\n\tif (a == undefined) {\n\t\ta = x / 2;\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n`if (a == undefined)` 条件只会让 `foo()` 和 `bar()` 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！\n\n**注意：** 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。\n\n### 协作\n协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。\n\n举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 `Array.map(..)` 来简化代码：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `data` values doubled\n\t\tdata.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n如果 `\"http://some.url.1\"` 先得到返回结果，整个列表立即会被 map 进 `res`。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。\n\n当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(...) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。\n\n所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。\n\n这里有个很简单的方法：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// let's just do 1000 at a time\n\tvar chunk = data.splice( 0, 1000 );\n\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `chunk` values doubled\n\t\tchunk.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n\n\t// anything left to process?\n\tif (data.length > 0) {\n\t\t// async schedule next batch\n\t\tsetTimeout( function(){\n\t\t\tresponse( data );\n\t\t}, 0 );\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。\n\n当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 `res` 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。\n\n为了实现异步调度，我们使用了 `setTimeout(..0)`（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。\n\n**注意：** 严格来说，`setTimeout(..0)` 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 `setTimeout(..0)` 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 `process.nextTick(..)`。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。\n","source":"_posts/【译】异步：现在与将来（并发篇）.md","raw":"---\ntitle: 【译】异步：现在与将来（并发篇）\ndate: 2017-04-05 16:45:33\ntags:\n- 翻译\n- JavaScript\ncategories:\n- 前端\n---\n> 原文： https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\n译者：[熊贤仁](https://blog.skrskrskrskr.com)\n\n让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。\n\n**注意：** 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。\n\n当用户向下滚动页面后，第一个 “进程” 会响应 `onscroll` 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。\n\n显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 `onscroll` 事件被触发。因此你将得到快速触发并交错执行的`onscroll` 事件和 Ajax 响应事件。\n\n并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。\n\n**注意：** 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。\n\n对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：\n\n“进程” 1（`onscroll` 事件）:\n```\nonscroll, request 1\nonscroll, request 2\nonscroll, request 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nonscroll, request 7\n```\n“进程” 2（Ajax 响应事件）：\n```\nresponse 1\nresponse 2\nresponse 3\nresponse 4\nresponse 5\nresponse 6\nresponse 7\n```\n`onscroll` 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：\n```\nonscroll, request 1\nonscroll, request 2          response 1\nonscroll, request 3          response 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6          response 4\nonscroll, request 7\nresponse 6\nresponse 5\nresponse 7\n```\n但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，`onscroll` 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。\n\n我们设想所有这些事件在事件循环队列中交替执行。\n事件循环队列：\n```\nonscroll, request 1 <--- Process 1 starts\nonscroll, request 2\nresponse 1 <--- Process 2 starts\nonscroll, request 3\nresponse 2\nresponse 3\nonscroll, request 4\nonscroll, request 5\nonscroll, request 6\nresponse 4\nonscroll, request 7 <--- Process 1 finishes\nresponse 6\nresponse 5\nresponse 7 <--- Process 2 finishes\n```\n\n“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。\n\n顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？\n\n基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。\n\n### 非交互\n\n当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。**如果它们没有交互，程序的不确定性将相当低。**\n\n比如：\n```\nvar res = {};\n\nfunction foo(results) {\n\tres.foo = results;\n}\n\nfunction bar(results) {\n\tres.bar = results;\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n\n`foo()` 和 `bar()` 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。\n\n这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。\n\n### 交互\n\n更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。\n\n这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序**有时会被破坏**：\n```\nvar res = [];\n\nfunction response(data) {\n\tres.push( data );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n并发 “进程” 是两个用于处理 Ajax 响应而调用的 `response()` 方法。它们任意一个都可以先执行。\n\n我们假设期待的行为是，`res[0]` 存放调用 `\"http://some.url.1\"` 的结果，`res[1]`存放调用 `\"http://some.url.2\"` 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。\n\n**注意：**  你要对这些情况保持极度警惕。比如，开发者如果观察到响应\n `\"http://some.url.2\"` **总是** 比 `\"http://some.url.1\"` 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。\n\n为了处理这种竞态条件，你可以调整交互顺序：\n```\nvar res = [];\n\nfunction response(data) {\n\tif (data.url == \"http://some.url.1\") {\n\t\tres[0] = data;\n\t}\n\telse if (data.url == \"http://some.url.2\") {\n\t\tres[1] = data;\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n无论先返回哪个 Ajax 响应，我们都要通过检查 `data.url` （当然，假设其中一个返回自服务器）来确定响应数据应该放在 `res` 数组的哪个位置。 `res[0]` 总是保存 `\"http://some.url.1\"` 返回的结果，`res[1]` 总是保存 `\"http://some.url.2\"` 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。\n\n如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 `<div>` 的内容，另一个更新 `<div>` 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。\n\n若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log(a + b);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n在这个例子中，不管是  `foo()` 还是 `bar()` 先执行，总是会造成 `baz()` 过早执行（`a` 和 `b` 都还是 `unfined`），但 `baz()` 的第二次调用会正常工作，因为 `a` 和 `b` 都已被初始化了。\n\n有多种方法可以处理此类情况。这里有一个简单的办法：\n```\nvar a, b;\n\nfunction foo(x) {\n\ta = x * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction bar(y) {\n\tb = y * 2;\n\tif (a && b) {\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a + b );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n包裹着 `baz()` 调用的 `if (a && b)` 条件语句通常被称为一个 “门”，因为不确定 `a` 和`b` 的到达顺序，我们要在开门之前（调用 `baz()`）等待这两者的到达。\n\n另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。\n\n考虑这段有问题的代码：\n```\nvar a;\n\nfunction foo(x) {\n\ta = x * 2;\n\tbaz();\n}\n\nfunction bar(x) {\n\ta = x / 2;\n\tbaz();\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n无论哪个（`foo()` 或者 `bar()`）先执行，不仅 `a` 的赋值会被另一个覆盖，而且还会重复调用 `baz()` （很可能并不希望这样）。\n\n所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：\n```\nvar a;\n\nfunction foo(x) {\n\tif (a == undefined) {\n\t\ta = x * 2;\n\t\tbaz();\n\t}\n}\n\nfunction bar(x) {\n\tif (a == undefined) {\n\t\ta = x / 2;\n\t\tbaz();\n\t}\n}\n\nfunction baz() {\n\tconsole.log( a );\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", foo );\najax( \"http://some.url.2\", bar );\n```\n`if (a == undefined)` 条件只会让 `foo()` 和 `bar()` 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！\n\n**注意：** 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。\n\n### 协作\n协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。\n\n举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 `Array.map(..)` 来简化代码：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `data` values doubled\n\t\tdata.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n如果 `\"http://some.url.1\"` 先得到返回结果，整个列表立即会被 map 进 `res`。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。\n\n当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(...) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。\n\n所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。\n\n这里有个很简单的方法：\n```\nvar res = [];\n\n// `response(..)` receives array of results from the Ajax call\nfunction response(data) {\n\t// let's just do 1000 at a time\n\tvar chunk = data.splice( 0, 1000 );\n\n\t// add onto existing `res` array\n\tres = res.concat(\n\t\t// make a new transformed array with all `chunk` values doubled\n\t\tchunk.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n\n\t// anything left to process?\n\tif (data.length > 0) {\n\t\t// async schedule next batch\n\t\tsetTimeout( function(){\n\t\t\tresponse( data );\n\t\t}, 0 );\n\t}\n}\n\n// ajax(..) is some arbitrary Ajax function given by a library\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。\n\n当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 `res` 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。\n\n为了实现异步调度，我们使用了 `setTimeout(..0)`（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。\n\n**注意：** 严格来说，`setTimeout(..0)` 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 `setTimeout(..0)` 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 `process.nextTick(..)`。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。\n","slug":"【译】异步：现在与将来（并发篇）","published":1,"updated":"2019-12-29T09:19:29.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbk0068hns6p8n6wsqc","content":"<blockquote>\n<p>原文： <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency</a><br>译者：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n</blockquote>\n<p>让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。</p>\n<p><strong>注意：</strong> 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。</p>\n<p>当用户向下滚动页面后，第一个 “进程” 会响应 <code>onscroll</code> 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。</p>\n<p>显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 <code>onscroll</code> 事件被触发。因此你将得到快速触发并交错执行的<code>onscroll</code> 事件和 Ajax 响应事件。</p>\n<p>并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。</p>\n<p><strong>注意：</strong> 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。</p>\n<p>对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：</p>\n<p>“进程” 1（<code>onscroll</code> 事件）:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">onscroll, request 7</span><br></pre></td></tr></table></figure></p>\n<p>“进程” 2（Ajax 响应事件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">response 1</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">response 4</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p><code>onscroll</code> 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2          response 1</span><br><span class=\"line\">onscroll, request 3          response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6          response 4</span><br><span class=\"line\">onscroll, request 7</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p>但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，<code>onscroll</code> 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。</p>\n<p>我们设想所有这些事件在事件循环队列中交替执行。<br>事件循环队列：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1 &lt;--- Process 1 starts</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">response 1 &lt;--- Process 2 starts</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">response 4</span><br><span class=\"line\">onscroll, request 7 &lt;--- Process 1 finishes</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7 &lt;--- Process 2 finishes</span><br></pre></td></tr></table></figure></p>\n<p>“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。</p>\n<p>顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？</p>\n<p>基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。</p>\n<h3 id=\"非交互\"><a href=\"#非交互\" class=\"headerlink\" title=\"非交互\"></a>非交互</h3><p>当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。<strong>如果它们没有交互，程序的不确定性将相当低。</strong></p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(results) &#123;</span><br><span class=\"line\">\tres.foo = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(results) &#123;</span><br><span class=\"line\">\tres.bar = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>foo()</code> 和 <code>bar()</code> 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。</p>\n<p>这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。</p>\n<h3 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h3><p>更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。</p>\n<p>这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序<strong>有时会被破坏</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tres.push( data );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>并发 “进程” 是两个用于处理 Ajax 响应而调用的 <code>response()</code> 方法。它们任意一个都可以先执行。</p>\n<p>我们假设期待的行为是，<code>res[0]</code> 存放调用 <code>&quot;http://some.url.1&quot;</code> 的结果，<code>res[1]</code>存放调用 <code>&quot;http://some.url.2&quot;</code> 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。</p>\n<p><strong>注意：</strong>  你要对这些情况保持极度警惕。比如，开发者如果观察到响应<br> <code>&quot;http://some.url.2&quot;</code> <strong>总是</strong> 比 <code>&quot;http://some.url.1&quot;</code> 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。</p>\n<p>为了处理这种竞态条件，你可以调整交互顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tif (data.url == &quot;http://some.url.1&quot;) &#123;</span><br><span class=\"line\">\t\tres[0] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if (data.url == &quot;http://some.url.2&quot;) &#123;</span><br><span class=\"line\">\t\tres[1] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>无论先返回哪个 Ajax 响应，我们都要通过检查 <code>data.url</code> （当然，假设其中一个返回自服务器）来确定响应数据应该放在 <code>res</code> 数组的哪个位置。 <code>res[0]</code> 总是保存 <code>&quot;http://some.url.1&quot;</code> 返回的结果，<code>res[1]</code> 总是保存 <code>&quot;http://some.url.2&quot;</code> 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。</p>\n<p>如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 <code>&lt;div&gt;</code> 的内容，另一个更新 <code>&lt;div&gt;</code> 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。</p>\n<p>若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log(a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，不管是  <code>foo()</code> 还是 <code>bar()</code> 先执行，总是会造成 <code>baz()</code> 过早执行（<code>a</code> 和 <code>b</code> 都还是 <code>unfined</code>），但 <code>baz()</code> 的第二次调用会正常工作，因为 <code>a</code> 和 <code>b</code> 都已被初始化了。</p>\n<p>有多种方法可以处理此类情况。这里有一个简单的办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>包裹着 <code>baz()</code> 调用的 <code>if (a &amp;&amp; b)</code> 条件语句通常被称为一个 “门”，因为不确定 <code>a</code> 和<code>b</code> 的到达顺序，我们要在开门之前（调用 <code>baz()</code>）等待这两者的到达。</p>\n<p>另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。</p>\n<p>考虑这段有问题的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\ta = x / 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>无论哪个（<code>foo()</code> 或者 <code>bar()</code>）先执行，不仅 <code>a</code> 的赋值会被另一个覆盖，而且还会重复调用 <code>baz()</code> （很可能并不希望这样）。</p>\n<p>所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x * 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x / 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>if (a == undefined)</code> 条件只会让 <code>foo()</code> 和 <code>bar()</code> 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！</p>\n<p><strong>注意：</strong> 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。</p>\n<h3 id=\"协作\"><a href=\"#协作\" class=\"headerlink\" title=\"协作\"></a>协作</h3><p>协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。</p>\n<p>举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 <code>Array.map(..)</code> 来简化代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `data` values doubled</span><br><span class=\"line\">\t\tdata.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>&quot;http://some.url.1&quot;</code> 先得到返回结果，整个列表立即会被 map 进 <code>res</code>。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。</p>\n<p>当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(…) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。</p>\n<p>所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。</p>\n<p>这里有个很简单的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// let&apos;s just do 1000 at a time</span><br><span class=\"line\">\tvar chunk = data.splice( 0, 1000 );</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `chunk` values doubled</span><br><span class=\"line\">\t\tchunk.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// anything left to process?</span><br><span class=\"line\">\tif (data.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// async schedule next batch</span><br><span class=\"line\">\t\tsetTimeout( function()&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, 0 );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。</p>\n<p>当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 <code>res</code> 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。</p>\n<p>为了实现异步调度，我们使用了 <code>setTimeout(..0)</code>（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。</p>\n<p><strong>注意：</strong> 严格来说，<code>setTimeout(..0)</code> 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 <code>setTimeout(..0)</code> 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 <code>process.nextTick(..)</code>。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文： <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency\" target=\"_blank\" rel=\"noopener\">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md#concurrency</a><br>译者：<a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n</blockquote>\n<p>让我们想象有个网站，展示状态更新的列表（类似社交网络信息流），当用户下滑列表时，渐进式地加载数据。为了让这一特性正确工作，（至少）两个独立的 “进程” 需要同时执行（也就是说，在同一段窗口时间下，而不必是同一时刻）。</p>\n<p><strong>注意：</strong> 我们使用了给 “进程” 加了引号，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，用来表示一系列逻辑相关的连续的操作。我们简单地使用了 “进程” 而不是 “任务”，因为这个术语更加匹配我们正在探讨的定义。</p>\n<p>当用户向下滚动页面后，第一个 “进程” 会响应 <code>onscroll</code> 事件（发起 Ajax 请求去获取新内容）。第二个 “进程” 会接收 Ajax 返回的响应（去渲染内容到页面上）。</p>\n<p>显然，如果用户向下滚动页面足够快的话，你可能在页面接收到第一个响应并处理时，看到不止一个 <code>onscroll</code> 事件被触发。因此你将得到快速触发并交错执行的<code>onscroll</code> 事件和 Ajax 响应事件。</p>\n<p>并发是在同一段时间内两个或多个 “进程” 同时运行，不管它们的独立构成的运算是否 “并行” （多个独立的处理器或核心同一时刻）执行。你可以把并发看作是 “进程” 级（或者任务级）的并行化，这与运算级的并行化（多个独立处理器线程）是截然相反的。</p>\n<p><strong>注意：</strong> 并发也引入了这些相互作用的 “进程”间的一个可选的概念。我们将随后介绍它。</p>\n<p>对于给定的一段窗口时间（用户滚动页面的几秒内），我们把每个独立的 “进程” 看作是一系列事件或运算：</p>\n<p>“进程” 1（<code>onscroll</code> 事件）:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">onscroll, request 7</span><br></pre></td></tr></table></figure></p>\n<p>“进程” 2（Ajax 响应事件）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">response 1</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">response 4</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p><code>onscroll</code> 事件和 Ajax 响应事件很可能在同一时刻准备执行。举个例子，让我们设想这些事件在一个时间线上：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1</span><br><span class=\"line\">onscroll, request 2          response 1</span><br><span class=\"line\">onscroll, request 3          response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6          response 4</span><br><span class=\"line\">onscroll, request 7</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7</span><br></pre></td></tr></table></figure></p>\n<p>但是，回到我们之前章节讲过的事件循环的概念，JS 同一时刻只能处理一个事件，<code>onscroll</code> 事件也不例外。要么请求 2 先执行，要么响应 1 先执行，但它们字面上不能同时执行。就像学校食堂的孩子们，不管门外挤进了多少人，他们也必须排队取餐。</p>\n<p>我们设想所有这些事件在事件循环队列中交替执行。<br>事件循环队列：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">onscroll, request 1 &lt;--- Process 1 starts</span><br><span class=\"line\">onscroll, request 2</span><br><span class=\"line\">response 1 &lt;--- Process 2 starts</span><br><span class=\"line\">onscroll, request 3</span><br><span class=\"line\">response 2</span><br><span class=\"line\">response 3</span><br><span class=\"line\">onscroll, request 4</span><br><span class=\"line\">onscroll, request 5</span><br><span class=\"line\">onscroll, request 6</span><br><span class=\"line\">response 4</span><br><span class=\"line\">onscroll, request 7 &lt;--- Process 1 finishes</span><br><span class=\"line\">response 6</span><br><span class=\"line\">response 5</span><br><span class=\"line\">response 7 &lt;--- Process 2 finishes</span><br></pre></td></tr></table></figure></p>\n<p>“进程 1” 和 “进程 2” 并发运行（任务级并发），而他们独立的事件在事件循环队列中按序运行。</p>\n<p>顺便说一下，注意到响应 6 和响应 5 那令人意外的顺序了吗？</p>\n<p>基于单线程的事件循环是一种并发的形式（当然还有其他的，我们后面讲介绍）。</p>\n<h3 id=\"非交互\"><a href=\"#非交互\" class=\"headerlink\" title=\"非交互\"></a>非交互</h3><p>当两个或多个 “进程” 在同一个程序内并发地交替执行它们的步骤或事件，如果彼此任务不相关，它们不必有交互。<strong>如果它们没有交互，程序的不确定性将相当低。</strong></p>\n<p>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(results) &#123;</span><br><span class=\"line\">\tres.foo = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(results) &#123;</span><br><span class=\"line\">\tres.bar = results;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>foo()</code> 和 <code>bar()</code> 是两个并发 “进程”，它们哪个先执行是不确定的。但它们的执行顺序对这段程序来说都无关紧要的，因为它们是独立执行的，故不需要交互。</p>\n<p>这不是一个 “竞态条件” bug，不管执行顺序如何，因为这段代码总是正常工作。</p>\n<h3 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h3><p>更常见的是，并发 “进程” 直接通过作用域和 DOM 进行必要的交互。如前面所述，你需要协调这些交互，从而防止 “竞态条件”。</p>\n<p>这里有个简单的例子，有两个并发 “进程”，它们由于隐含的排列顺序而产生交互，这个顺序<strong>有时会被破坏</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tres.push( data );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>并发 “进程” 是两个用于处理 Ajax 响应而调用的 <code>response()</code> 方法。它们任意一个都可以先执行。</p>\n<p>我们假设期待的行为是，<code>res[0]</code> 存放调用 <code>&quot;http://some.url.1&quot;</code> 的结果，<code>res[1]</code>存放调用 <code>&quot;http://some.url.2&quot;</code> 的结果。但有时并非如此，这取决于哪个调用先结束。这种不确定性很可能就是一个 “竞态条件” bug。</p>\n<p><strong>注意：</strong>  你要对这些情况保持极度警惕。比如，开发者如果观察到响应<br> <code>&quot;http://some.url.2&quot;</code> <strong>总是</strong> 比 <code>&quot;http://some.url.1&quot;</code> 慢得多，这可能是由于它们处理的任务不同（比如，一个执行数据库任务，另一个只是在获取某个静态文件），因此观察到的执行顺序看起来总是在我们意料之中。即使这两个请求都访问同一个服务器，然后按照确定的顺序返回响应，也不能完全保证浏览器中响应返回的顺序。</p>\n<p>为了处理这种竞态条件，你可以调整交互顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\tif (data.url == &quot;http://some.url.1&quot;) &#123;</span><br><span class=\"line\">\t\tres[0] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse if (data.url == &quot;http://some.url.2&quot;) &#123;</span><br><span class=\"line\">\t\tres[1] = data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>无论先返回哪个 Ajax 响应，我们都要通过检查 <code>data.url</code> （当然，假设其中一个返回自服务器）来确定响应数据应该放在 <code>res</code> 数组的哪个位置。 <code>res[0]</code> 总是保存 <code>&quot;http://some.url.1&quot;</code> 返回的结果，<code>res[1]</code> 总是保存 <code>&quot;http://some.url.2&quot;</code> 的结果。通过简单的调整，我们排除了 “竞态条件” 不确定性。</p>\n<p>如果调用了多个并发函数，这些函数通过共享内存产生交互，上面场景下的论证也可以得到应用。比如其中一个更新一个 <code>&lt;div&gt;</code> 的内容，另一个更新 <code>&lt;div&gt;</code> 的样式或属性（比如，一旦 DOM 元素有内容，就使其可见）。你可能不想在 DOM 元素有内容之前展示它，那么调整必须保证正确的交互顺序。</p>\n<p>若没有调整交互顺序，有些并发场景总是会出错（并非偶尔），考虑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log(a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，不管是  <code>foo()</code> 还是 <code>bar()</code> 先执行，总是会造成 <code>baz()</code> 过早执行（<code>a</code> 和 <code>b</code> 都还是 <code>unfined</code>），但 <code>baz()</code> 的第二次调用会正常工作，因为 <code>a</code> 和 <code>b</code> 都已被初始化了。</p>\n<p>有多种方法可以处理此类情况。这里有一个简单的办法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(y) &#123;</span><br><span class=\"line\">\tb = y * 2;</span><br><span class=\"line\">\tif (a &amp;&amp; b) &#123;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>包裹着 <code>baz()</code> 调用的 <code>if (a &amp;&amp; b)</code> 条件语句通常被称为一个 “门”，因为不确定 <code>a</code> 和<code>b</code> 的到达顺序，我们要在开门之前（调用 <code>baz()</code>）等待这两者的到达。</p>\n<p>另一种可能遇到的并发交互条件有时被称为 “竞态”（race），更准确的说应该是 “门闩”（latch）。它的特征是 “先到先赢” 行为。这里，不确定性是可接受的，因为你明确说明了 “竞态” 中为了成为那个唯一的赢家，需要竞争到终点。</p>\n<p>考虑这段有问题的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\ta = x * 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\ta = x / 2;</span><br><span class=\"line\">\tbaz();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p>无论哪个（<code>foo()</code> 或者 <code>bar()</code>）先执行，不仅 <code>a</code> 的赋值会被另一个覆盖，而且还会重复调用 <code>baz()</code> （很可能并不希望这样）。</p>\n<p>所以，我们可以通过一个简单的门闩来调整交互过程，以只让第一个通过：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x * 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(x) &#123;</span><br><span class=\"line\">\tif (a == undefined) &#123;</span><br><span class=\"line\">\t\ta = x / 2;</span><br><span class=\"line\">\t\tbaz();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function baz() &#123;</span><br><span class=\"line\">\tconsole.log( a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, foo );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, bar );</span><br></pre></td></tr></table></figure></p>\n<p><code>if (a == undefined)</code> 条件只会让 <code>foo()</code> 和 <code>bar()</code> 中的第一个通过，第二个调用（事实上是任何后续调用的）的会被忽略。第二名并不光荣！</p>\n<p><strong>注意：</strong> 在以上所有场景中，我们都使用了全局变量来做简单的示范，但对于我们的论证来说，这样做并不是必要的。只要问题中的函数可以访问变量（通过作用域），它们都会正常工作。依赖于词法作用域变量（见本书的作用域和闭包部分），以上例子中的全局变量，事实上对于那些并发调整来说是一个明显的负面因素。随着后面章节的展开，我们会看到更多种干净得多的调整方式。</p>\n<h3 id=\"协作\"><a href=\"#协作\" class=\"headerlink\" title=\"协作\"></a>协作</h3><p>协调并发的另一个形式被称为 “协作式并发”。在这里，我们要关注的点不再是通过共享作用域内的值来进行交互（尽管这显然也是可以的）。通过使用一个长期运行的 “进程” ，并把 “进程” 分成多个步骤或批次，并发 “进程” 可以在事件循环队列中交叉执行它们的各种操作。</p>\n<p>举个例子，考虑一个 Ajax 响应处理器，它需要遍历一长串结果列表来转换值。我们会使用 <code>Array.map(..)</code> 来简化代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `data` values doubled</span><br><span class=\"line\">\t\tdata.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>&quot;http://some.url.1&quot;</code> 先得到返回结果，整个列表立即会被 map 进 <code>res</code>。如果只有几千或者更少的数据，通常问题不大。但如果说有个一千万条数据，这需要运行好一会儿（性能不错的笔记本上要几秒种，移动设备上会久得多，等待）。</p>\n<p>当这样一个 “进程” 在运行，页面中的其他任务就可以去一边呆着了，包括没有其他的response(…) 函数调用，没有任何 UI 更新，甚至像滚动、输入、按钮点击这样的用户事件也没法工作了。这相当痛苦。</p>\n<p>所以，为了实现一个协作更好的并发系统，它更友好，而且不会霸占事件循环队列，你可以异步地批处理这些结果，每次 “yielding” 后返回事件循环，让其他等待事件执行。</p>\n<p>这里有个很简单的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">// `response(..)` receives array of results from the Ajax call</span><br><span class=\"line\">function response(data) &#123;</span><br><span class=\"line\">\t// let&apos;s just do 1000 at a time</span><br><span class=\"line\">\tvar chunk = data.splice( 0, 1000 );</span><br><span class=\"line\"></span><br><span class=\"line\">\t// add onto existing `res` array</span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t// make a new transformed array with all `chunk` values doubled</span><br><span class=\"line\">\t\tchunk.map( function(val)&#123;</span><br><span class=\"line\">\t\t\treturn val * 2;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// anything left to process?</span><br><span class=\"line\">\tif (data.length &gt; 0) &#123;</span><br><span class=\"line\">\t\t// async schedule next batch</span><br><span class=\"line\">\t\tsetTimeout( function()&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, 0 );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ajax(..) is some arbitrary Ajax function given by a library</span><br><span class=\"line\">ajax( &quot;http://some.url.1&quot;, response );</span><br><span class=\"line\">ajax( &quot;http://some.url.2&quot;, response );</span><br></pre></td></tr></table></figure></p>\n<p>我们把数据集处理成一些最大容量为 1000 的块。这样做可以保证 “进程” 运行时间比较短，即使这样也意味着会有更多后续的 “进程”，因为事件循环队列的交叉执行会提升网站/APP 的响应性能。</p>\n<p>当然，我们没有针对这些 “进程” 的执行顺序做任何的交互调整，因此 <code>res</code> 中结果的顺序将是不确定的。如果要求保证顺序，你需要使用像我们前面讨论过的交互技巧，或者本书后面章节要介绍的技术。</p>\n<p>为了实现异步调度，我们使用了 <code>setTimeout(..0)</code>（hack），基本上，这里的意思是 “把这个函数插入到事件循环队列的末尾”。</p>\n<p><strong>注意：</strong> 严格来说，<code>setTimeout(..0)</code> 并没有直接往事件循环队列插入处理函数。定时器将在有机会的情况下插入事件。比如说，两个相继的 <code>setTimeout(..0)</code> 调用并不能严格保证按照调用顺序处理，所以可以各种不同的情况都可能发生，比如定时器漂移，这时这些事件是不可预测的。Node.js 中，一个相似的方法是 <code>process.nextTick(..)</code>。尽管这很方便（通常性能也更好），但还没有直接的方法（至少现在还没有）可以跨所有环境来保证异步事件顺序。我们会在下一节深入讨论这个话题。</p>\n"},{"title":"【译】使用 Script-Streaming 提升页面加载性能","date":"2018-08-29T13:08:48.000Z","_content":"\n# script-streaming 是什么？\n\n加载 JavaScript 算是 web 性能最严重的瓶颈之一，尤其在低端 CPU 上情况更糟糕。加载 JavaScript 的性能损耗不仅包括从服务器上下载数据的网络时间，也包括文件解压、解析、编译，以及执行 JavaScript 的时间。为了更好的用户体验，web 页面[大量的 JavaScript 代码数量持续地增长](https://mobile.httparchive.org/trends.php?s=Top1000&minlabel=Jun+1+2011&maxlabel=Jun+15+2018#bytesJS&reqJS)，页面加载变得越来越慢。浏览器社区一直在开发很多优化措施来提升 JavaScript 加载速度，比如将解析 JavaScript 文件和下载过程并行化（在此之前，浏览器会等待 JavaScript 文件完全下载后才会在渲染主线程上进行解析）。这项优化措施就是 [script-streaming](https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html)，它在 Chrome v41 上被引入。Google 声称 script-streaming 能够将页面加载速度提升 10%，因为大型 JavaScript 文件会边下载边解析，这可以减少数百毫秒的页面加载时间。\n\nScript-streaming 是为加速 JavaScript 解析而做的一项巨大的优化。然而，Chrome 针对 JavaScript 文件启用 script-streaming 还有一些限制。\n \n* 首先，下载的 JavaScript 文件大小[至少 30KB](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer.cc?dr=C&sq=package:chromium&l=325)。这个尺寸限制确保了只有大型 JS 文件能够通过 script-streaming 解析，因为相比于较小的 JavaScript 文件，并行下载和解析大型 JavaScript 文件的收益最大。\n\n* 其次，目前 Chrome 在 script-streaming 的实现上，同一时刻 script-streaming 只能应用到一个 JavaScript 文件上。这是由于 [Chrome 对于 script-streaming 只使用了单线程](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&q=scriptstream&g=0&l=49)。既然这个线程忙于解析某个 JavaScript 文件，那么其他 JavaScript 文件就必须在主线程下载完成后，才能进行解析。\n\n# web 开发者如何利用 script-streaming ?\n\nscript-streaming 加速了 JavaScript 的解析。作为一个 web 开发者，你不必为了在页面上启用 script-streaming 做任何事情。然而，script-streaming 还是有一些限制的，这些限制只存在于 Chrome，它们是由于 Chrome 的实现造成的。具体来说，当大型 JavaScript 文件下载完成，script-streaming 线程不保证一定可用。同样地，页面并行下载多个大型 JavaScript 文件，只有一个文件能够通过 script-streaming 解析。并且，某些情况下，script-streaming 可能解析较小的脚本文件，而较大的脚本只能等待 script-streaming 线程可用，或者在\b完成下载后，由主线程进行解析。\n\n开发者可以使用 [performance 开发者工具](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference)来研究 script-streaming 是否被用于解析大型 JavaScript 文件，因为这项技术可以显著提升页面性能。下图是 [www.akamai.com](http://www.akamai.com) 在 performance 面板上的一个截图，脚本就是被红框里的 ScriptStreamer 线程解析的。\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/1.png)\n\n# 提升解析速度的两种方法\n\n我做了一些研究，为了启用 script-streaming，可以解析较小的 JavaScript 文件（仍然大于 30KB）,这样在解析相对较大的 JavaScript 文件时，保持线程是可用的。理论上，可以在大型 JavaScript 文件上发送一个 HTTP 响应头，告诉浏览器在具有这种响应头的文件上应用 script-streaming。然而，这个方法要求主流浏览器作出调整，并\b且能让 script-streaming 利用多线程，而不仅仅是单线程。\b值得注意的是，目前 使用多个 script-streaming 线程在 Chrome 团队内部\b依然是 [TODO](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&q=scriptstream&g=0&l=50) 状态。\n\n一个比较实用的，执行起来简单得多，并且不需要浏览器改变的技巧，是重新\b排序 HTML 中那些加载静态资源 URL 的 `<script>` 标签的位置，以让大的 JavaScript 文件在较小（仍然大于 30KB）\b文件之前下载。当 script-streaming 可用时，此方法会强制解析大型 JavaScript \b文件。重新排序 `<script>` 标签在\b HTML 中的位置，可能\b存在潜在风险。因为为了保持页面的功能和 UI，一些 JavaScript 必须按顺序执行。因此，在重新排序时必须要谨慎。**重新排序那些带上=有 **async** 或者 **defer** 属性的 `<script>` 标签会保险一些，因为这些脚本执行并不依赖于执行顺序**。由于脚本\b重排序伴随着种种限制，这项实验性的方法将只在指定的网站上生效。除了\b脚本重排序之外，我加进来的另一个方法是，将多个大型 JavaScript 文件并行下载，让它们竞争 script-streaming 线程。我将所有这样的 JavaScript 文件串联起来\b，目的是让他们都可以实现边下载边解析。\n\n# \b实验结果\n\n我做了一些实验，去衡量上述两个方法在多个设备上的页面加载时间，包括 MacBook Pro，一个低端移动设备（Motorola Moto E），和一个高端移动设备（Motorola Moto G）。性能数据通过一个[私有网页测试实例](https://docs.google.com/document/d/1-UKw2FO3YNqS5CjRHrPOwbHjGOIoISd4hGJZ6L7Hws0/edit?usp=sharing).收集。在两个手动修改的网站（“Page A” 和 “Page B”，\b详情见下表）集合上，观察到在多个移动设备和 MacBook Pro 上，对于中等规模的页面\b有多达 6.2% 的页面加载时间提升。这些性能提升要归功于 JavaScript 解析和下载\b的并行化。\n\n**Page** | **\\资源数** | **页面大小** | **\\#JavaScript 资源数** | ** JavaScript 总大小**\n---- | ---- | ---- | ---- | ---- \nA|41|2.7 MB|12|1.3 MB\nB|95|2.2 MB|19|1.1 MB\n\n## MacBook Pro 上的性能\n\n\b图 1 和图 2 展示了在一台 MacBook Pro 上，两个测试页面加载时间的 [CDF](https://www.andata.at/en/software-blog-reader/why-we-love-the-cdf-and-do-not-like-histograms-that-much.html)  分布。页面 A 上，重新排序 script 标签在 HTML 中的位置的页面加载时间减少了 6.2%。页面 B 上，加载重新排序的 scrip 标签的页面加载时间减少了 4.5%。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/2.png)\n\n\n##  Motorola Moto E 上的性能\n\n正如下图所示，重排序 script 标签的页面 A 的加载时间减少了 4.3%。\n\n页面 B（没有示例图）上没有出现更快的加载速度，这可能是因为在 Moto E 设备上，当移动版页面 A 加载时， \bscript-streaming 线程被占用了。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/3.png)\n\n\n\n## Motorola Moto G 上的性能\n\n如下图所示，重排序 script 标签的页面 A 的加载时间减少了 3.5%。\n\n页面 B 上，中等规模页面的加载时间减少了 1.9%。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/4.png)\n\n\n# 总结\n\n本文描述的实验性工作\b举例说明了相比默认的解析，通过 script-streaming 解析较大 JavaScript 文件带来的好处。实验包含重排序 HTML 中的 `<script>` 标签，以及串联多个大型 JavaScript 文件，让它们并行下载，以允许相对较大的文件能够通过 script-streaming 解析。实验结果显示\b，在 MacBook Pro 和\b两个低端和高端的移动设备上，对于中等大小的页面，加载速度有多达 6% 的提升。\n\n---------\n> \b原文作者： [Utkarsh Goel](https://www.utkarshgoel.in/)\n> 原文：https://developer.akamai.com/blog/2018/07/17/experiment-improving-page-load-times-script-streaming\n> 译者： [熊贤仁](https://blog.skrskrskrskr.com)\n\n","source":"_posts/【译】使用Script-Streaming提升页面加载性能.md","raw":"---\ntitle: 【译】使用 Script-Streaming 提升页面加载性能\ndate: 2018-08-29 21:08:48\ntags:\n- 翻译\n- Chrome\ncategories:\n- 前端\n---\n\n# script-streaming 是什么？\n\n加载 JavaScript 算是 web 性能最严重的瓶颈之一，尤其在低端 CPU 上情况更糟糕。加载 JavaScript 的性能损耗不仅包括从服务器上下载数据的网络时间，也包括文件解压、解析、编译，以及执行 JavaScript 的时间。为了更好的用户体验，web 页面[大量的 JavaScript 代码数量持续地增长](https://mobile.httparchive.org/trends.php?s=Top1000&minlabel=Jun+1+2011&maxlabel=Jun+15+2018#bytesJS&reqJS)，页面加载变得越来越慢。浏览器社区一直在开发很多优化措施来提升 JavaScript 加载速度，比如将解析 JavaScript 文件和下载过程并行化（在此之前，浏览器会等待 JavaScript 文件完全下载后才会在渲染主线程上进行解析）。这项优化措施就是 [script-streaming](https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html)，它在 Chrome v41 上被引入。Google 声称 script-streaming 能够将页面加载速度提升 10%，因为大型 JavaScript 文件会边下载边解析，这可以减少数百毫秒的页面加载时间。\n\nScript-streaming 是为加速 JavaScript 解析而做的一项巨大的优化。然而，Chrome 针对 JavaScript 文件启用 script-streaming 还有一些限制。\n \n* 首先，下载的 JavaScript 文件大小[至少 30KB](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer.cc?dr=C&sq=package:chromium&l=325)。这个尺寸限制确保了只有大型 JS 文件能够通过 script-streaming 解析，因为相比于较小的 JavaScript 文件，并行下载和解析大型 JavaScript 文件的收益最大。\n\n* 其次，目前 Chrome 在 script-streaming 的实现上，同一时刻 script-streaming 只能应用到一个 JavaScript 文件上。这是由于 [Chrome 对于 script-streaming 只使用了单线程](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&q=scriptstream&g=0&l=49)。既然这个线程忙于解析某个 JavaScript 文件，那么其他 JavaScript 文件就必须在主线程下载完成后，才能进行解析。\n\n# web 开发者如何利用 script-streaming ?\n\nscript-streaming 加速了 JavaScript 的解析。作为一个 web 开发者，你不必为了在页面上启用 script-streaming 做任何事情。然而，script-streaming 还是有一些限制的，这些限制只存在于 Chrome，它们是由于 Chrome 的实现造成的。具体来说，当大型 JavaScript 文件下载完成，script-streaming 线程不保证一定可用。同样地，页面并行下载多个大型 JavaScript 文件，只有一个文件能够通过 script-streaming 解析。并且，某些情况下，script-streaming 可能解析较小的脚本文件，而较大的脚本只能等待 script-streaming 线程可用，或者在\b完成下载后，由主线程进行解析。\n\n开发者可以使用 [performance 开发者工具](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference)来研究 script-streaming 是否被用于解析大型 JavaScript 文件，因为这项技术可以显著提升页面性能。下图是 [www.akamai.com](http://www.akamai.com) 在 performance 面板上的一个截图，脚本就是被红框里的 ScriptStreamer 线程解析的。\n\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/1.png)\n\n# 提升解析速度的两种方法\n\n我做了一些研究，为了启用 script-streaming，可以解析较小的 JavaScript 文件（仍然大于 30KB）,这样在解析相对较大的 JavaScript 文件时，保持线程是可用的。理论上，可以在大型 JavaScript 文件上发送一个 HTTP 响应头，告诉浏览器在具有这种响应头的文件上应用 script-streaming。然而，这个方法要求主流浏览器作出调整，并\b且能让 script-streaming 利用多线程，而不仅仅是单线程。\b值得注意的是，目前 使用多个 script-streaming 线程在 Chrome 团队内部\b依然是 [TODO](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&q=scriptstream&g=0&l=50) 状态。\n\n一个比较实用的，执行起来简单得多，并且不需要浏览器改变的技巧，是重新\b排序 HTML 中那些加载静态资源 URL 的 `<script>` 标签的位置，以让大的 JavaScript 文件在较小（仍然大于 30KB）\b文件之前下载。当 script-streaming 可用时，此方法会强制解析大型 JavaScript \b文件。重新排序 `<script>` 标签在\b HTML 中的位置，可能\b存在潜在风险。因为为了保持页面的功能和 UI，一些 JavaScript 必须按顺序执行。因此，在重新排序时必须要谨慎。**重新排序那些带上=有 **async** 或者 **defer** 属性的 `<script>` 标签会保险一些，因为这些脚本执行并不依赖于执行顺序**。由于脚本\b重排序伴随着种种限制，这项实验性的方法将只在指定的网站上生效。除了\b脚本重排序之外，我加进来的另一个方法是，将多个大型 JavaScript 文件并行下载，让它们竞争 script-streaming 线程。我将所有这样的 JavaScript 文件串联起来\b，目的是让他们都可以实现边下载边解析。\n\n# \b实验结果\n\n我做了一些实验，去衡量上述两个方法在多个设备上的页面加载时间，包括 MacBook Pro，一个低端移动设备（Motorola Moto E），和一个高端移动设备（Motorola Moto G）。性能数据通过一个[私有网页测试实例](https://docs.google.com/document/d/1-UKw2FO3YNqS5CjRHrPOwbHjGOIoISd4hGJZ6L7Hws0/edit?usp=sharing).收集。在两个手动修改的网站（“Page A” 和 “Page B”，\b详情见下表）集合上，观察到在多个移动设备和 MacBook Pro 上，对于中等规模的页面\b有多达 6.2% 的页面加载时间提升。这些性能提升要归功于 JavaScript 解析和下载\b的并行化。\n\n**Page** | **\\资源数** | **页面大小** | **\\#JavaScript 资源数** | ** JavaScript 总大小**\n---- | ---- | ---- | ---- | ---- \nA|41|2.7 MB|12|1.3 MB\nB|95|2.2 MB|19|1.1 MB\n\n## MacBook Pro 上的性能\n\n\b图 1 和图 2 展示了在一台 MacBook Pro 上，两个测试页面加载时间的 [CDF](https://www.andata.at/en/software-blog-reader/why-we-love-the-cdf-and-do-not-like-histograms-that-much.html)  分布。页面 A 上，重新排序 script 标签在 HTML 中的位置的页面加载时间减少了 6.2%。页面 B 上，加载重新排序的 scrip 标签的页面加载时间减少了 4.5%。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/2.png)\n\n\n##  Motorola Moto E 上的性能\n\n正如下图所示，重排序 script 标签的页面 A 的加载时间减少了 4.3%。\n\n页面 B（没有示例图）上没有出现更快的加载速度，这可能是因为在 Moto E 设备上，当移动版页面 A 加载时， \bscript-streaming 线程被占用了。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/3.png)\n\n\n\n## Motorola Moto G 上的性能\n\n如下图所示，重排序 script 标签的页面 A 的加载时间减少了 3.5%。\n\n页面 B 上，中等规模页面的加载时间减少了 1.9%。\n![](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/4.png)\n\n\n# 总结\n\n本文描述的实验性工作\b举例说明了相比默认的解析，通过 script-streaming 解析较大 JavaScript 文件带来的好处。实验包含重排序 HTML 中的 `<script>` 标签，以及串联多个大型 JavaScript 文件，让它们并行下载，以允许相对较大的文件能够通过 script-streaming 解析。实验结果显示\b，在 MacBook Pro 和\b两个低端和高端的移动设备上，对于中等大小的页面，加载速度有多达 6% 的提升。\n\n---------\n> \b原文作者： [Utkarsh Goel](https://www.utkarshgoel.in/)\n> 原文：https://developer.akamai.com/blog/2018/07/17/experiment-improving-page-load-times-script-streaming\n> 译者： [熊贤仁](https://blog.skrskrskrskr.com)\n\n","slug":"【译】使用Script-Streaming提升页面加载性能","published":1,"updated":"2019-12-29T11:28:13.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbl006chns6j8atbaww","content":"<h1 id=\"script-streaming-是什么？\"><a href=\"#script-streaming-是什么？\" class=\"headerlink\" title=\"script-streaming 是什么？\"></a>script-streaming 是什么？</h1><p>加载 JavaScript 算是 web 性能最严重的瓶颈之一，尤其在低端 CPU 上情况更糟糕。加载 JavaScript 的性能损耗不仅包括从服务器上下载数据的网络时间，也包括文件解压、解析、编译，以及执行 JavaScript 的时间。为了更好的用户体验，web 页面<a href=\"https://mobile.httparchive.org/trends.php?s=Top1000&amp;minlabel=Jun+1+2011&amp;maxlabel=Jun+15+2018#bytesJS&amp;reqJS\" target=\"_blank\" rel=\"noopener\">大量的 JavaScript 代码数量持续地增长</a>，页面加载变得越来越慢。浏览器社区一直在开发很多优化措施来提升 JavaScript 加载速度，比如将解析 JavaScript 文件和下载过程并行化（在此之前，浏览器会等待 JavaScript 文件完全下载后才会在渲染主线程上进行解析）。这项优化措施就是 <a href=\"https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html\" target=\"_blank\" rel=\"noopener\">script-streaming</a>，它在 Chrome v41 上被引入。Google 声称 script-streaming 能够将页面加载速度提升 10%，因为大型 JavaScript 文件会边下载边解析，这可以减少数百毫秒的页面加载时间。</p>\n<p>Script-streaming 是为加速 JavaScript 解析而做的一项巨大的优化。然而，Chrome 针对 JavaScript 文件启用 script-streaming 还有一些限制。</p>\n<ul>\n<li><p>首先，下载的 JavaScript 文件大小<a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer.cc?dr=C&amp;sq=package:chromium&amp;l=325\" target=\"_blank\" rel=\"noopener\">至少 30KB</a>。这个尺寸限制确保了只有大型 JS 文件能够通过 script-streaming 解析，因为相比于较小的 JavaScript 文件，并行下载和解析大型 JavaScript 文件的收益最大。</p>\n</li>\n<li><p>其次，目前 Chrome 在 script-streaming 的实现上，同一时刻 script-streaming 只能应用到一个 JavaScript 文件上。这是由于 <a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&amp;q=scriptstream&amp;g=0&amp;l=49\" target=\"_blank\" rel=\"noopener\">Chrome 对于 script-streaming 只使用了单线程</a>。既然这个线程忙于解析某个 JavaScript 文件，那么其他 JavaScript 文件就必须在主线程下载完成后，才能进行解析。</p>\n</li>\n</ul>\n<h1 id=\"web-开发者如何利用-script-streaming\"><a href=\"#web-开发者如何利用-script-streaming\" class=\"headerlink\" title=\"web 开发者如何利用 script-streaming ?\"></a>web 开发者如何利用 script-streaming ?</h1><p>script-streaming 加速了 JavaScript 的解析。作为一个 web 开发者，你不必为了在页面上启用 script-streaming 做任何事情。然而，script-streaming 还是有一些限制的，这些限制只存在于 Chrome，它们是由于 Chrome 的实现造成的。具体来说，当大型 JavaScript 文件下载完成，script-streaming 线程不保证一定可用。同样地，页面并行下载多个大型 JavaScript 文件，只有一个文件能够通过 script-streaming 解析。并且，某些情况下，script-streaming 可能解析较小的脚本文件，而较大的脚本只能等待 script-streaming 线程可用，或者在\b完成下载后，由主线程进行解析。</p>\n<p>开发者可以使用 <a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference\" target=\"_blank\" rel=\"noopener\">performance 开发者工具</a>来研究 script-streaming 是否被用于解析大型 JavaScript 文件，因为这项技术可以显著提升页面性能。下图是 <a href=\"http://www.akamai.com\" target=\"_blank\" rel=\"noopener\">www.akamai.com</a> 在 performance 面板上的一个截图，脚本就是被红框里的 ScriptStreamer 线程解析的。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/1.png\" alt=\"\"></p>\n<h1 id=\"提升解析速度的两种方法\"><a href=\"#提升解析速度的两种方法\" class=\"headerlink\" title=\"提升解析速度的两种方法\"></a>提升解析速度的两种方法</h1><p>我做了一些研究，为了启用 script-streaming，可以解析较小的 JavaScript 文件（仍然大于 30KB）,这样在解析相对较大的 JavaScript 文件时，保持线程是可用的。理论上，可以在大型 JavaScript 文件上发送一个 HTTP 响应头，告诉浏览器在具有这种响应头的文件上应用 script-streaming。然而，这个方法要求主流浏览器作出调整，并\b且能让 script-streaming 利用多线程，而不仅仅是单线程。\b值得注意的是，目前 使用多个 script-streaming 线程在 Chrome 团队内部\b依然是 <a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&amp;q=scriptstream&amp;g=0&amp;l=50\" target=\"_blank\" rel=\"noopener\">TODO</a> 状态。</p>\n<p>一个比较实用的，执行起来简单得多，并且不需要浏览器改变的技巧，是重新\b排序 HTML 中那些加载静态资源 URL 的 <code>&lt;script&gt;</code> 标签的位置，以让大的 JavaScript 文件在较小（仍然大于 30KB）\b文件之前下载。当 script-streaming 可用时，此方法会强制解析大型 JavaScript \b文件。重新排序 <code>&lt;script&gt;</code> 标签在\b HTML 中的位置，可能\b存在潜在风险。因为为了保持页面的功能和 UI，一些 JavaScript 必须按顺序执行。因此，在重新排序时必须要谨慎。<strong>重新排序那些带上=有 </strong>async<strong> 或者 </strong>defer<strong> 属性的 <code>&lt;script&gt;</code> 标签会保险一些，因为这些脚本执行并不依赖于执行顺序</strong>。由于脚本\b重排序伴随着种种限制，这项实验性的方法将只在指定的网站上生效。除了\b脚本重排序之外，我加进来的另一个方法是，将多个大型 JavaScript 文件并行下载，让它们竞争 script-streaming 线程。我将所有这样的 JavaScript 文件串联起来\b，目的是让他们都可以实现边下载边解析。</p>\n<h1 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"\b实验结果\"></a>\b实验结果</h1><p>我做了一些实验，去衡量上述两个方法在多个设备上的页面加载时间，包括 MacBook Pro，一个低端移动设备（Motorola Moto E），和一个高端移动设备（Motorola Moto G）。性能数据通过一个<a href=\"https://docs.google.com/document/d/1-UKw2FO3YNqS5CjRHrPOwbHjGOIoISd4hGJZ6L7Hws0/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">私有网页测试实例</a>.收集。在两个手动修改的网站（“Page A” 和 “Page B”，\b详情见下表）集合上，观察到在多个移动设备和 MacBook Pro 上，对于中等规模的页面\b有多达 6.2% 的页面加载时间提升。这些性能提升要归功于 JavaScript 解析和下载\b的并行化。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Page</strong></th>\n<th><strong>\\资源数</strong></th>\n<th><strong>页面大小</strong></th>\n<th><strong>#JavaScript 资源数</strong></th>\n<th><strong> JavaScript 总大小</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>41</td>\n<td>2.7 MB</td>\n<td>12</td>\n<td>1.3 MB</td>\n</tr>\n<tr>\n<td>B</td>\n<td>95</td>\n<td>2.2 MB</td>\n<td>19</td>\n<td>1.1 MB</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"MacBook-Pro-上的性能\"><a href=\"#MacBook-Pro-上的性能\" class=\"headerlink\" title=\"MacBook Pro 上的性能\"></a>MacBook Pro 上的性能</h2><p>\b图 1 和图 2 展示了在一台 MacBook Pro 上，两个测试页面加载时间的 <a href=\"https://www.andata.at/en/software-blog-reader/why-we-love-the-cdf-and-do-not-like-histograms-that-much.html\" target=\"_blank\" rel=\"noopener\">CDF</a>  分布。页面 A 上，重新排序 script 标签在 HTML 中的位置的页面加载时间减少了 6.2%。页面 B 上，加载重新排序的 scrip 标签的页面加载时间减少了 4.5%。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/2.png\" alt=\"\"></p>\n<h2 id=\"Motorola-Moto-E-上的性能\"><a href=\"#Motorola-Moto-E-上的性能\" class=\"headerlink\" title=\"Motorola Moto E 上的性能\"></a>Motorola Moto E 上的性能</h2><p>正如下图所示，重排序 script 标签的页面 A 的加载时间减少了 4.3%。</p>\n<p>页面 B（没有示例图）上没有出现更快的加载速度，这可能是因为在 Moto E 设备上，当移动版页面 A 加载时， \bscript-streaming 线程被占用了。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/3.png\" alt=\"\"></p>\n<h2 id=\"Motorola-Moto-G-上的性能\"><a href=\"#Motorola-Moto-G-上的性能\" class=\"headerlink\" title=\"Motorola Moto G 上的性能\"></a>Motorola Moto G 上的性能</h2><p>如下图所示，重排序 script 标签的页面 A 的加载时间减少了 3.5%。</p>\n<p>页面 B 上，中等规模页面的加载时间减少了 1.9%。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/4.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文描述的实验性工作\b举例说明了相比默认的解析，通过 script-streaming 解析较大 JavaScript 文件带来的好处。实验包含重排序 HTML 中的 <code>&lt;script&gt;</code> 标签，以及串联多个大型 JavaScript 文件，让它们并行下载，以允许相对较大的文件能够通过 script-streaming 解析。实验结果显示\b，在 MacBook Pro 和\b两个低端和高端的移动设备上，对于中等大小的页面，加载速度有多达 6% 的提升。</p>\n<hr>\n<blockquote>\n<p>\b原文作者： <a href=\"https://www.utkarshgoel.in/\" target=\"_blank\" rel=\"noopener\">Utkarsh Goel</a><br>原文：<a href=\"https://developer.akamai.com/blog/2018/07/17/experiment-improving-page-load-times-script-streaming\" target=\"_blank\" rel=\"noopener\">https://developer.akamai.com/blog/2018/07/17/experiment-improving-page-load-times-script-streaming</a><br>译者： <a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"script-streaming-是什么？\"><a href=\"#script-streaming-是什么？\" class=\"headerlink\" title=\"script-streaming 是什么？\"></a>script-streaming 是什么？</h1><p>加载 JavaScript 算是 web 性能最严重的瓶颈之一，尤其在低端 CPU 上情况更糟糕。加载 JavaScript 的性能损耗不仅包括从服务器上下载数据的网络时间，也包括文件解压、解析、编译，以及执行 JavaScript 的时间。为了更好的用户体验，web 页面<a href=\"https://mobile.httparchive.org/trends.php?s=Top1000&amp;minlabel=Jun+1+2011&amp;maxlabel=Jun+15+2018#bytesJS&amp;reqJS\" target=\"_blank\" rel=\"noopener\">大量的 JavaScript 代码数量持续地增长</a>，页面加载变得越来越慢。浏览器社区一直在开发很多优化措施来提升 JavaScript 加载速度，比如将解析 JavaScript 文件和下载过程并行化（在此之前，浏览器会等待 JavaScript 文件完全下载后才会在渲染主线程上进行解析）。这项优化措施就是 <a href=\"https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html\" target=\"_blank\" rel=\"noopener\">script-streaming</a>，它在 Chrome v41 上被引入。Google 声称 script-streaming 能够将页面加载速度提升 10%，因为大型 JavaScript 文件会边下载边解析，这可以减少数百毫秒的页面加载时间。</p>\n<p>Script-streaming 是为加速 JavaScript 解析而做的一项巨大的优化。然而，Chrome 针对 JavaScript 文件启用 script-streaming 还有一些限制。</p>\n<ul>\n<li><p>首先，下载的 JavaScript 文件大小<a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer.cc?dr=C&amp;sq=package:chromium&amp;l=325\" target=\"_blank\" rel=\"noopener\">至少 30KB</a>。这个尺寸限制确保了只有大型 JS 文件能够通过 script-streaming 解析，因为相比于较小的 JavaScript 文件，并行下载和解析大型 JavaScript 文件的收益最大。</p>\n</li>\n<li><p>其次，目前 Chrome 在 script-streaming 的实现上，同一时刻 script-streaming 只能应用到一个 JavaScript 文件上。这是由于 <a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&amp;q=scriptstream&amp;g=0&amp;l=49\" target=\"_blank\" rel=\"noopener\">Chrome 对于 script-streaming 只使用了单线程</a>。既然这个线程忙于解析某个 JavaScript 文件，那么其他 JavaScript 文件就必须在主线程下载完成后，才能进行解析。</p>\n</li>\n</ul>\n<h1 id=\"web-开发者如何利用-script-streaming\"><a href=\"#web-开发者如何利用-script-streaming\" class=\"headerlink\" title=\"web 开发者如何利用 script-streaming ?\"></a>web 开发者如何利用 script-streaming ?</h1><p>script-streaming 加速了 JavaScript 的解析。作为一个 web 开发者，你不必为了在页面上启用 script-streaming 做任何事情。然而，script-streaming 还是有一些限制的，这些限制只存在于 Chrome，它们是由于 Chrome 的实现造成的。具体来说，当大型 JavaScript 文件下载完成，script-streaming 线程不保证一定可用。同样地，页面并行下载多个大型 JavaScript 文件，只有一个文件能够通过 script-streaming 解析。并且，某些情况下，script-streaming 可能解析较小的脚本文件，而较大的脚本只能等待 script-streaming 线程可用，或者在\b完成下载后，由主线程进行解析。</p>\n<p>开发者可以使用 <a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference\" target=\"_blank\" rel=\"noopener\">performance 开发者工具</a>来研究 script-streaming 是否被用于解析大型 JavaScript 文件，因为这项技术可以显著提升页面性能。下图是 <a href=\"http://www.akamai.com\" target=\"_blank\" rel=\"noopener\">www.akamai.com</a> 在 performance 面板上的一个截图，脚本就是被红框里的 ScriptStreamer 线程解析的。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/1.png\" alt=\"\"></p>\n<h1 id=\"提升解析速度的两种方法\"><a href=\"#提升解析速度的两种方法\" class=\"headerlink\" title=\"提升解析速度的两种方法\"></a>提升解析速度的两种方法</h1><p>我做了一些研究，为了启用 script-streaming，可以解析较小的 JavaScript 文件（仍然大于 30KB）,这样在解析相对较大的 JavaScript 文件时，保持线程是可用的。理论上，可以在大型 JavaScript 文件上发送一个 HTTP 响应头，告诉浏览器在具有这种响应头的文件上应用 script-streaming。然而，这个方法要求主流浏览器作出调整，并\b且能让 script-streaming 利用多线程，而不仅仅是单线程。\b值得注意的是，目前 使用多个 script-streaming 线程在 Chrome 团队内部\b依然是 <a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/script_streamer_thread.h?type=cs&amp;q=scriptstream&amp;g=0&amp;l=50\" target=\"_blank\" rel=\"noopener\">TODO</a> 状态。</p>\n<p>一个比较实用的，执行起来简单得多，并且不需要浏览器改变的技巧，是重新\b排序 HTML 中那些加载静态资源 URL 的 <code>&lt;script&gt;</code> 标签的位置，以让大的 JavaScript 文件在较小（仍然大于 30KB）\b文件之前下载。当 script-streaming 可用时，此方法会强制解析大型 JavaScript \b文件。重新排序 <code>&lt;script&gt;</code> 标签在\b HTML 中的位置，可能\b存在潜在风险。因为为了保持页面的功能和 UI，一些 JavaScript 必须按顺序执行。因此，在重新排序时必须要谨慎。<strong>重新排序那些带上=有 </strong>async<strong> 或者 </strong>defer<strong> 属性的 <code>&lt;script&gt;</code> 标签会保险一些，因为这些脚本执行并不依赖于执行顺序</strong>。由于脚本\b重排序伴随着种种限制，这项实验性的方法将只在指定的网站上生效。除了\b脚本重排序之外，我加进来的另一个方法是，将多个大型 JavaScript 文件并行下载，让它们竞争 script-streaming 线程。我将所有这样的 JavaScript 文件串联起来\b，目的是让他们都可以实现边下载边解析。</p>\n<h1 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"\b实验结果\"></a>\b实验结果</h1><p>我做了一些实验，去衡量上述两个方法在多个设备上的页面加载时间，包括 MacBook Pro，一个低端移动设备（Motorola Moto E），和一个高端移动设备（Motorola Moto G）。性能数据通过一个<a href=\"https://docs.google.com/document/d/1-UKw2FO3YNqS5CjRHrPOwbHjGOIoISd4hGJZ6L7Hws0/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">私有网页测试实例</a>.收集。在两个手动修改的网站（“Page A” 和 “Page B”，\b详情见下表）集合上，观察到在多个移动设备和 MacBook Pro 上，对于中等规模的页面\b有多达 6.2% 的页面加载时间提升。这些性能提升要归功于 JavaScript 解析和下载\b的并行化。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Page</strong></th>\n<th><strong>\\资源数</strong></th>\n<th><strong>页面大小</strong></th>\n<th><strong>#JavaScript 资源数</strong></th>\n<th><strong> JavaScript 总大小</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>41</td>\n<td>2.7 MB</td>\n<td>12</td>\n<td>1.3 MB</td>\n</tr>\n<tr>\n<td>B</td>\n<td>95</td>\n<td>2.2 MB</td>\n<td>19</td>\n<td>1.1 MB</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"MacBook-Pro-上的性能\"><a href=\"#MacBook-Pro-上的性能\" class=\"headerlink\" title=\"MacBook Pro 上的性能\"></a>MacBook Pro 上的性能</h2><p>\b图 1 和图 2 展示了在一台 MacBook Pro 上，两个测试页面加载时间的 <a href=\"https://www.andata.at/en/software-blog-reader/why-we-love-the-cdf-and-do-not-like-histograms-that-much.html\" target=\"_blank\" rel=\"noopener\">CDF</a>  分布。页面 A 上，重新排序 script 标签在 HTML 中的位置的页面加载时间减少了 6.2%。页面 B 上，加载重新排序的 scrip 标签的页面加载时间减少了 4.5%。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/2.png\" alt=\"\"></p>\n<h2 id=\"Motorola-Moto-E-上的性能\"><a href=\"#Motorola-Moto-E-上的性能\" class=\"headerlink\" title=\"Motorola Moto E 上的性能\"></a>Motorola Moto E 上的性能</h2><p>正如下图所示，重排序 script 标签的页面 A 的加载时间减少了 4.3%。</p>\n<p>页面 B（没有示例图）上没有出现更快的加载速度，这可能是因为在 Moto E 设备上，当移动版页面 A 加载时， \bscript-streaming 线程被占用了。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/3.png\" alt=\"\"></p>\n<h2 id=\"Motorola-Moto-G-上的性能\"><a href=\"#Motorola-Moto-G-上的性能\" class=\"headerlink\" title=\"Motorola Moto G 上的性能\"></a>Motorola Moto G 上的性能</h2><p>如下图所示，重排序 script 标签的页面 A 的加载时间减少了 3.5%。</p>\n<p>页面 B 上，中等规模页面的加载时间减少了 1.9%。<br><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Script-Streaming/4.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文描述的实验性工作\b举例说明了相比默认的解析，通过 script-streaming 解析较大 JavaScript 文件带来的好处。实验包含重排序 HTML 中的 <code>&lt;script&gt;</code> 标签，以及串联多个大型 JavaScript 文件，让它们并行下载，以允许相对较大的文件能够通过 script-streaming 解析。实验结果显示\b，在 MacBook Pro 和\b两个低端和高端的移动设备上，对于中等大小的页面，加载速度有多达 6% 的提升。</p>\n<hr>\n<blockquote>\n<p>\b原文作者： <a href=\"https://www.utkarshgoel.in/\" target=\"_blank\" rel=\"noopener\">Utkarsh Goel</a><br>原文：<a href=\"https://developer.akamai.com/blog/2018/07/17/experiment-improving-page-load-times-script-streaming\" target=\"_blank\" rel=\"noopener\">https://developer.akamai.com/blog/2018/07/17/experiment-improving-page-load-times-script-streaming</a><br>译者： <a href=\"https://blog.skrskrskrskr.com\">熊贤仁</a></p>\n</blockquote>\n"},{"title":"【译】无头 Chrome：服务端渲染 JS 页面的一个解决方案","date":"2018-09-17T13:05:57.000Z","_content":"\n### TL;DR\n\n\n> [无头 Chrome](https://developers.google.com/web/updates/2017/04/headless-chrome) 是一个将动态 JS 页面转成静态 HTML 页面的即插即用的解决方案。将其运行于 web 服务器之上，你可以**预渲染任何现代 JS 特性**，从而提速内容加载，并且是**可被搜索引擎索引的**。\n\n\n本篇文章介绍的技术，旨在教大家如何使用 [Puppeteer](https://developers.google.com/web/tools/puppeteer/) 的 API，给一个 Express 服务器添加服务端渲染（SSR）能力。最棒的地方是，**应用本身几乎不需要修改任何代码**。无头 Chrome 做了所有的重活。三两行代码，SSR 页面带回家。\n\n大餐之前先来点甜点：\n\n```\nimport puppeteer from 'puppeteer';\n\nasync function ssr(url) {\n  const browser = await puppeteer.launch({headless: true});\n  const page = await browser.newPage();\n  await page.goto(url, {waitUntil: 'networkidle0'});\n  const html = await page.content(); // serialized HTML of page DOM.\n  await browser.close();\n  return html;\n}\n```\n\n**注意：** 我会在文章中使用 ES 模块（`import`），这要求 Node 8.5.0+，并在运行时加上 `--experimental-modules` 标志。觉得麻烦的话可以自行使用 `require()` 语句。关于 Node 上的 ES 模块支持可以读读[这篇文章](https://nodejs.org/api/esm.html)。\n\n\n<br>\n## 导论\n----------------------------\n\n如果我对 [SEO](https://en.wikipedia.org/wiki/Search_engine_optimization) 理解没有偏差的话，你读到这篇文章可能因为下面两个原因之一。首先，你已经搭建了一个 web 应用，并且它没有被搜索引擎索引！你的应用可能是 SPA，[PWA](https://developers.google.com/web/progressive-web-apps/)，使用了 vanilla JS，或者使用了其他更复杂的框架或类库。老实说，你使用何种技术并不重要。重要的是，你花费了大量时间搭建出优秀的 web 页面，然而用户却搜不到它。你读这篇文章的另一个理由可能是因为，网上一些文章说了服务端渲染可以提升性能。你希望快速减少[ JavaScript 启动时间](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization/)，提升[首次有效绘制](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint)速度。\n\n一些框架，比如 Preact 使用了[工具](https://github.com/developit/preact-render-to-string)来实现服务端渲染。如果你使用的框架具备预渲染的解决方案，请继续使用。没有任何理由引入另一个工具（无头 Chrome / Puppeteer）。\n\n\n### 爬取现代网站\n\n\n\b搜索引擎爬虫，社交平台，[甚至浏览器](https://en.wikipedia.org/wiki/Lynx_(web_browser))自诞生至今就唯一依赖于静态 HTML 标记，来索引 web 页面和表层内容。现代 web 页面已经演变的\b大为不同。基于 JavaScript 的应用，在很多时候，需要保持网站内容是对于爬取工具是可见的。\n\n一些爬虫，比如 Google \b搜索，已经变得更智能了！Google 的爬虫使用\b Chrome 41 [执行 JavaScript](https://developers.google.com/search/docs/guides/rendering)，并渲染出最终的页面。但是这个方案才刚出来，还不完美。\b举个例子，使用了新特性的页面，比如 ES6 Class，[模块](https://www.chromestatus.com/feature/5365692190687232)，箭头函数等，将会在这个\b比较老的浏览器上报错，使得页面不能正确渲染。至于其他搜索引擎，\b鬼知道它们在干嘛！？¯\\_(ツ)_/¯\n\n\n## 使用无头 Chrome 预渲染页面\n\n--------------------------------------------------------\n\n所有的爬虫程序都能够理解 HTML。我们要“解决”索引问题的话需要一个工具，它来执行 JS 生成 HTML。我不会告诉你现在已经有这样一个工具了！\n\n1. 该工具可以运行所有类型的现代 JavaScript，并吐出静态 HTML。\n2. 出现新特性时，该工具可以保持更新\n3. 已有应用上只需少量代码就可以运行这个工具\n\n\n听起来很不错吧？**这个工具就是浏览器**！\n\n无头 Chrome 不在乎你使用什么库、框架或者工具。它将 JavaScript 作为早餐，在午饭前吐出静态 HTML。可能会更快一点 :) -Eric\n\n如果你用的 Node，Puppeteer 容易上手。它的 API 提供了预渲染客户端应用的能力。下面用个例子演示下。\n\n### 1. JS 应用示例\n\n我们以一个 JavaScript 生成 HTML 的动态页面为例：\n\n**public/index.html**\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <!-- Populated by the JS below. -->\n  </div>\n</body>\n<script>\nfunction renderPosts(posts, container) {\n  const html = posts.reduce((html, post) => {\n    return `${html}\n      <li class=\"post\">\n        <h2>${post.title}</h2>\n        <div class=\"summary\">${post.summary}</div>\n        <p>${post.content}</p>\n      </li>`;\n  }, '');\n\n  // CAREFUL: assumes html is sanitized.\n  container.innerHTML = `<ul id=\"posts\">${html}</ul>`;\n}\n\n(async() => {\n  const container = document.querySelector('#container');\n  const posts = await fetch('/posts').then(resp => resp.json());\n  renderPosts(posts, container);\n})();\n</script>\n</html>\n```\n\n### 2. 服务端渲染函数\n\n接下来，我们会使用之前提到的 `ssr()` 函数，并充实它的内容。\n\n**ssr.mjs**\n\n```\nimport puppeteer from 'puppeteer';\n\n// In-memory cache of rendered pages. Note: this will be cleared whenever the\n// server process stops. If you need true persistence, use something like\n// Google Cloud Storage (https://firebase.google.com/docs/storage/web/start).\nconst RENDER_CACHE = new Map();\n\nasync function ssr(url) {\n  if (RENDER_CACHE.has(url)) {\n    return {html: RENDER_CACHE.get(url), ttRenderMs: 0};\n  }\n\n  const start = Date.now();\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  try {\n    // networkidle0 waits for the network to be idle (no requests for 500ms).\n    // The page's JS has likely produced markup by this point, but wait longer\n    // if your site lazy loads, etc.\n    await page.goto(url, {waitUntil: 'networkidle0'});\n    await page.waitForSelector('#posts'); // ensure #posts exists in the DOM.\n  } catch (err) {\n    console.error(err);\n    throw new Error('page.goto/waitForSelector timed out.');\n  }\n\n  const html = await page.content(); // serialized HTML of page DOM.\n  await browser.close();\n\n  const ttRenderMs = Date.now() - start;\n  console.info(`Headless rendered page in: ${ttRenderMs}ms`);\n\n  RENDER_CACHE.set(url, html); // cache rendered page.\n\n  return {html, ttRenderMs};\n}\n\nexport {ssr as default};\n```\n\n主要的变化：\n\n1. 添加了缓存。缓存已渲染的 HTML 对于加速响应时间居功至伟。当页面再次有请求过来，避免了无头 Chrome 的重复执行。我随后会讨论其他的[优化](#optimizations) 。\n2. 添加加载页面超时时的基本错误处理。\n3. 添加了 `page.waitForSelector('#posts')` 这行代码。确保在丢弃这个序列化页面之前，posts 节点存在于 DOM 之中。\n4. 记录无头浏览器渲染页面所用时间。\n5. 代码都被封装进名为 `ssr.mjs` 的模块中。\n\n\n### 3. web 服务器示例\n\n\n最后，一个小的 express 服务器完成了所有的工作。它预渲染 URL `http://localhost/index.html`（主页），并在响应中返回渲染结果。由于响应中包含了静态 HTML， 当用户访问页面，posts 节点会立刻呈现。\n\n**server.mjs**\n\n```\nimport express from 'express';\nimport ssr from './ssr.mjs';\n\nconst app = express();\n\napp.get('/', async (req, res, next) => {\n  const {html, ttRenderMs} = await ssr(`${req.protocol}://${req.get('host')}/index.html`);\n  // Add Server-Timing! See https://w3c.github.io/server-timing/.\n  res.set('Server-Timing', `Prerender;dur=${ttRenderMs};desc=\"Headless render time (ms)\"`);\n  return res.status(200).send(html); // Serve prerendered page as response.\n});\n\napp.listen(8080, () => console.log('Server started. Press Ctrl+C to quit')); \n```\n\n\n要运行这个例子，需安装依赖 (`npm i --save puppeteer express`)，然后使用 Node 8.5.0+ 并带有 `--experimental-modules` 标志来运行服务器。\n\n这是一个该服务器返回的响应示例：\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <ul id=\"posts\">\n      <li class=\"post\">\n        <h2>Title 1</h2>\n        <div class=\"summary\">Summary 1</div>\n        <p>post content 1</p>\n      </li>\n      <li class=\"post\">\n        <h2>Title 2</h2>\n        <div class=\"summary\">Summary 2</div>\n        <p>post content 2</p>\n      </li>\n      ...\n    </ul>\n  </div>\n</body>\n<script>\n...\n</script>\n</html>\n```\n\n\n#### Server-Timing API 的一个最佳用例\n\n\n[Server-Timing](https://w3c.github.io/server-timing/) API 支持将服务器性能指标（比如请求/响应时间，数据库查询）返回给浏览器。客户端可以使用这些信息来追踪 web 应用的所有性能数据。\n\n\nServer-Timing 的一个最佳用例是上报无头 Chrome 预渲染页面的时间！只需在响应上添加 `Server-Timing` 头，就可以实现这一点：\n\n```\nres.set('Server-Timing',  `Prerender;dur=1000;desc=\"Headless render time (ms)\"`);  \n```\n\n\n客户端上，[Performance Timeline API](https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline) 和 [PerformanceObserver](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver) 可以获取这些指标：\n\n\n```\n  const entry = performance.getEntriesByType('navigation').find(\n    e => e.name === location.href);\nconsole.log(entry.serverTiming[0].toJSON());\n```\n\n```\n{\n  \"name\": \"Prerender\",\n  \"duration\": 3808,\n  \"description\": \"Headless render time (ms)\"\n}\n```\n\n\n### 性能结果\n\n\n**注意：** 这些数据体现了我随后讨论的大多数性能[优化](#optimizations)。\n\n\n性能数据怎么样？在我的一个[应用](https://devwebfeed.appspot.com/ssr)([代码](https://github.com/ebidel/devwebfeed/blob/master/server.mjs))上，无头 Chrome 渲染页面大约需要 1s。页面被缓存后， **3G 低网速模拟**下，[FCP](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics) 要比客户端渲染版本的**快 8.37s**。\n\n\n &nbsp; | **首次绘制 (FP)** | **首次内容绘制 (FCP)** |\n---- | ---- | ---- |\n客户端渲染|4s|11s|\n服务端渲染|2.3s|~2.3s|\n\n\n这些结果很有用。因为服务端渲染页面**不再依赖于 JavaScript 的加载**，用户看到有意义的内容比以前快得多。\n\n<br>\n\n## Preventing re-hydration\n\n---------------------------------------\n\n还记得我说“我们无需在客户端应用上改任何代码”吗？那是骗你们的。\n\nExpress 应用接收请求，使用 Puppeteer 将页面加载进无头浏览器，然后在响应中返回结果。但这里有一个问题。\n\n浏览器加载页面时，**无头 Chrome 中相同的 JS** 会在服务器上**再次执行**。有两处都在生成 HTML。 \n\n一起来修复这个问题。我们要告知页面，它的 HTML 早就名花有主了。我找到的解决方案是，在页面加载时判断 `<ul id=\"posts\">` 是否已在 DOM 中，如果在，页面就已经在服务端渲染过了，这样就可以避免重新创建 DOM。\n\n**public/index.html**\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <!-- Populated by JS (below) or by prerendering (server). Either way,\n         #container gets populated with the posts markup:\n      <ul id=\"posts\">...</ul>\n    -->\n  </div>\n</body>\n<script>\n...\n(async() => {\n  const container = document.querySelector('#container');\n\n  // Posts markup is already in DOM if we're seeing a SSR'd.\n  // Don't re-hydrate the posts here on the client.\n  const PRE_RENDERED = container.querySelector('#posts');\n  if (!PRE_RENDERED) {\n    const posts = await fetch('/posts').then(resp => resp.json());\n    renderPosts(posts, container);\n  }\n})();\n</script>\n</html>\n```\n<br>\n\n## 优化\n-----------------------------\n\n除了缓存渲染结果之外，还有一些有趣的优化技巧。有的优化可以快速见效，而有的可能带有猜测性的。\n\n### 中止不必要的请求\n\n现在，整个页面（以及它请求的所有资源）都无脑地加载进无头 Chrome。然而，我们只关注于两件事情：\n\n1. 渲染 HTML\n2. 生成 HTML 的 JS\n\n\n**不构造 DOM 的网络请求是浪费的**。一些资源，比如图片、字体、样式表和媒体内容，不参与页面的 HTML 构建。它们负责添加样式，补充页面的结构，但并不显式地创建页面。我们应该告诉浏览器去忽略掉这些资源！这样可以减少无头 Chrome 的工作负担，从而**节省带宽**，并且潜在地**加速了大型页面的预渲染时间**。\n\n[Protocol 开发者工具](https://chromedevtools.github.io/devtools-protocol/)提供了一个强大的特性，叫做[网络拦截](https://chromedevtools.github.io/devtools-protocol/tot/Network#event-requestIntercepted)。它可以用于**在浏览器发出之前修改请求**。Puppeteer 也支持网络拦截，它是通过打开 [`page.setRequestInterception(true)`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetrequestinterceptionvalue)，监听[页面的 `request` 事件](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-request)来实现的。这样我们可以中止某些资源请求。\n\n**ssr.mjs**\n\n```\nasync function ssr(url) {\n  ...\n  const page = await browser.newPage();\n\n  // 1. Intercept network requests.\n  await page.setRequestInterception(true);\n\n  page.on('request', req => {\n    // 2. Ignore requests for resources that don't produce DOM\n    // (images, stylesheets, media).\n    const whitelist = ['document', 'script', 'xhr', 'fetch'];\n    if (!whitelist.includes(req.resourceType())) {\n      return req.abort();\n    }\n\n    // 3. Pass through all other requests.\n    req.continue();\n  });\n\n  await page.goto(url, {waitUntil: 'networkidle0'});\n  const html = await page.content(); // serialized HTML of page DOM.\n  await browser.close();\n\n  return {html};\n}\n```\n\n**注意：** 安全起见，我使用了一个白名单，允许所有其他类型的请求能够继续正常发出。预先避免中止掉其他必要的请求。\n\n\n### 内联关键资源\n\n使用构建工具（比如 `gulp`）编译应用，并在构建时将关键 CSS/JS 内联到页面内，是一种很常见的做法。由于浏览器初始化页面加载时的请求数更少了，这样也就加速了首次有效绘制时间。\n\n别用构建工具了，**浏览器就是你的构建工具**！我们可以用 Puppeteer 管理页面 DOM，内联样式，JavaScript， 或者其他任何你想在预渲染之前加到页面中的东西。\n\n这个例子演示了如何拦截本地样式表的响应，并将这些资源内联进 `<style>` 标签中：\n\n**ssr.mjs**\n\n```\nimport urlModule from 'url';\nconst URL = urlModule.URL;\n\nasync function ssr(url) {\n  ...\n  const stylesheetContents = {};\n\n  // 1. Stash the responses of local stylesheets.\n  page.on('response', async resp => {\n    const responseUrl = resp.url();\n    const sameOrigin = new URL(responseUrl).origin === new URL(url).origin;\n    const isStylesheet = resp.request().resourceType() === 'stylesheet';\n    if (sameOrigin && isStylesheet) {\n      stylesheetContents[responseUrl] = await resp.text();\n    }\n  });\n\n  // 2. Load page as normal, waiting for network requests to be idle.\n  await page.goto(url, {waitUntil: 'networkidle0'});\n\n  // 3. Inline the CSS.\n  // Replace stylesheets in the page with their equivalent <style>.\n  await page.$$eval('link[rel=\"stylesheet\"]', (links, content) => {\n    links.forEach(link => {\n      const cssText = content[link.href];\n      if (cssText) {\n        const style = document.createElement('style');\n        style.textContent = cssText;\n        link.replaceWith(style);\n      }\n    });\n  }, stylesheetContents);\n\n  // 4. Get updated serialized HTML of page.\n  const html = await page.content();\n  await browser.close();\n\n  return {html};\n}\n```\n\n\n这段代码：\n\n1. 使用一个 [`page.on('response')`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-response) 处理器来监听网络响应。\n2. 储藏本地样式表的响应。\n3. 找到 DOM 中所有的 `<link rel=\"stylesheet\">`，将它们替换成一个等价的 `<style>`。具体见 [`page.$$eval`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevalselector-pagefunction-args) API 文档。`style.textContent` 被设为样式表的响应内容。\n\n\n### 自动压缩资源\n\n另一个可以借助网络拦截玩的小把戏是**修改请求的响应内容**。\n\n举个例子，你想要压缩 CSS，但也希望开发阶段不要被压缩，这样开发时能方便些。假设你已经用另一个工具来预压缩 `styles.css`，可以用 `Request.respond()`，将 `styles.css` 的内容重写为 `styles.min.css`。\n\n**ssr.mjs**\n\n```\nimport fs from 'fs';\n\nasync function ssr(url) {\n  ...\n\n  // 1. Intercept network requests.\n  await page.setRequestInterception(true);\n\n  page.on('request', req => {\n    // 2. If request is for styles.css, respond with the minified version.\n    if (req.url().endsWith('styles.css')) {\n      return req.respond({\n        status: 200,\n        contentType: 'text/css',\n        body: fs.readFileSync('./public/styles.min.css', 'utf-8')\n      });\n    }\n    ...\n\n    req.continue();\n  });\n  ...\n\n  const html = await page.content();\n  await browser.close();\n\n  return {html};\n}\n```\n\n\n### 重用 Chrome 实例实现交叉渲染\n\n\n每次预渲染都启动新的浏览器会很浪费。相反，你希望只启动一个实例，然后在多个页面渲染时重用它。\n\nPuppeteer 可以通过调用 [`puppeteer.connect()`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions)，连接到一个已有的 Chrome 实例，它接收实例的远程调试 URL 作为参数。为保证浏览器实例的长时间运行，我们可以将 `ssr()` 函数启动 Chrome 这部分代码移到 Express 服务器里。\n\n**server.mjs**\n\n```\nimport express from 'express';\nimport puppeteer from 'puppeteer';\nimport ssr from './ssr.mjs';\n\nlet browserWSEndpoint = null;\nconst app = express();\n\napp.get('/', async (req, res, next) => {\n  if (!browserWSEndpoint) {\n    const browser = await puppeteer.launch();\n    browserWSEndpoint = await browser.wsEndpoint();\n  }\n\n  const url = `${req.protocol}://${req.get('host')}/index.html`;\n  const {html} = await ssr(url, browserWSEndpoint);\n\n  return res.status(200).send(html);\n});  \n```\n\n**ssr.mjs**\n\n```\nimport puppeteer from 'puppeteer';\n\n/**\n * @param {string} url URL to prerender.\n * @param {string} browserWSEndpoint Optional remote debugging URL. If\n *     provided, Puppeteer's reconnects to the browser instance. Otherwise,\n *     a new browser instance is launched.\n */\nasync function ssr(url, browserWSEndpoint) {\n  ...\n  console.info('Connecting to existing Chrome instance.');\n  const browser = await puppeteer.connect({browserWSEndpoint});\n\n  const page = await browser.newPage();\n  ...\n  await page.close(); // Close the page we opened here (not the browser).\n\n  return {html};\n}\n```\n\n\n#### 例子：实现周期性预渲染的定时任务\n\n\n在 [App 引擎面板应用](https://devwebfeed.appspot.com/ssr) 里，我创建了一个[定时处理器](https://cloud.google.com/appengine/docs/flexible/nodejs/scheduling-jobs-with-cron-yaml)，来周期性的重复渲染排名前几位的页面。帮助用户快速看到最新内容，他们根本感知不到一个新页面的启动性能消耗。在这个例子中，生成多个 Chrome 实例会很浪费。相反，我用了一个共享的浏览器实例来一次性渲染这些页面。\n\n```\nimport puppeteer from 'puppeteer';\nimport * as prerender from './ssr.mjs';\nimport urlModule from 'url';\nconst URL = urlModule.URL;\n\napp.get('/cron/update_cache', async (req, res) => {\n  if (!req.get('X-Appengine-Cron')) {\n    return res.status(403).send('Sorry, cron handler can only be run as admin.');\n  }\n\n  const browser = await puppeteer.launch();\n  const homepage = new URL(`${req.protocol}://${req.get('host')}`);\n\n  // Re-render main page and a few pages back.\n  prerender.clearCache();\n  await prerender.ssr(homepage.href, await browser.wsEndpoint());\n  await prerender.ssr(`${homepage}?year=2018`);\n  await prerender.ssr(`${homepage}?year=2017`);\n  await prerender.ssr(`${homepage}?year=2016`);\n  await browser.close();\n\n  res.status(200).send('Render cache updated!');\n});\n```\n\n我还在 **ssr.js** export 上加了一个 `clearCache()` 函数。\n\n```\n...\nfunction clearCache() {\n  RENDER_CACHE.clear();\n}\n\nexport {ssr, clearCache};\n```\n\n<br>\n## 其他因素\n------------------------------------\n\n### 告诉页面：“你正在被无头浏览器渲染”\n\n\n当页面正在服务器上的无头 Chrome 中渲染时，客户端逻辑很有必要知道这一信息。我的应用使用了钩子来“关闭”部分不参与渲染 post 节点的页面。举例来说，我禁用了懒加载 [firebase-auth.js](https://firebase.google.com/docs/web/setup) 这部分代码。根本不需要用户登录！\n\n在 URL 上加一个 `?headless` 参数，是一个给页面加钩子的简单方法：\n\n**ssr.mjs**\n\n```\nimport urlModule from 'url';\nconst URL = urlModule.URL;\n\nasync function ssr(url) {\n  ...\n  // Add ?headless to the URL so the page has a signal\n  // it's being loaded by headless Chrome.\n  const renderUrl = new URL(url);\n  renderUrl.searchParams.set('headless', '');\n  await page.goto(renderUrl, {waitUntil: 'networkidle0'});\n  ...\n\n  return {html};\n}\n```\n\n可以在页面内查询该参数：\n\n**public/index.html**\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <!-- Populated by the JS below. -->\n  </div>\n</body>\n<script>\n...\n\n(async() => {\n  const params = new URL(location.href).searchParams;\n\n  const RENDERING_IN_HEADLESS = params.has('headless');\n  if (RENDERING_IN_HEADLESS) {\n    // Being rendered by headless Chrome on the server.\n    // e.g. shut off features, don't lazy load non-essential resources, etc.\n  }\n\n  const container = document.querySelector('#container');\n  const posts = await fetch('/posts').then(resp => resp.json());\n  renderPosts(posts, container);\n})();\n</script>\n</html> \n```\n\n\nTip：[`Page.evaluateOnNewDocument()`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluateonnewdocumentpagefunction-args) 也可以方便的查询参数。它会在页面中注入代码，让 Puppeteer 在页面中剩余待执行的 JavaScript 之前运行这些代码。\n\n\n### 避免 PV 膨胀\n\n\n你如果正在页面上使用分析工具，那么要小心了。预渲染的页面可能会造成 PV 出现膨胀。具体来说，**打点数据将会提升2倍**，一半是在无头 Chrome 渲染时，另一半出现在用户浏览器渲染时。\n\n那么怎么修复这个问题呢？将所有加载分析脚本的请求拦截掉。\n\n```\npage.on('request', req => {\n  // Don't load Google Analytics lib requests so pageviews aren't 2x.\n  const blacklist = ['www.google-analytics.com', '/gtag/js', 'ga.js', 'analytics.js'];\n  if (blacklist.find(regex => req.url().match(regex))) {\n    return req.abort();\n  }\n  ...\n  req.continue();\n});\n```\n\n\n代码不加载，页面访问就不会被记录。真 Skr 个机灵鬼 💥。\n\n或者，你也可以继续加载分析脚本，来获悉服务器上运行的预渲染器数。\n\n<br>\n\n## 结论\n--------------------------\n\nPuppeteer 通过运行无头 Chrome，不费吹灰之力就实现了服务端渲染。**提升加载性能**和**没有改动大量代码就增强了应用的可索引性**，是这个方案中我最喜欢的“特性”。\n\n**注意：** 如果你对文章中描述的技术感兴趣，可以去看看[这个应用](https://devwebfeed.appspot.com/ssr)，以及[它的代码](https://github.com/ebidel/devwebfeed/blob/master/server.mjs)。\n\n<br>\n\n## 附录\n------------------------\n\n### 现有技术的讨论\n\n很难在服务端上渲染客户端应用。有多难？去看看大家给这个话题奉献了多少个 [npm 包](https://www.npmjs.com/search?q=server%20side%20rendering)就知道了。有数不清的[模式](https://en.wikipedia.org/wiki/Isomorphic_JavaScript)，[工具](https://github.com/GoogleChrome/rendertron)，和[服务](https://prerender.io/)来辅助服务端渲染的 JS 应用。\n\n#### 同构 JavaScript\n\n同构 JavaScript 的概念很简单：同样的代码既能在服务端运行，也能在客户端（浏览器）运行。服务器和客户端共享代码，美滋滋！\n\n实践中，我发现同构 JS 很难实现。这是我自己的问题...\n\n> 我最近开始做一个[项目](https://github.com/ebidel/devwebfeed/blob/master/server.mjs)，尝试下 [lit-html](https://github.com/Polymer/lit-html)。Lit 是一个优秀的库，它可以允许你写使用 JS 模板字符串写 [HTML \\<template>](https://www.html5rocks.com/en/tutorials/webcomponents/template/)，然后高效地将这些模板渲染为 DOM。问题是它的核心特性（使用 `<template>` 元素）只能在浏览器上工作。这意味着它在 Node 服务器上不能运行。我希望 Node 和前端共享的 SSR 代码能够脱离 window 对象。\n\n> 最后我意识到可以使用无头 Chrome 来服务端渲染应用，Chrome 是经用户的手运行或是在服务器上自动运行并不重要，它反正是愉快地执行了所有 JS。不要多问。 \n\n无头 Chrome 在服务器和客户端上启用 “同构 JS”。它对于当前库不支持服务端（Node）给出了一个不错的解决方案。\n\n\n#### 预渲染工具\n\nNode 社区已经诞生了好几吨解决服务端渲染 JS 应用的工具。毫无新意！个人而言，我发现各人对于这些工具的体会可能不同，所以使用这些工具前肯定要做好功课。比如说，一些服务端渲染工具比较老，并且没有使用无头 Chrome（或者任何其他无头浏览器）。相反，它们使用 PhantomJS（又名旧 Safari），这意味着使用新特性时页面不会正确渲染。\n\n一个值得注意的例外是 [Prerender](https://github.com/prerender/prerender/)。Prerender 使用了无头 Chrome 和 [Express 中间件](https://github.com/prerender/prerender-node)。\n\n```\nconst prerender =  require('prerender');  \nconst server = prerender();  \nserver.use(prerender.removeScriptTags());  \nserver.use(prerender.blockResources());  \nserver.start();  \n```\n\nPrerender 省去了跨平台下载和安装 Chrome 的所有细节。要正确完成这一过程通常是相当棘手的，这也是 [Puppeteer](https://developers.google.com/web/tools/puppeteer/faq#q_which_chromium_version_does_puppeteer_use) 存在的原因之一。我也提了一些渲染我的部分应用的 issue。\n\n\n![浏览器中渲染的 Chrome 状态](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/1.png)\n\n\n\n![prerender 渲染的 Chrome 状态](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/2.png)\n\n\n","source":"_posts/【译】无头Chrome：服务端渲染JS页面的一个解决方案.md","raw":"---\ntitle: 【译】无头 Chrome：服务端渲染 JS 页面的一个解决方案\ndate: 2018-09-17 21:05:57\ntags:\n- 翻译\n- Puppeteer\n- Chrome\ncategories:\n- 前端\n---\n\n### TL;DR\n\n\n> [无头 Chrome](https://developers.google.com/web/updates/2017/04/headless-chrome) 是一个将动态 JS 页面转成静态 HTML 页面的即插即用的解决方案。将其运行于 web 服务器之上，你可以**预渲染任何现代 JS 特性**，从而提速内容加载，并且是**可被搜索引擎索引的**。\n\n\n本篇文章介绍的技术，旨在教大家如何使用 [Puppeteer](https://developers.google.com/web/tools/puppeteer/) 的 API，给一个 Express 服务器添加服务端渲染（SSR）能力。最棒的地方是，**应用本身几乎不需要修改任何代码**。无头 Chrome 做了所有的重活。三两行代码，SSR 页面带回家。\n\n大餐之前先来点甜点：\n\n```\nimport puppeteer from 'puppeteer';\n\nasync function ssr(url) {\n  const browser = await puppeteer.launch({headless: true});\n  const page = await browser.newPage();\n  await page.goto(url, {waitUntil: 'networkidle0'});\n  const html = await page.content(); // serialized HTML of page DOM.\n  await browser.close();\n  return html;\n}\n```\n\n**注意：** 我会在文章中使用 ES 模块（`import`），这要求 Node 8.5.0+，并在运行时加上 `--experimental-modules` 标志。觉得麻烦的话可以自行使用 `require()` 语句。关于 Node 上的 ES 模块支持可以读读[这篇文章](https://nodejs.org/api/esm.html)。\n\n\n<br>\n## 导论\n----------------------------\n\n如果我对 [SEO](https://en.wikipedia.org/wiki/Search_engine_optimization) 理解没有偏差的话，你读到这篇文章可能因为下面两个原因之一。首先，你已经搭建了一个 web 应用，并且它没有被搜索引擎索引！你的应用可能是 SPA，[PWA](https://developers.google.com/web/progressive-web-apps/)，使用了 vanilla JS，或者使用了其他更复杂的框架或类库。老实说，你使用何种技术并不重要。重要的是，你花费了大量时间搭建出优秀的 web 页面，然而用户却搜不到它。你读这篇文章的另一个理由可能是因为，网上一些文章说了服务端渲染可以提升性能。你希望快速减少[ JavaScript 启动时间](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization/)，提升[首次有效绘制](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint)速度。\n\n一些框架，比如 Preact 使用了[工具](https://github.com/developit/preact-render-to-string)来实现服务端渲染。如果你使用的框架具备预渲染的解决方案，请继续使用。没有任何理由引入另一个工具（无头 Chrome / Puppeteer）。\n\n\n### 爬取现代网站\n\n\n\b搜索引擎爬虫，社交平台，[甚至浏览器](https://en.wikipedia.org/wiki/Lynx_(web_browser))自诞生至今就唯一依赖于静态 HTML 标记，来索引 web 页面和表层内容。现代 web 页面已经演变的\b大为不同。基于 JavaScript 的应用，在很多时候，需要保持网站内容是对于爬取工具是可见的。\n\n一些爬虫，比如 Google \b搜索，已经变得更智能了！Google 的爬虫使用\b Chrome 41 [执行 JavaScript](https://developers.google.com/search/docs/guides/rendering)，并渲染出最终的页面。但是这个方案才刚出来，还不完美。\b举个例子，使用了新特性的页面，比如 ES6 Class，[模块](https://www.chromestatus.com/feature/5365692190687232)，箭头函数等，将会在这个\b比较老的浏览器上报错，使得页面不能正确渲染。至于其他搜索引擎，\b鬼知道它们在干嘛！？¯\\_(ツ)_/¯\n\n\n## 使用无头 Chrome 预渲染页面\n\n--------------------------------------------------------\n\n所有的爬虫程序都能够理解 HTML。我们要“解决”索引问题的话需要一个工具，它来执行 JS 生成 HTML。我不会告诉你现在已经有这样一个工具了！\n\n1. 该工具可以运行所有类型的现代 JavaScript，并吐出静态 HTML。\n2. 出现新特性时，该工具可以保持更新\n3. 已有应用上只需少量代码就可以运行这个工具\n\n\n听起来很不错吧？**这个工具就是浏览器**！\n\n无头 Chrome 不在乎你使用什么库、框架或者工具。它将 JavaScript 作为早餐，在午饭前吐出静态 HTML。可能会更快一点 :) -Eric\n\n如果你用的 Node，Puppeteer 容易上手。它的 API 提供了预渲染客户端应用的能力。下面用个例子演示下。\n\n### 1. JS 应用示例\n\n我们以一个 JavaScript 生成 HTML 的动态页面为例：\n\n**public/index.html**\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <!-- Populated by the JS below. -->\n  </div>\n</body>\n<script>\nfunction renderPosts(posts, container) {\n  const html = posts.reduce((html, post) => {\n    return `${html}\n      <li class=\"post\">\n        <h2>${post.title}</h2>\n        <div class=\"summary\">${post.summary}</div>\n        <p>${post.content}</p>\n      </li>`;\n  }, '');\n\n  // CAREFUL: assumes html is sanitized.\n  container.innerHTML = `<ul id=\"posts\">${html}</ul>`;\n}\n\n(async() => {\n  const container = document.querySelector('#container');\n  const posts = await fetch('/posts').then(resp => resp.json());\n  renderPosts(posts, container);\n})();\n</script>\n</html>\n```\n\n### 2. 服务端渲染函数\n\n接下来，我们会使用之前提到的 `ssr()` 函数，并充实它的内容。\n\n**ssr.mjs**\n\n```\nimport puppeteer from 'puppeteer';\n\n// In-memory cache of rendered pages. Note: this will be cleared whenever the\n// server process stops. If you need true persistence, use something like\n// Google Cloud Storage (https://firebase.google.com/docs/storage/web/start).\nconst RENDER_CACHE = new Map();\n\nasync function ssr(url) {\n  if (RENDER_CACHE.has(url)) {\n    return {html: RENDER_CACHE.get(url), ttRenderMs: 0};\n  }\n\n  const start = Date.now();\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  try {\n    // networkidle0 waits for the network to be idle (no requests for 500ms).\n    // The page's JS has likely produced markup by this point, but wait longer\n    // if your site lazy loads, etc.\n    await page.goto(url, {waitUntil: 'networkidle0'});\n    await page.waitForSelector('#posts'); // ensure #posts exists in the DOM.\n  } catch (err) {\n    console.error(err);\n    throw new Error('page.goto/waitForSelector timed out.');\n  }\n\n  const html = await page.content(); // serialized HTML of page DOM.\n  await browser.close();\n\n  const ttRenderMs = Date.now() - start;\n  console.info(`Headless rendered page in: ${ttRenderMs}ms`);\n\n  RENDER_CACHE.set(url, html); // cache rendered page.\n\n  return {html, ttRenderMs};\n}\n\nexport {ssr as default};\n```\n\n主要的变化：\n\n1. 添加了缓存。缓存已渲染的 HTML 对于加速响应时间居功至伟。当页面再次有请求过来，避免了无头 Chrome 的重复执行。我随后会讨论其他的[优化](#optimizations) 。\n2. 添加加载页面超时时的基本错误处理。\n3. 添加了 `page.waitForSelector('#posts')` 这行代码。确保在丢弃这个序列化页面之前，posts 节点存在于 DOM 之中。\n4. 记录无头浏览器渲染页面所用时间。\n5. 代码都被封装进名为 `ssr.mjs` 的模块中。\n\n\n### 3. web 服务器示例\n\n\n最后，一个小的 express 服务器完成了所有的工作。它预渲染 URL `http://localhost/index.html`（主页），并在响应中返回渲染结果。由于响应中包含了静态 HTML， 当用户访问页面，posts 节点会立刻呈现。\n\n**server.mjs**\n\n```\nimport express from 'express';\nimport ssr from './ssr.mjs';\n\nconst app = express();\n\napp.get('/', async (req, res, next) => {\n  const {html, ttRenderMs} = await ssr(`${req.protocol}://${req.get('host')}/index.html`);\n  // Add Server-Timing! See https://w3c.github.io/server-timing/.\n  res.set('Server-Timing', `Prerender;dur=${ttRenderMs};desc=\"Headless render time (ms)\"`);\n  return res.status(200).send(html); // Serve prerendered page as response.\n});\n\napp.listen(8080, () => console.log('Server started. Press Ctrl+C to quit')); \n```\n\n\n要运行这个例子，需安装依赖 (`npm i --save puppeteer express`)，然后使用 Node 8.5.0+ 并带有 `--experimental-modules` 标志来运行服务器。\n\n这是一个该服务器返回的响应示例：\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <ul id=\"posts\">\n      <li class=\"post\">\n        <h2>Title 1</h2>\n        <div class=\"summary\">Summary 1</div>\n        <p>post content 1</p>\n      </li>\n      <li class=\"post\">\n        <h2>Title 2</h2>\n        <div class=\"summary\">Summary 2</div>\n        <p>post content 2</p>\n      </li>\n      ...\n    </ul>\n  </div>\n</body>\n<script>\n...\n</script>\n</html>\n```\n\n\n#### Server-Timing API 的一个最佳用例\n\n\n[Server-Timing](https://w3c.github.io/server-timing/) API 支持将服务器性能指标（比如请求/响应时间，数据库查询）返回给浏览器。客户端可以使用这些信息来追踪 web 应用的所有性能数据。\n\n\nServer-Timing 的一个最佳用例是上报无头 Chrome 预渲染页面的时间！只需在响应上添加 `Server-Timing` 头，就可以实现这一点：\n\n```\nres.set('Server-Timing',  `Prerender;dur=1000;desc=\"Headless render time (ms)\"`);  \n```\n\n\n客户端上，[Performance Timeline API](https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline) 和 [PerformanceObserver](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver) 可以获取这些指标：\n\n\n```\n  const entry = performance.getEntriesByType('navigation').find(\n    e => e.name === location.href);\nconsole.log(entry.serverTiming[0].toJSON());\n```\n\n```\n{\n  \"name\": \"Prerender\",\n  \"duration\": 3808,\n  \"description\": \"Headless render time (ms)\"\n}\n```\n\n\n### 性能结果\n\n\n**注意：** 这些数据体现了我随后讨论的大多数性能[优化](#optimizations)。\n\n\n性能数据怎么样？在我的一个[应用](https://devwebfeed.appspot.com/ssr)([代码](https://github.com/ebidel/devwebfeed/blob/master/server.mjs))上，无头 Chrome 渲染页面大约需要 1s。页面被缓存后， **3G 低网速模拟**下，[FCP](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics) 要比客户端渲染版本的**快 8.37s**。\n\n\n &nbsp; | **首次绘制 (FP)** | **首次内容绘制 (FCP)** |\n---- | ---- | ---- |\n客户端渲染|4s|11s|\n服务端渲染|2.3s|~2.3s|\n\n\n这些结果很有用。因为服务端渲染页面**不再依赖于 JavaScript 的加载**，用户看到有意义的内容比以前快得多。\n\n<br>\n\n## Preventing re-hydration\n\n---------------------------------------\n\n还记得我说“我们无需在客户端应用上改任何代码”吗？那是骗你们的。\n\nExpress 应用接收请求，使用 Puppeteer 将页面加载进无头浏览器，然后在响应中返回结果。但这里有一个问题。\n\n浏览器加载页面时，**无头 Chrome 中相同的 JS** 会在服务器上**再次执行**。有两处都在生成 HTML。 \n\n一起来修复这个问题。我们要告知页面，它的 HTML 早就名花有主了。我找到的解决方案是，在页面加载时判断 `<ul id=\"posts\">` 是否已在 DOM 中，如果在，页面就已经在服务端渲染过了，这样就可以避免重新创建 DOM。\n\n**public/index.html**\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <!-- Populated by JS (below) or by prerendering (server). Either way,\n         #container gets populated with the posts markup:\n      <ul id=\"posts\">...</ul>\n    -->\n  </div>\n</body>\n<script>\n...\n(async() => {\n  const container = document.querySelector('#container');\n\n  // Posts markup is already in DOM if we're seeing a SSR'd.\n  // Don't re-hydrate the posts here on the client.\n  const PRE_RENDERED = container.querySelector('#posts');\n  if (!PRE_RENDERED) {\n    const posts = await fetch('/posts').then(resp => resp.json());\n    renderPosts(posts, container);\n  }\n})();\n</script>\n</html>\n```\n<br>\n\n## 优化\n-----------------------------\n\n除了缓存渲染结果之外，还有一些有趣的优化技巧。有的优化可以快速见效，而有的可能带有猜测性的。\n\n### 中止不必要的请求\n\n现在，整个页面（以及它请求的所有资源）都无脑地加载进无头 Chrome。然而，我们只关注于两件事情：\n\n1. 渲染 HTML\n2. 生成 HTML 的 JS\n\n\n**不构造 DOM 的网络请求是浪费的**。一些资源，比如图片、字体、样式表和媒体内容，不参与页面的 HTML 构建。它们负责添加样式，补充页面的结构，但并不显式地创建页面。我们应该告诉浏览器去忽略掉这些资源！这样可以减少无头 Chrome 的工作负担，从而**节省带宽**，并且潜在地**加速了大型页面的预渲染时间**。\n\n[Protocol 开发者工具](https://chromedevtools.github.io/devtools-protocol/)提供了一个强大的特性，叫做[网络拦截](https://chromedevtools.github.io/devtools-protocol/tot/Network#event-requestIntercepted)。它可以用于**在浏览器发出之前修改请求**。Puppeteer 也支持网络拦截，它是通过打开 [`page.setRequestInterception(true)`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetrequestinterceptionvalue)，监听[页面的 `request` 事件](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-request)来实现的。这样我们可以中止某些资源请求。\n\n**ssr.mjs**\n\n```\nasync function ssr(url) {\n  ...\n  const page = await browser.newPage();\n\n  // 1. Intercept network requests.\n  await page.setRequestInterception(true);\n\n  page.on('request', req => {\n    // 2. Ignore requests for resources that don't produce DOM\n    // (images, stylesheets, media).\n    const whitelist = ['document', 'script', 'xhr', 'fetch'];\n    if (!whitelist.includes(req.resourceType())) {\n      return req.abort();\n    }\n\n    // 3. Pass through all other requests.\n    req.continue();\n  });\n\n  await page.goto(url, {waitUntil: 'networkidle0'});\n  const html = await page.content(); // serialized HTML of page DOM.\n  await browser.close();\n\n  return {html};\n}\n```\n\n**注意：** 安全起见，我使用了一个白名单，允许所有其他类型的请求能够继续正常发出。预先避免中止掉其他必要的请求。\n\n\n### 内联关键资源\n\n使用构建工具（比如 `gulp`）编译应用，并在构建时将关键 CSS/JS 内联到页面内，是一种很常见的做法。由于浏览器初始化页面加载时的请求数更少了，这样也就加速了首次有效绘制时间。\n\n别用构建工具了，**浏览器就是你的构建工具**！我们可以用 Puppeteer 管理页面 DOM，内联样式，JavaScript， 或者其他任何你想在预渲染之前加到页面中的东西。\n\n这个例子演示了如何拦截本地样式表的响应，并将这些资源内联进 `<style>` 标签中：\n\n**ssr.mjs**\n\n```\nimport urlModule from 'url';\nconst URL = urlModule.URL;\n\nasync function ssr(url) {\n  ...\n  const stylesheetContents = {};\n\n  // 1. Stash the responses of local stylesheets.\n  page.on('response', async resp => {\n    const responseUrl = resp.url();\n    const sameOrigin = new URL(responseUrl).origin === new URL(url).origin;\n    const isStylesheet = resp.request().resourceType() === 'stylesheet';\n    if (sameOrigin && isStylesheet) {\n      stylesheetContents[responseUrl] = await resp.text();\n    }\n  });\n\n  // 2. Load page as normal, waiting for network requests to be idle.\n  await page.goto(url, {waitUntil: 'networkidle0'});\n\n  // 3. Inline the CSS.\n  // Replace stylesheets in the page with their equivalent <style>.\n  await page.$$eval('link[rel=\"stylesheet\"]', (links, content) => {\n    links.forEach(link => {\n      const cssText = content[link.href];\n      if (cssText) {\n        const style = document.createElement('style');\n        style.textContent = cssText;\n        link.replaceWith(style);\n      }\n    });\n  }, stylesheetContents);\n\n  // 4. Get updated serialized HTML of page.\n  const html = await page.content();\n  await browser.close();\n\n  return {html};\n}\n```\n\n\n这段代码：\n\n1. 使用一个 [`page.on('response')`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-response) 处理器来监听网络响应。\n2. 储藏本地样式表的响应。\n3. 找到 DOM 中所有的 `<link rel=\"stylesheet\">`，将它们替换成一个等价的 `<style>`。具体见 [`page.$$eval`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevalselector-pagefunction-args) API 文档。`style.textContent` 被设为样式表的响应内容。\n\n\n### 自动压缩资源\n\n另一个可以借助网络拦截玩的小把戏是**修改请求的响应内容**。\n\n举个例子，你想要压缩 CSS，但也希望开发阶段不要被压缩，这样开发时能方便些。假设你已经用另一个工具来预压缩 `styles.css`，可以用 `Request.respond()`，将 `styles.css` 的内容重写为 `styles.min.css`。\n\n**ssr.mjs**\n\n```\nimport fs from 'fs';\n\nasync function ssr(url) {\n  ...\n\n  // 1. Intercept network requests.\n  await page.setRequestInterception(true);\n\n  page.on('request', req => {\n    // 2. If request is for styles.css, respond with the minified version.\n    if (req.url().endsWith('styles.css')) {\n      return req.respond({\n        status: 200,\n        contentType: 'text/css',\n        body: fs.readFileSync('./public/styles.min.css', 'utf-8')\n      });\n    }\n    ...\n\n    req.continue();\n  });\n  ...\n\n  const html = await page.content();\n  await browser.close();\n\n  return {html};\n}\n```\n\n\n### 重用 Chrome 实例实现交叉渲染\n\n\n每次预渲染都启动新的浏览器会很浪费。相反，你希望只启动一个实例，然后在多个页面渲染时重用它。\n\nPuppeteer 可以通过调用 [`puppeteer.connect()`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions)，连接到一个已有的 Chrome 实例，它接收实例的远程调试 URL 作为参数。为保证浏览器实例的长时间运行，我们可以将 `ssr()` 函数启动 Chrome 这部分代码移到 Express 服务器里。\n\n**server.mjs**\n\n```\nimport express from 'express';\nimport puppeteer from 'puppeteer';\nimport ssr from './ssr.mjs';\n\nlet browserWSEndpoint = null;\nconst app = express();\n\napp.get('/', async (req, res, next) => {\n  if (!browserWSEndpoint) {\n    const browser = await puppeteer.launch();\n    browserWSEndpoint = await browser.wsEndpoint();\n  }\n\n  const url = `${req.protocol}://${req.get('host')}/index.html`;\n  const {html} = await ssr(url, browserWSEndpoint);\n\n  return res.status(200).send(html);\n});  \n```\n\n**ssr.mjs**\n\n```\nimport puppeteer from 'puppeteer';\n\n/**\n * @param {string} url URL to prerender.\n * @param {string} browserWSEndpoint Optional remote debugging URL. If\n *     provided, Puppeteer's reconnects to the browser instance. Otherwise,\n *     a new browser instance is launched.\n */\nasync function ssr(url, browserWSEndpoint) {\n  ...\n  console.info('Connecting to existing Chrome instance.');\n  const browser = await puppeteer.connect({browserWSEndpoint});\n\n  const page = await browser.newPage();\n  ...\n  await page.close(); // Close the page we opened here (not the browser).\n\n  return {html};\n}\n```\n\n\n#### 例子：实现周期性预渲染的定时任务\n\n\n在 [App 引擎面板应用](https://devwebfeed.appspot.com/ssr) 里，我创建了一个[定时处理器](https://cloud.google.com/appengine/docs/flexible/nodejs/scheduling-jobs-with-cron-yaml)，来周期性的重复渲染排名前几位的页面。帮助用户快速看到最新内容，他们根本感知不到一个新页面的启动性能消耗。在这个例子中，生成多个 Chrome 实例会很浪费。相反，我用了一个共享的浏览器实例来一次性渲染这些页面。\n\n```\nimport puppeteer from 'puppeteer';\nimport * as prerender from './ssr.mjs';\nimport urlModule from 'url';\nconst URL = urlModule.URL;\n\napp.get('/cron/update_cache', async (req, res) => {\n  if (!req.get('X-Appengine-Cron')) {\n    return res.status(403).send('Sorry, cron handler can only be run as admin.');\n  }\n\n  const browser = await puppeteer.launch();\n  const homepage = new URL(`${req.protocol}://${req.get('host')}`);\n\n  // Re-render main page and a few pages back.\n  prerender.clearCache();\n  await prerender.ssr(homepage.href, await browser.wsEndpoint());\n  await prerender.ssr(`${homepage}?year=2018`);\n  await prerender.ssr(`${homepage}?year=2017`);\n  await prerender.ssr(`${homepage}?year=2016`);\n  await browser.close();\n\n  res.status(200).send('Render cache updated!');\n});\n```\n\n我还在 **ssr.js** export 上加了一个 `clearCache()` 函数。\n\n```\n...\nfunction clearCache() {\n  RENDER_CACHE.clear();\n}\n\nexport {ssr, clearCache};\n```\n\n<br>\n## 其他因素\n------------------------------------\n\n### 告诉页面：“你正在被无头浏览器渲染”\n\n\n当页面正在服务器上的无头 Chrome 中渲染时，客户端逻辑很有必要知道这一信息。我的应用使用了钩子来“关闭”部分不参与渲染 post 节点的页面。举例来说，我禁用了懒加载 [firebase-auth.js](https://firebase.google.com/docs/web/setup) 这部分代码。根本不需要用户登录！\n\n在 URL 上加一个 `?headless` 参数，是一个给页面加钩子的简单方法：\n\n**ssr.mjs**\n\n```\nimport urlModule from 'url';\nconst URL = urlModule.URL;\n\nasync function ssr(url) {\n  ...\n  // Add ?headless to the URL so the page has a signal\n  // it's being loaded by headless Chrome.\n  const renderUrl = new URL(url);\n  renderUrl.searchParams.set('headless', '');\n  await page.goto(renderUrl, {waitUntil: 'networkidle0'});\n  ...\n\n  return {html};\n}\n```\n\n可以在页面内查询该参数：\n\n**public/index.html**\n\n```\n<html>\n<body>\n  <div id=\"container\">\n    <!-- Populated by the JS below. -->\n  </div>\n</body>\n<script>\n...\n\n(async() => {\n  const params = new URL(location.href).searchParams;\n\n  const RENDERING_IN_HEADLESS = params.has('headless');\n  if (RENDERING_IN_HEADLESS) {\n    // Being rendered by headless Chrome on the server.\n    // e.g. shut off features, don't lazy load non-essential resources, etc.\n  }\n\n  const container = document.querySelector('#container');\n  const posts = await fetch('/posts').then(resp => resp.json());\n  renderPosts(posts, container);\n})();\n</script>\n</html> \n```\n\n\nTip：[`Page.evaluateOnNewDocument()`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluateonnewdocumentpagefunction-args) 也可以方便的查询参数。它会在页面中注入代码，让 Puppeteer 在页面中剩余待执行的 JavaScript 之前运行这些代码。\n\n\n### 避免 PV 膨胀\n\n\n你如果正在页面上使用分析工具，那么要小心了。预渲染的页面可能会造成 PV 出现膨胀。具体来说，**打点数据将会提升2倍**，一半是在无头 Chrome 渲染时，另一半出现在用户浏览器渲染时。\n\n那么怎么修复这个问题呢？将所有加载分析脚本的请求拦截掉。\n\n```\npage.on('request', req => {\n  // Don't load Google Analytics lib requests so pageviews aren't 2x.\n  const blacklist = ['www.google-analytics.com', '/gtag/js', 'ga.js', 'analytics.js'];\n  if (blacklist.find(regex => req.url().match(regex))) {\n    return req.abort();\n  }\n  ...\n  req.continue();\n});\n```\n\n\n代码不加载，页面访问就不会被记录。真 Skr 个机灵鬼 💥。\n\n或者，你也可以继续加载分析脚本，来获悉服务器上运行的预渲染器数。\n\n<br>\n\n## 结论\n--------------------------\n\nPuppeteer 通过运行无头 Chrome，不费吹灰之力就实现了服务端渲染。**提升加载性能**和**没有改动大量代码就增强了应用的可索引性**，是这个方案中我最喜欢的“特性”。\n\n**注意：** 如果你对文章中描述的技术感兴趣，可以去看看[这个应用](https://devwebfeed.appspot.com/ssr)，以及[它的代码](https://github.com/ebidel/devwebfeed/blob/master/server.mjs)。\n\n<br>\n\n## 附录\n------------------------\n\n### 现有技术的讨论\n\n很难在服务端上渲染客户端应用。有多难？去看看大家给这个话题奉献了多少个 [npm 包](https://www.npmjs.com/search?q=server%20side%20rendering)就知道了。有数不清的[模式](https://en.wikipedia.org/wiki/Isomorphic_JavaScript)，[工具](https://github.com/GoogleChrome/rendertron)，和[服务](https://prerender.io/)来辅助服务端渲染的 JS 应用。\n\n#### 同构 JavaScript\n\n同构 JavaScript 的概念很简单：同样的代码既能在服务端运行，也能在客户端（浏览器）运行。服务器和客户端共享代码，美滋滋！\n\n实践中，我发现同构 JS 很难实现。这是我自己的问题...\n\n> 我最近开始做一个[项目](https://github.com/ebidel/devwebfeed/blob/master/server.mjs)，尝试下 [lit-html](https://github.com/Polymer/lit-html)。Lit 是一个优秀的库，它可以允许你写使用 JS 模板字符串写 [HTML \\<template>](https://www.html5rocks.com/en/tutorials/webcomponents/template/)，然后高效地将这些模板渲染为 DOM。问题是它的核心特性（使用 `<template>` 元素）只能在浏览器上工作。这意味着它在 Node 服务器上不能运行。我希望 Node 和前端共享的 SSR 代码能够脱离 window 对象。\n\n> 最后我意识到可以使用无头 Chrome 来服务端渲染应用，Chrome 是经用户的手运行或是在服务器上自动运行并不重要，它反正是愉快地执行了所有 JS。不要多问。 \n\n无头 Chrome 在服务器和客户端上启用 “同构 JS”。它对于当前库不支持服务端（Node）给出了一个不错的解决方案。\n\n\n#### 预渲染工具\n\nNode 社区已经诞生了好几吨解决服务端渲染 JS 应用的工具。毫无新意！个人而言，我发现各人对于这些工具的体会可能不同，所以使用这些工具前肯定要做好功课。比如说，一些服务端渲染工具比较老，并且没有使用无头 Chrome（或者任何其他无头浏览器）。相反，它们使用 PhantomJS（又名旧 Safari），这意味着使用新特性时页面不会正确渲染。\n\n一个值得注意的例外是 [Prerender](https://github.com/prerender/prerender/)。Prerender 使用了无头 Chrome 和 [Express 中间件](https://github.com/prerender/prerender-node)。\n\n```\nconst prerender =  require('prerender');  \nconst server = prerender();  \nserver.use(prerender.removeScriptTags());  \nserver.use(prerender.blockResources());  \nserver.start();  \n```\n\nPrerender 省去了跨平台下载和安装 Chrome 的所有细节。要正确完成这一过程通常是相当棘手的，这也是 [Puppeteer](https://developers.google.com/web/tools/puppeteer/faq#q_which_chromium_version_does_puppeteer_use) 存在的原因之一。我也提了一些渲染我的部分应用的 issue。\n\n\n![浏览器中渲染的 Chrome 状态](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/1.png)\n\n\n\n![prerender 渲染的 Chrome 状态](https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/2.png)\n\n\n","slug":"【译】无头Chrome：服务端渲染JS页面的一个解决方案","published":1,"updated":"2019-12-29T11:28:13.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4qygnbs006qhns6xsr4thu5","content":"<h3 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h3><blockquote>\n<p><a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">无头 Chrome</a> 是一个将动态 JS 页面转成静态 HTML 页面的即插即用的解决方案。将其运行于 web 服务器之上，你可以<strong>预渲染任何现代 JS 特性</strong>，从而提速内容加载，并且是<strong>可被搜索引擎索引的</strong>。</p>\n</blockquote>\n<p>本篇文章介绍的技术，旨在教大家如何使用 <a href=\"https://developers.google.com/web/tools/puppeteer/\" target=\"_blank\" rel=\"noopener\">Puppeteer</a> 的 API，给一个 Express 服务器添加服务端渲染（SSR）能力。最棒的地方是，<strong>应用本身几乎不需要修改任何代码</strong>。无头 Chrome 做了所有的重活。三两行代码，SSR 页面带回家。</p>\n<p>大餐之前先来点甜点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  const browser = await puppeteer.launch(&#123;headless: true&#125;);</span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\">  await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">  const html = await page.content(); // serialized HTML of page DOM.</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\">  return html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 我会在文章中使用 ES 模块（<code>import</code>），这要求 Node 8.5.0+，并在运行时加上 <code>--experimental-modules</code> 标志。觉得麻烦的话可以自行使用 <code>require()</code> 语句。关于 Node 上的 ES 模块支持可以读读<a href=\"https://nodejs.org/api/esm.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p><br></p>\n<h2 id=\"导论\"><a href=\"#导论\" class=\"headerlink\" title=\"导论\"></a>导论</h2><hr>\n<p>如果我对 <a href=\"https://en.wikipedia.org/wiki/Search_engine_optimization\" target=\"_blank\" rel=\"noopener\">SEO</a> 理解没有偏差的话，你读到这篇文章可能因为下面两个原因之一。首先，你已经搭建了一个 web 应用，并且它没有被搜索引擎索引！你的应用可能是 SPA，<a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">PWA</a>，使用了 vanilla JS，或者使用了其他更复杂的框架或类库。老实说，你使用何种技术并不重要。重要的是，你花费了大量时间搭建出优秀的 web 页面，然而用户却搜不到它。你读这篇文章的另一个理由可能是因为，网上一些文章说了服务端渲染可以提升性能。你希望快速减少<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization/\" target=\"_blank\" rel=\"noopener\"> JavaScript 启动时间</a>，提升<a href=\"https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint\" target=\"_blank\" rel=\"noopener\">首次有效绘制</a>速度。</p>\n<p>一些框架，比如 Preact 使用了<a href=\"https://github.com/developit/preact-render-to-string\" target=\"_blank\" rel=\"noopener\">工具</a>来实现服务端渲染。如果你使用的框架具备预渲染的解决方案，请继续使用。没有任何理由引入另一个工具（无头 Chrome / Puppeteer）。</p>\n<h3 id=\"爬取现代网站\"><a href=\"#爬取现代网站\" class=\"headerlink\" title=\"爬取现代网站\"></a>爬取现代网站</h3><p>\b搜索引擎爬虫，社交平台，<a href=\"https://en.wikipedia.org/wiki/Lynx_(web_browser\" target=\"_blank\" rel=\"noopener\">甚至浏览器</a>)自诞生至今就唯一依赖于静态 HTML 标记，来索引 web 页面和表层内容。现代 web 页面已经演变的\b大为不同。基于 JavaScript 的应用，在很多时候，需要保持网站内容是对于爬取工具是可见的。</p>\n<p>一些爬虫，比如 Google \b搜索，已经变得更智能了！Google 的爬虫使用\b Chrome 41 <a href=\"https://developers.google.com/search/docs/guides/rendering\" target=\"_blank\" rel=\"noopener\">执行 JavaScript</a>，并渲染出最终的页面。但是这个方案才刚出来，还不完美。\b举个例子，使用了新特性的页面，比如 ES6 Class，<a href=\"https://www.chromestatus.com/feature/5365692190687232\" target=\"_blank\" rel=\"noopener\">模块</a>，箭头函数等，将会在这个\b比较老的浏览器上报错，使得页面不能正确渲染。至于其他搜索引擎，\b鬼知道它们在干嘛！？¯_(ツ)_/¯</p>\n<h2 id=\"使用无头-Chrome-预渲染页面\"><a href=\"#使用无头-Chrome-预渲染页面\" class=\"headerlink\" title=\"使用无头 Chrome 预渲染页面\"></a>使用无头 Chrome 预渲染页面</h2><hr>\n<p>所有的爬虫程序都能够理解 HTML。我们要“解决”索引问题的话需要一个工具，它来执行 JS 生成 HTML。我不会告诉你现在已经有这样一个工具了！</p>\n<ol>\n<li>该工具可以运行所有类型的现代 JavaScript，并吐出静态 HTML。</li>\n<li>出现新特性时，该工具可以保持更新</li>\n<li>已有应用上只需少量代码就可以运行这个工具</li>\n</ol>\n<p>听起来很不错吧？<strong>这个工具就是浏览器</strong>！</p>\n<p>无头 Chrome 不在乎你使用什么库、框架或者工具。它将 JavaScript 作为早餐，在午饭前吐出静态 HTML。可能会更快一点 :) -Eric</p>\n<p>如果你用的 Node，Puppeteer 容易上手。它的 API 提供了预渲染客户端应用的能力。下面用个例子演示下。</p>\n<h3 id=\"1-JS-应用示例\"><a href=\"#1-JS-应用示例\" class=\"headerlink\" title=\"1. JS 应用示例\"></a>1. JS 应用示例</h3><p>我们以一个 JavaScript 生成 HTML 的动态页面为例：</p>\n<p><strong>public/index.html</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Populated by the JS below. --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">function renderPosts(posts, container) &#123;</span><br><span class=\"line\">  const html = posts.reduce((html, post) =&gt; &#123;</span><br><span class=\"line\">    return `$&#123;html&#125;</span><br><span class=\"line\">      &lt;li class=&quot;post&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;$&#123;post.title&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;div class=&quot;summary&quot;&gt;$&#123;post.summary&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;p&gt;$&#123;post.content&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/li&gt;`;</span><br><span class=\"line\">  &#125;, &apos;&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // CAREFUL: assumes html is sanitized.</span><br><span class=\"line\">  container.innerHTML = `&lt;ul id=&quot;posts&quot;&gt;$&#123;html&#125;&lt;/ul&gt;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(async() =&gt; &#123;</span><br><span class=\"line\">  const container = document.querySelector(&apos;#container&apos;);</span><br><span class=\"line\">  const posts = await fetch(&apos;/posts&apos;).then(resp =&gt; resp.json());</span><br><span class=\"line\">  renderPosts(posts, container);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-服务端渲染函数\"><a href=\"#2-服务端渲染函数\" class=\"headerlink\" title=\"2. 服务端渲染函数\"></a>2. 服务端渲染函数</h3><p>接下来，我们会使用之前提到的 <code>ssr()</code> 函数，并充实它的内容。</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// In-memory cache of rendered pages. Note: this will be cleared whenever the</span><br><span class=\"line\">// server process stops. If you need true persistence, use something like</span><br><span class=\"line\">// Google Cloud Storage (https://firebase.google.com/docs/storage/web/start).</span><br><span class=\"line\">const RENDER_CACHE = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  if (RENDER_CACHE.has(url)) &#123;</span><br><span class=\"line\">    return &#123;html: RENDER_CACHE.get(url), ttRenderMs: 0&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const start = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  const browser = await puppeteer.launch();</span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    // networkidle0 waits for the network to be idle (no requests for 500ms).</span><br><span class=\"line\">    // The page&apos;s JS has likely produced markup by this point, but wait longer</span><br><span class=\"line\">    // if your site lazy loads, etc.</span><br><span class=\"line\">    await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">    await page.waitForSelector(&apos;#posts&apos;); // ensure #posts exists in the DOM.</span><br><span class=\"line\">  &#125; catch (err) &#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">    throw new Error(&apos;page.goto/waitForSelector timed out.&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const html = await page.content(); // serialized HTML of page DOM.</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  const ttRenderMs = Date.now() - start;</span><br><span class=\"line\">  console.info(`Headless rendered page in: $&#123;ttRenderMs&#125;ms`);</span><br><span class=\"line\"></span><br><span class=\"line\">  RENDER_CACHE.set(url, html); // cache rendered page.</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html, ttRenderMs&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;ssr as default&#125;;</span><br></pre></td></tr></table></figure>\n<p>主要的变化：</p>\n<ol>\n<li>添加了缓存。缓存已渲染的 HTML 对于加速响应时间居功至伟。当页面再次有请求过来，避免了无头 Chrome 的重复执行。我随后会讨论其他的<a href=\"#optimizations\">优化</a> 。</li>\n<li>添加加载页面超时时的基本错误处理。</li>\n<li>添加了 <code>page.waitForSelector(&#39;#posts&#39;)</code> 这行代码。确保在丢弃这个序列化页面之前，posts 节点存在于 DOM 之中。</li>\n<li>记录无头浏览器渲染页面所用时间。</li>\n<li>代码都被封装进名为 <code>ssr.mjs</code> 的模块中。</li>\n</ol>\n<h3 id=\"3-web-服务器示例\"><a href=\"#3-web-服务器示例\" class=\"headerlink\" title=\"3. web 服务器示例\"></a>3. web 服务器示例</h3><p>最后，一个小的 express 服务器完成了所有的工作。它预渲染 URL <code>http://localhost/index.html</code>（主页），并在响应中返回渲染结果。由于响应中包含了静态 HTML， 当用户访问页面，posts 节点会立刻呈现。</p>\n<p><strong>server.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import express from &apos;express&apos;;</span><br><span class=\"line\">import ssr from &apos;./ssr.mjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, async (req, res, next) =&gt; &#123;</span><br><span class=\"line\">  const &#123;html, ttRenderMs&#125; = await ssr(`$&#123;req.protocol&#125;://$&#123;req.get(&apos;host&apos;)&#125;/index.html`);</span><br><span class=\"line\">  // Add Server-Timing! See https://w3c.github.io/server-timing/.</span><br><span class=\"line\">  res.set(&apos;Server-Timing&apos;, `Prerender;dur=$&#123;ttRenderMs&#125;;desc=&quot;Headless render time (ms)&quot;`);</span><br><span class=\"line\">  return res.status(200).send(html); // Serve prerendered page as response.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(8080, () =&gt; console.log(&apos;Server started. Press Ctrl+C to quit&apos;));</span><br></pre></td></tr></table></figure>\n<p>要运行这个例子，需安装依赖 (<code>npm i --save puppeteer express</code>)，然后使用 Node 8.5.0+ 并带有 <code>--experimental-modules</code> 标志来运行服务器。</p>\n<p>这是一个该服务器返回的响应示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;ul id=&quot;posts&quot;&gt;</span><br><span class=\"line\">      &lt;li class=&quot;post&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;Title 1&lt;/h2&gt;</span><br><span class=\"line\">        &lt;div class=&quot;summary&quot;&gt;Summary 1&lt;/div&gt;</span><br><span class=\"line\">        &lt;p&gt;post content 1&lt;/p&gt;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">      &lt;li class=&quot;post&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;Title 2&lt;/h2&gt;</span><br><span class=\"line\">        &lt;div class=&quot;summary&quot;&gt;Summary 2&lt;/div&gt;</span><br><span class=\"line\">        &lt;p&gt;post content 2&lt;/p&gt;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Server-Timing-API-的一个最佳用例\"><a href=\"#Server-Timing-API-的一个最佳用例\" class=\"headerlink\" title=\"Server-Timing API 的一个最佳用例\"></a>Server-Timing API 的一个最佳用例</h4><p><a href=\"https://w3c.github.io/server-timing/\" target=\"_blank\" rel=\"noopener\">Server-Timing</a> API 支持将服务器性能指标（比如请求/响应时间，数据库查询）返回给浏览器。客户端可以使用这些信息来追踪 web 应用的所有性能数据。</p>\n<p>Server-Timing 的一个最佳用例是上报无头 Chrome 预渲染页面的时间！只需在响应上添加 <code>Server-Timing</code> 头，就可以实现这一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">res.set(&apos;Server-Timing&apos;,  `Prerender;dur=1000;desc=&quot;Headless render time (ms)&quot;`);</span><br></pre></td></tr></table></figure>\n<p>客户端上，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline\" target=\"_blank\" rel=\"noopener\">Performance Timeline API</a> 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\" target=\"_blank\" rel=\"noopener\">PerformanceObserver</a> 可以获取这些指标：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">  const entry = performance.getEntriesByType(&apos;navigation&apos;).find(</span><br><span class=\"line\">    e =&gt; e.name === location.href);</span><br><span class=\"line\">console.log(entry.serverTiming[0].toJSON());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;Prerender&quot;,</span><br><span class=\"line\">  &quot;duration&quot;: 3808,</span><br><span class=\"line\">  &quot;description&quot;: &quot;Headless render time (ms)&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能结果\"><a href=\"#性能结果\" class=\"headerlink\" title=\"性能结果\"></a>性能结果</h3><p><strong>注意：</strong> 这些数据体现了我随后讨论的大多数性能<a href=\"#optimizations\">优化</a>。</p>\n<p>性能数据怎么样？在我的一个<a href=\"https://devwebfeed.appspot.com/ssr\" target=\"_blank\" rel=\"noopener\">应用</a>(<a href=\"https://github.com/ebidel/devwebfeed/blob/master/server.mjs\" target=\"_blank\" rel=\"noopener\">代码</a>)上，无头 Chrome 渲染页面大约需要 1s。页面被缓存后， <strong>3G 低网速模拟</strong>下，<a href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics\" target=\"_blank\" rel=\"noopener\">FCP</a> 要比客户端渲染版本的<strong>快 8.37s</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>&nbsp;</th>\n<th><strong>首次绘制 (FP)</strong></th>\n<th><strong>首次内容绘制 (FCP)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端渲染</td>\n<td>4s</td>\n<td>11s</td>\n<td></td>\n</tr>\n<tr>\n<td>服务端渲染</td>\n<td>2.3s</td>\n<td>~2.3s</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>这些结果很有用。因为服务端渲染页面<strong>不再依赖于 JavaScript 的加载</strong>，用户看到有意义的内容比以前快得多。</p>\n<p><br></p>\n<h2 id=\"Preventing-re-hydration\"><a href=\"#Preventing-re-hydration\" class=\"headerlink\" title=\"Preventing re-hydration\"></a>Preventing re-hydration</h2><hr>\n<p>还记得我说“我们无需在客户端应用上改任何代码”吗？那是骗你们的。</p>\n<p>Express 应用接收请求，使用 Puppeteer 将页面加载进无头浏览器，然后在响应中返回结果。但这里有一个问题。</p>\n<p>浏览器加载页面时，<strong>无头 Chrome 中相同的 JS</strong> 会在服务器上<strong>再次执行</strong>。有两处都在生成 HTML。 </p>\n<p>一起来修复这个问题。我们要告知页面，它的 HTML 早就名花有主了。我找到的解决方案是，在页面加载时判断 <code>&lt;ul id=&quot;posts&quot;&gt;</code> 是否已在 DOM 中，如果在，页面就已经在服务端渲染过了，这样就可以避免重新创建 DOM。</p>\n<p><strong>public/index.html</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Populated by JS (below) or by prerendering (server). Either way,</span><br><span class=\"line\">         #container gets populated with the posts markup:</span><br><span class=\"line\">      &lt;ul id=&quot;posts&quot;&gt;...&lt;/ul&gt;</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">(async() =&gt; &#123;</span><br><span class=\"line\">  const container = document.querySelector(&apos;#container&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // Posts markup is already in DOM if we&apos;re seeing a SSR&apos;d.</span><br><span class=\"line\">  // Don&apos;t re-hydrate the posts here on the client.</span><br><span class=\"line\">  const PRE_RENDERED = container.querySelector(&apos;#posts&apos;);</span><br><span class=\"line\">  if (!PRE_RENDERED) &#123;</span><br><span class=\"line\">    const posts = await fetch(&apos;/posts&apos;).then(resp =&gt; resp.json());</span><br><span class=\"line\">    renderPosts(posts, container);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><hr>\n<p>除了缓存渲染结果之外，还有一些有趣的优化技巧。有的优化可以快速见效，而有的可能带有猜测性的。</p>\n<h3 id=\"中止不必要的请求\"><a href=\"#中止不必要的请求\" class=\"headerlink\" title=\"中止不必要的请求\"></a>中止不必要的请求</h3><p>现在，整个页面（以及它请求的所有资源）都无脑地加载进无头 Chrome。然而，我们只关注于两件事情：</p>\n<ol>\n<li>渲染 HTML</li>\n<li>生成 HTML 的 JS</li>\n</ol>\n<p><strong>不构造 DOM 的网络请求是浪费的</strong>。一些资源，比如图片、字体、样式表和媒体内容，不参与页面的 HTML 构建。它们负责添加样式，补充页面的结构，但并不显式地创建页面。我们应该告诉浏览器去忽略掉这些资源！这样可以减少无头 Chrome 的工作负担，从而<strong>节省带宽</strong>，并且潜在地<strong>加速了大型页面的预渲染时间</strong>。</p>\n<p><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noopener\">Protocol 开发者工具</a>提供了一个强大的特性，叫做<a href=\"https://chromedevtools.github.io/devtools-protocol/tot/Network#event-requestIntercepted\" target=\"_blank\" rel=\"noopener\">网络拦截</a>。它可以用于<strong>在浏览器发出之前修改请求</strong>。Puppeteer 也支持网络拦截，它是通过打开 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetrequestinterceptionvalue\" target=\"_blank\" rel=\"noopener\"><code>page.setRequestInterception(true)</code></a>，监听<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-request\" target=\"_blank\" rel=\"noopener\">页面的 <code>request</code> 事件</a>来实现的。这样我们可以中止某些资源请求。</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\"></span><br><span class=\"line\">  // 1. Intercept network requests.</span><br><span class=\"line\">  await page.setRequestInterception(true);</span><br><span class=\"line\"></span><br><span class=\"line\">  page.on(&apos;request&apos;, req =&gt; &#123;</span><br><span class=\"line\">    // 2. Ignore requests for resources that don&apos;t produce DOM</span><br><span class=\"line\">    // (images, stylesheets, media).</span><br><span class=\"line\">    const whitelist = [&apos;document&apos;, &apos;script&apos;, &apos;xhr&apos;, &apos;fetch&apos;];</span><br><span class=\"line\">    if (!whitelist.includes(req.resourceType())) &#123;</span><br><span class=\"line\">      return req.abort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 3. Pass through all other requests.</span><br><span class=\"line\">    req.continue();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">  const html = await page.content(); // serialized HTML of page DOM.</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 安全起见，我使用了一个白名单，允许所有其他类型的请求能够继续正常发出。预先避免中止掉其他必要的请求。</p>\n<h3 id=\"内联关键资源\"><a href=\"#内联关键资源\" class=\"headerlink\" title=\"内联关键资源\"></a>内联关键资源</h3><p>使用构建工具（比如 <code>gulp</code>）编译应用，并在构建时将关键 CSS/JS 内联到页面内，是一种很常见的做法。由于浏览器初始化页面加载时的请求数更少了，这样也就加速了首次有效绘制时间。</p>\n<p>别用构建工具了，<strong>浏览器就是你的构建工具</strong>！我们可以用 Puppeteer 管理页面 DOM，内联样式，JavaScript， 或者其他任何你想在预渲染之前加到页面中的东西。</p>\n<p>这个例子演示了如何拦截本地样式表的响应，并将这些资源内联进 <code>&lt;style&gt;</code> 标签中：</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import urlModule from &apos;url&apos;;</span><br><span class=\"line\">const URL = urlModule.URL;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const stylesheetContents = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 1. Stash the responses of local stylesheets.</span><br><span class=\"line\">  page.on(&apos;response&apos;, async resp =&gt; &#123;</span><br><span class=\"line\">    const responseUrl = resp.url();</span><br><span class=\"line\">    const sameOrigin = new URL(responseUrl).origin === new URL(url).origin;</span><br><span class=\"line\">    const isStylesheet = resp.request().resourceType() === &apos;stylesheet&apos;;</span><br><span class=\"line\">    if (sameOrigin &amp;&amp; isStylesheet) &#123;</span><br><span class=\"line\">      stylesheetContents[responseUrl] = await resp.text();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 2. Load page as normal, waiting for network requests to be idle.</span><br><span class=\"line\">  await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 3. Inline the CSS.</span><br><span class=\"line\">  // Replace stylesheets in the page with their equivalent &lt;style&gt;.</span><br><span class=\"line\">  await page.$$eval(&apos;link[rel=&quot;stylesheet&quot;]&apos;, (links, content) =&gt; &#123;</span><br><span class=\"line\">    links.forEach(link =&gt; &#123;</span><br><span class=\"line\">      const cssText = content[link.href];</span><br><span class=\"line\">      if (cssText) &#123;</span><br><span class=\"line\">        const style = document.createElement(&apos;style&apos;);</span><br><span class=\"line\">        style.textContent = cssText;</span><br><span class=\"line\">        link.replaceWith(style);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, stylesheetContents);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 4. Get updated serialized HTML of page.</span><br><span class=\"line\">  const html = await page.content();</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码：</p>\n<ol>\n<li>使用一个 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-response\" target=\"_blank\" rel=\"noopener\"><code>page.on(&#39;response&#39;)</code></a> 处理器来监听网络响应。</li>\n<li>储藏本地样式表的响应。</li>\n<li>找到 DOM 中所有的 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>，将它们替换成一个等价的 <code>&lt;style&gt;</code>。具体见 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevalselector-pagefunction-args\" target=\"_blank\" rel=\"noopener\"><code>page.$$eval</code></a> API 文档。<code>style.textContent</code> 被设为样式表的响应内容。</li>\n</ol>\n<h3 id=\"自动压缩资源\"><a href=\"#自动压缩资源\" class=\"headerlink\" title=\"自动压缩资源\"></a>自动压缩资源</h3><p>另一个可以借助网络拦截玩的小把戏是<strong>修改请求的响应内容</strong>。</p>\n<p>举个例子，你想要压缩 CSS，但也希望开发阶段不要被压缩，这样开发时能方便些。假设你已经用另一个工具来预压缩 <code>styles.css</code>，可以用 <code>Request.respond()</code>，将 <code>styles.css</code> 的内容重写为 <code>styles.min.css</code>。</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import fs from &apos;fs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  // 1. Intercept network requests.</span><br><span class=\"line\">  await page.setRequestInterception(true);</span><br><span class=\"line\"></span><br><span class=\"line\">  page.on(&apos;request&apos;, req =&gt; &#123;</span><br><span class=\"line\">    // 2. If request is for styles.css, respond with the minified version.</span><br><span class=\"line\">    if (req.url().endsWith(&apos;styles.css&apos;)) &#123;</span><br><span class=\"line\">      return req.respond(&#123;</span><br><span class=\"line\">        status: 200,</span><br><span class=\"line\">        contentType: &apos;text/css&apos;,</span><br><span class=\"line\">        body: fs.readFileSync(&apos;./public/styles.min.css&apos;, &apos;utf-8&apos;)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    req.continue();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  const html = await page.content();</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重用-Chrome-实例实现交叉渲染\"><a href=\"#重用-Chrome-实例实现交叉渲染\" class=\"headerlink\" title=\"重用 Chrome 实例实现交叉渲染\"></a>重用 Chrome 实例实现交叉渲染</h3><p>每次预渲染都启动新的浏览器会很浪费。相反，你希望只启动一个实例，然后在多个页面渲染时重用它。</p>\n<p>Puppeteer 可以通过调用 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions\" target=\"_blank\" rel=\"noopener\"><code>puppeteer.connect()</code></a>，连接到一个已有的 Chrome 实例，它接收实例的远程调试 URL 作为参数。为保证浏览器实例的长时间运行，我们可以将 <code>ssr()</code> 函数启动 Chrome 这部分代码移到 Express 服务器里。</p>\n<p><strong>server.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import express from &apos;express&apos;;</span><br><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\">import ssr from &apos;./ssr.mjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">let browserWSEndpoint = null;</span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, async (req, res, next) =&gt; &#123;</span><br><span class=\"line\">  if (!browserWSEndpoint) &#123;</span><br><span class=\"line\">    const browser = await puppeteer.launch();</span><br><span class=\"line\">    browserWSEndpoint = await browser.wsEndpoint();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const url = `$&#123;req.protocol&#125;://$&#123;req.get(&apos;host&apos;)&#125;/index.html`;</span><br><span class=\"line\">  const &#123;html&#125; = await ssr(url, browserWSEndpoint);</span><br><span class=\"line\"></span><br><span class=\"line\">  return res.status(200).send(html);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; url URL to prerender.</span><br><span class=\"line\"> * @param &#123;string&#125; browserWSEndpoint Optional remote debugging URL. If</span><br><span class=\"line\"> *     provided, Puppeteer&apos;s reconnects to the browser instance. Otherwise,</span><br><span class=\"line\"> *     a new browser instance is launched.</span><br><span class=\"line\"> */</span><br><span class=\"line\">async function ssr(url, browserWSEndpoint) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  console.info(&apos;Connecting to existing Chrome instance.&apos;);</span><br><span class=\"line\">  const browser = await puppeteer.connect(&#123;browserWSEndpoint&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  await page.close(); // Close the page we opened here (not the browser).</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"例子：实现周期性预渲染的定时任务\"><a href=\"#例子：实现周期性预渲染的定时任务\" class=\"headerlink\" title=\"例子：实现周期性预渲染的定时任务\"></a>例子：实现周期性预渲染的定时任务</h4><p>在 <a href=\"https://devwebfeed.appspot.com/ssr\" target=\"_blank\" rel=\"noopener\">App 引擎面板应用</a> 里，我创建了一个<a href=\"https://cloud.google.com/appengine/docs/flexible/nodejs/scheduling-jobs-with-cron-yaml\" target=\"_blank\" rel=\"noopener\">定时处理器</a>，来周期性的重复渲染排名前几位的页面。帮助用户快速看到最新内容，他们根本感知不到一个新页面的启动性能消耗。在这个例子中，生成多个 Chrome 实例会很浪费。相反，我用了一个共享的浏览器实例来一次性渲染这些页面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\">import * as prerender from &apos;./ssr.mjs&apos;;</span><br><span class=\"line\">import urlModule from &apos;url&apos;;</span><br><span class=\"line\">const URL = urlModule.URL;</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/cron/update_cache&apos;, async (req, res) =&gt; &#123;</span><br><span class=\"line\">  if (!req.get(&apos;X-Appengine-Cron&apos;)) &#123;</span><br><span class=\"line\">    return res.status(403).send(&apos;Sorry, cron handler can only be run as admin.&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const browser = await puppeteer.launch();</span><br><span class=\"line\">  const homepage = new URL(`$&#123;req.protocol&#125;://$&#123;req.get(&apos;host&apos;)&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">  // Re-render main page and a few pages back.</span><br><span class=\"line\">  prerender.clearCache();</span><br><span class=\"line\">  await prerender.ssr(homepage.href, await browser.wsEndpoint());</span><br><span class=\"line\">  await prerender.ssr(`$&#123;homepage&#125;?year=2018`);</span><br><span class=\"line\">  await prerender.ssr(`$&#123;homepage&#125;?year=2017`);</span><br><span class=\"line\">  await prerender.ssr(`$&#123;homepage&#125;?year=2016`);</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  res.status(200).send(&apos;Render cache updated!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我还在 <strong>ssr.js</strong> export 上加了一个 <code>clearCache()</code> 函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">function clearCache() &#123;</span><br><span class=\"line\">  RENDER_CACHE.clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;ssr, clearCache&#125;;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"其他因素\"><a href=\"#其他因素\" class=\"headerlink\" title=\"其他因素\"></a>其他因素</h2><hr>\n<h3 id=\"告诉页面：“你正在被无头浏览器渲染”\"><a href=\"#告诉页面：“你正在被无头浏览器渲染”\" class=\"headerlink\" title=\"告诉页面：“你正在被无头浏览器渲染”\"></a>告诉页面：“你正在被无头浏览器渲染”</h3><p>当页面正在服务器上的无头 Chrome 中渲染时，客户端逻辑很有必要知道这一信息。我的应用使用了钩子来“关闭”部分不参与渲染 post 节点的页面。举例来说，我禁用了懒加载 <a href=\"https://firebase.google.com/docs/web/setup\" target=\"_blank\" rel=\"noopener\">firebase-auth.js</a> 这部分代码。根本不需要用户登录！</p>\n<p>在 URL 上加一个 <code>?headless</code> 参数，是一个给页面加钩子的简单方法：</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import urlModule from &apos;url&apos;;</span><br><span class=\"line\">const URL = urlModule.URL;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  // Add ?headless to the URL so the page has a signal</span><br><span class=\"line\">  // it&apos;s being loaded by headless Chrome.</span><br><span class=\"line\">  const renderUrl = new URL(url);</span><br><span class=\"line\">  renderUrl.searchParams.set(&apos;headless&apos;, &apos;&apos;);</span><br><span class=\"line\">  await page.goto(renderUrl, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以在页面内查询该参数：</p>\n<p><strong>public/index.html</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Populated by the JS below. --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">(async() =&gt; &#123;</span><br><span class=\"line\">  const params = new URL(location.href).searchParams;</span><br><span class=\"line\"></span><br><span class=\"line\">  const RENDERING_IN_HEADLESS = params.has(&apos;headless&apos;);</span><br><span class=\"line\">  if (RENDERING_IN_HEADLESS) &#123;</span><br><span class=\"line\">    // Being rendered by headless Chrome on the server.</span><br><span class=\"line\">    // e.g. shut off features, don&apos;t lazy load non-essential resources, etc.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const container = document.querySelector(&apos;#container&apos;);</span><br><span class=\"line\">  const posts = await fetch(&apos;/posts&apos;).then(resp =&gt; resp.json());</span><br><span class=\"line\">  renderPosts(posts, container);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>Tip：<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluateonnewdocumentpagefunction-args\" target=\"_blank\" rel=\"noopener\"><code>Page.evaluateOnNewDocument()</code></a> 也可以方便的查询参数。它会在页面中注入代码，让 Puppeteer 在页面中剩余待执行的 JavaScript 之前运行这些代码。</p>\n<h3 id=\"避免-PV-膨胀\"><a href=\"#避免-PV-膨胀\" class=\"headerlink\" title=\"避免 PV 膨胀\"></a>避免 PV 膨胀</h3><p>你如果正在页面上使用分析工具，那么要小心了。预渲染的页面可能会造成 PV 出现膨胀。具体来说，<strong>打点数据将会提升2倍</strong>，一半是在无头 Chrome 渲染时，另一半出现在用户浏览器渲染时。</p>\n<p>那么怎么修复这个问题呢？将所有加载分析脚本的请求拦截掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">page.on(&apos;request&apos;, req =&gt; &#123;</span><br><span class=\"line\">  // Don&apos;t load Google Analytics lib requests so pageviews aren&apos;t 2x.</span><br><span class=\"line\">  const blacklist = [&apos;www.google-analytics.com&apos;, &apos;/gtag/js&apos;, &apos;ga.js&apos;, &apos;analytics.js&apos;];</span><br><span class=\"line\">  if (blacklist.find(regex =&gt; req.url().match(regex))) &#123;</span><br><span class=\"line\">    return req.abort();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  req.continue();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码不加载，页面访问就不会被记录。真 Skr 个机灵鬼 💥。</p>\n<p>或者，你也可以继续加载分析脚本，来获悉服务器上运行的预渲染器数。</p>\n<p><br></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><hr>\n<p>Puppeteer 通过运行无头 Chrome，不费吹灰之力就实现了服务端渲染。<strong>提升加载性能</strong>和<strong>没有改动大量代码就增强了应用的可索引性</strong>，是这个方案中我最喜欢的“特性”。</p>\n<p><strong>注意：</strong> 如果你对文章中描述的技术感兴趣，可以去看看<a href=\"https://devwebfeed.appspot.com/ssr\" target=\"_blank\" rel=\"noopener\">这个应用</a>，以及<a href=\"https://github.com/ebidel/devwebfeed/blob/master/server.mjs\" target=\"_blank\" rel=\"noopener\">它的代码</a>。</p>\n<p><br></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><hr>\n<h3 id=\"现有技术的讨论\"><a href=\"#现有技术的讨论\" class=\"headerlink\" title=\"现有技术的讨论\"></a>现有技术的讨论</h3><p>很难在服务端上渲染客户端应用。有多难？去看看大家给这个话题奉献了多少个 <a href=\"https://www.npmjs.com/search?q=server%20side%20rendering\" target=\"_blank\" rel=\"noopener\">npm 包</a>就知道了。有数不清的<a href=\"https://en.wikipedia.org/wiki/Isomorphic_JavaScript\" target=\"_blank\" rel=\"noopener\">模式</a>，<a href=\"https://github.com/GoogleChrome/rendertron\" target=\"_blank\" rel=\"noopener\">工具</a>，和<a href=\"https://prerender.io/\" target=\"_blank\" rel=\"noopener\">服务</a>来辅助服务端渲染的 JS 应用。</p>\n<h4 id=\"同构-JavaScript\"><a href=\"#同构-JavaScript\" class=\"headerlink\" title=\"同构 JavaScript\"></a>同构 JavaScript</h4><p>同构 JavaScript 的概念很简单：同样的代码既能在服务端运行，也能在客户端（浏览器）运行。服务器和客户端共享代码，美滋滋！</p>\n<p>实践中，我发现同构 JS 很难实现。这是我自己的问题…</p>\n<blockquote>\n<p>我最近开始做一个<a href=\"https://github.com/ebidel/devwebfeed/blob/master/server.mjs\" target=\"_blank\" rel=\"noopener\">项目</a>，尝试下 <a href=\"https://github.com/Polymer/lit-html\" target=\"_blank\" rel=\"noopener\">lit-html</a>。Lit 是一个优秀的库，它可以允许你写使用 JS 模板字符串写 <a href=\"https://www.html5rocks.com/en/tutorials/webcomponents/template/\" target=\"_blank\" rel=\"noopener\">HTML \\<template></template></a>，然后高效地将这些模板渲染为 DOM。问题是它的核心特性（使用 <code>&lt;template&gt;</code> 元素）只能在浏览器上工作。这意味着它在 Node 服务器上不能运行。我希望 Node 和前端共享的 SSR 代码能够脱离 window 对象。</p>\n<p>最后我意识到可以使用无头 Chrome 来服务端渲染应用，Chrome 是经用户的手运行或是在服务器上自动运行并不重要，它反正是愉快地执行了所有 JS。不要多问。 </p>\n</blockquote>\n<p>无头 Chrome 在服务器和客户端上启用 “同构 JS”。它对于当前库不支持服务端（Node）给出了一个不错的解决方案。</p>\n<h4 id=\"预渲染工具\"><a href=\"#预渲染工具\" class=\"headerlink\" title=\"预渲染工具\"></a>预渲染工具</h4><p>Node 社区已经诞生了好几吨解决服务端渲染 JS 应用的工具。毫无新意！个人而言，我发现各人对于这些工具的体会可能不同，所以使用这些工具前肯定要做好功课。比如说，一些服务端渲染工具比较老，并且没有使用无头 Chrome（或者任何其他无头浏览器）。相反，它们使用 PhantomJS（又名旧 Safari），这意味着使用新特性时页面不会正确渲染。</p>\n<p>一个值得注意的例外是 <a href=\"https://github.com/prerender/prerender/\" target=\"_blank\" rel=\"noopener\">Prerender</a>。Prerender 使用了无头 Chrome 和 <a href=\"https://github.com/prerender/prerender-node\" target=\"_blank\" rel=\"noopener\">Express 中间件</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const prerender =  require(&apos;prerender&apos;);  </span><br><span class=\"line\">const server = prerender();  </span><br><span class=\"line\">server.use(prerender.removeScriptTags());  </span><br><span class=\"line\">server.use(prerender.blockResources());  </span><br><span class=\"line\">server.start();</span><br></pre></td></tr></table></figure>\n<p>Prerender 省去了跨平台下载和安装 Chrome 的所有细节。要正确完成这一过程通常是相当棘手的，这也是 <a href=\"https://developers.google.com/web/tools/puppeteer/faq#q_which_chromium_version_does_puppeteer_use\" target=\"_blank\" rel=\"noopener\">Puppeteer</a> 存在的原因之一。我也提了一些渲染我的部分应用的 issue。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/1.png\" alt=\"浏览器中渲染的 Chrome 状态\"></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/2.png\" alt=\"prerender 渲染的 Chrome 状态\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h3><blockquote>\n<p><a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\" target=\"_blank\" rel=\"noopener\">无头 Chrome</a> 是一个将动态 JS 页面转成静态 HTML 页面的即插即用的解决方案。将其运行于 web 服务器之上，你可以<strong>预渲染任何现代 JS 特性</strong>，从而提速内容加载，并且是<strong>可被搜索引擎索引的</strong>。</p>\n</blockquote>\n<p>本篇文章介绍的技术，旨在教大家如何使用 <a href=\"https://developers.google.com/web/tools/puppeteer/\" target=\"_blank\" rel=\"noopener\">Puppeteer</a> 的 API，给一个 Express 服务器添加服务端渲染（SSR）能力。最棒的地方是，<strong>应用本身几乎不需要修改任何代码</strong>。无头 Chrome 做了所有的重活。三两行代码，SSR 页面带回家。</p>\n<p>大餐之前先来点甜点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  const browser = await puppeteer.launch(&#123;headless: true&#125;);</span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\">  await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">  const html = await page.content(); // serialized HTML of page DOM.</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\">  return html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 我会在文章中使用 ES 模块（<code>import</code>），这要求 Node 8.5.0+，并在运行时加上 <code>--experimental-modules</code> 标志。觉得麻烦的话可以自行使用 <code>require()</code> 语句。关于 Node 上的 ES 模块支持可以读读<a href=\"https://nodejs.org/api/esm.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p><br></p>\n<h2 id=\"导论\"><a href=\"#导论\" class=\"headerlink\" title=\"导论\"></a>导论</h2><hr>\n<p>如果我对 <a href=\"https://en.wikipedia.org/wiki/Search_engine_optimization\" target=\"_blank\" rel=\"noopener\">SEO</a> 理解没有偏差的话，你读到这篇文章可能因为下面两个原因之一。首先，你已经搭建了一个 web 应用，并且它没有被搜索引擎索引！你的应用可能是 SPA，<a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">PWA</a>，使用了 vanilla JS，或者使用了其他更复杂的框架或类库。老实说，你使用何种技术并不重要。重要的是，你花费了大量时间搭建出优秀的 web 页面，然而用户却搜不到它。你读这篇文章的另一个理由可能是因为，网上一些文章说了服务端渲染可以提升性能。你希望快速减少<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization/\" target=\"_blank\" rel=\"noopener\"> JavaScript 启动时间</a>，提升<a href=\"https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint\" target=\"_blank\" rel=\"noopener\">首次有效绘制</a>速度。</p>\n<p>一些框架，比如 Preact 使用了<a href=\"https://github.com/developit/preact-render-to-string\" target=\"_blank\" rel=\"noopener\">工具</a>来实现服务端渲染。如果你使用的框架具备预渲染的解决方案，请继续使用。没有任何理由引入另一个工具（无头 Chrome / Puppeteer）。</p>\n<h3 id=\"爬取现代网站\"><a href=\"#爬取现代网站\" class=\"headerlink\" title=\"爬取现代网站\"></a>爬取现代网站</h3><p>\b搜索引擎爬虫，社交平台，<a href=\"https://en.wikipedia.org/wiki/Lynx_(web_browser\" target=\"_blank\" rel=\"noopener\">甚至浏览器</a>)自诞生至今就唯一依赖于静态 HTML 标记，来索引 web 页面和表层内容。现代 web 页面已经演变的\b大为不同。基于 JavaScript 的应用，在很多时候，需要保持网站内容是对于爬取工具是可见的。</p>\n<p>一些爬虫，比如 Google \b搜索，已经变得更智能了！Google 的爬虫使用\b Chrome 41 <a href=\"https://developers.google.com/search/docs/guides/rendering\" target=\"_blank\" rel=\"noopener\">执行 JavaScript</a>，并渲染出最终的页面。但是这个方案才刚出来，还不完美。\b举个例子，使用了新特性的页面，比如 ES6 Class，<a href=\"https://www.chromestatus.com/feature/5365692190687232\" target=\"_blank\" rel=\"noopener\">模块</a>，箭头函数等，将会在这个\b比较老的浏览器上报错，使得页面不能正确渲染。至于其他搜索引擎，\b鬼知道它们在干嘛！？¯_(ツ)_/¯</p>\n<h2 id=\"使用无头-Chrome-预渲染页面\"><a href=\"#使用无头-Chrome-预渲染页面\" class=\"headerlink\" title=\"使用无头 Chrome 预渲染页面\"></a>使用无头 Chrome 预渲染页面</h2><hr>\n<p>所有的爬虫程序都能够理解 HTML。我们要“解决”索引问题的话需要一个工具，它来执行 JS 生成 HTML。我不会告诉你现在已经有这样一个工具了！</p>\n<ol>\n<li>该工具可以运行所有类型的现代 JavaScript，并吐出静态 HTML。</li>\n<li>出现新特性时，该工具可以保持更新</li>\n<li>已有应用上只需少量代码就可以运行这个工具</li>\n</ol>\n<p>听起来很不错吧？<strong>这个工具就是浏览器</strong>！</p>\n<p>无头 Chrome 不在乎你使用什么库、框架或者工具。它将 JavaScript 作为早餐，在午饭前吐出静态 HTML。可能会更快一点 :) -Eric</p>\n<p>如果你用的 Node，Puppeteer 容易上手。它的 API 提供了预渲染客户端应用的能力。下面用个例子演示下。</p>\n<h3 id=\"1-JS-应用示例\"><a href=\"#1-JS-应用示例\" class=\"headerlink\" title=\"1. JS 应用示例\"></a>1. JS 应用示例</h3><p>我们以一个 JavaScript 生成 HTML 的动态页面为例：</p>\n<p><strong>public/index.html</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Populated by the JS below. --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">function renderPosts(posts, container) &#123;</span><br><span class=\"line\">  const html = posts.reduce((html, post) =&gt; &#123;</span><br><span class=\"line\">    return `$&#123;html&#125;</span><br><span class=\"line\">      &lt;li class=&quot;post&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;$&#123;post.title&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;div class=&quot;summary&quot;&gt;$&#123;post.summary&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;p&gt;$&#123;post.content&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/li&gt;`;</span><br><span class=\"line\">  &#125;, &apos;&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // CAREFUL: assumes html is sanitized.</span><br><span class=\"line\">  container.innerHTML = `&lt;ul id=&quot;posts&quot;&gt;$&#123;html&#125;&lt;/ul&gt;`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(async() =&gt; &#123;</span><br><span class=\"line\">  const container = document.querySelector(&apos;#container&apos;);</span><br><span class=\"line\">  const posts = await fetch(&apos;/posts&apos;).then(resp =&gt; resp.json());</span><br><span class=\"line\">  renderPosts(posts, container);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-服务端渲染函数\"><a href=\"#2-服务端渲染函数\" class=\"headerlink\" title=\"2. 服务端渲染函数\"></a>2. 服务端渲染函数</h3><p>接下来，我们会使用之前提到的 <code>ssr()</code> 函数，并充实它的内容。</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// In-memory cache of rendered pages. Note: this will be cleared whenever the</span><br><span class=\"line\">// server process stops. If you need true persistence, use something like</span><br><span class=\"line\">// Google Cloud Storage (https://firebase.google.com/docs/storage/web/start).</span><br><span class=\"line\">const RENDER_CACHE = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  if (RENDER_CACHE.has(url)) &#123;</span><br><span class=\"line\">    return &#123;html: RENDER_CACHE.get(url), ttRenderMs: 0&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const start = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  const browser = await puppeteer.launch();</span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    // networkidle0 waits for the network to be idle (no requests for 500ms).</span><br><span class=\"line\">    // The page&apos;s JS has likely produced markup by this point, but wait longer</span><br><span class=\"line\">    // if your site lazy loads, etc.</span><br><span class=\"line\">    await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">    await page.waitForSelector(&apos;#posts&apos;); // ensure #posts exists in the DOM.</span><br><span class=\"line\">  &#125; catch (err) &#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">    throw new Error(&apos;page.goto/waitForSelector timed out.&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const html = await page.content(); // serialized HTML of page DOM.</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  const ttRenderMs = Date.now() - start;</span><br><span class=\"line\">  console.info(`Headless rendered page in: $&#123;ttRenderMs&#125;ms`);</span><br><span class=\"line\"></span><br><span class=\"line\">  RENDER_CACHE.set(url, html); // cache rendered page.</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html, ttRenderMs&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;ssr as default&#125;;</span><br></pre></td></tr></table></figure>\n<p>主要的变化：</p>\n<ol>\n<li>添加了缓存。缓存已渲染的 HTML 对于加速响应时间居功至伟。当页面再次有请求过来，避免了无头 Chrome 的重复执行。我随后会讨论其他的<a href=\"#optimizations\">优化</a> 。</li>\n<li>添加加载页面超时时的基本错误处理。</li>\n<li>添加了 <code>page.waitForSelector(&#39;#posts&#39;)</code> 这行代码。确保在丢弃这个序列化页面之前，posts 节点存在于 DOM 之中。</li>\n<li>记录无头浏览器渲染页面所用时间。</li>\n<li>代码都被封装进名为 <code>ssr.mjs</code> 的模块中。</li>\n</ol>\n<h3 id=\"3-web-服务器示例\"><a href=\"#3-web-服务器示例\" class=\"headerlink\" title=\"3. web 服务器示例\"></a>3. web 服务器示例</h3><p>最后，一个小的 express 服务器完成了所有的工作。它预渲染 URL <code>http://localhost/index.html</code>（主页），并在响应中返回渲染结果。由于响应中包含了静态 HTML， 当用户访问页面，posts 节点会立刻呈现。</p>\n<p><strong>server.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import express from &apos;express&apos;;</span><br><span class=\"line\">import ssr from &apos;./ssr.mjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, async (req, res, next) =&gt; &#123;</span><br><span class=\"line\">  const &#123;html, ttRenderMs&#125; = await ssr(`$&#123;req.protocol&#125;://$&#123;req.get(&apos;host&apos;)&#125;/index.html`);</span><br><span class=\"line\">  // Add Server-Timing! See https://w3c.github.io/server-timing/.</span><br><span class=\"line\">  res.set(&apos;Server-Timing&apos;, `Prerender;dur=$&#123;ttRenderMs&#125;;desc=&quot;Headless render time (ms)&quot;`);</span><br><span class=\"line\">  return res.status(200).send(html); // Serve prerendered page as response.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(8080, () =&gt; console.log(&apos;Server started. Press Ctrl+C to quit&apos;));</span><br></pre></td></tr></table></figure>\n<p>要运行这个例子，需安装依赖 (<code>npm i --save puppeteer express</code>)，然后使用 Node 8.5.0+ 并带有 <code>--experimental-modules</code> 标志来运行服务器。</p>\n<p>这是一个该服务器返回的响应示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;ul id=&quot;posts&quot;&gt;</span><br><span class=\"line\">      &lt;li class=&quot;post&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;Title 1&lt;/h2&gt;</span><br><span class=\"line\">        &lt;div class=&quot;summary&quot;&gt;Summary 1&lt;/div&gt;</span><br><span class=\"line\">        &lt;p&gt;post content 1&lt;/p&gt;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">      &lt;li class=&quot;post&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;Title 2&lt;/h2&gt;</span><br><span class=\"line\">        &lt;div class=&quot;summary&quot;&gt;Summary 2&lt;/div&gt;</span><br><span class=\"line\">        &lt;p&gt;post content 2&lt;/p&gt;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Server-Timing-API-的一个最佳用例\"><a href=\"#Server-Timing-API-的一个最佳用例\" class=\"headerlink\" title=\"Server-Timing API 的一个最佳用例\"></a>Server-Timing API 的一个最佳用例</h4><p><a href=\"https://w3c.github.io/server-timing/\" target=\"_blank\" rel=\"noopener\">Server-Timing</a> API 支持将服务器性能指标（比如请求/响应时间，数据库查询）返回给浏览器。客户端可以使用这些信息来追踪 web 应用的所有性能数据。</p>\n<p>Server-Timing 的一个最佳用例是上报无头 Chrome 预渲染页面的时间！只需在响应上添加 <code>Server-Timing</code> 头，就可以实现这一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">res.set(&apos;Server-Timing&apos;,  `Prerender;dur=1000;desc=&quot;Headless render time (ms)&quot;`);</span><br></pre></td></tr></table></figure>\n<p>客户端上，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline\" target=\"_blank\" rel=\"noopener\">Performance Timeline API</a> 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\" target=\"_blank\" rel=\"noopener\">PerformanceObserver</a> 可以获取这些指标：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">  const entry = performance.getEntriesByType(&apos;navigation&apos;).find(</span><br><span class=\"line\">    e =&gt; e.name === location.href);</span><br><span class=\"line\">console.log(entry.serverTiming[0].toJSON());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;Prerender&quot;,</span><br><span class=\"line\">  &quot;duration&quot;: 3808,</span><br><span class=\"line\">  &quot;description&quot;: &quot;Headless render time (ms)&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能结果\"><a href=\"#性能结果\" class=\"headerlink\" title=\"性能结果\"></a>性能结果</h3><p><strong>注意：</strong> 这些数据体现了我随后讨论的大多数性能<a href=\"#optimizations\">优化</a>。</p>\n<p>性能数据怎么样？在我的一个<a href=\"https://devwebfeed.appspot.com/ssr\" target=\"_blank\" rel=\"noopener\">应用</a>(<a href=\"https://github.com/ebidel/devwebfeed/blob/master/server.mjs\" target=\"_blank\" rel=\"noopener\">代码</a>)上，无头 Chrome 渲染页面大约需要 1s。页面被缓存后， <strong>3G 低网速模拟</strong>下，<a href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics\" target=\"_blank\" rel=\"noopener\">FCP</a> 要比客户端渲染版本的<strong>快 8.37s</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>&nbsp;</th>\n<th><strong>首次绘制 (FP)</strong></th>\n<th><strong>首次内容绘制 (FCP)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端渲染</td>\n<td>4s</td>\n<td>11s</td>\n<td></td>\n</tr>\n<tr>\n<td>服务端渲染</td>\n<td>2.3s</td>\n<td>~2.3s</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>这些结果很有用。因为服务端渲染页面<strong>不再依赖于 JavaScript 的加载</strong>，用户看到有意义的内容比以前快得多。</p>\n<p><br></p>\n<h2 id=\"Preventing-re-hydration\"><a href=\"#Preventing-re-hydration\" class=\"headerlink\" title=\"Preventing re-hydration\"></a>Preventing re-hydration</h2><hr>\n<p>还记得我说“我们无需在客户端应用上改任何代码”吗？那是骗你们的。</p>\n<p>Express 应用接收请求，使用 Puppeteer 将页面加载进无头浏览器，然后在响应中返回结果。但这里有一个问题。</p>\n<p>浏览器加载页面时，<strong>无头 Chrome 中相同的 JS</strong> 会在服务器上<strong>再次执行</strong>。有两处都在生成 HTML。 </p>\n<p>一起来修复这个问题。我们要告知页面，它的 HTML 早就名花有主了。我找到的解决方案是，在页面加载时判断 <code>&lt;ul id=&quot;posts&quot;&gt;</code> 是否已在 DOM 中，如果在，页面就已经在服务端渲染过了，这样就可以避免重新创建 DOM。</p>\n<p><strong>public/index.html</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Populated by JS (below) or by prerendering (server). Either way,</span><br><span class=\"line\">         #container gets populated with the posts markup:</span><br><span class=\"line\">      &lt;ul id=&quot;posts&quot;&gt;...&lt;/ul&gt;</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">(async() =&gt; &#123;</span><br><span class=\"line\">  const container = document.querySelector(&apos;#container&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // Posts markup is already in DOM if we&apos;re seeing a SSR&apos;d.</span><br><span class=\"line\">  // Don&apos;t re-hydrate the posts here on the client.</span><br><span class=\"line\">  const PRE_RENDERED = container.querySelector(&apos;#posts&apos;);</span><br><span class=\"line\">  if (!PRE_RENDERED) &#123;</span><br><span class=\"line\">    const posts = await fetch(&apos;/posts&apos;).then(resp =&gt; resp.json());</span><br><span class=\"line\">    renderPosts(posts, container);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><hr>\n<p>除了缓存渲染结果之外，还有一些有趣的优化技巧。有的优化可以快速见效，而有的可能带有猜测性的。</p>\n<h3 id=\"中止不必要的请求\"><a href=\"#中止不必要的请求\" class=\"headerlink\" title=\"中止不必要的请求\"></a>中止不必要的请求</h3><p>现在，整个页面（以及它请求的所有资源）都无脑地加载进无头 Chrome。然而，我们只关注于两件事情：</p>\n<ol>\n<li>渲染 HTML</li>\n<li>生成 HTML 的 JS</li>\n</ol>\n<p><strong>不构造 DOM 的网络请求是浪费的</strong>。一些资源，比如图片、字体、样式表和媒体内容，不参与页面的 HTML 构建。它们负责添加样式，补充页面的结构，但并不显式地创建页面。我们应该告诉浏览器去忽略掉这些资源！这样可以减少无头 Chrome 的工作负担，从而<strong>节省带宽</strong>，并且潜在地<strong>加速了大型页面的预渲染时间</strong>。</p>\n<p><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noopener\">Protocol 开发者工具</a>提供了一个强大的特性，叫做<a href=\"https://chromedevtools.github.io/devtools-protocol/tot/Network#event-requestIntercepted\" target=\"_blank\" rel=\"noopener\">网络拦截</a>。它可以用于<strong>在浏览器发出之前修改请求</strong>。Puppeteer 也支持网络拦截，它是通过打开 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagesetrequestinterceptionvalue\" target=\"_blank\" rel=\"noopener\"><code>page.setRequestInterception(true)</code></a>，监听<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-request\" target=\"_blank\" rel=\"noopener\">页面的 <code>request</code> 事件</a>来实现的。这样我们可以中止某些资源请求。</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\"></span><br><span class=\"line\">  // 1. Intercept network requests.</span><br><span class=\"line\">  await page.setRequestInterception(true);</span><br><span class=\"line\"></span><br><span class=\"line\">  page.on(&apos;request&apos;, req =&gt; &#123;</span><br><span class=\"line\">    // 2. Ignore requests for resources that don&apos;t produce DOM</span><br><span class=\"line\">    // (images, stylesheets, media).</span><br><span class=\"line\">    const whitelist = [&apos;document&apos;, &apos;script&apos;, &apos;xhr&apos;, &apos;fetch&apos;];</span><br><span class=\"line\">    if (!whitelist.includes(req.resourceType())) &#123;</span><br><span class=\"line\">      return req.abort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 3. Pass through all other requests.</span><br><span class=\"line\">    req.continue();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">  const html = await page.content(); // serialized HTML of page DOM.</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 安全起见，我使用了一个白名单，允许所有其他类型的请求能够继续正常发出。预先避免中止掉其他必要的请求。</p>\n<h3 id=\"内联关键资源\"><a href=\"#内联关键资源\" class=\"headerlink\" title=\"内联关键资源\"></a>内联关键资源</h3><p>使用构建工具（比如 <code>gulp</code>）编译应用，并在构建时将关键 CSS/JS 内联到页面内，是一种很常见的做法。由于浏览器初始化页面加载时的请求数更少了，这样也就加速了首次有效绘制时间。</p>\n<p>别用构建工具了，<strong>浏览器就是你的构建工具</strong>！我们可以用 Puppeteer 管理页面 DOM，内联样式，JavaScript， 或者其他任何你想在预渲染之前加到页面中的东西。</p>\n<p>这个例子演示了如何拦截本地样式表的响应，并将这些资源内联进 <code>&lt;style&gt;</code> 标签中：</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import urlModule from &apos;url&apos;;</span><br><span class=\"line\">const URL = urlModule.URL;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const stylesheetContents = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 1. Stash the responses of local stylesheets.</span><br><span class=\"line\">  page.on(&apos;response&apos;, async resp =&gt; &#123;</span><br><span class=\"line\">    const responseUrl = resp.url();</span><br><span class=\"line\">    const sameOrigin = new URL(responseUrl).origin === new URL(url).origin;</span><br><span class=\"line\">    const isStylesheet = resp.request().resourceType() === &apos;stylesheet&apos;;</span><br><span class=\"line\">    if (sameOrigin &amp;&amp; isStylesheet) &#123;</span><br><span class=\"line\">      stylesheetContents[responseUrl] = await resp.text();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 2. Load page as normal, waiting for network requests to be idle.</span><br><span class=\"line\">  await page.goto(url, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 3. Inline the CSS.</span><br><span class=\"line\">  // Replace stylesheets in the page with their equivalent &lt;style&gt;.</span><br><span class=\"line\">  await page.$$eval(&apos;link[rel=&quot;stylesheet&quot;]&apos;, (links, content) =&gt; &#123;</span><br><span class=\"line\">    links.forEach(link =&gt; &#123;</span><br><span class=\"line\">      const cssText = content[link.href];</span><br><span class=\"line\">      if (cssText) &#123;</span><br><span class=\"line\">        const style = document.createElement(&apos;style&apos;);</span><br><span class=\"line\">        style.textContent = cssText;</span><br><span class=\"line\">        link.replaceWith(style);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, stylesheetContents);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 4. Get updated serialized HTML of page.</span><br><span class=\"line\">  const html = await page.content();</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码：</p>\n<ol>\n<li>使用一个 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-response\" target=\"_blank\" rel=\"noopener\"><code>page.on(&#39;response&#39;)</code></a> 处理器来监听网络响应。</li>\n<li>储藏本地样式表的响应。</li>\n<li>找到 DOM 中所有的 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>，将它们替换成一个等价的 <code>&lt;style&gt;</code>。具体见 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevalselector-pagefunction-args\" target=\"_blank\" rel=\"noopener\"><code>page.$$eval</code></a> API 文档。<code>style.textContent</code> 被设为样式表的响应内容。</li>\n</ol>\n<h3 id=\"自动压缩资源\"><a href=\"#自动压缩资源\" class=\"headerlink\" title=\"自动压缩资源\"></a>自动压缩资源</h3><p>另一个可以借助网络拦截玩的小把戏是<strong>修改请求的响应内容</strong>。</p>\n<p>举个例子，你想要压缩 CSS，但也希望开发阶段不要被压缩，这样开发时能方便些。假设你已经用另一个工具来预压缩 <code>styles.css</code>，可以用 <code>Request.respond()</code>，将 <code>styles.css</code> 的内容重写为 <code>styles.min.css</code>。</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import fs from &apos;fs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  // 1. Intercept network requests.</span><br><span class=\"line\">  await page.setRequestInterception(true);</span><br><span class=\"line\"></span><br><span class=\"line\">  page.on(&apos;request&apos;, req =&gt; &#123;</span><br><span class=\"line\">    // 2. If request is for styles.css, respond with the minified version.</span><br><span class=\"line\">    if (req.url().endsWith(&apos;styles.css&apos;)) &#123;</span><br><span class=\"line\">      return req.respond(&#123;</span><br><span class=\"line\">        status: 200,</span><br><span class=\"line\">        contentType: &apos;text/css&apos;,</span><br><span class=\"line\">        body: fs.readFileSync(&apos;./public/styles.min.css&apos;, &apos;utf-8&apos;)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    req.continue();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  const html = await page.content();</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重用-Chrome-实例实现交叉渲染\"><a href=\"#重用-Chrome-实例实现交叉渲染\" class=\"headerlink\" title=\"重用 Chrome 实例实现交叉渲染\"></a>重用 Chrome 实例实现交叉渲染</h3><p>每次预渲染都启动新的浏览器会很浪费。相反，你希望只启动一个实例，然后在多个页面渲染时重用它。</p>\n<p>Puppeteer 可以通过调用 <a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions\" target=\"_blank\" rel=\"noopener\"><code>puppeteer.connect()</code></a>，连接到一个已有的 Chrome 实例，它接收实例的远程调试 URL 作为参数。为保证浏览器实例的长时间运行，我们可以将 <code>ssr()</code> 函数启动 Chrome 这部分代码移到 Express 服务器里。</p>\n<p><strong>server.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import express from &apos;express&apos;;</span><br><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\">import ssr from &apos;./ssr.mjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">let browserWSEndpoint = null;</span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, async (req, res, next) =&gt; &#123;</span><br><span class=\"line\">  if (!browserWSEndpoint) &#123;</span><br><span class=\"line\">    const browser = await puppeteer.launch();</span><br><span class=\"line\">    browserWSEndpoint = await browser.wsEndpoint();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const url = `$&#123;req.protocol&#125;://$&#123;req.get(&apos;host&apos;)&#125;/index.html`;</span><br><span class=\"line\">  const &#123;html&#125; = await ssr(url, browserWSEndpoint);</span><br><span class=\"line\"></span><br><span class=\"line\">  return res.status(200).send(html);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;string&#125; url URL to prerender.</span><br><span class=\"line\"> * @param &#123;string&#125; browserWSEndpoint Optional remote debugging URL. If</span><br><span class=\"line\"> *     provided, Puppeteer&apos;s reconnects to the browser instance. Otherwise,</span><br><span class=\"line\"> *     a new browser instance is launched.</span><br><span class=\"line\"> */</span><br><span class=\"line\">async function ssr(url, browserWSEndpoint) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  console.info(&apos;Connecting to existing Chrome instance.&apos;);</span><br><span class=\"line\">  const browser = await puppeteer.connect(&#123;browserWSEndpoint&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const page = await browser.newPage();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  await page.close(); // Close the page we opened here (not the browser).</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"例子：实现周期性预渲染的定时任务\"><a href=\"#例子：实现周期性预渲染的定时任务\" class=\"headerlink\" title=\"例子：实现周期性预渲染的定时任务\"></a>例子：实现周期性预渲染的定时任务</h4><p>在 <a href=\"https://devwebfeed.appspot.com/ssr\" target=\"_blank\" rel=\"noopener\">App 引擎面板应用</a> 里，我创建了一个<a href=\"https://cloud.google.com/appengine/docs/flexible/nodejs/scheduling-jobs-with-cron-yaml\" target=\"_blank\" rel=\"noopener\">定时处理器</a>，来周期性的重复渲染排名前几位的页面。帮助用户快速看到最新内容，他们根本感知不到一个新页面的启动性能消耗。在这个例子中，生成多个 Chrome 实例会很浪费。相反，我用了一个共享的浏览器实例来一次性渲染这些页面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import puppeteer from &apos;puppeteer&apos;;</span><br><span class=\"line\">import * as prerender from &apos;./ssr.mjs&apos;;</span><br><span class=\"line\">import urlModule from &apos;url&apos;;</span><br><span class=\"line\">const URL = urlModule.URL;</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/cron/update_cache&apos;, async (req, res) =&gt; &#123;</span><br><span class=\"line\">  if (!req.get(&apos;X-Appengine-Cron&apos;)) &#123;</span><br><span class=\"line\">    return res.status(403).send(&apos;Sorry, cron handler can only be run as admin.&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const browser = await puppeteer.launch();</span><br><span class=\"line\">  const homepage = new URL(`$&#123;req.protocol&#125;://$&#123;req.get(&apos;host&apos;)&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">  // Re-render main page and a few pages back.</span><br><span class=\"line\">  prerender.clearCache();</span><br><span class=\"line\">  await prerender.ssr(homepage.href, await browser.wsEndpoint());</span><br><span class=\"line\">  await prerender.ssr(`$&#123;homepage&#125;?year=2018`);</span><br><span class=\"line\">  await prerender.ssr(`$&#123;homepage&#125;?year=2017`);</span><br><span class=\"line\">  await prerender.ssr(`$&#123;homepage&#125;?year=2016`);</span><br><span class=\"line\">  await browser.close();</span><br><span class=\"line\"></span><br><span class=\"line\">  res.status(200).send(&apos;Render cache updated!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我还在 <strong>ssr.js</strong> export 上加了一个 <code>clearCache()</code> 函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">function clearCache() &#123;</span><br><span class=\"line\">  RENDER_CACHE.clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;ssr, clearCache&#125;;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"其他因素\"><a href=\"#其他因素\" class=\"headerlink\" title=\"其他因素\"></a>其他因素</h2><hr>\n<h3 id=\"告诉页面：“你正在被无头浏览器渲染”\"><a href=\"#告诉页面：“你正在被无头浏览器渲染”\" class=\"headerlink\" title=\"告诉页面：“你正在被无头浏览器渲染”\"></a>告诉页面：“你正在被无头浏览器渲染”</h3><p>当页面正在服务器上的无头 Chrome 中渲染时，客户端逻辑很有必要知道这一信息。我的应用使用了钩子来“关闭”部分不参与渲染 post 节点的页面。举例来说，我禁用了懒加载 <a href=\"https://firebase.google.com/docs/web/setup\" target=\"_blank\" rel=\"noopener\">firebase-auth.js</a> 这部分代码。根本不需要用户登录！</p>\n<p>在 URL 上加一个 <code>?headless</code> 参数，是一个给页面加钩子的简单方法：</p>\n<p><strong>ssr.mjs</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import urlModule from &apos;url&apos;;</span><br><span class=\"line\">const URL = urlModule.URL;</span><br><span class=\"line\"></span><br><span class=\"line\">async function ssr(url) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  // Add ?headless to the URL so the page has a signal</span><br><span class=\"line\">  // it&apos;s being loaded by headless Chrome.</span><br><span class=\"line\">  const renderUrl = new URL(url);</span><br><span class=\"line\">  renderUrl.searchParams.set(&apos;headless&apos;, &apos;&apos;);</span><br><span class=\"line\">  await page.goto(renderUrl, &#123;waitUntil: &apos;networkidle0&apos;&#125;);</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;html&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以在页面内查询该参数：</p>\n<p><strong>public/index.html</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Populated by the JS below. --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">(async() =&gt; &#123;</span><br><span class=\"line\">  const params = new URL(location.href).searchParams;</span><br><span class=\"line\"></span><br><span class=\"line\">  const RENDERING_IN_HEADLESS = params.has(&apos;headless&apos;);</span><br><span class=\"line\">  if (RENDERING_IN_HEADLESS) &#123;</span><br><span class=\"line\">    // Being rendered by headless Chrome on the server.</span><br><span class=\"line\">    // e.g. shut off features, don&apos;t lazy load non-essential resources, etc.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const container = document.querySelector(&apos;#container&apos;);</span><br><span class=\"line\">  const posts = await fetch(&apos;/posts&apos;).then(resp =&gt; resp.json());</span><br><span class=\"line\">  renderPosts(posts, container);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>Tip：<a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageevaluateonnewdocumentpagefunction-args\" target=\"_blank\" rel=\"noopener\"><code>Page.evaluateOnNewDocument()</code></a> 也可以方便的查询参数。它会在页面中注入代码，让 Puppeteer 在页面中剩余待执行的 JavaScript 之前运行这些代码。</p>\n<h3 id=\"避免-PV-膨胀\"><a href=\"#避免-PV-膨胀\" class=\"headerlink\" title=\"避免 PV 膨胀\"></a>避免 PV 膨胀</h3><p>你如果正在页面上使用分析工具，那么要小心了。预渲染的页面可能会造成 PV 出现膨胀。具体来说，<strong>打点数据将会提升2倍</strong>，一半是在无头 Chrome 渲染时，另一半出现在用户浏览器渲染时。</p>\n<p>那么怎么修复这个问题呢？将所有加载分析脚本的请求拦截掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">page.on(&apos;request&apos;, req =&gt; &#123;</span><br><span class=\"line\">  // Don&apos;t load Google Analytics lib requests so pageviews aren&apos;t 2x.</span><br><span class=\"line\">  const blacklist = [&apos;www.google-analytics.com&apos;, &apos;/gtag/js&apos;, &apos;ga.js&apos;, &apos;analytics.js&apos;];</span><br><span class=\"line\">  if (blacklist.find(regex =&gt; req.url().match(regex))) &#123;</span><br><span class=\"line\">    return req.abort();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  req.continue();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码不加载，页面访问就不会被记录。真 Skr 个机灵鬼 💥。</p>\n<p>或者，你也可以继续加载分析脚本，来获悉服务器上运行的预渲染器数。</p>\n<p><br></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><hr>\n<p>Puppeteer 通过运行无头 Chrome，不费吹灰之力就实现了服务端渲染。<strong>提升加载性能</strong>和<strong>没有改动大量代码就增强了应用的可索引性</strong>，是这个方案中我最喜欢的“特性”。</p>\n<p><strong>注意：</strong> 如果你对文章中描述的技术感兴趣，可以去看看<a href=\"https://devwebfeed.appspot.com/ssr\" target=\"_blank\" rel=\"noopener\">这个应用</a>，以及<a href=\"https://github.com/ebidel/devwebfeed/blob/master/server.mjs\" target=\"_blank\" rel=\"noopener\">它的代码</a>。</p>\n<p><br></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><hr>\n<h3 id=\"现有技术的讨论\"><a href=\"#现有技术的讨论\" class=\"headerlink\" title=\"现有技术的讨论\"></a>现有技术的讨论</h3><p>很难在服务端上渲染客户端应用。有多难？去看看大家给这个话题奉献了多少个 <a href=\"https://www.npmjs.com/search?q=server%20side%20rendering\" target=\"_blank\" rel=\"noopener\">npm 包</a>就知道了。有数不清的<a href=\"https://en.wikipedia.org/wiki/Isomorphic_JavaScript\" target=\"_blank\" rel=\"noopener\">模式</a>，<a href=\"https://github.com/GoogleChrome/rendertron\" target=\"_blank\" rel=\"noopener\">工具</a>，和<a href=\"https://prerender.io/\" target=\"_blank\" rel=\"noopener\">服务</a>来辅助服务端渲染的 JS 应用。</p>\n<h4 id=\"同构-JavaScript\"><a href=\"#同构-JavaScript\" class=\"headerlink\" title=\"同构 JavaScript\"></a>同构 JavaScript</h4><p>同构 JavaScript 的概念很简单：同样的代码既能在服务端运行，也能在客户端（浏览器）运行。服务器和客户端共享代码，美滋滋！</p>\n<p>实践中，我发现同构 JS 很难实现。这是我自己的问题…</p>\n<blockquote>\n<p>我最近开始做一个<a href=\"https://github.com/ebidel/devwebfeed/blob/master/server.mjs\" target=\"_blank\" rel=\"noopener\">项目</a>，尝试下 <a href=\"https://github.com/Polymer/lit-html\" target=\"_blank\" rel=\"noopener\">lit-html</a>。Lit 是一个优秀的库，它可以允许你写使用 JS 模板字符串写 <a href=\"https://www.html5rocks.com/en/tutorials/webcomponents/template/\" target=\"_blank\" rel=\"noopener\">HTML \\<template></template></a>，然后高效地将这些模板渲染为 DOM。问题是它的核心特性（使用 <code>&lt;template&gt;</code> 元素）只能在浏览器上工作。这意味着它在 Node 服务器上不能运行。我希望 Node 和前端共享的 SSR 代码能够脱离 window 对象。</p>\n<p>最后我意识到可以使用无头 Chrome 来服务端渲染应用，Chrome 是经用户的手运行或是在服务器上自动运行并不重要，它反正是愉快地执行了所有 JS。不要多问。 </p>\n</blockquote>\n<p>无头 Chrome 在服务器和客户端上启用 “同构 JS”。它对于当前库不支持服务端（Node）给出了一个不错的解决方案。</p>\n<h4 id=\"预渲染工具\"><a href=\"#预渲染工具\" class=\"headerlink\" title=\"预渲染工具\"></a>预渲染工具</h4><p>Node 社区已经诞生了好几吨解决服务端渲染 JS 应用的工具。毫无新意！个人而言，我发现各人对于这些工具的体会可能不同，所以使用这些工具前肯定要做好功课。比如说，一些服务端渲染工具比较老，并且没有使用无头 Chrome（或者任何其他无头浏览器）。相反，它们使用 PhantomJS（又名旧 Safari），这意味着使用新特性时页面不会正确渲染。</p>\n<p>一个值得注意的例外是 <a href=\"https://github.com/prerender/prerender/\" target=\"_blank\" rel=\"noopener\">Prerender</a>。Prerender 使用了无头 Chrome 和 <a href=\"https://github.com/prerender/prerender-node\" target=\"_blank\" rel=\"noopener\">Express 中间件</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const prerender =  require(&apos;prerender&apos;);  </span><br><span class=\"line\">const server = prerender();  </span><br><span class=\"line\">server.use(prerender.removeScriptTags());  </span><br><span class=\"line\">server.use(prerender.blockResources());  </span><br><span class=\"line\">server.start();</span><br></pre></td></tr></table></figure>\n<p>Prerender 省去了跨平台下载和安装 Chrome 的所有细节。要正确完成这一过程通常是相当棘手的，这也是 <a href=\"https://developers.google.com/web/tools/puppeteer/faq#q_which_chromium_version_does_puppeteer_use\" target=\"_blank\" rel=\"noopener\">Puppeteer</a> 存在的原因之一。我也提了一些渲染我的部分应用的 issue。</p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/1.png\" alt=\"浏览器中渲染的 Chrome 状态\"></p>\n<p><img src=\"https://mares.oss-cn-qingdao.aliyuncs.com/blog/Puppeteer/2.png\" alt=\"prerender 渲染的 Chrome 状态\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4qygn72000ahns6wc5p59x2","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn7e000hhns63plt3ps6"},{"post_id":"ck4qygn6b0002hns6zay1ccd5","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn7g000lhns6bwzvail1"},{"post_id":"ck4qygn79000fhns6bfc7cvn4","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn7i000ohns6wdy0g1a6"},{"post_id":"ck4qygn6i0004hns69pzy6o60","category_id":"ck4qygn77000chns6nqdxmb6r","_id":"ck4qygn7m000shns6igoeuflc"},{"post_id":"ck4qygn7c000ghns69py1o2cw","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn7o000vhns64b7ymiiq"},{"post_id":"ck4qygn7f000khns66ba6wang","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn7r000zhns67kd1cwr5"},{"post_id":"ck4qygn6z0008hns6db2m9h0a","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn7s0011hns6gh9vq805"},{"post_id":"ck4qygn7k000rhns6xasmogd7","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn7v0014hns6sj7krfhq"},{"post_id":"ck4qygn76000bhns6yt5ypqpm","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn7x0018hns6f0ee72ye"},{"post_id":"ck4qygn7n000uhns6zf1fjazq","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn7y001bhns6qv6ekwg7"},{"post_id":"ck4qygn7p000yhns63atoxi3i","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn80001fhns6rihcrldf"},{"post_id":"ck4qygn7h000nhns6xerdthhf","category_id":"ck4qygn7p000whns65prkra3b","_id":"ck4qygn81001ihns67wlra32i"},{"post_id":"ck4qygn7r0010hns68pp2nkqo","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn83001mhns6aw0zan5k"},{"post_id":"ck4qygn7t0013hns6gyozmakv","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn86001phns64yyupnli"},{"post_id":"ck4qygn7w0017hns6f80zsfvi","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn88001thns6t279a0pm"},{"post_id":"ck4qygn7y001ahns6kw3rj5qp","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn8a001xhns6buxenrva"},{"post_id":"ck4qygn7z001ehns6yjv9h9rk","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8c0021hns65sjdjhso"},{"post_id":"ck4qygn80001hhns6cdizu8wd","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8d0025hns68ceef0ee"},{"post_id":"ck4qygn82001lhns6kvn4en28","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8f0029hns6q4at7gy0"},{"post_id":"ck4qygn87001shns65365e1wq","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8g002chns65n0f6q7r"},{"post_id":"ck4qygn8b0020hns6srxhikf7","category_id":"ck4qygn89001uhns6aog6u7mi","_id":"ck4qygn8i002fhns639uu4m19"},{"post_id":"ck4qygn84001ohns68sgii6ww","category_id":"ck4qygn89001uhns6aog6u7mi","_id":"ck4qygn8k002jhns66xoyd06f"},{"post_id":"ck4qygn8c0023hns6shboo86g","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8m002mhns6imst61s0"},{"post_id":"ck4qygn8e0028hns6fk9vusok","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8p002phns6ezxzq15e"},{"post_id":"ck4qygn89001whns6hz1m1kil","category_id":"ck4qygn89001uhns6aog6u7mi","_id":"ck4qygn8r002shns637vzrppk"},{"post_id":"ck4qygn8f002bhns6blbvtak1","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8s002whns6oa2tghhh"},{"post_id":"ck4qygn8h002ehns64wcocvrf","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8u002zhns66mzp61j9"},{"post_id":"ck4qygn8j002ihns6u29c5vz9","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8v0033hns626plcv2p"},{"post_id":"ck4qygn8l002lhns6ck86lk4y","category_id":"ck4qygn89001uhns6aog6u7mi","_id":"ck4qygn8x0037hns63xejn84u"},{"post_id":"ck4qygn8o002ohns6zpmwdkla","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn8y003ahns63ag9rjn4"},{"post_id":"ck4qygn8q002rhns6cs1jedtg","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn90003fhns6e88yqwat"},{"post_id":"ck4qygn8s002vhns6jw3lddmv","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn92003ihns6anbni9od"},{"post_id":"ck4qygn8w0036hns60yf9uwfy","category_id":"ck4qygn7p000whns65prkra3b","_id":"ck4qygn98003mhns6wc8wfku8"},{"post_id":"ck4qygn8x0039hns6a67p13ok","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn9c003phns6qtj7saep"},{"post_id":"ck4qygn8t002yhns6d6im7ch9","category_id":"ck4qygn8w0035hns6wcjhwefs","_id":"ck4qygn9i003thns65ib4kuz9"},{"post_id":"ck4qygn8z003dhns6ejka6sik","category_id":"ck4qygn6s0005hns6x6yb1p7l","_id":"ck4qygn9k003whns6cspbzsvr"},{"post_id":"ck4qygn91003hhns6c51ntt76","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn9m0040hns65ztm3zcd"},{"post_id":"ck4qygn8u0032hns615i3zznn","category_id":"ck4qygn8w0035hns6wcjhwefs","_id":"ck4qygn9o0043hns645qlfetd"},{"post_id":"ck4qygn96003lhns62hju6u8g","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygn9r0047hns6wygf4ck6"},{"post_id":"ck4qygn9a003ohns627yie8o8","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygna1004ahns62avjy53w"},{"post_id":"ck4qygn9h003shns6zdizcstc","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygna5004ehns6xh2bbyy5"},{"post_id":"ck4qygn9i003vhns67gmvm05j","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygna6004ihns6ajnuzdfn"},{"post_id":"ck4qygn9l003zhns6a38tns2p","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygna7004lhns67lpko81n"},{"post_id":"ck4qygn9m0042hns6yvsey10w","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygna8004nhns6549cibc9"},{"post_id":"ck4qygn9p0046hns6xsdlste3","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygna9004qhns6o935avxm"},{"post_id":"ck4qygna4004dhns6dtmexnif","category_id":"ck4qygn77000chns6nqdxmb6r","_id":"ck4qygna9004shns6yrx9ppx2"},{"post_id":"ck4qygna6004hhns6n78nusq1","category_id":"ck4qygn8w0035hns6wcjhwefs","_id":"ck4qygnaa004vhns6bhk0h59g"},{"post_id":"ck4qygn9s0049hns6qd5h6eyn","category_id":"ck4qygna6004fhns6wqpivfug","_id":"ck4qygnaa004xhns6lezlc74v"},{"post_id":"ck4qygnba005shns61i3zs2zx","category_id":"ck4qygn89001uhns6aog6u7mi","_id":"ck4qygnbh005yhns6yt5a5n6c"},{"post_id":"ck4qygnbc005thns6b099buza","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbi0062hns6bsvk8dhn"},{"post_id":"ck4qygnbf005vhns60h1xniv6","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbj0065hns6chgqc89l"},{"post_id":"ck4qygnbg005xhns6552vd1o7","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbl006ahns6zhc7a2ma"},{"post_id":"ck4qygnbj0064hns6rfne07l4","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbm006ehns6h1eoal8o"},{"post_id":"ck4qygnbk0068hns6p8n6wsqc","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbn006hhns6patdo1rx"},{"post_id":"ck4qygnbl006chns6j8atbaww","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbn006jhns64oadbpzm"},{"post_id":"ck4qygnbi0061hns6m1xsd27k","category_id":"ck4qygnbk0066hns661bprsoi","_id":"ck4qygnbn006lhns6bahq08la"},{"post_id":"ck4qygnbs006qhns6xsr4thu5","category_id":"ck4qygn7e000ihns6vac84tvf","_id":"ck4qygnbv006shns6tu7doe0a"}],"PostTag":[{"post_id":"ck4qygn6b0002hns6zay1ccd5","tag_id":"ck4qygn6y0006hns6yi0nrgx2","_id":"ck4qygn79000ehns6jgutbx4t"},{"post_id":"ck4qygn6i0004hns69pzy6o60","tag_id":"ck4qygn78000dhns6dbfrxw0n","_id":"ck4qygn7h000mhns6h285alza"},{"post_id":"ck4qygn6z0008hns6db2m9h0a","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn7m000thns6980bs09l"},{"post_id":"ck4qygn7p000yhns63atoxi3i","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn7t0012hns63l6jnhzx"},{"post_id":"ck4qygn7r0010hns68pp2nkqo","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn7w0016hns6gbkbcgym"},{"post_id":"ck4qygn72000ahns6wc5p59x2","tag_id":"ck4qygn7i000qhns6ongpidku","_id":"ck4qygn7y0019hns635bzcyt0"},{"post_id":"ck4qygn72000ahns6wc5p59x2","tag_id":"ck4qygn7p000xhns6c75sqldp","_id":"ck4qygn7z001dhns6vr1luxer"},{"post_id":"ck4qygn7t0013hns6gyozmakv","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn80001ghns60d229br8"},{"post_id":"ck4qygn7w0017hns6f80zsfvi","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn82001khns6lkrbk7p0"},{"post_id":"ck4qygn76000bhns6yt5ypqpm","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn84001nhns6u4hwhkag"},{"post_id":"ck4qygn79000fhns6bfc7cvn4","tag_id":"ck4qygn7y001chns6yxd4nnjg","_id":"ck4qygn86001rhns68py5oynz"},{"post_id":"ck4qygn80001hhns6cdizu8wd","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn89001vhns6kwczk109"},{"post_id":"ck4qygn82001lhns6kvn4en28","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn8b001zhns6g47tt3o5"},{"post_id":"ck4qygn7c000ghns69py1o2cw","tag_id":"ck4qygn7y001chns6yxd4nnjg","_id":"ck4qygn8c0022hns6m0wcn8u6"},{"post_id":"ck4qygn87001shns65365e1wq","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn8e0026hns61hqvk71e"},{"post_id":"ck4qygn7f000khns66ba6wang","tag_id":"ck4qygn86001qhns6n8rjua9f","_id":"ck4qygn8f002ahns6t20ajz1l"},{"post_id":"ck4qygn7h000nhns6xerdthhf","tag_id":"ck4qygn8a001yhns6v15e6o14","_id":"ck4qygn8h002dhns6xjtwkntr"},{"post_id":"ck4qygn7k000rhns6xasmogd7","tag_id":"ck4qygn8e0027hns6xaj5zvjs","_id":"ck4qygn8i002hhns6mfl06zmx"},{"post_id":"ck4qygn7k000rhns6xasmogd7","tag_id":"ck4qygn6y0006hns6yi0nrgx2","_id":"ck4qygn8l002khns6g70s5fcn"},{"post_id":"ck4qygn7n000uhns6zf1fjazq","tag_id":"ck4qygn8i002ghns6012m6ek2","_id":"ck4qygn8p002qhns6552j0t51"},{"post_id":"ck4qygn7n000uhns6zf1fjazq","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn8r002thns6o9rktn2n"},{"post_id":"ck4qygn8o002ohns6zpmwdkla","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn8s002xhns6gkzuodtf"},{"post_id":"ck4qygn7y001ahns6kw3rj5qp","tag_id":"ck4qygn8n002nhns6ge2t3hjl","_id":"ck4qygn8u0030hns6lhwcxo1e"},{"post_id":"ck4qygn8q002rhns6cs1jedtg","tag_id":"ck4qygn7y001chns6yxd4nnjg","_id":"ck4qygn8v0034hns60qxbfp1r"},{"post_id":"ck4qygn8s002vhns6jw3lddmv","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn8x0038hns6pc96a2x6"},{"post_id":"ck4qygn7z001ehns6yjv9h9rk","tag_id":"ck4qygn8r002uhns65ab41b78","_id":"ck4qygn8y003chns6ozkbqenx"},{"post_id":"ck4qygn8x0039hns6a67p13ok","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn90003ghns63mw9z5oc"},{"post_id":"ck4qygn8z003dhns6ejka6sik","tag_id":"ck4qygn7y001chns6yxd4nnjg","_id":"ck4qygn95003khns6ste4squi"},{"post_id":"ck4qygn84001ohns68sgii6ww","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn99003nhns6wd28e3ea"},{"post_id":"ck4qygn84001ohns68sgii6ww","tag_id":"ck4qygn8u0031hns63sdjnddw","_id":"ck4qygn9g003rhns6hcrr3aws"},{"post_id":"ck4qygn84001ohns68sgii6ww","tag_id":"ck4qygn8y003bhns6uqg1y4gi","_id":"ck4qygn9i003uhns6vu4koox8"},{"post_id":"ck4qygn91003hhns6c51ntt76","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn9l003yhns61j5tvfb3"},{"post_id":"ck4qygn96003lhns62hju6u8g","tag_id":"ck4qygn8r002uhns65ab41b78","_id":"ck4qygn9m0041hns6foeiupos"},{"post_id":"ck4qygn89001whns6hz1m1kil","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygn9p0045hns68ox80gyn"},{"post_id":"ck4qygn89001whns6hz1m1kil","tag_id":"ck4qygn8u0031hns63sdjnddw","_id":"ck4qygn9s0048hns66zidkkw9"},{"post_id":"ck4qygn9h003shns6zdizcstc","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygna3004chns68pzkinxe"},{"post_id":"ck4qygn8b0020hns6srxhikf7","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygna6004ghns6rzcu5gbh"},{"post_id":"ck4qygn8b0020hns6srxhikf7","tag_id":"ck4qygn8y003bhns6uqg1y4gi","_id":"ck4qygna7004khns6syxvgvd7"},{"post_id":"ck4qygn9l003zhns6a38tns2p","tag_id":"ck4qygn6y0006hns6yi0nrgx2","_id":"ck4qygna8004mhns69nc74bw3"},{"post_id":"ck4qygn9m0042hns6yvsey10w","tag_id":"ck4qygn8r002uhns65ab41b78","_id":"ck4qygna8004phns661jmnpgv"},{"post_id":"ck4qygn9p0046hns6xsdlste3","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygna9004rhns6mffxvt7g"},{"post_id":"ck4qygn8c0023hns6shboo86g","tag_id":"ck4qygn8r002uhns65ab41b78","_id":"ck4qygna9004uhns6pknx82o9"},{"post_id":"ck4qygn8c0023hns6shboo86g","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnaa004whns67yots9qs"},{"post_id":"ck4qygna4004dhns6dtmexnif","tag_id":"ck4qygn78000dhns6dbfrxw0n","_id":"ck4qygnab004zhns6a1oxln01"},{"post_id":"ck4qygn8e0028hns6fk9vusok","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnac0050hns6m1ecbznp"},{"post_id":"ck4qygn8e0028hns6fk9vusok","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnac0051hns6icj4hlm5"},{"post_id":"ck4qygn8f002bhns6blbvtak1","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnad0053hns642smatrj"},{"post_id":"ck4qygn8f002bhns6blbvtak1","tag_id":"ck4qygn8i002ghns6012m6ek2","_id":"ck4qygnag0054hns6neu5twgm"},{"post_id":"ck4qygn8f002bhns6blbvtak1","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnai0056hns6k3gwv8uj"},{"post_id":"ck4qygn8h002ehns64wcocvrf","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnai0057hns6u7ybuuum"},{"post_id":"ck4qygn8h002ehns64wcocvrf","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnaj0059hns6g33o618o"},{"post_id":"ck4qygn8j002ihns6u29c5vz9","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnak005ahns6ldkhh4q7"},{"post_id":"ck4qygn8j002ihns6u29c5vz9","tag_id":"ck4qygnab004yhns6wnchi8bf","_id":"ck4qygnal005chns62ghwujyq"},{"post_id":"ck4qygn8j002ihns6u29c5vz9","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnam005dhns6no9tbksw"},{"post_id":"ck4qygn8l002lhns6ck86lk4y","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnan005fhns68y1pkgud"},{"post_id":"ck4qygn8l002lhns6ck86lk4y","tag_id":"ck4qygn8y003bhns6uqg1y4gi","_id":"ck4qygnan005ghns6lz0xvb6r"},{"post_id":"ck4qygn8t002yhns6d6im7ch9","tag_id":"ck4qygnaj0058hns6ilaqfxho","_id":"ck4qygnao005ihns6a0cfbgon"},{"post_id":"ck4qygn8u0032hns615i3zznn","tag_id":"ck4qygnaj0058hns6ilaqfxho","_id":"ck4qygnap005jhns690arfohq"},{"post_id":"ck4qygn8w0036hns60yf9uwfy","tag_id":"ck4qygnam005ehns6f4qhjcxh","_id":"ck4qygnap005lhns6lmbkwqxn"},{"post_id":"ck4qygn9a003ohns627yie8o8","tag_id":"ck4qygnan005hhns6v03c1kii","_id":"ck4qygnap005mhns6aufzclzw"},{"post_id":"ck4qygn9i003vhns67gmvm05j","tag_id":"ck4qygnap005khns6rj00yw32","_id":"ck4qygnaq005ohns6dmhd3oiu"},{"post_id":"ck4qygn9s0049hns6qd5h6eyn","tag_id":"ck4qygnaq005nhns6rtzhbpel","_id":"ck4qygnar005qhns68r94b7zp"},{"post_id":"ck4qygna6004hhns6n78nusq1","tag_id":"ck4qygnaj0058hns6ilaqfxho","_id":"ck4qygnas005rhns6dh6njxmp"},{"post_id":"ck4qygnba005shns61i3zs2zx","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnbe005uhns6uplziqww"},{"post_id":"ck4qygnba005shns61i3zs2zx","tag_id":"ck4qygn8y003bhns6uqg1y4gi","_id":"ck4qygnbg005whns6mwsrw2la"},{"post_id":"ck4qygnbc005thns6b099buza","tag_id":"ck4qygnan005hhns6v03c1kii","_id":"ck4qygnbh0060hns6xzywrfee"},{"post_id":"ck4qygnbg005xhns6552vd1o7","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnbj0063hns6accmeuo9"},{"post_id":"ck4qygnbg005xhns6552vd1o7","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnbk0067hns6wjt68eqd"},{"post_id":"ck4qygnbj0064hns6rfne07l4","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnbl006bhns6ye9x2qww"},{"post_id":"ck4qygnbj0064hns6rfne07l4","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnbm006dhns6j5ks1p08"},{"post_id":"ck4qygnbf005vhns60h1xniv6","tag_id":"ck4qygnbh005zhns67ldygldr","_id":"ck4qygnbn006ghns6c928pp4c"},{"post_id":"ck4qygnbk0068hns6p8n6wsqc","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnbn006ihns6g7psy9na"},{"post_id":"ck4qygnbk0068hns6p8n6wsqc","tag_id":"ck4qygn7e000jhns6hb16b5ab","_id":"ck4qygnbn006khns691ue3o5e"},{"post_id":"ck4qygnbi0061hns6m1xsd27k","tag_id":"ck4qygnbk0069hns6ia6mfpd2","_id":"ck4qygnbn006mhns6el4p3mxm"},{"post_id":"ck4qygnbi0061hns6m1xsd27k","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnbo006nhns6jr43s7ik"},{"post_id":"ck4qygnbl006chns6j8atbaww","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnbo006ohns6511pbx1t"},{"post_id":"ck4qygnbl006chns6j8atbaww","tag_id":"ck4qygnbm006fhns63rwge4oq","_id":"ck4qygnbo006phns69prk6vii"},{"post_id":"ck4qygnbs006qhns6xsr4thu5","tag_id":"ck4qygn9o0044hns6d2rwq3ee","_id":"ck4qygnbv006thns6em9dsmsf"},{"post_id":"ck4qygnbs006qhns6xsr4thu5","tag_id":"ck4qygnbu006rhns678bot6tu","_id":"ck4qygnbv006uhns6tym0v7ib"},{"post_id":"ck4qygnbs006qhns6xsr4thu5","tag_id":"ck4qygnbm006fhns63rwge4oq","_id":"ck4qygnbv006vhns6wl4w8a2y"}],"Tag":[{"name":"性能优化","_id":"ck4qygn6y0006hns6yi0nrgx2"},{"name":"面试","_id":"ck4qygn78000dhns6dbfrxw0n"},{"name":"JavaScript","_id":"ck4qygn7e000jhns6hb16b5ab"},{"name":"DNS","_id":"ck4qygn7i000qhns6ongpidku"},{"name":"web安全","_id":"ck4qygn7p000xhns6c75sqldp"},{"name":"HTTP","_id":"ck4qygn7y001chns6yxd4nnjg"},{"name":"设计模式","_id":"ck4qygn86001qhns6n8rjua9f"},{"name":"Markdown","_id":"ck4qygn8a001yhns6v15e6o14"},{"name":"TCP","_id":"ck4qygn8e0027hns6xaj5zvjs"},{"name":"Vue","_id":"ck4qygn8i002ghns6012m6ek2"},{"name":"IP","_id":"ck4qygn8n002nhns6ge2t3hjl"},{"name":"CSS","_id":"ck4qygn8r002uhns65ab41b78"},{"name":"数据结构","_id":"ck4qygn8u0031hns63sdjnddw"},{"name":"算法","_id":"ck4qygn8y003bhns6uqg1y4gi"},{"name":"翻译","_id":"ck4qygn9o0044hns6d2rwq3ee"},{"name":"React","_id":"ck4qygnab004yhns6wnchi8bf"},{"name":"随笔","_id":"ck4qygnaj0058hns6ilaqfxho"},{"name":"Git","_id":"ck4qygnam005ehns6f4qhjcxh"},{"name":"Node.js","_id":"ck4qygnan005hhns6v03c1kii"},{"name":"浏览器","_id":"ck4qygnap005khns6rj00yw32"},{"name":"运维","_id":"ck4qygnaq005nhns6rtzhbpel"},{"name":"WebP","_id":"ck4qygnbh005zhns67ldygldr"},{"name":"直播","_id":"ck4qygnbk0069hns6ia6mfpd2"},{"name":"Chrome","_id":"ck4qygnbm006fhns63rwge4oq"},{"name":"Puppeteer","_id":"ck4qygnbu006rhns678bot6tu"}]}}